{
Selector mutK
Path of
class method class Path #default##apply(Void of)Path
class method class Selector #default##apply(Void mutK)Selector
Fail:Message.$<><{ implements This2.Fail}



//initial delegation
method
Library<><(Library that) exception Fail{
  l=Location.Lib(that).navigate(this.of())
  exception on Location.NotAvailable
    Fail"Nested class "[this.of()]" not found"
  ,,(mToS=l.method(selector:\"toS()")
    catch exception Location.NotAvailable void
    if !l.implements(classObj:Concept.ToS) (
      error Fail"method toS not from Concept.ToS"
      )
    if !mToS.isAbstract() (return that)
    )
  m=l.method(selector:this.mutK())
  exception on Location.NotAvailable
    Fail"Selector "[this.mutK()]" not found"
  //TODO: add checks mutK is actually a factory

  fNs=m.selector().names()
  fTs=m.parameterTypes().withoutLeft()
  return Use[that]<><
    Refactor2.rename(path:\"This" into:this.of())<><
    This.toSTrait(fNs:fNs,fTs:fTs)
  error on Refactor2.Fail, Location.NotAvailable
    X"AddToS.<><"
  }


//code generation
class method
Library toSTrait(Strings fNs, Location.Type.Parameter.List fTs)
exception Fail{
  //accumulation
  acc=Use.Override[with fN in fNs.vals(), fT in fTs.vals() (
    use[
      Refactor2.Method[hide:\"fN()"]<><
      Use[Resource(fN,selector:\"fN()")]<><
      This(fSel:Selector.from(string:fN++S"()"),fT:fT)
      ])]
  lib=acc.foldLeft(resolver:{
      read method S #1baseToS()
      read method S #2baseToS()
      read method S baseToS()
        S""[this.#1baseToS()]", "[this.#2baseToS()]""
     })
  error on Refactor2.Fail X"AddToS.accumulation"
  //final wrapping
  miniToS={ implements Concept.ToS
    method toS() S"["[this.baseToS()]"]"
    read method S baseToS() S""
    }
  //lib can override baseToS to provid the real behaviour,
  //the empty baseToS is used for classes wiht no fields
  return Refactor2.Method[hide:\"baseToS()"]<><Use.Override[miniToS]<><lib
  error on Refactor2.Fail X"AddToS.finalWrapping - hide"
  }

//auxiliary functions

 class method
 S className(class Any that){
   with that (
     on class Void return S"Void"
     on class Library return S"Library"
     on class Concept.Classable return that.readableName()
     )
   return GetMyName(that)
   }

 class method
 S nodeName(read Any that){
   with that (
     on read Void return S"Void"
     on read Library return S"Library"
     on read Concept.Classable return that.class().readableName()
     )
   return S"?"
  }
class method
 S valToS(read Any that){
   with that (
     on read Concept.ToS (
       ts=that.toS()
       if ts.beginsWith(S"[") ( return ts)
       return S.doubleQuote()++ts++S.doubleQuote()
       )
     on read Void  return S.doubleQuote()++S"void"++S.doubleQuote()
     on read Library  return S.doubleQuote()++S"{..}"++S.doubleQuote()
     )
   return S"?"
  }
class method
 S nodeNameAndValToS(read Any that){
   S nn=this.nodeName(that)
   S ts=this.valToS(that)
   return nn++ts
   }

class method Location.Lib lib(Location.Type.RefTo refTo)
  exception Fail {
  with refTo (
    on Location.Type.RefTo.Lib
      return refTo.referredLib()
    on Location.Type.RefTo.Binded
      return Location.Lib(classObj:refTo.referredClassObj())
    )
  exception Fail"field missing or unavailable: "[refTo]""
  }

class method
Library ( Selector fSel,Location.Type fT) exception Fail {
  isInterface=this.lib(refTo:fT.refTo()).isInterface()
  if isInterface (
    return ToSSpecializerInterface(selector:fSel,type:fT) 
    )
  return ToSSpecializer(selector:fSel,type:fT) 
  }

ToSSpecializer:FieldOpSpecializer(
  forReadable:{
    class method S fN()
    read method S baseToS()
      S""[This.fN()]":"[This1.valToS(this.f())]""}
  forClass:{
    class method S fN()
    read method S baseToS()
      S""[This.fN()]":"[This1.className(this.f())]""}
  )

ToSSpecializerInterface:FieldOpSpecializer(
  forReadable:{
    class method S fN()
    read method S baseToS()
      S""[This.fN()]":"[This1.nodeNameAndValToS(this.f())]""}
  forClass:{// can not do ToSSpecializer.forClass() since uses This1
    class method S fN()
    read method S baseToS()
      S""[This.fN()]":"[This1.className(this.f())]""}
  )

}