Now Data invariant and Data wither implement in Java,
less nice but faster and more general.

Invariant:
check the ret type of #invariant method: if bool, wrap it.
if no #invariant, add empty,
Then call invariant J




----------
WitherOf({
class method mdf This k(T1' x1..Tn' xn)
read method Ti xi()
/*tons of other non state methods*/
})=
{
class method mdf This k(T1' x1..Tn' xn)
read method Ti xi()
read method read This with(Ti xi)
  This.k(x1:this.x1(),..xi:xi,..xn:this.xn())
read method Ti #default#xi()
}
With Ti'.mdf in {fwd mut, fwd imm,imm, read,class} //not in capsule,mut, lent.
mdf in {imm,mut,lent,read}
//Note, the wither can then be sum with the starting point.
--------------------
closeWithInvariant({
var?1 T1 x1..var?n Tn xn //or methods generated from
read method Void invariant()exception Void
})
Ti.mdf in {imm,capsule,class} //no mut, no read (could not be lent/fwd anyway)
=
{
var?1 T1 x1_$_j..var?n Tn xn_$_j //or methods generated from
class method mdf This k_$_j(T1' x1..Tn' xn)//as generated by K, but with mut instead of capsule
read method Void invariant()
class method mdf This k(T1'' x1..Tn'' xn)(
    res=This.k_$_j(x1:x1..Xn:xn)
    res.invariant()//can propagate error out
    res
    )

mut method Void xi(Ti that)( //if var?i=var
  this.xi_$_j(that)
  this.invariant()
  )
read method read(Ti) xi() this.xi_$_j()
//all methods using this.#xi_$_j(),or exposer name
//mdf method T m(ps)e
mdf method T m(ps) (r=e this.invariant() r)
//for mdf not capsule, ok to leave untouched the (stupid) ones with mdf=capsule!
}
Ti''=Ti'[fwd mut->capsule]
With Ti'.mdf in {fwd mut, fwd imm,imm, read,class} //not in capsule,mut, lent.
with #xi_$_j used only on this, on all the bubble
with k_$_j used only 1 time in k, on all the bubble

NO: carefull: to check invariant you can not use fwds...
steps:
1 close class, in the while
  check #xi_$_j()/This.#xi() used only on this, on all the bubble
  //this step can be more efficient if done on groups of paths
2 add new k+invariant+KMut(K with mut instead of capsule) called k_$_j
  add new sets+invariant
  add new getters
  edit methods exposers+invariant

-----
reasoning:
wither on read is strange: take mut in and produce read.
wither on read need to FAIL if there are capsule parameters
wither on imm can work even with capsule parameters

Data on no k? generate invariant, generate imm withers abusing of private k?

Data steps:
  Kfwdmut
  wither
  equals,hashcode,toS etc..
  sum all
  invariant: error if mut exposer
  ending data:
    if lent P exposer exists: close state with capsule requirement.
    ( if there is invariant() was closed already)



should fwd apply on all mdf?
this is independent from all mdf can be member of constructor
  -no set on read/lent. myEvilCode.doStuff(e)
  -currently, no lent fields, yes read fields.
   *why? 
   capsule P  generate read method read P  and mut method lent P#
   lent P would be the same?
   constructors can take mut or capsule in that case. No lent.
   set can take mut or capsule. 



Data will never chose to create a read->read constructor.
if no invariant, empty invariant added, so it can be refined later
data will always close the class and expose no fwd mut/imm constructors 
lent exposer->capsule in mutK, + imm in immK


------

Data: String mutK,immK,invaraint,ops
Decorate: L0,path
  String fresh=...
  var L=L0
  L ><>= EnsureInvariant(path,invariant)//if no invariant, add invariant
  L ><>= DataOpen(fresh,mutK,immK,invariant, path)
  L ><>= Use.Override[with op in ops ( 
    use[ op(L2,path,mutK,immK) ]
    )]
  L ><>= DataClose(fresh,mutK,immK,path)
  L

class method
Location.Method k(String fresh,Library that, Path of,Library opened){
  i1=Location.Lib(that).navigate(of)
  i2=Location.Lib(that).navigate(of)
  with m2 in i2.methods().vals() (
    s2=m2.selector()
    if s2.name()==fresh (
      m1=i1.method(selector:s2)
      catch exception Location.NotAvailable return m2
      )
    )
  error X"fresh constructor not added"
  }

DataClose:{
  Location.Method that, Path of
  class method Library <><(Library that) (
    lib=WrapExposers(this.that() of:this.of())<><that
    solver=Use[with
    ,,,,n in freshK.selector().names().vals()
    ,,,,t in freshK.parameterTypes().vals() (
      if t.mdf().is(\fwdImm) (use[This.getSetTraitImm()])
      else (use[This.getSetTraitCapsule()])
      )]
    Refactor2.Method[close:path]<><Use.Override[lib]<><solver<><{}
    )
  class method
  Library getSetTraitImm(){
    Ti:{}
    read method Ti xi() this.#1xi() //getter
    mut method Void xi(Ti that)( //setter, on need
      this.#1xi(that)
      this.invariant()
      )
    }
  class method
  Library getSetTraitCapsule(){
    Ti:{}
    read method read Ti xi() this.#1xi() //getter
    mut method Void xi(capsule Ti that)( //setter, on need
      this.#1xi(that)
      this.invariant()
      )
    }
  }
