
WitherOf({
class method mdf This k(T1' x1..Tn' xn)
read method Ti xi()
/*tons of other non state methods*/
})=
{
class method mdf This k(T1' x1..Tn' xn)
read method Ti xi()
read method read This with(Ti xi)
  This.k(x1:this.x1(),..xi:xi,..xn:this.xn())
read method Ti #default#xi()
}
With Ti'.mdf in {fwd mut, fwd imm,imm, read,class} //not in capsule,mut, lent.
mdf in {imm,mut,lent,read}
//Note, the wither can then be sum with the starting point.
--------------------
closeWithInvariant({
var?1 T1 x1..var?n Tn xn //or methods generated from
read method Void invariant()exception Void
})
Ti.mdf in {imm,capsule,class} //no mut, no read (could not be lent/fwd anyway)
=
{
var?1 T1 x1_$_j..var?n Tn xn_$_j //or methods generated from
class method mdf This k_$_j(T1' x1..Tn' xn)//as generated by K, but with mut instead of capsule
read method Void invariant()
class method mdf This k(T1'' x1..Tn'' xn)(
    res=This.k_$_j(x1:x1..Xn:xn)
    res.invariant()//can propagate error out
    res
    )

mut method Void xi(Ti that)( //if var?i=var
  this.xi_$_j(that)
  this.invariant()
  )
read method read(Ti) xi() this.xi_$_j()
//all methods using this.#xi_$_j(),or exposer name
//mdf method T m(ps)e
mdf method T m(ps) (r=e this.invariant() r)
//for mdf not capsule, ok to leave untouched the (stupid) ones with mdf=capsule!
}
Ti''=Ti'[fwd mut->capsule]
With Ti'.mdf in {fwd mut, fwd imm,imm, read,class} //not in capsule,mut, lent.
with #xi_$_j used only on this, on all the bubble
with k_$_j used only 1 time in k, on all the bubble

NO: carefull: to check invariant you can not use fwds...
steps:
1 close class, in the while
  check #xi_$_j()/This.#xi() used only on this, on all the bubble
  //this step can be more efficient if done on groups of paths
2 add new k+invariant+KMut(K with mut instead of capsule) called k_$_j
  add new sets+invariant
  add new getters
  edit methods exposers+invariant

-----
reasoning:
wither on read is strange: take mut in and produce read.
wither on read need to FAIL if there are capsule parameters
wither on imm can work even with capsule parameters

Data on no k? generate invariant, generate imm withers abusing of private k?

Data steps:
  Kfwdmut
  wither
  equals,hashcode,toS etc..
  sum all
  invariant: error if mut exposer
  ending data:
    if lent P exposer exists: close state with capsule requirement.
    ( if there is invariant() was closed already)



should fwd apply on all mdf?
this is independent from all mdf can be member of constructor
  -no set on read/lent. myEvilCode.doStuff(e)
  -currently, no lent fields, yes read fields.
   *why? 
   capsule P  generate read method read P  and mut method lent P#
   lent P would be the same?
   constructors can take mut or capsule in that case. No lent.
   set can take mut or capsule. 



Data will never chose to create a read->read constructor.
if no invariant, empty invariant added, so it can be refined later
data will always close the class and expose no fwd mut/imm constructors 
lent exposer->capsule in mutK, + imm in immK


------

DataOpen: mutK,immK,invariant, L1, path
create unique j,
L2=L1[create fwdKj, mutK->fwdKj+inv immK->fwdKj+inv]

DataAccumulate: mutK,immK, L2, path
L3=Use.Override[ base,wither(immK,L2,path), equals, toS,..]<><L2

DataClose: mutK,immK, L2, path
recover j exploring immK
L4=L3[in path immK,delegate
  setter to inv+setterj
  getter to getterj]
L5=L4[rename path.exposer to exposerj, check used only on this]

Data: mutK,immK,invaraint,ops
Decorate: L0,path
  mutK,immK+=collectFieldNames(L0)
  var L=L0
  L ><>= EnsureInvariant(path,invariant)//if no invariant, add invariant
  L ><>= DataOpen(mutK,immK,invariant, path)
  L ><>= Use.Override[with op in ops ( 
    use[ op(L2,path,mutK,immK) ]
    )]
  L ><>= DataClose(mutK,immK,path)
  L


TODO:
//-comment data and related tests
//-make other tests pass
//-make other tests for all sources pass
//newTypeSystem
//gui test deploy
//withSafeOperators
//helpers.TestRunner
//withSafeOperators.refactor.sum //about refreshing uniqueNum
//programReduction
//profiling
//gui.TestTests

//-make REPL work again
-check the issues on the paper
-more review