{
Fail:{interface implements Guard}
Invariant:K<><...
//Wither:...
//AddToS:...
//AddEquals:...

class method S mutKName() S"#apply"
class method S immKName() S"#immK"

ExcHelp:{
  class method Refactor2.SelectorUnfit selectorUnfit(Selector that) {
    unused=Refactor2.toAbstract(selector:that)<><{}
    catch exception Refactor2.SelectorUnfit r return r
    error on Refactor2.Fail X""
    error X""
    }
  class method Refactor2.PathUnfit pathUnfit(Path that) {
    unused=Refactor2.toAbstract(selector:\"a()" of:that)<><{}
    catch exception Refactor2.PathUnfit r return r
    error on Refactor2.Fail X""
    error X""
    }
  }
Base:{
  //class, ToS == required
  class method Library (){
    implements Concept.Base
    
    refine read method
    class This class()
      This

    method readableName()
      GetMyName(This)

    method is(subtype){
      with subtype (on class This return Bool.true())
      return Bool.false()}

    method ==(that) {
      with that (on read This return this.equals(that))
      return Bool.false()}

    read method Bool equals(read This that)
    }
  class method
  Library<><(Library that)
  exception 
  ,,,,Refactor2.MethodClash,
  ,,,,Refactor2.ClassClash,
  ,,,,Refactor2.SubtleSubtypeViolation
    Use.Override[this()]<><that
  }

class method
Library <>< (Library that)
exception Invariant.Fail Refactor2.PathUnfit {
 var Library res=that
 res><>=Invariant(of:\"This")
 return res
}

/*
class method
Library <>< (Library that)
exception StateUnfit, MetaGuard
 {
  var Library res=that
  if Introspection(lib:res).classKind().equals(\class._Interface()) (
    return Extends[res]<><{interface implements 
      Concept.Classable, Concept.ToS, Concept.Equals
      }
    )
  res><>=K
  res><>=Wither
  res><>=AddToS
  res><>=AddEquals
  res><>=Invariant
  res><>=Solid
  return res
  //data: toS == class named,  invariant, with  ---  Still missing: fromS, clone mutk
  }
*/
}