{
StateUnfit:Message.$<><{ implements Guard}
InvariantUnfit:Message.$<><{ implements Guard}
//Invariant:...
//Wither:...
//AddToS:...
//AddEquals:...

Base:{
  //class, ToS == required
  class method Library (){
    implements Concept.Base
    
    refine read method
    class This class()
      This

    method readableName()
      GetMyName(This)

    method is(subtype){
      with subtype (on class This return Bool.true())
      return Bool.false()}

    method ==(that) {
      with that (on read This return this.equals(that))
      return Bool.false()}

    read method Bool equals(read This that)
    }
  class method
  Library<><(Library that)
  exception 
  ,,,,Refactor2.MethodClash,
  ,,,,Refactor2.ClassClash,
  ,,,,Refactor2.SubtleSubtypeViolation
    Use.Override[this()]<><that
  }

EnsureInvariant:K<><{
  Path path
  method
  Library<><(Library that)
  exception NotAvailable {
    i=Location.Lib(that).nested(path:this.path())
      (
      m=i.method(selector:\"#invariant()")
      catch exception NotAvailable
        return Refactor2.compose(
          that and:{read method Void #invariant()void})
       void
       )
    //here I'm sure #invariant() is defined, check has right type
      (
      unused=Refactor2.compose(that and:{read method Void #invariant()})
      exception on Refactor2.Fail
        InvariantUnfit"Method '#invariant()' has incompatible type"
      void //TODO: somehow it accept that InvariantUnfit is not in the throws... fixing this bug
      )
    return that
    }
  }

PlgDataOpen:Refactor2.JavaImport<><{
  //@plugin is.L42.connected.withSafeOperators
  //@pluginPart is.L42.connected.withSafeOperators.refactor.MakeK
  class method
  Library dataOpen(Library that,Path path,S fresh,S mutKName,S immKName)
  exception 
  ,,,,Refactor2.PathUnfit
  ,,,,Refactor2.ParseFail
  ,,,,Refactor2.ClassUnfit
  ,,,,Refactor2.MethodClash

  class method
  Library #pluginUnresponsive(Library binaryRepr)
    binaryRepr  
  }
DataOpen:K<><{
  Path path, S fresh, S mutKName, S immKName
  method
  Library <><(Library that)
  exception 
  ,,,,Refactor2.PathUnfit
  ,,,,Refactor2.ParseFail
  ,,,,Refactor2.ClassUnfit
  ,,,,Refactor2.MethodClash
    PlgDataOpen.dataOpen(that,path:this.path(),
      fresh:this.fresh(),
      mutKName:this.mutKName(),
      immKName:this.immKName())
  }

PlgInvariantClose:{
  //@plugin is.L42.connected.withSafeOperators
  //@pluginPart is.L42.connected.withSafeOperators.refactor.MakeK
  class method
  Library close(Path path,Library top,Selector fresh)
  exception 
  ,,,,Refactor2.PathUnfit
  ,,,,Refactor2.ClassUnfit

  class method
  Library #pluginUnresponsive(Library binaryRepr)
    binaryRepr  
  }
InvariantClose:K<><{
  Selector that, Path of
  method
  Library <><(Library that)
  exception 
  ,,,,Refactor2.PathUnfit
  ,,,,Refactor2.ClassUnfit
    PlgInvariantClose.close(
      path:this.of(),top:that,fresh:this.that()
    )
  }


DataClose:K<><{
  Location.Method that, Path of
  method Library <><(Library that)
  exception 
  ,,,,Refactor2.SelectorUnfit
  ,,,,Refactor2.PathUnfit
  ,,,,Refactor2.ClassUnfit 
  ,,,,Refactor2.ClassClash
  ,,,,Refactor2.MethodClash (
    s=this.that().selector()
    ts=this.that().parameterTypes()
    lib=InvariantClose(s of:this.of())<><that
    dec=
    solver=Use[with n in s.names().vals(), t in ts.vals() (
      if t.mdf().isFwdImm() (use[This.getSetTraitImm()])
      else (use[This.getSetTraitCapsule()])
      )]
    Refactor2.Method[closeState:this.of()]<><
      Use.Override[lib]<><solver<><{}
    )
  class method 
  Library dec(Library that,Path of,S name,Location.Type.RefTo r)(
    Refactor2.RedirectRefTo(path:\"Ti" into:r)
    <><Refactor2.Method[rename:\"xi()" of:of into:Selector.from(string:na]
/*
-check tat all time call coherentF use program.navigate in java
-no, expand wrapeposer:
rename .exposer() ->freshExposer()
rename decl exposer() ->decl freshExposer()
replace decl get() ->decl freshXi()+ delegator get() this.freshXi()
replace decl set() ->decl freshXi(that)+ delegator set(that) (this.freshXi(that) invariant())
replace delc freshK ->decl freshK(freshx1..freshxn) +delegator freshK
close class, make freshK private.


xi(), xi(that) may start with #, or not be there at all
OptSelector gi=getSel(intro,xi)
OptSelector si=setSel(intro,xi)
//filter before gi.isPresent() | si.isPresent()
var Library res=select(isImm,gi.isPresent(),si.isPresent())
if gi.isPresent() (
  res=><>Refactor2.Method[rename:\"xi()" of:of into:gi.get()]
  )
if si.isPresent() (
  res=><>Refactor2.Method[rename:\"xi(that)" of:of into:si.get()]
  )
ref=><>Refactor2.RedirectRefTo(path:\"Ti" into:r)
ref
)

getSel(into,xi)
what if both xi and #xi defined?
be coherent with makeK?

*/
    )
  class method
  Library getSetTraitImm(){
    Ti:{}
    read method Ti xi() this.#1xi() //getter
    mut method Void xi(Ti that)( //setter, on need
      this.#1xi(that)
      this.invariant()
      )
    }
  class method
  Library getSetTraitCapsule(){
    Ti:{}
    read method read Ti xi() this.#1xi() //getter
    mut method Void xi(capsule Ti that)( //setter, on need
      this.#1xi(that)
      this.invariant()
      )
    }
  }

/*
class method
Library <>< (Library that)
exception StateUnfit, MetaGuard
 {
  var Library res=that
  if Introspection(lib:res).classKind().equals(\class._Interface()) (
    return Extends[res]<><{interface implements 
      Concept.Classable, Concept.ToS, Concept.Equals
      }
    )
  res><>=K
  res><>=Wither
  res><>=AddToS
  res><>=AddEquals
  res><>=Invariant
  res><>=Solid
  return res
  //data: toS == class named,  invariant, with  ---  Still missing: fromS, clone mutk
  }
*/
}