{reuse L42.is/AdamTowel01
/*
Here we document and test The introspection/location library for 42
This library is mostly a complex wrapper over plugin classes.
The main different with respect of other introspection/reflection
libraries is that we represent the code as is wrote *where* is wrote.
That is, an occurence of a type and the class of such type are
different objects: indeed the occurence of a type is wrote
in a certain place in the source, and the corresponding class
is declared in a completly different place.
---------------
Location.Origin
---------------
Origin is a Data class representing a point in the sourcecode. It fields are self explanatory
*/
OriginTest:{
  o=Location.Origin(fileName:S"foo",
    lineStart:0Size, lineEnd:10Size,
    columnStart:1Size, columnEnd:10Size
    )
  Debug.test(
    S"our origin is in "[o]"!!"
    expected:
    S"our origin is in Origin:foo"[S.nl()]
 "lines 0 to 10; colums 1 to 10!!")
  return ExitCode.normal()
  }
/*
--------------------------------
Location
--------------------------------
Location is the general interface of all things that have origins.
Location.Lib, Location.Method, Location.Type and Location.Doc
implements Location.
All locations are Data classes and offer
origins,location,doc
----
origins(): a list of Origin of this Location.
An element can have many origins since metaprogramming can merge
things from multiple sources.
----
location()
The location object containing this Location
----
doc()
The documentation associated with this Location

--------------------------------
Location.Lib
--------------------------------
Lib reify library literals.
To create a Lib object there are two main ways:
Lib({method Void hi()})//argument of type Library
Lib(classAny:Void)//argument of type class Any
Lib offers many methods, we will examin them now:
--------------------------
Accessing nested classes:
method Lib.List nesteds() //direct nesteds
method Lib.List allNesteds()//nesteds at any levels
method Bool has(Path path) //check and retrive a nested with a Path
method Lib nested(Path path) exception Location.NotAvailable
*/
LibNestedTest:{
  Location.Lib lib1=Location.Lib({method Void hi()})
  Debug.test(lib1.nesteds().size() expected:0Size)//we have no nesteds
  Debug.test(lib1.allNesteds().size() expected:1Size)//there is at least This
  lib2=Location.Lib({A:{A1:{}} B:{B1:{} B2:{}} C:{C1:{} C2:{} C3:{}}})
  Location.Lib.List libs=lib2.nesteds()
  Debug.test(libs.val(0\).nesteds().size() expected:1Size)
  Debug.test(libs.val(1\).nesteds().size() expected:2Size)
  Debug.test(libs.val(2\).nesteds().size() expected:3Size)
  Debug.test(lib2.allNesteds().size() expected:10Size)
  Debug.test(lib2.has(path:\"A") expected:Bool.true())
  Debug.test(lib2.has(path:\"A1") expected:Bool.false())
  Debug.test(lib2.nested(path:\"B").has(path:\"B2") expected:Bool.true())
  return ExitCode.normal()
  }
/*
--------------------------
Accessing methods:
  method Method.List methods()
  method Method method(Selector selector) exception NotAvailable
  method Bool has(Selector selector)
*/
LibMethodsTest:{
  Debug.test(Location.Lib({}).methods().size()
    expected:0Size)
  Debug.test(Location.Lib({var Any field}).methods().size()
    expected:3Size)//getter, setter and exposer
  Debug.test(Location.Lib({Any field}).methods().size()
    expected:2Size)//getter and exposer
  Debug.test(Location.Lib({Any field}).has(selector:\"field()") 
    expected:Bool.true())
  Debug.test(Location.Lib({Any field}).has(selector:\"foo()") 
    expected:Bool.false())
  return ExitCode.normal()
  }
/*
--------------------------
Accessing implements:

  Type.Implemented.List implementeds()
  method Bool implements(class Any clazz)
  method Bool implements(Path path)
*/
LibImplementsTest:{
  a=Location.Lib({implements A, Concept.ToS A:{interface}})
  Debug.test(a.implements().size()
    expected:2Size)
  b=Location.Lib({implements A, Concept.Base A:{interface} })
  Debug.test(b.implements()
    expected:S"")//normalization!
  return ExitCode.normal()
  }
/*
  Doc doc()
  Bool isBinded()
  Bool isCloseState()
  method//as in EnsureCoherent<><
  Bool isEnsuredCoherent()
  Bool isInterface()
  Bool isPotentialInterface()
  Bool isRedirectable()
  This navigate(Path that)
  method //empty doc if it is root
  Doc nestedDoc()
  method//last is its name, empty path for root
  Path path()
  This root()
  This location()
  

*/
LibTest:{
  

  return ExitCode.normal()
  }



EmptyTest:{
  return ExitCode.normal()
  }

}