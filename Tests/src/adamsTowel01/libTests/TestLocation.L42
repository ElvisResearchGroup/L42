{reuse L42.is/AdamTowel01
/*
Here we document and test The introspection/location library for 42
This library is mostly a complex wrapper over plugin classes.
The main different with respect of other introspection/reflection
libraries is that we represent the code as is wrote *where* is wrote.
That is, an occurence of a type and the class of such type are
different objects: indeed the occurence of a type is wrote
in a certain place in the source, and the corresponding class
is declared in a completly different place.
---------------
Location.Origin
---------------
Origin is a Data class representing a point in the sourcecode. It fields are self explanatory
*/
OriginTest:{
  o=Location.Origin(fileName:S"foo",
    lineStart:0Size, lineEnd:10Size,
    columnStart:1Size, columnEnd:10Size
    )
  Debug.test(
    S"our origin is in "[o]"!!"
    expected:
    S"our origin is in Origin:foo"[S.nl()]
 "lines 0 to 10; colums 1 to 10!!")
  return ExitCode.normal()
  }
/*
--------------------------------
Location
--------------------------------
Location is the general interface of all things that have origins.
Location.Lib, Location.Method, Location.Type and Location.Doc
implements Location.
All locations are Data classes and offer
origins,location,doc
----
origins(): a list of Origin of this Location.
An element can have many origins since metaprogramming can merge
things from multiple sources.
----
location()
The location object containing this Location
----
doc()
The documentation associated with this Location

--------------------------------
Location.Lib
--------------------------------
Lib reify library literals.
To create a Lib object there are two main ways:
Lib({method Void hi()})//argument of type Library
Lib(classAny:Void)//argument of type class Any
Lib offers many methods, we will examin them now:

method Lib.List nesteds() //direct nesteds
method Lib.List allNesteds()//nesteds at any levels
method Bool has(Path path) //check and retrive a nested with a Path
method Lib nested(Path path) exception Location.NotAvailable
*/
LibNestedTest:{
  lib1=Location.Lib({method Void hi()})
  Debug.test(lib1.nesteds().size() expected:0Size)
  Debug.test(lib1.allNesteds().size() expected:0Size)
  return ExitCode.normal()
  }

/*


  Method.List methods()
  method Method method(Selector selector) exception NotAvailable {
  method Bool has(Selector selector) (
  Type.Implemented.List implementeds()
  method Bool implements(class Any clazz){
  method Bool implements(Path path) {
  This (class Any classAny)
  This (Library that)
  Doc doc()
  Bool isBinded()
  Bool isCloseState()
  method//as in EnsureCoherent<><
  Bool isEnsuredCoherent()
  Bool isInterface()
  Bool isPotentialInterface()
  Bool isRedirectable()
  This navigate(Path that)
  method //empty doc if it is root
  Doc nestedDoc()
  method//last is its name, empty path for root
  Path path()
  This root()
  This location()
  

*/
LibTest:{
  

  return ExitCode.normal()
  }



EmptyTest:{
  return ExitCode.normal()
  }

}