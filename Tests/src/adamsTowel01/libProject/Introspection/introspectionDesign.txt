Idea: the introspection lets you talk about locations in the code, so 
if you have the class { class method Library foo()}
you can ask what is the return type of This.foo(), and you get
a Location.ReturnType knowing the Path (Library) the modifier (imm/immutable)
and the Location.Method that contains such type annotation.

General class shape:

//###0 Location declaration and methods 
//------------------------------------

Location:{interface implements Base //that is equals, toS and "know your class"
  
  method
  Location location()
  
  NotAvailable:Message.$<><{implements Guard}
  
  Mdf:Enum"imm, mut, read, lent, capsule, class"


//###1 Origin
//------------------------------------  

  Origin:MiniData<><{
    S fileName
    Size line
    Size column
    
    $This:MiniData.thisLib()
    List:Collection.vector(of:$This)
    }
    
  method Size originsSize()//many since metaprogramming
  method Origin origin(Size that)   
  method
  Origin.List origins()
    Origin.List[with i in Count(this.originSize()) (use[this.origin(i)])]


//###2 Doc 
//------------------------------------

  Doc:MiniData<><{ implements Location
    method Location location()//user will need typecase to discover precise type
    Annotation:MiniData<><{
      Type.RefTo 
      S text
    
      $This:MiniData.thisLib()
      List:Collection.vector(of:$This)
      }
    }

    
//###3 Lib 
//------------------------------------

  //there is no Member since normalized classes have order: first nested, then methods
  Lib:MiniData<><{ implements Location
    refine method Lib location()
    method Size nestedsSize()
    method This nested(Size that)
    method
    List nesteds()
      List[with i in Count(this.nestedSize()) (use[this.nested(i)])]
    List allNesteds()
      List[this]++
      List[with nc in this.nesteds().vals() (
        with nci in nc.allNesteds().vals() (use[nci])
      )]
    method Lib nested(Path path) exception NotAvailable (
      with ni in this.root().allNested().vals() (
        if ni.path()==path (return ni)
        )
      exception NotAvailable"Path "[path]"not present"
      )
    method Bool has(Path path) (
      unused=this.nested(path:path)
      catch exception NotAvailable Bool.false()
      Bool.true()
      )
          
    method Size methodsSize()
    method Method method(Size that)
    Method.List methods()
      Method.List[with i in Count(this.methodsSize()) (use[this.method(i)])]
    
    method Method method(Selector selector) exception NotAvailable (
      with mi in this.methods() (
        if mi.selector()==selector (return mi)
        )
      exception NotAvailable"Selector "[selector]"not present"
      )
    method Bool has(Selector selector) (
      unused=this.method(selector:selector)
      catch exception NotAvailable Bool.false()
      Bool.true()
      )      
    method Size implementedsSize()
    method Type.Implemented implemented(Size that)
    method
    Type.Implemented.List implementeds()
      Type.Implemented.List[with i in Count(this.implementedsSize()) (use[this.implemented(i)])]
    
    method Bool implements(class Any clazz){
      if Refactor.equalsClassObj(Any, and:clazz) (
        return Bool.True()
        ) 
       with ti in this.implementeds().vals() (
         with ri=ti.refTo() (
           on Type.RefTo.Binded (
             ci=ri.referredClassObj()
             if Refactor.equalsClassObj(ci, and:clazz) (
              //no need of supertypes since normalized classes has transitive implements already
              return Bool.True()
              )
             )
           )
         )
       return Bool.false()
       }
    method Bool implements(Path path) {
       with ti in this.implementeds().vals() (
         with ri=ti.refTo() (
           on Type.RefTo.Lib (
             libi=ri.referredLib()
             if path==libi.path() (
               return Bool.true()
               )
             )
           )
         )
       return Bool.false()
       }   
    
    method Doc doc()
    method S kindS()
    Kind:Enum"..."
    method
    Bool isInterface()
      this.kindS()==S"Interface"
    Bool isCoherent()
      this.isInterface() | this.kindS()==S"CoherentClass"
    $This:MiniData.thisLib()
    List:Collection.vector(of:$This)
    
    method Lib root()
    method Path path()//last is its name, empty path for root
    method Doc nestedDoc()//empty doc if it is root
    //even if obtained with a classObj, no method to get it back
    //to get a nested classObj, Refactor.navigateClassObj(classAny,Path)->classAny??
    }

    
//###4 Method 
//------------------------------------

  Method:MiniData<><{
    $This:MiniData.thisLib()
    List:Collection.vector(of:$This)

    refine method Lib location()
    method Bool isAbstract()
    method Bool isRefine()
    method Selector selector()
    method Type.Return returnType()
    
    method Size parameterTypesSize()
    method Type.Implemented parameterType(Size that)
    method
    Type.Parameter.List parameterTypes()
      Type.Parameter.List[with i in Count(this.parameterTypesSize()) (use[this.parameterType(i)])]
      
    method Size exceptionsSize()
    method Type.Implemented exception(Size that)
    method
    Type.Exception.List exceptions()
      Type.Exception.List[with i in Count(this.exceptionsSize()) (use[this.exceptions(i)])]
    }


//###5 Type and RefTo 
//------------------------------------

  Type:{ interface implements Base??
    method Doc doc()
    RefTo:{interface implements Base??
      //toS is the full path with Thisn.
      Lib:{ implements This1
        method Location.Lib referredLib()
        }
      Uncompiled:{ implements This1
        method S pathToExpression()//can be a subset of toS
        method S expression()
        }
      Binded:{implements This1 //includes primitives
        method class Any referredClassObj()
        }
      Missing:{implements This1
        //mostly useful for docs, where we can use lowercase annotation
        //or we may want to preserve @P where we removed the P
        //also, if an (nested) Uncompiled is resolved not existing..        
        }
      }
    method RefTo refTo()
    method Mdf mdf()//imm for exception/implemented    
    Return:{ implements This1
      refine Method location()
      }
    Parameter:MiniData<><{ implements This1
      $This:MiniData.thisLib()
      List:Collection.vector(of:$This)

      refine method Method location()
      method Size pos()//0 for this
      }
    Exception:MiniData<><{ implements This1
      $This:MiniData.thisLib()
      List:Collection.vector(of:$This)

      refine method Method location()
      method Size pos()//should start from 1 or 0?
      }
    Implemented:MiniData<><{ implements This1
      $This:MiniData.thisLib()
      List:Collection.vector(of:$This)

      refine method Lib location()
      method Size pos()//should start from 1 or 0?
      }    
    }

//###6 Discussions 
//------------------------------------

By calling Refactor.introspect(lib:{...})or
By calling Refactor.introspect(class:A.B) you get a Location.Lib

L::={ interface? Doc implements Ts mwt1..mwtn nc1..nck Phase}  //library compiled
mwt::= abstract? refine? mh //we do not expose the implementation
nc::= C Doc:L
mdf::= imm|mut|lent|read|capsule|class | fwdImm | fwdMut 
ms::=m(xs) //method selector
mh::= mdf method Doc T m(T1 x1..Tn xn) exception Ts
P::= Thisn.Cs | Any | Library | Void  //is pronounced "Path"
T::= mdf P Doc
Doc::= /*has a text, a set of annotations,
 where every annotation can be either a string or
 a Path, and a string content for each annotation */
C::= uppercase identifiers including $ as uppercase
x::= lowercase identifier including _ as lowercase
m::= x| #x

Notes:
//no more methodKind, just isAbstract+isRefine is all we need 

//from oldImpl: state/stateCandidate
//rootPath no. nestedFromRoot can be emulated by root().nested(path:))

//isPrivate should be a method for Selector/Path

impl Concept.ToS,Concept.Equals, Concept.Classable //that is Base
equals is complex: are two equal literal equal 
  if binded to different names? yes if they have the same origins?

MiniDataTrait:Resource<><{
  implements Concept.Base
  read method class This class() This
  class method S readableName() Refactor.classObjToS()//new plugin as for classObjEq
  class method Bool is(class Any subtype){ with subtype (on class This return Bool.true()) return Bool.false()}
  read method Bool equals(read Any that) { with that (on This return this==that)  return Bool.false()  }
  //read method Bool ==(read This that)
  //read method S toS()
  }
MiniData:{
  class method Library <><(Library that) exception MetaGuard //Refactor.Guard ??
    Refactor.rename(path:\"$This" to:\"This")<><Refactor.compose(left:MiniDataTrait() right:that)
    }


-------
Please, sort of ignore the rest, it is a former attempt
Introspection:{
  class method NestedClass (Library lib)
  class method NestedClass (Library lib,Path path) exception MetaGuard.NestedClassUnavailable
  class method NestedClass (class Any clazz)
  class method NestedClass (class Any clazz,Path path) exception MetaGuard.NestedClassUnavailable

  Member:{interface implements Concepts.Base}
  NestedClass:{<:Member
    Library mirror
    NestedClass root
    Path path
    Record record
    method Bool ==(This that)
    method Doc nestedDoc()// error  for This
    method Doc doc() //of the library literal
    method Path pathFromRoot() // invariant NestedClass(...).nestedClassFromRoot(path).pathFromRoot()==path
    method Bool hasExternalType()
    method class Any externalType() //error if  root()!=this or root() is literal, otherwise contains the class Any used to initialize root/this.
    method S externalTypeToS()
    method ClassKind classKind()
    method S allAsString()  //just the library literal//badname
    method Members members()
    method Methods methods()
    method NestedClasses nestedClasses()
    method Types implementedInterfaces()
    method NestedClasses transitivelyNestedClasses()
    method Bool implements(This that)//note type of argument
    method Bool consistent()
    method Methods constructors()
    method Methods getters()
    method Methods setters()
    method Methods exposers()    
    method Method method(Selector that) exception MetaGuard.MethodUnavailable
    method Bool has(Selector selector)
    method NestedClass nestedClassFromRoot(Path that) exception MetaGuard.NestedClassUnavailable
    method Bool has(Path pathFromRoot)
    method Bool isPrivate()
    }

  Method:{<:Member
    method NestedClass root()
    method NestedClass nestedClass()
    method Doc doc()
    method Mdf thisMdf()
    method Path pathFromRoot()// invariant NestedClass(...).nestedClassFromRoot(path).pathFromRoot()==path
    method Selector selector()
    method MethodKind methodKind() //one of InterfaceImplementedMethod,ImplementedMethod,AbstractMethod
    method S allAsString()
    method Type returnType()
    method Types exceptions()
    method Types parameterTypes()
    }

  Type:{
    method NestedClass root()
    method TypeKind typeKind() //{Normal,Alias,AliasUnresolvable}
    method Mdf mdf()//error on AliasUnresolvable
    method NestedClass referencedPath()
    method NestedClass resolvedReferencedPath() //error on AliasUnresolvable
    method Bool partial()
    method Bool resolvedPartial() //error on Normal? or the same of partial()
    method S suffix()  //error on Normal
    method Doc doc()
    method S allAsString()
    }
    Members: ...
    Methods: ...
    NestedClasses: ...
    Types:...
  }