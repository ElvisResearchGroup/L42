{
  class method Library<><(Library that) //TODO: handle errors for the better version
    //Use[Refactor.RenamePath(Path"Top" to:Path"This")<><this.enumTrait()]<><that
    UnsafeRefactor.Compose.compose(
        left:UnsafeRefactor.RenameClass.renameClass(this.enumTrait(), nameSrc:S"Top" , nameDest:S"This")
        right:that)

SolidTrait:{class method Library (){//Data is more than Solid, and Liquid, Gas, Plasma can be good methafores
     implements Concept.ToS,Concept.Equals,Concept.Classable  //may be Parsable?
    
    method is(subtype) {  with subtype (on class This return Bool.true()) return Bool.false()}     
    refine read method class This class() This
    method readableName() GetMyName(This)
    method ==(that) {
      with that (on read This return that.equals(this))
      return Bool.false()
      }
    read method
    Bool equals(read This that) // this.toS()==that.toS()
  }}

  class method Library enumTrait() {
    ParseFail:Message.$<><{ implements Guard.ParseFail}
    Top: UnsafeRefactor.Compose.compose(left:SolidTrait() //Use[SolidTrait()]<><
      right:{implements Concept.ToS
        Size inner
        class method This(Size inner)
        //class method This(Size that) This(inner:that) 
       
        method toS()
          This.readableName()++S"."++this.name()
       
        read method
        S name()
          This.names().val(this.inner())
       
        read method Bool equals(read This that) this.inner()==that.inner()
       
        class method Strings names()
       
        class method
        This fromS(S that){
          with n in 0Size.vals(), d in This.names().vals() (
            if d==that (return This(inner:n))
            )
          error ParseFail"The provided string is not valid: "[that]""
        }
      })//end compose
    List:Collections.vector(of:Top)
    //class method mut Set #seqBuilder() Set.empty()
    //class method Set #from(Set seqBuilder)seqBuilder
    //Set: UnsafeRefactor.Compose.compose(left:SolidTrait() //Use[SolidTrait()]<><
    //  right:{(var BinaryFlag32 that) implements Concept.ToS
    //  class method mut This #seqBuilder() this.empty()
    //  class method mut This empty() This(0BinaryFlag32)
    //  class method This #from(This seqBuilder) seqBuilder
    //  mut method Void #add(Top that) this.that(\that | (1BinaryFlag32<><that.that()))
    //  method This ++(This that) This(this.that() | that.that())
    //  method This --(This that) This(this.that() & ~that.that())
    //  method This &(This that) This(this.that() & that.that())
    //  method Bool >(Top that)  this.that() equals(this.that() | 1BinaryFlag32<><that.that())
    //  method toS()
    //    This.myName()++S"["[
    //      with n in 0Size.vals(), d in Top.names().vals() (
    //        if this>Top(n) (use[ d sep:S";"])
    //        )]"]"
   //
   //   read method Bool equals(read This that) this.that()==that.that()
   //   })//end compose
  }
}