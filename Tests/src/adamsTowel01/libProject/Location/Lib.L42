{ implements This1.This$
  //@plugin  toFix 
  //@pluginPart is.L42.connected.withSafeOperators.location.Lib
  
  
  This$:UnsafeRefactor.MiniData.thisLib()

  List:Collections.vector(of:This$)

  class method
   Library #pluginUnresponsive(Library binaryRepr)
     binaryRepr

  method
  List nesteds()
    List[with i in 0Size.vals(upTo:this.nestedSize()) (use[this.nested(i)])]
  method
  List allNesteds()
    List[this]++
    List[with nc in this.nesteds().vals() (
      with nci in nc.allNesteds().vals() (use[nci])
    )]
  method This nested(Path path) exception NotAvailable (
    with ni in this.root().allNested().vals() (
      if ni.path()==path (return ni)
      )
    exception NotAvailable"Path "[path]"not present"
    )
  method Bool has(Path path) (
    unused=this.nested(path:path)
    catch exception NotAvailable Bool.false()
    Bool.true()
    )
        
  method
  Method.List methods()
    Method.List[with i in 0Size.vals(upTo:this.methodsSize()) (use[this.method(i)])]
    
  method Method method(Selector selector) exception NotAvailable (
    with mi in this.methods() (
      if mi.selector()==selector (return mi)
      )
    exception NotAvailable"Selector "[selector]"not present"
    )
  method Bool has(Selector selector) (
    unused=this.method(selector:selector)
    catch exception NotAvailable Bool.false()
    Bool.true()
    )      
  method
  Type.Implemented.List implementeds()
    Type.Implemented.List[with i in 0Size.vals(upTo:this.implementedSize()) (use[this.implemented(i)])]
    
  method Bool implements(class Any clazz){
    if Refactor.equalsClassObj(Any, and:clazz) (
      return Bool.True()
      ) 
     with ti in this.implementeds().vals() (
       with ri=ti.refTo() (
         on Type.RefTo.Binded (
           ci=ri.referredClassObj()
           if Type.RefTo.Binded.equalsClassObj(ci, and:clazz) (
            //no need of supertypes since normalized classes has transitive implements already
            return Bool.True()
            )
           )
         )
       )
     return Bool.false()
     }
  method Bool implements(Path path) {
     with ti in this.implementeds().vals() (
       with ri=ti.refTo() (
         on Type.RefTo.Lib (
           libi=ri.referredLib()
           if path==libi.path() (
             return Bool.true()
             )
           )
         )
       )
     return Bool.false()
     }   
  
    
  //methods imported from java
  method
  This newFromClass(class Any that)
  method 
  This newFromLibrary(Library that)
  method
  Doc doc()
  method 
  Type.Implemented implemented(Size that)
  method
  Size implementedsSize()
  method
  Bool isBinded()
  method
  Bool isCloseState()
  method//as in EnsureCoherent<><
  Bool isEnsuredCoherent()
  method
  Bool isInterface()
  method
  Bool isPotentialInterface()
  method
  Bool isRedirectable()
  method
  Method method(Size that)
  method
  Size methodSize()
  method
  This navigate(Path that)
  method
  Bool nested(Size that)
  method //empty doc if it is root
  Doc nestedDoc()
  method 
  Size nestedSize()
  method//last is its name, empty path for root
  Path path()
  method
  This root()

  refine method   //implemented but refined
  This location()
  refine read method
  class This class()
  //and == location() origin(Size) originSize() toS()
  }