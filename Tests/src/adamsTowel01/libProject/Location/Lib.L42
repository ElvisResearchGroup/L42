{
  //@plugin  toFix 
  //@pluginPart is.L42.connected.withSafeOperators.location.Doc
  class method Library #pluginUnresponsive(Library binaryRepr) binaryRepr
  refine method Lib location()
  method Size nestedsSize()
  method This nested(Size that)
  method
  List nesteds()
    List[with i in 0Size.vals(upTo:this.nestedSize()) (use[this.nested(i)])]
  method
  List allNesteds()
    List[this]++
    List[with nc in this.nesteds().vals() (
      with nci in nc.allNesteds().vals() (use[nci])
    )]
  method Lib nested(Path path) exception NotAvailable (
    with ni in this.root().allNested().vals() (
      if ni.path()==path (return ni)
      )
    exception NotAvailable"Path "[path]"not present"
    )
  method Bool has(Path path) (
    unused=this.nested(path:path)
    catch exception NotAvailable Bool.false()
    Bool.true()
    )
        
  method 
  Size methodsSize()

  method
  Method method(Size that)

  method
  Method.List methods()
    Method.List[with i in 0Size.vals(upTo:this.methodsSize()) (use[this.method(i)])]
    
  method Method method(Selector selector) exception NotAvailable (
    with mi in this.methods() (
      if mi.selector()==selector (return mi)
      )
    exception NotAvailable"Selector "[selector]"not present"
    )
  method Bool has(Selector selector) (
    unused=this.method(selector:selector)
    catch exception NotAvailable Bool.false()
    Bool.true()
    )      
  method Size implementedSize()
  method Type.Implemented implemented(Size that)
  method
  Type.Implemented.List implementeds()
    Type.Implemented.List[with i in 0Size.vals(upTo:this.implementedSize()) (use[this.implemented(i)])]
    
  method Bool implements(class Any clazz){
    if Refactor.equalsClassObj(Any, and:clazz) (
      return Bool.True()
      ) 
     with ti in this.implementeds().vals() (
       with ri=ti.refTo() (
         on Type.RefTo.Binded (
           ci=ri.referredClassObj()
           if Refactor.equalsClassObj(ci, and:clazz) (
            //no need of supertypes since normalized classes has transitive implements already
            return Bool.True()
            )
           )
         )
       )
     return Bool.false()
     }
  method Bool implements(Path path) {
     with ti in this.implementeds().vals() (
       with ri=ti.refTo() (
         on Type.RefTo.Lib (
           libi=ri.referredLib()
           if path==libi.path() (
             return Bool.true()
             )
           )
         )
       )
     return Bool.false()
     }   
  
  method Doc doc()
  **method S kindS()
  **Kind:Enum"interface,closedClass,openClass,template,freeTemplate"
  //TODO: freeTemplate must mean no class methods!! old idea (class methods not called) does not seams to make sense, if not called, then could be just not having them...
  technically you can still have class Type variables and use the method over those, but it seams like a minor case
  interface if label
  closedclass if private abstract exists
  else free template if all abs and no class meth
  else template  if all abs (recursive?)
  else open class??
  we may want different infos?
  -isInterface = easy
  plus one option between:
  -isBinded? = store flag? or, only for not binded:
  --isRedirectableToClass(all abstract)
  --isRedirectableToInterface (free template + interfaces)
  --isClosedClass (private state)? use the isOpenState?
that is closed for sure when binded?
  //or is all false: is open class
  
  --isCoherent (deep+need program)? only for not binded? use lable for binded? but label is imprecise? just false for binded?
called isCoherentlyBindable?
PROBLEMS:
  isCoherent can not be really checked on non still typable classes:
  -surelly coherent, surelly incoherent, most likly coherent
  *May be we just want a decorator PreventAbstract that fail if surelly incoherent? and not have an equivalent of isCoherent on Lib?
  *A decorator MakeStatePrivate also have the same trouble: what to do if the "state" is only most likly coherent?


  method
  Bool isInterface()
    this.kindS()==S"Interface"
  
  method
  Bool isCoherent()
    this.isInterface() | this.kindS()==S"CoherentClass"//Not a kind???
  
  This$:UnsafeRefactor.MiniData.thisLib()
  
  List:Collections.vector(of:This$)
    
  method Lib root()
  method Path path()//last is its name, empty path for root
  method Doc nestedDoc()//empty doc if it is root
  //even if obtained with a classObj, no method to get it back
  //to get a nested classObj, Refactor.navigateClassObj(classAny,Path)->classAny??
  }