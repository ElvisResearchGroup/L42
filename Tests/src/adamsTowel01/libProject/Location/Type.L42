{ interface
    This$:{interface implements This2.This$}
    method Doc doc()
    RefTo:UnsafeRefactor.This$er<><{interface implements Concept.Base
      This$:{interface}
      //toS is the full path with Thisn.
      Lib:UnsafeRefactor.MiniData<><This$Impl<><{ implements This1.This$
        This$:UnsafeRefactor.MiniData.thisLib()
        method Lib referredLib()
        }
      Unavailable:UnsafeRefactor.MiniData<><This$Impl<><{ implements This1.This$
        This$:UnsafeRefactor.MiniData.thisLib()
        //cases:
        //  (1)
        //  A: .. Refactor.introspect(lib:{ method B(B.C that)})..
        //  B:{..}//just not yet normalized in the program flow
        //  (2)
        //  A: .. Refactor.introspect(lib:{ method B()})..
        //  B:Foo<><{..}//B is not there yet.
        //  (3)
        //  A: .. Refactor.introspect(lib:{ method B.C()})..
        //  B:Foo<><{..}//we do not know if B.C will ever exists
        //  (4)
        //  {//this all is seen as This1 by lib:{..}
        //  A: .. Refactor.introspect(lib:{ method This1()})..
        //  }//it can not be norm, not even in principle, since
        //   // A is under compilation right now.
        
        }
      Binded:UnsafeRefactor.MiniData<><This$Impl<><{ implements This1.This$ //includes primitives
        This$:UnsafeRefactor.MiniData.thisLib()
        method class Any referredClassObj()
        //This class will also offer some static 
        //functionalities to work with classObjs: 
        //Refactor.navigateClassObj(classAny,Path)->classAny??
        //Lib do not offer a way to get back a classObj
        }
      Missing:UnsafeRefactor.MiniData<><This$Impl<><{ implements This1.This$
        This$:UnsafeRefactor.MiniData.thisLib()
        //mostly useful for docs, where we can use lowercase annotation
        //or we may want to preserve @P where we removed the P
        //also, if an (nested) Unavailable is resolved not existing..        
        }
      }
    method RefTo refTo()
    method Mdf mdf()//imm for exception/implemented    
    Return:UnsafeRefactor.MiniData<><This$Impl<><{ implements This1.This$
      This$:UnsafeRefactor.MiniData.thisLib()
      refine method Method location()
      }
    Parameter:UnsafeRefactor.MiniData<><This$Impl<><{ implements This1.This$
      This$:UnsafeRefactor.MiniData.thisLib()
      List:Collections.vector(of:This$)

      refine method Method location()
      method Size pos()//0 for this
      }
    Exception:UnsafeRefactor.MiniData<><This$Impl<><{ implements This1.This$
      This$:UnsafeRefactor.MiniData.thisLib()
      List:Collections.vector(of:This$)

      refine method Method location()
      method Size pos()//should start from 1 or 0?
      }
    Implemented:UnsafeRefactor.MiniData<><This$Impl<><{ implements This1.This$
      This$:UnsafeRefactor.MiniData.thisLib()
      List:Collections.vector(of:This$)

      refine method Lib location()
      method Size pos()//should start from 1 or 0?
      }    
    }