{ interface
    This$:{interface implements This2.This$}
    method Doc doc()
    RefTo:UnsafeRefactor.This$er<><{interface implements Concept.Base
      This$:{interface}
      //toS is the full path with Thisn.
      Lib:PUnresponsive<><UnsafeRefactor.MiniData<><{
        //@plugin  toFix 
        //@pluginPart is.L42.connected.withSafeOperators.location.TypeRefTo$Lib
        implements This1.This$
        This$:UnsafeRefactor.MiniData.thisLib()
        method Lib referredLib()
        }
      Unavailable:PUnresponsive<><UnsafeRefactor.MiniData<><{ 
        //@plugin  toFix 
        //@pluginPart is.L42.connected.withSafeOperators.location.TypeRefTo$Unavailable
        implements This1.This$
        This$:UnsafeRefactor.MiniData.thisLib()
        //cases:
        //  (1)
        //  A: .. Refactor.introspect(lib:{ method B(B.C that)})..
        //  B:{..}//just not yet normalized in the program flow
        //  (2)
        //  A: .. Refactor.introspect(lib:{ method B()})..
        //  B:Foo<><{..}//B is not there yet.
        //  (3)
        //  A: .. Refactor.introspect(lib:{ method B.C()})..
        //  B:Foo<><{..}//we do not know if B.C will ever exists
        //  (4)
        //  {//this all is seen as This1 by lib:{..}
        //  A: .. Refactor.introspect(lib:{ method This1()})..
        //  }//it can not be norm, not even in principle, since
        //   // A is under compilation right now.
        
        }
      Binded:PUnresponsive<><UnsafeRefactor.MiniData<><{
        //@plugin  toFix 
        //@pluginPart is.L42.connected.withSafeOperators.location.TypeRefTo$Binded
        implements This1.This$ //includes primitives
        This$:UnsafeRefactor.MiniData.thisLib()
        method
        class Any referredClassObj()

        class method
        Bool equalsClassObj(class Any that, class Any and)

        //This class will also offer some static 
        //functionalities to work with classObjs: 
        //Refactor.navigateClassObj(classAny,Path)->classAny??
        //Lib do not offer a way to get back a classObj
        }
      Missing:PUnresponsive<><UnsafeRefactor.MiniData<><{
        //@plugin  toFix 
        //@pluginPart is.L42.connected.withSafeOperators.location.TypeRefTo$Missing
        implements This1.This$
        This$:UnsafeRefactor.MiniData.thisLib()
        //mostly useful for docs, where we can use lowercase annotation
        //or we may want to preserve @P where we removed the P
        //also, if an (nested) Unavailable is resolved not existing..        
        }
      }
    method RefTo refTo()
    method Mdf mdf()//imm for exception/implemented    
    Return:PlgClass<><{
        //@plugin  toFix 
        //@pluginPart is.L42.connected.withSafeOperators.location.Type$Return
      implements This1.This$
      This$:UnsafeRefactor.MiniData.thisLib()
      refine method Method location()
      }
    Parameter:PlgClass<><{
        //@plugin  toFix 
        //@pluginPart is.L42.connected.withSafeOperators.location.Type$Parameter     
      implements This1.This$
      This$:UnsafeRefactor.MiniData.thisLib()
      List:Collections.vector(of:This$)

      refine method Method location()
      method Size pos()//0 for this
      }
    Exception:PlgClass<><{
        //@plugin  toFix 
        //@pluginPart is.L42.connected.withSafeOperators.location.Type$Exception
      implements This1.This$
      This$:UnsafeRefactor.MiniData.thisLib()
      List:Collections.vector(of:This$)

      refine method Method location()
      method Size pos()//should start from 1 or 0?
      }
    Implemented:PlgClass<><{
        //@plugin  toFix 
        //@pluginPart is.L42.connected.withSafeOperators.location.Type$Implemented
      implements This1.This$
      This$:UnsafeRefactor.MiniData.thisLib()
      List:Collections.vector(of:This$)

      refine method Lib location()
      method Size pos()//should start from 1 or 0?
      }    
    }