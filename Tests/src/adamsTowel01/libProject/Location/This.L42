{
interface implements Base //that is equals, toS and "know your class"
/*Idea: the introspection lets you talk about locations in the code, so 
if you have the class { class method Library foo()}
you can ask what is the return type of This.foo(), and you get
a Location.ReturnType knowing the Path (Library) the modifier (imm/immutable)
and the Location.Method that contains such type annotation.
###0 Location declaration and methods 
------------------------------------
Location:{
*/

method
Location location()
  
NotAvailable:Message.$<><{implements Guard}
  
//note: "class" is not a good name for an enum elem. Thus we use uppercase down
//Mdf:Enumeration"imm, mut, read, lent, capsule, fwdImm, fwdMut"
Mdf:Enum<><{class method Strings names()Strings[S"Immutable";S"Mutable";S"Read";S"Lent";S"Capsule";S"Class";S"FwdImmuable";S"FwdMutable"]
  class method This _Immutable() This(inner:0Size)
  method Bool isImmutable() this.inner()==0Size
  class method This _Mutable() This(inner:1Size)
  method Bool isMutable() this.inner()==1Size
  class method This _Read() This(inner:2Size)
  method Bool isRead() this.inner()==2Size
  class method This _Lent() This(inner:3Size)
  method Bool isLent() this.inner()==3Size
  class method This _Capsule() This(inner:4Size)
  method Bool isCapsule() this.inner()==4Size
  class method This _Class() This(inner:5Size)
  method Bool isClass() this.inner()==5Size
  class method This _FwdImmutable() This(inner:6Size)
  method Bool isFwdImmutable() this.inner()==6Size
  class method This _FwdMutable() This(inner:7Size)
  method Bool isFwdMutable() this.inner()==7Size 
  }

//###1 Origin
//------------------------------------  
method Size originsSize()//many since metaprogramming
method Origin origin(Size that)   
Origin:UnsafeRefactor.MiniData<><{
  //@plugin  toFix 
  //@pluginPart is.L42.connected.withSafeOperators.location.Origin
  S fileName
  Size line
  Size column
  This$:UnsafeRefactor.MiniData.thisLib()
  List:Collections.vector(of:This$)
  }
    
}
//we should test the former first. Add to origin a constructor method and make a test

/*
//###2 Doc 
//------------------------------------

Doc:UnsafeRefactor.MiniData<><{ implements Location
  //user will need typecase to discover precise type, location() not refined
  Annotation:UnsafeRefactor.MiniData<><{
    Type.RefTo key
    S text
  
    This$:UnsafeRefactor.MiniData.thisLib()
    List:Collection.vector(of:This$)
    }
  method Size annotationsSize()
  method Annotation annotation(Size that)   
  method
  Annotation.List origins()
    Annotation.List[with i in Count(this.originSize()) (use[this.origin(i)])]  
  }
    
//###3 Lib 
//------------------------------------

  //there is no Member since normalized classes have order: first nested, then methods
  Lib:UnsafeRefactor.MiniData<><{ implements Location
    refine method Lib location()
    method Size nestedsSize()
    method This nested(Size that)
    method
    List nesteds()
      List[with i in Count(this.nestedSize()) (use[this.nested(i)])]
    List allNesteds()
      List[this]++
      List[with nc in this.nesteds().vals() (
        with nci in nc.allNesteds().vals() (use[nci])
      )]
    method Lib nested(Path path) exception NotAvailable (
      with ni in this.root().allNested().vals() (
        if ni.path()==path (return ni)
        )
      exception NotAvailable"Path "[path]"not present"
      )
    method Bool has(Path path) (
      unused=this.nested(path:path)
      catch exception NotAvailable Bool.false()
      Bool.true()
      )
          
    method Size methodsSize()
    method Method method(Size that)
    Method.List methods()
      Method.List[with i in Count(this.methodsSize()) (use[this.method(i)])]
    
    method Method method(Selector selector) exception NotAvailable (
      with mi in this.methods() (
        if mi.selector()==selector (return mi)
        )
      exception NotAvailable"Selector "[selector]"not present"
      )
    method Bool has(Selector selector) (
      unused=this.method(selector:selector)
      catch exception NotAvailable Bool.false()
      Bool.true()
      )      
    method Size implementedsSize()
    method Type.Implemented implemented(Size that)
    method
    Type.Implemented.List implementeds()
      Type.Implemented.List[with i in Count(this.implementedsSize()) (use[this.implemented(i)])]
    
    method Bool implements(class Any clazz){
      if Refactor.equalsClassObj(Any, and:clazz) (
        return Bool.True()
        ) 
       with ti in this.implementeds().vals() (
         with ri=ti.refTo() (
           on Type.RefTo.Binded (
             ci=ri.referredClassObj()
             if Refactor.equalsClassObj(ci, and:clazz) (
              //no need of supertypes since normalized classes has transitive implements already
              return Bool.True()
              )
             )
           )
         )
       return Bool.false()
       }
    method Bool implements(Path path) {
       with ti in this.implementeds().vals() (
         with ri=ti.refTo() (
           on Type.RefTo.Lib (
             libi=ri.referredLib()
             if path==libi.path() (
               return Bool.true()
               )
             )
           )
         )
       return Bool.false()
       }   
    
    method Doc doc()
    method S kindS()
    Kind:Enum"..."
    method
    Bool isInterface()
      this.kindS()==S"Interface"
    Bool isCoherent()
      this.isInterface() | this.kindS()==S"CoherentClass"
    This$:UnsafeRefactor.MiniData.thisLib()
    List:Collection.vector(of:This$)
    
    method Lib root()
    method Path path()//last is its name, empty path for root
    method Doc nestedDoc()//empty doc if it is root
    //even if obtained with a classObj, no method to get it back
    //to get a nested classObj, Refactor.navigateClassObj(classAny,Path)->classAny??
    }

    
//###4 Method 
//------------------------------------

  Method:UnsafeRefactor.MiniData<><{
    This$:UnsafeRefactor.MiniData.thisLib()
    List:Collection.vector(of:This$)

    refine method Lib location()
    method Bool isAbstract()
    method Bool isRefine()
    method Selector selector()
    method Type.Return returnType()
    
    method Size parameterTypesSize()
    method Type.Parameter parameterType(Size that)
    method
    Type.Parameter.List parameterTypes()
      Type.Parameter.List[with i in Count(this.parameterTypesSize()) (use[this.parameterType(i)])]
      
    method Size exceptionsSize()
    method Type.Exception exception(Size that)
    method
    Type.Exception.List exceptions()
      Type.Exception.List[with i in Count(this.exceptionsSize()) (use[this.exceptions(i)])]
    }


//###5 Type and RefTo 
//------------------------------------

  Type:{ interface implements Base??
    method Doc doc()
    RefTo:{interface implements Base??
      //toS is the full path with Thisn.
      Lib:{ implements This1
        method Location.Lib referredLib()
        }
      Unavailable:{ implements This1
        //cases:
        //  (1)
        //  A: .. Refactor.introspect(lib:{ method B(B.C that)})..
        //  B:{..}//just not yet normalized in the program flow
        //  (2)
        //  A: .. Refactor.introspect(lib:{ method B()})..
        //  B:Foo<><{..}//B is not there yet.
        //  (3)
        //  A: .. Refactor.introspect(lib:{ method B.C()})..
        //  B:Foo<><{..}//we do not know if B.C will ever exists
        //  (4)
        //  {//this all is seen as This1 by lib:{..}
        //  A: .. Refactor.introspect(lib:{ method This1()})..
        //  }//it can not be norm, not even in principle, since
        //   // A is under compilation right now.
        
        }
      Binded:{implements This1 //includes primitives
        method class Any referredClassObj()
        }
      Missing:{implements This1
        //mostly useful for docs, where we can use lowercase annotation
        //or we may want to preserve @P where we removed the P
        //also, if an (nested) Unavailable is resolved not existing..        
        }
      }
    method RefTo refTo()
    method Mdf mdf()//imm for exception/implemented    
    Return:{ implements This1
      refine Method location()
      }
    Parameter:UnsafeRefactor.MiniData<><{ implements This1
      This$:UnsafeRefactor.MiniData.thisLib()
      List:Collection.vector(of:This$)

      refine method Method location()
      method Size pos()//0 for this
      }
    Exception:UnsafeRefactor.MiniData<><{ implements This1
      This$:UnsafeRefactor.MiniData.thisLib()
      List:Collection.vector(of:This$)

      refine method Method location()
      method Size pos()//should start from 1 or 0?
      }
    Implemented:UnsafeRefactor.MiniData<><{ implements This1
      This$:UnsafeRefactor.MiniData.thisLib()
      List:Collection.vector(of:This$)

      refine method Lib location()
      method Size pos()//should start from 1 or 0?
      }    
    }

//###6 Discussions 
//------------------------------------

By calling Refactor.introspect(lib:{...})or
By calling Refactor.introspect(class:A.B) you get a Location.Lib

Java Lib need to store a optional classObj in case
the lib come from binded class.
When extracting a RefTo from a type with classObj, it will
never be Lib.
if the classObj is typed in p, it will be a RefTo a typed Binded
else will be any of Missing, Binded, Unreached 


L::={ interface? Doc implements Ts mwt1..mwtn nc1..nck Phase}  //library compiled
mwt::= abstract? refine? mh //we do not expose the implementation
nc::= C Doc:L
mdf::= imm|mut|lent|read|capsule|class | fwdImm | fwdMut 
ms::=m(xs) //method selector
mh::= mdf method Doc T m(T1 x1..Tn xn) exception Ts
P::= Thisn.Cs | Any | Library | Void  //is pronounced "Path"
T::= mdf P Doc
Doc::= //has a text, a set of annotations,
 //where every annotation can be either a string or
 //a Path, and a string content for each annotation 
C::= uppercase identifiers including $ as uppercase
x::= lowercase identifier including _ as lowercase
m::= x| #x

Notes:
//no more methodKind, just isAbstract+isRefine is all we need 

//from oldImpl: state/stateCandidate
//rootPath no. nestedFromRoot can be emulated by root().nested(path:))

//isPrivate should be a method for Selector/Path

impl Concept.ToS,Concept.Equals, Concept.Classable //that is Base
equals is complex: are two equal literal equal 
  if binded to different names? yes if they have the same origins?

    
All locations need to be sum with
{ implements Location
  method
  Origin.List origins()
    Origin.List[with i in Count(this.originSize()) (use[this.origin(i)])]
  }
Refactor.baseDefaults()<>< to call MiniData?

Refactor2 design:

who come first?

java impl for AllErrors(Doneish),Location, Sum, Redirect,liftValue with new errors
1 java Location
2 java enrich some errors with Location, some will have lists-> blasSize() blas(Size that)
3 java Sum with new errors/testing
4 redirect, and james can import the tests? depends on how sum goes?
5 safeOperatorsAccess can be updated to use new Sum/Redirect
6 finally, we can start Refactor2 as below...

Refactor2
  Fail impl Base
  OpAccess:PrW<><{//we may need to continue using a variation of
    //safeOperatorsAccess instead...
    compose,//use Compose check
    redirect, liftValue  //no errors
    }
  Resource
  MiniData/baseDefaults()
  ErrorW using MiniData
  AllErrors, with LocationTmp location() 
    and LocationTmp:{..dull impl for #binaryRepr etc for nested Lib:{} Method:{} etc}
  compose
  Compose:{//plugAnn
    class method
    Library main(Library left,Library right)
    exception ..
    }
  redirect //may need to add support for class Any
  Redirect:{//plgAnn}
  etc?
  }
  Location:..
  Redirect3:{..stuff needing Locations..}
  
  in Fixing:
    Refactor=Refactor2+Refactor3,
    Resource=Refactor.Resource
    redirect Refactor.LocationTmp to Location?
    
*/