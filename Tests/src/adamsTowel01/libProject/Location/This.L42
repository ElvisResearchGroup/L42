{
interface implements Concept.Base //that is equals, toS and "know your class"
/*Idea: the introspection lets you talk about locations in the code, so 
if you have the class { class method Library foo()}
you can ask what is the return type of This.foo(), and you get
a Location.ReturnType knowing the Path (Library) the modifier (imm/immutable)
and the Location.Method that contains such type annotation.
###0 Location declaration and methods 
------------------------------------
Location:{
*/

method
This location()
NotAvailable:Message.$<><{implements Guard}
  
//note: "class" is not a good name for an enum elem. Thus we use uppercase down
//Mdf:Enumeration"imm, mut, read, lent, capsule, fwdImm, fwdMut"
Mdf:Enum<><{class method Strings names()Strings[S"Immutable";S"Mutable";S"Read";S"Lent";S"Capsule";S"Class";S"FwdImmuable";S"FwdMutable"]
  class method This _Immutable() This(inner:0Size)
  method Bool isImmutable() this.inner()==0Size
  class method This _Mutable() This(inner:1Size)
  method Bool isMutable() this.inner()==1Size
  class method This _Read() This(inner:2Size)
  method Bool isRead() this.inner()==2Size
  class method This _Lent() This(inner:3Size)
  method Bool isLent() this.inner()==3Size
  class method This _Capsule() This(inner:4Size)
  method Bool isCapsule() this.inner()==4Size
  class method This _Class() This(inner:5Size)
  method Bool isClass() this.inner()==5Size
  class method This _FwdImmutable() This(inner:6Size)
  method Bool isFwdImmutable() this.inner()==6Size
  class method This _FwdMutable() This(inner:7Size)
  method Bool isFwdMutable() this.inner()==7Size 
  }

//###1 Origin
//------------------------------------  
This$:{interface
  method Size originsSize()//many since metaprogramming
  method Origin origin(Size that)   
  }  
Origin:UnsafeRefactor.MiniData<><...
//###2 Doc 
//------------------------------------
Doc:UnsafeRefactor.MiniData<><...
//###3 Lib 
//------------------------------------
//there is no Member since normalized classes have order: first nested, then methods
//Lib:UnsafeRefactor.MiniData<><...
}
 /*   
//###4 Method 
//------------------------------------

  Method:UnsafeRefactor.MiniData<><{
    This$:UnsafeRefactor.MiniData.thisLib()
    List:Collections.vector(of:This$)

    refine method Lib location()
    method Bool isAbstract()
    method Bool isRefine()
    method Selector selector()
    method Type.Return returnType()
    
    method Size parameterTypesSize()
    method Type.Parameter parameterType(Size that)
    method
    Type.Parameter.List parameterTypes()
      Type.Parameter.List[with i in 0Size.vals(upTo:this.parameterTypesSize()) (use[this.parameterType(i)])]
      
    method Size exceptionsSize()
    method Type.Exception exception(Size that)
    method
    Type.Exception.List exceptions()
      Type.Exception.List[with i in 0Size.vals(upTo:this.exceptionsSize()) (use[this.exceptions(i)])]
    }


//###5 Type and RefTo 
//------------------------------------

  Type:{ interface implements Base??
    method Doc doc()
    RefTo:{interface implements Base??
      //toS is the full path with Thisn.
      Lib:{ implements This1
        method Lib referredLib()
        }
      Unavailable:{ implements This1
        //cases:
        //  (1)
        //  A: .. Refactor.introspect(lib:{ method B(B.C that)})..
        //  B:{..}//just not yet normalized in the program flow
        //  (2)
        //  A: .. Refactor.introspect(lib:{ method B()})..
        //  B:Foo<><{..}//B is not there yet.
        //  (3)
        //  A: .. Refactor.introspect(lib:{ method B.C()})..
        //  B:Foo<><{..}//we do not know if B.C will ever exists
        //  (4)
        //  {//this all is seen as This1 by lib:{..}
        //  A: .. Refactor.introspect(lib:{ method This1()})..
        //  }//it can not be norm, not even in principle, since
        //   // A is under compilation right now.
        
        }
      Binded:{implements This1 //includes primitives
        method class Any referredClassObj()
        }
      Missing:{implements This1
        //mostly useful for docs, where we can use lowercase annotation
        //or we may want to preserve @P where we removed the P
        //also, if an (nested) Unavailable is resolved not existing..        
        }
      }
    method RefTo refTo()
    method Mdf mdf()//imm for exception/implemented    
    Return:{ implements This1
      refine Method location()
      }
    Parameter:UnsafeRefactor.MiniData<><{ implements This1
      This$:UnsafeRefactor.MiniData.thisLib()
      List:Collections.vector(of:This$)

      refine method Method location()
      method Size pos()//0 for this
      }
    Exception:UnsafeRefactor.MiniData<><{ implements This1
      This$:UnsafeRefactor.MiniData.thisLib()
      List:Collections.vector(of:This$)

      refine method Method location()
      method Size pos()//should start from 1 or 0?
      }
    Implemented:UnsafeRefactor.MiniData<><{ implements This1
      This$:UnsafeRefactor.MiniData.thisLib()
      List:Collections.vector(of:This$)

      refine method Lib location()
      method Size pos()//should start from 1 or 0?
      }    
    }

//###6 Discussions 
//------------------------------------

By calling Refactor.introspect(lib:{...})or
By calling Refactor.introspect(class:A.B) you get a Lib

Java Lib need to store a optional classObj in case
the lib come from binded class.
When extracting a RefTo from a type with classObj, it will
never be Lib.
if the classObj is typed in p, it will be a RefTo a typed Binded
else will be any of Missing, Binded, Unreached 


L::={ interface? Doc implements Ts mwt1..mwtn nc1..nck Phase}  //library compiled
mwt::= abstract? refine? mh //we do not expose the implementation
nc::= C Doc:L
mdf::= imm|mut|lent|read|capsule|class | fwdImm | fwdMut 
ms::=m(xs) //method selector
mh::= mdf method Doc T m(T1 x1..Tn xn) exception Ts
P::= Thisn.Cs | Any | Library | Void  //is pronounced "Path"
T::= mdf P Doc
Doc::= //has a text, a set of annotations,
 //where every annotation can be either a string or
 //a Path, and a string content for each annotation 
C::= uppercase identifiers including $ as uppercase
x::= lowercase identifier including _ as lowercase
m::= x| #x

Notes:
//no more methodKind, just isAbstract+isRefine is all we need 

//from oldImpl: state/stateCandidate
//rootPath no. nestedFromRoot can be emulated by root().nested(path:))

//isPrivate should be a method for Selector/Path

impl Concept.ToS,Concept.Equals, Concept.Classable //that is Base
equals is complex: are two equal literal equal 
  if binded to different names? yes if they have the same origins?

    
All locations need to be sum with
{ implements Location
  method
  Origin.List origins()
    Origin.List[with i in 0Size.vals(upTo:this.originSize()) (use[this.origin(i)])]
  }
Refactor.baseDefaults()<>< to call MiniData?

Refactor2 design:

who come first?

java impl for AllErrors(Doneish),Location, Sum, Redirect,liftValue with new errors
1 java Location
2 java enrich some errors with Location, some will have lists-> blasSize() blas(Size that)
3 java Sum with new errors/testing
4 redirect, and james can import the tests? depends on how sum goes?
5 safeOperatorsAccess can be updated to use new Sum/Redirect
6 finally, we can start Refactor2 as below...

Refactor2
  Fail impl Base
  OpAccess:PrW<><{//we may need to continue using a variation of
    //safeOperatorsAccess instead...
    compose,//use Compose check
    redirect, liftValue  //no errors
    }
  Resource
  MiniData/baseDefaults()
  ErrorW using MiniData
  AllErrors, with LocationTmp location() 
    and LocationTmp:{..dull impl for #binaryRepr etc for nested Lib:{} Method:{} etc}
  compose
  Compose:{//plugAnn
    class method
    Library main(Library left,Library right)
    exception ..
    }
  redirect //may need to add support for class Any
  Redirect:{//plgAnn}
  etc?
  }
  Location:..
  Redirect3:{..stuff needing Locations..}
  
  in Fixing:
    Refactor=Refactor2+Refactor3,
    Resource=Refactor.Resource
    redirect Refactor.LocationTmp to Location?
    
*/