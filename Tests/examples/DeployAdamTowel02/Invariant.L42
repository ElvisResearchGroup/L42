{

  ' error handling
  InvariantFailure:Message.$<<{<:MetaGuard}
  type method Bool isInvariant(Introspection.NestedClass that) {
    interf=that.transitivelyImplementedInterfaces()
    with ti in interf.vals() (
      with tAny=ti.referencedPath().externalType() (
        on type Concept.Invariant return Bool.true()
        )
      catch error Guard.Operation void
      void
      )
    return Bool.false()
    }
  type method
  Introspection.Methods extractOkState(Library that)
  exception Default.DecorationUnfeasable{
    i=Introspection(lib:that)
    isInv=this.isInvariant(i)
    if !isInv (return Introspection.Methods[])
    state=i.state()
    if state.isEmpty() (exception Default.DecorationUnfeasable"State is empty")
    k=state.top()
    if k.isPrivate() (exception Default.DecorationUnfeasable"State is private")
    return state
    }
  
  'invariant checking and actions
  type method
  Void checkInvariant(read Concept.Invariant that) (
    if !that.invariant() (
      error InvariantFailure(
        text:S"invalid object detected "++Refactor.Tools.getToSOrName(that) )
      )
    )
  type method
  Library constructorAction(Introspection.Type that) {
    immA={<:Concept.Invariant 
      type method
      Outer0 (Outer0 that) ( Invariant.checkInvariant(that) that )
      }
    mutA={<:Concept.Invariant 
      type method
      mut Outer0 (mut Outer0 that) ( Invariant.checkInvariant(that) that )
      }
    lentA={<:Concept.Invariant 
      type method
      mut Outer0 (mut Outer0 that) ( Invariant.checkInvariant(that) that )
      }
    readA={<:Concept.Invariant 
      type method
      mut Outer0 (mut Outer0 that) ( Invariant.checkInvariant(that) that )
      }
    capsuleA={<:Concept.Invariant 
      type method
      capsule Outer0 (capsule Outer0 that) ( 
        mut Outer0 open=that
        Invariant.checkInvariant(open)
        open
        )
      }
    mdf=that.mdf()
    if mdf==S"" (return immA)
    if mdf==S"mut" (return mutA)
    if mdf==S"lent" (return lentA)
    if mdf==S"read" (return readA)
    if mdf==S"capsule" (return capsuleA)
    error Default.DecorationUnfeasable(
        text:S"unidentified mdf:"[mdf]"!")
    }
  type method
  Library setterAction() {<:Concept.Invariant 
    mut method
    Void (Void that) (
      Invariant.checkInvariant(this) 
      that
      )
    }
  
  type method
  Library idAction(Introspection.Type that){
    classA={ type method type T (type T that) that T:{}}
    immA={ type method T (T that) that T:{}}
    mutA={ type method mut T (mut T that) that T:{}}
    lentA={ type method lent T (lent T that) that T:{}}
    readA={ type method read T (read T that) that T:{}}
    Library mdfA={
      mdf=that.mdf()
      if mdf==S"type" (return classA)
      if mdf==S"" (return immA)
      if mdf==S"mut" (return mutA)
      if mdf==S"lent" (return lentA)
      if mdf==S"read" (return readA)
      error Default.DecorationUnfeasable(
        text:S"unidentified mdf:"[mdf]"!")
      }
    nc=that.referencedPath()
    if nc.hasExternalType() (
      return Refactor.Redirect(
        Path"T" to:nc.externalType())<<mdfA
      )
    return Refactor.RenamePath(
      Path"T" to:nc.pathFromRoot())<<mdfA
    catch exception MetaGuard cnr
      error Assert.CodeNotReachable"idAction"(cnr)
    }
    
  'main decoration method
  type method
  Library<<(Library that)
  exception Default.DecorationUnfeasable
    this.stateDecoration(that,state:this.extractOkState(that))
  
  'decoration after pre checking
  type method
  Library stateDecoration(Library that,Introspection.Methods state){
    if state.isEmpty() (return that)
    p=Path"Outer0"
    kSel=state.top().selector()
    kName=kSel.name()
    kNames=kSel.names()
    kNameF=SafeOperators.freshName(kName)
    kNamesF=Strings[with n in kNames.vals() (
      use[SafeOperators.freshName(n)])]
    kSelF=Selector.from(name:kNameF,names:kNamesF)
    var acc=that
    with m in state.vals() (
      s=m.selector()
      mdf=m.thisMdf()
      zeroArgs=s.names().isEmpty()
      'Debug(S"zeroArgs"[zeroArgs]"")
      if mdf==S"type" (
        'Debug(S"is k "[s]"")
        acc:=PostAction(s of:p 
          action:this.constructorAction(m.returnType())
          deprecated: kSelF)<<acc
        )
      else (
        newSel=Outer0.stateFName(s,old:kNames, fresh:kNamesF)
        'Debug(S"!!")
        if zeroArgs (
          'Debug(S"is getter/exposer "[s]" "[newSel]"")
          acc:=PostAction(s of:p 
            action:this.idAction(m.returnType())
            deprecated:newSel
            )<<acc
          )
        else (
          'Debug(S"is setter "[s]" "[newSel]" "[with ni in s.names().vals() (use[S"{"++ni++S"}"])]"!!")
          acc:=PostAction(s of:p 
            action:this.setterAction()
            deprecated:newSel
            )<<acc
          )
        )
      )
    'Debug(Introspection(lib:acc).allAsString())
    acc:=Refactor.MakePrivateSelector(kSelF of:p)<<acc
    return acc
    catch exception  MetaGuard cnr
      error Assert.CodeNotReachable"Invariant"(cnr)
    }
    
  type method
  Selector stateFName(
  Selector that, Strings old,Strings fresh){
    name=that.nameAsField()
    prefix=that.prefixAsField()
    names=that.names()
    with o in old.vals(), f in fresh.vals() (
      if name==o (return Selector.from(name:prefix++f,names:names))
      )
    error Assert.CodeNotReachable(text:S"stateFName ["[name]"]"
    [with o1 in old.vals(), f1 in fresh.vals() (use[o1++S"!"++f1])]"")     
    }
  }