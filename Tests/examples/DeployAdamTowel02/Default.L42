{
MyName:{
  DecorationUnfeasable:{(MetaGuard cause)<:MetaGuard
    type method Outer0 (MetaGuard that) Outer0(cause:that)
    method S::ToS ~() this.cause()
    method toS() S"MyName::DecorationUnfeasable["[this.cause()]"]"
    }
  type method Library<<(Library that) exception DecorationUnfeasable{
    return Extends[{
        type method S myName()(
          doc=Introspection(clazz:Outer0).record().docOf(path:Path"MyClass")
          nameAndPrefix=doc.annotations().top().toS()
          nameAndPrefix(start:nameAndPrefix.firstIndexOf(S"::")+2N)
          )}]<<that
    catch exception x(on MetaGuard exception DecorationUnfeasable(x))
    }
  }
    'i=Introspection(lib:that)
    'myName=i.methodFromSelector(Selector"myName()")
    'catch exception (on MetaGuard::MethodUnavailable return that)
    'if myName.methodKind()!=S"AbstractMethod" ( return that)
    'Library myNameImpl={
    '  if myName.thisMdf()==S"Immutable" (return {
    '    method S myName()(
    '      doc=Introspection(clazz:Outer0).record().docOf(path:Path"MyClass")
    '      nameAndPrefix=doc.annotations().top().toS()
    '      nameAndPrefix(start:nameAndPrefix.firstIndexOf(S"::")+2N)
    '      )})
}