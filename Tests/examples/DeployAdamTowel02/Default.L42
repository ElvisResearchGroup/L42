{
DecorationUnfeasable:Message::$[]<<{<:MetaGuard}


Parsable:{
  type method Library<<(Library that) exception DecorationUnfeasable{
    return Extends[{
    'ParseFailure:Message:S[]<<{<:Guard} no need, related to invariant?
    type method' if you do not implement it, it is a constructor?
    capsule Outer0 fromS(read Concept::ToS that)      
    type method
    Outer0 #stringParser(Library that) 
      Outer0.fromS(S.#stringParser(that))
      }]<<that
    catch exception mg (on MetaGuard exception DecorationUnfeasable(mg))
    }
  }
SealState:{
  ' how to specify which factory to keep out? what getters
  type method Library<<(Library that){
    i=Introspection(lib:that)
    return that
    }
  }
  
Invariant:{
  type method Bool isInvariant(Introspection::NestedClass that) {
    interf=that.transitivelyImplementedInterfaces()
    with ti in interf.vals() (
      with tAny=ti.referencedPath().externalType() (
        on type Concept::Invariant return Bool.true()
        )
      catch error (on Guard::Operation void)
      void
      )
    return Bool.false()
    }
  type method Library<<(Library that) exception DecorationUnfeasable{
    i=Introspection(lib:that)
    isInv=this.isInvariant(i)
    if !isInv (return that)
    state=i.state()
    if state.isEmpty() (exception DecorationUnfeasable"State is empty")
    k=state.top()
    if k.isPrivate() (exception DecorationUnfeasable"State is private")
    return that
    'tmp={type method mdf Outer0 k(args) }[rename k.selector() in fresh]+
    '  {<:Concept::Invariant 
    '  type method
    '  mdf Outer0 (mdf Outer0 new) {
    '  if !new.invariant() error ...
    '  return new}
    '  }[rename #apply(new) in k.selector()#]
    ' sumMethod Outer0 fresh k.selector()#
    'for  setters:
    '{ mut method Void (Void fresh){
    '  if !this.invariant() error ...
    '  return fresh
    '  }}
    }
  }

DataFromToS:{' in the future we can add also hashCode and > =>
  type method Library<<(Library that) exception DecorationUnfeasable{
    return Extends[{
    method Bool != (Outer0 that) !(this==that)
    read method Bool ==(read Outer0 that) this.toS()==that.toS()
    }]<<Equals<<that
    catch exception mg (
      on DecorationUnfeasable exception mg
      on MetaGuard exception DecorationUnfeasable(mg)
      )
    }
  }

Equals:{
  type method Library<<(Library that) exception DecorationUnfeasable{
    return Extends[{<:Concept::Equals
      method equals(that){
        with that (on Outer0 return this==that)
        return Bool.false()
        }
      read method Bool ==(read Outer0 that)
      }]<<that
    catch exception x(on MetaGuard exception DecorationUnfeasable(x))
    }
  }
Named:{
  type method Library<<(Library that) exception DecorationUnfeasable{
    return Extends[{<:Concept::Named
        method myName() Introspection(clazz:Outer0).externalTypeToS()
        }]<<that
    'can improve error: if is method defined against method implemented
    catch exception x(on MetaGuard exception DecorationUnfeasable(x))
    }
  }
    'i=Introspection(lib:that)
    'myName=i.methodFromSelector(Selector"myName()")
    'catch exception (on MetaGuard::MethodUnavailable return that)
    'if myName.methodKind()!=S"AbstractMethod" ( return that)
    'Library myNameImpl={
    '  if myName.thisMdf()==S"Immutable" (return {
    '    method S myName()(
    '      doc=Introspection(clazz:Outer0).record().docOf(path:Path"MyClass")
    '      nameAndPrefix=doc.annotations().top().toS()
    '      nameAndPrefix(start:nameAndPrefix.firstIndexOf(S"::")+2N)
    '      )})
}