{

type method Library ontologicMap(){interface
  method Alu _Alu()
  method ExitCode _ExitCode()
  method Bool _Bool()
  method N _N()
  method S _S()
  method Concept _Concept()
  method Message _Message()
  method Guard _Guard()
  method System _System()
  method Assert _Assert()
  method Strings _Strings()
  method Debug _Debug() 'change debug to avoid use introspection
  method ConceptMap _ConceptMap()
  
  method Path _Path()
  method Selector _Selector()
  method MetaGuard _MetaGuard()
  method Introspection _Introspection()
  method Refactor _Refactor()
  method Optimize _Optimize()
  method Opt _Opt()
  method Extends _Extends()
  method Use _Use()
  method Default _Default()
  method LinkedList _LinkedList()

  method Load _Load()
  method DeployLibrary _DeployLibrary()
  method DeployTowel _DeployTowel()

  method PreferentialComposition _PreferentialComposition()
}
'shape of a loadable library:
' Outer0 contains actual library, but
' Abstract:{} contains abstract classes, and 
' Abstract::ConceptMap mapps concepts names to abstract classes
  type method Outer0 #begin()'constructor
  method Outer0 #end() this
  ConceptMapMismatch:Message::$[]<<Default::MyName<<{<:MetaGuard}
  ConceptMapUnavailable:Message::$[]<<Default::MyName<<{<:MetaGuard}
  method
  Library << (Library that)
  exception ConceptMapMismatch, ConceptMapUnavailable
    {
    return Refactor::Redirect[Path"Abstract::ConceptMap" to:ConceptMap]<<that
    catch exception err (
      on MetaGuard::MemberUnavailable exception ConceptMapUnavailable(err)
      on MetaGuard::SourceUnfit exception ConceptMapMismatch(err)
      on MetaGuard::MethodClash exception ConceptMapMismatch()
      on MetaGuard::InvalidOnTopLevel error Assert::CodeNotReachable""
      )
    }
}