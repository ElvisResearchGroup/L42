{
'shape of a loadable library:
' Outer0 contains actual library, but
' Abstract:{} contains abstract classes, and 
' Abstract::ConceptMap mapps concepts names to abstract classes
  type method Outer0 #begin()'constructor
  method Outer0 #end() this
  ConceptMapMismatch:Message::$[]<<{<:MetaGuard}
  ConceptMapUnavailable:Message::$[]<<{<:MetaGuard}
  method
  Library << (Library that)
  exception ConceptMapMismatch, ConceptMapUnavailable
    {
    return Refactor::Redirect(Path"Abstract::ConceptMap" to:ConceptMap)<<that
    catch exception  MetaGuard::NestedClassUnavailable err (
        available=Introspection(lib:that).transitivelyNestedClasses()
        sAvailable=S""[with av in available.vals() ( 
            use[S.nl()++av.pathFromRoot().toS()] '(start:8N)  
            )]"" '[Introspection(lib:that)]"" contains a private PrImpl with still not normalized name?
        exception ConceptMapUnavailable(text:S"provided library do not offers Abstract::ConceptMap or "[err.path()]" avaible paths are "++sAvailable)
        'string parsing may have problem with parenthesis, try add par around or
        )
      catch exception MetaGuard::SourceUnfit err exception ConceptMapMismatch""(err)
      catch exception  MetaGuard::MethodClash err exception ConceptMapMismatch""(err)
      catch exception  MetaGuard::IncoherentRedirectMapping err exception ConceptMapMismatch""(err)
      catch exception  MetaGuard::InvalidOnTopLevel err error Assert::CodeNotReachable"Load1"
    }
  DeployLibrary:...
}