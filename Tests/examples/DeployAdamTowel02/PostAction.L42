{(Selector that,Path of,  Library action,Selector deprecated)

InvalidAction:Message::$[]<<{<:MetaGuard}

method
Library <<(Library that)
exception InvalidAction{
  'no throw
  origin=this.that()
  dest=this.deprecated()
  p=this.of()
  'only throw InvalidAction
  a=Action(path:p,proposedAction:this.action())
  'no throw expected
  var acc=that    
  acc:=Refactor::MoveImplementationSelector[
    origin of:p to:dest]<<acc
  acc:=Refactor.compose(left:acc,right:a.action())
  ('throws ParameterMismatch
    acc:=Refactor::SumMethods
      [dest and:a.fresh() of:p to: origin]<<acc
    catch exception parm( on MetaGuard::ParameterMismatch
        error InvalidAction
          "Action type signature do not fit with.. PostAct::Action0"(parm) 
          )
    void)
  'no throw expected
  acc:=Refactor::MakePrivateSelector[a.fresh() of:p]<<acc
  return acc    
  catch exception cnr( on MetaGuard
        error Assert::CodeNotReachable"PostAct::Action1"(cnr) )
  }
  Action:{(Selector fresh,Library action)
    type method Outer0 (Path path,Library proposedAction)
    exception InvalidAction{
      defS=Selector"#apply(that)"
      fresh=Selector.fresh(defS)
      defM=Introspection(lib: proposedAction, path:path)
        .methodFromSelector(defS)
      catch exception err (on MetaGuard 
        exception InvalidAction"action method not present"(err) )
      pt=defM.parameterTypes().top()
      rt=defM.returnType()
      if pt.toS()!=rt.toS() (exception InvalidAction"action return type need to be equal to parameter type" )
      action=Refactor::RenameSelector[
        defS of:path to:fresh]<<proposedAction
      catch exception cnr( on MetaGuard
        error Assert::CodeNotReachable"PostAct::Action2"(cnr) )
      return Outer0(fresh:fresh,action:action)
    }
  }
}
