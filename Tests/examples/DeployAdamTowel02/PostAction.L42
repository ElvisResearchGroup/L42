{(Selector that,Path of,  Library action,Selector deprecated)

InvalidAction:Message::$[]<<{<:MetaGuard}

method
Library <<(Library that)
exception InvalidAction{
  src=this.that() 'src selector of the method
  dest=this.deprecated()'dest selector for the copy of the method
  p=this.of()' path of the method
  a=Action(path:p,proposedAction:this.action())'throws InvalidAction
  var acc=that    
  acc:=Refactor::MoveImplementationSelector[
    src of:p to:dest]<<acc
  acc:=Refactor.compose(left:acc,right:a.action())
  acc:={'throws ParameterMismatch
    return Refactor::SumMethods
      [dest and:a.fresh() of:p over:a.fresh().names().top() to: src]<<acc
    catch exception MetaGuard::ParameterMismatch parm
        exception InvalidAction
          "Action type signature do not fit with.. PostAct::Action0"(parm) 
    }
  'no throw expected
  acc:=Refactor::MakePrivateSelector[a.fresh() of:p]<<acc
  return acc    
  catch exception MetaGuard cnr
        error Assert::CodeNotReachable"PostAct::Action1"(cnr)
  }
  Action:{(Selector fresh,Library action)
    type method Outer0 (Path path,Library proposedAction)
    exception InvalidAction{
      defS=Selector"#apply(that)"
      fresh=Selector.fresh(defS)
      defM=Introspection(lib: proposedAction, path:path)
        .methodFromSelector(defS)
      catch exception MetaGuard err 
        exception InvalidAction"action method not present"(err) 
      pt=defM.parameterTypes().top()
      rt=defM.returnType()
      if pt.toS()!=rt.toS() (exception InvalidAction"action return type need to be equal to parameter type" )
      action=Refactor::RenameSelector[
        defS of:path to:fresh]<<proposedAction
      catch exception MetaGuard cnr
        error Assert::CodeNotReachable"PostAct::Action2"(cnr)
      return Outer0(fresh:fresh,action:action)
    }
  }
}
