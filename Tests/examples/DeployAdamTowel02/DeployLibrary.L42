{(Path path,Url url)


type method
Library  exposeAsLibrary(Library that, Path path)
exception MetaGuard::NestedClassUnavailable, MetaGuard::PrivacyCoupuled
  {
  Assert::$[path!=Path"Outer0"]
  this.checkTargetExists(that,path:path)'throws MetaGuard::NestedClassUnavailable
  var res=that
  res:=Refactor::RenamePath[Path"Outer0" to:Path"PrImpl"]<<res
  catch exception unreachable(on MetaGuard error Assert::CodeNotReachable""(unreachable))
  with m in Introspection(lib:that, path:Path"ConceptMap").methods().vals() (
    p=m.pathFromRoot()
      (
      res:=Refactor::RenamePath[Path"PrImpl"++p to:Path"Abstract"++p]<<res
      catch exception notFound (
        on MetaGuard::MemberUnavailable error Assert::ObservedBug(
          text:S"map and library mismatch on "[p]"",cause:notFound)
        on MetaGuard error Assert::CodeNotReachable""(notFound)
        )
      void
      )
    )
  res:=Refactor::RemoveImplementationPath[Path"Abstract"]<<res'leak PrivacyCoupuled
  catch exception (on MetaGuard::MemberUnavailable error Assert::CodeNotReachable"")
  res:=Refactor::RenamePath[Path"PrImpl"++path to:Path"Outer0"]<<res
  res:=Refactor::MakePrivatePath[Path"PrImpl"]<<res
  catch exception (on MetaGuard error Assert::CodeNotReachable"")
  return res
  }
type method
Void checkTargetExists(Library that,Path path) exception MetaGuard::NestedClassUnavailable (
  unused=Refactor::AddDocumentationPath[path doc:Introspection::Doc"JustToSeeIfItIsThere"]<<that
  catch exception x (
    on MetaGuard::InvalidOnTopLevel error Assert::CodeNotReachable""
    )
  void
  )

type method type Outer0 #begin() Outer0
method Outer0 #end() this
type method Outer0 #add(Path that,Url url) Outer0(path:that,url:url)

method
Library <<(Library that) exception MetaGuard::NestedClassUnavailable, MetaGuard::PrivacyCoupuled {
  var res=Outer0.exposeAsLibrary(that,path:this.path())
  res:=Optimize::RemoveUnreachableCode[]<<res
  return DeployTowel[fileName:this.url().binaryRepr()]<<res
  }
}