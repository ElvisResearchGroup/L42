{(Path path,Url url)


type method
Library  exposeAsLibrary(Library that, Path path,Library map)
exception MetaGuard::NestedClassUnavailable, MetaGuard::PrivacyCoupuled
  {
  Assert::$[path!=Path"Outer0"]
  this.checkTargetExists(that)'throws MetaGuard::NestedClassUnavailable
  var res=that
  res:=Refactor::RenamePath[Path"Outer0" to:Path"PrImpl"]<<res
  catch exception unreachable(on MetaGuard error Assert::CodeNotReachable(unreachable))
  imap=Paths[with m in Introspection(lib:map).methods().vals() (m.pathFromRoot())]
  with p in imap (
    res:=Refactor::RenamePath[Path"PrImpl"++p to:Path"Abstract"++p]<<res
    catch exception notFound (
      on MetaGuard::MemberUnavailable error Assert::ObservedBug(
        text:S"map and library mismatch on "[p]"",cause:notFound)
      on MetaGuard error Assert::CodeNotReachable(notFound)
      )
    void
    )
  res:=Refactor::RemoveImplementationPath[Path"Abstract"]<<res'leak PrivacyCoupuled
  catch exception (on MetaGuard::MemberUnavailable error Assert::CodeNotReachable"")
  res:=RenamePath[Path"PrImpl"++path to:Path"Outer0"]<<res
  res:=MakePrivatePath[Path"PrImpl"]<<res
  catch exception (on MetaGuard error Assert::CodeNotReachable"")
  return res
  }
method
Void checkTargetExists(Library that) exception MetaGuard::NestedClassUnavailable (
  unused=AddDocumentationPath[this.that() doc:Introspection::Doc"JustToSeeIfItIsThere"]<<that
  catch exception x (
    on MetaGuard::InvalidOnTopLevel error Assert::CodeNotReachable""
    )
  void
  )

type method type Outer0 #begin() Outer0
method Outer0 #end() this
type method Outer0 #add(Path that,Url url) Outer0(path:that,url:url)

method
Library <<(Library that) exception MetaGuard::NestedClassUnavailable, MetaGuard::PrivacyCoupuled {
  var res=exposeAsLibrary(that,path:this.path(),map:Load.ontologicMap())
  res:=Optimize::RemoveUnreachableCode[]<<res
  return DeployTowel[fileName:this.url().binaryRepr()]<<res
  }
}