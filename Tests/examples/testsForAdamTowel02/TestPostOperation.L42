{reuse L42.is/AdamTowel02
PostAct:{(Selector that,Path of,  Library action,Selector deprecated)
  InvalidAction:Message::$[]<<{<:MetaGuard}
  method
  Library <<(Library that)
  exception InvalidAction{
    'no throw
    origin=this.that()
    dest=this.deprecated()
    p=this.of()
    'only throw InvalidAction
    a=Action(path:p,proposedAction:this.action())
    
    var acc=that    
    acc:=Refactor::MoveImplementationSelector[
      origin of:p to:dest]<<acc
    acc:=Refactor.compose(left:acc,right:a.action())
    (
      acc:=Refactor::SumMethods
        [dest and:a.fresh() of:p to: origin]<<acc
      catch exception parm( on MetaGuard::ParameterMismatch
          error InvalidAction
            "Action type signature do not fit with.. PostAct::Action0"(parm) 
            )
      void)
    acc:=Refactor::MakePrivateSelector[a.fresh() of:p]<<acc
    return acc    
    catch exception cnr( on MetaGuard
          error Assert::CodeNotReachable"PostAct::Action0"(cnr) )
    }
    Action:{(Selector fresh,Library action)
      type method Outer0 (Path path,Library proposedAction)
      exception InvalidAction{
        defS=Selector"#apply(that)"
        fresh=Selector.fresh(defS)
        defM=Introspection(lib: proposedAction, path:path)
          .methodFromSelector(defS)
        catch exception err (on MetaGuard 
          exception InvalidAction"action method not present"(err) )
        pt=defM.parameterTypes().top()
        rt=defM.returnType()
        if pt.toS()!=rt.toS() (exception InvalidAction"action return type need to be equal to parameter type" )
        action=Refactor::RenameSelector[
          defS of:path to:fresh]<<proposedAction
        catch exception cnr( on MetaGuard
          error Assert::CodeNotReachable"PostAct::Action0"(cnr) )
        return Outer0(fresh:fresh,action:action)
      }
    }
  }

  'throws shortcuts: return { return }  exception errorOn/exceptionOn
    ' on Metaguard, Guard error e
    ' exceptionOn Metaguard InvalidAction"YEP"
    
  
GetSOrName:{
  type method S(read Any that){
    with that (
      on Concept::ToS return that.toS()
      on Concept::Classable return GetMyName(that.classAny())++S" instance"
      default return S"instance not ToS or Classable"
      )
    }
  }
Selectors:LinkedList.list(Selector)
    

C:PostAct(Selector"foo()"
  of:Path"Outer0",
  action:{ type method Void (Void that) Debug(S"World")}
  deprecated:Selector"bar()"
  )<<{type method Void foo() Debug(S"Hello")}
Main:{
  C.foo()
  C.bar()
  return ExitCode.failure()
  }
' method Bool isConcrete() true iff all non state methods are implemented and
' all the interface methods are implemented.

'add a printableOutline() to nested class
' all public methods lv1,
' for all public nc lv*, if not annotated '@importanceX with x 1-*, with indented methods
' otherwise with all methods inline, nested after?

 

}
