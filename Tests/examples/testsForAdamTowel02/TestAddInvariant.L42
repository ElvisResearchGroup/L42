{reuse L42.is/AdamTowel02

GetSOrName:{
  type method S(read Any that){
    with that (
      on Concept::ToS return that.toS()
      on Concept::Classable return GetMyName(that.classAny())++S" instance"
      default return S"instance not ToS or Classable"
      )
    }
  }
Selectors:LinkedList.list(Selector)

Invariant:{
  InvariantFailure:Message::$[]<<{<:MetaGuard}
  type method Bool isInvariant(Introspection::NestedClass that) {
    interf=that.transitivelyImplementedInterfaces()
    with ti in interf.vals() (
      with tAny=ti.referencedPath().externalType() (
        on type Concept::Invariant return Bool.true()
        )
      catch error (on Guard::Operation void)
      void
      )
    return Bool.false()
    }
  type method
  Introspection::Methods extractOkState(Library that)
  exception Default::DecorationUnfeasable{
    i=Introspection(lib:that)
    isInv=this.isInvariant(i)
    if !isInv (return Introspection::Methods[])
    state=i.state()
    if state.isEmpty() (exception Default::DecorationUnfeasable"State is empty")
    k=state.top()
    if k.isPrivate() (exception Default::DecorationUnfeasable"State is private")
    return state
    }
  type method
  Selector getCheckerSelector() Selector.fresh(Selector"k(new)")
  type method
  Library getChecker(Selector that) {
    return Refactor::RenameSelector[
      Selector"k(new)"
      of: Path"Outer0"
      to: that
      ]<<{<:Concept::Invariant 
        type method ' TODO:should not work on immutable objects only
        Outer0 k(Outer0 new) {
          if !new.invariant() ( error InvariantFailure(text:S"invalid object detected "++GetSOrName(new) ))
          return new
          }
        }
      catch exception cnr( on MetaGuard error Assert::CodeNotReachable"Invariant0"(cnr) )
      }
  type method
  Library<<(Library that)
  exception Default::DecorationUnfeasable
    this.stateDecoration(that,state:this.extractOkState(that))
    
  type method Library stateDecoration(Library that,Introspection::Methods state){
    if state.isEmpty() (return that)
    k=state.top()
    kSel=k.selector()
    kSelFresh=Selector.fresh(kSel)
    'for now, we should
    'check all ret.types are imm mdf
    checkerKSel=this.getCheckerSelector()
    var checker=Refactor.compose(left:that,
      right:this.getChecker(checkerKSel))
    checker:=Refactor::SumMethods[
      kSel
      and:checkerKSel
      of:Path"Outer0"
      to:kSelFresh]<<checker      
    catch exception cnr1(
      on MetaGuard error Assert::CodeNotReachable"Invariant1"(cnr1)
      )
    fields=Selectors[with m in state.pop().vals() (
      s=m.selector()
      s1=Selector.fresh(s)
      checker:=Refactor::MoveImplementationSelector[s of:Path"Outer0" to:s1]<<checker
      s1)]
    catch exception cnr2(
      on MetaGuard error Assert::CodeNotReachable"Invariant2"(cnr2)
      )
    checker:=Refactor::MakePrivateSelector[kSel of:Path"Outer0"]<<checker
    checker:=Refactor::MakePrivateSelector[checkerKSel of:Path"Outer0"]<<checker
    catch exception cnr3(
      on MetaGuard error Assert::CodeNotReachable"Invariant3"(cnr3)
      )
    checker:=Refactor::RenameSelector[kSelFresh of:Path"Outer0" to: kSel]<<checker
    'Debug(Introspection(lib:checker).allAsString())
    with s2 in fields.vals(), m2 in state.pop().vals() (
      Debug(S"rename "[s2]"into "[m2.selector()]"")
      checker:=Refactor::RenameSelector[s2 of:Path"Outer0" to: m2.selector()]<<checker
      Debug(S"-------------------------------DONE")
Debug(Introspection(lib:checker).allAsString())
      
   )
    return checker
    catch exception cnr4(
      on MetaGuard error Assert::CodeNotReachable"Invariant4"(cnr4)
      )
    }
  }
  
  '-#n diventa privato? controlla cosa succede in add doc private constr.
  '-fare un operatre di delega generale, che prende un post oporation optionale e fa anche rename e lascia il vecchio come deprecated
  'tmp={type method mdf Outer0 k(args) }[rename k.selector() in fresh]+
    '  {<:Concept::Invariant 
    '  type method
    '  mdf Outer0 (mdf Outer0 new) {
    '  if !new.invariant() error ...
    '  return new}
    '  }[rename #apply(new) in k.selector()#]
    ' sumMethod Outer0 fresh k.selector()#
    'for  setters:
    '{ mut method Void (Void fresh){
    '  if !this.invariant() error ...
    '  return fresh
    '  }}
    

C:Invariant<<{a(N n)<:Concept::Invariant
  method invariant() this.n()>10N
  }
Main:{
  C c1=C.a(n:20N)
  Debug(S"Ok 20")
  C c2=C.a(n:5N)
  Debug(S"Ok 5")
  return ExitCode.failure()
  catch error err (
    on Invariant::InvariantFailure
      return ExitCode.normal()
    )
  }
' method Bool isConcrete() true iff all non state methods are implemented and
' all the interface methods are implemented.
}
'add a printableOutline() to nested class
' all public methods lv1,
' for all public nc lv*, if not annotated '@importanceX with x 1-*, with indented methods
' otherwise with all methods inline, nested after?

Patch:{'no, remove metaguard entirelly, make methClash and co as 
'nested in Refactor, and specific errors as nested in the operator?
'remove also the general DecorationUnfeasable?
'or on the opposite, have DecorationUnfeasable take a class, and print itself in a fancy way to look like a nested?
'  MetaGuard:{interface
'    DecorationUnfeasable:Message::$[]<<{<:MetaGuard}
'    }
'make [] works for Message messages
'throws shortcuts: return { return }  exception errorOn/exceptionOn
    ' on Metaguard, Guard error e
    ' exceptionOn Metaguard InvalidAction"YEP"  
' method Bool isConcrete() true iff all non state methods are implemented and
' all the interface methods are implemented.

'add a printableOutline() to nested class
' all public methods lv1,
' for all public nc lv*, if not annotated '@importanceX with x 1-*, with indented methods
' otherwise with all methods inline, nested after?
  }

  }


