{reuse L42.is/AdamTowel02

Invariant:{

  ' error handling
  InvariantFailure:Message::$[]<<{<:MetaGuard}
  type method Bool isInvariant(Introspection::NestedClass that) {
    interf=that.transitivelyImplementedInterfaces()
    with ti in interf.vals() (
      with tAny=ti.referencedPath().externalType() (
        on type Concept::Invariant return Bool.true()
        )
      catch error (on Guard::Operation void)
      void
      )
    return Bool.false()
    }
  type method
  Introspection::Methods extractOkState(Library that)
  exception Default::DecorationUnfeasable{
    i=Introspection(lib:that)
    isInv=this.isInvariant(i)
    if !isInv (return Introspection::Methods[])
    state=i.state()
    if state.isEmpty() (exception Default::DecorationUnfeasable"State is empty")
    k=state.top()
    if k.isPrivate() (exception Default::DecorationUnfeasable"State is private")
    return state
    }
  
  'invariant checking and actions
  type method
  Void checkInvariant(read Concept::Invariant that) (
    if !that.invariant() (
      error InvariantFailure(
        text:S"invalid object detected "++GetSOrName(that) )
      )
    )
  type method
  Library constructorAction(Invariant::Method that) {
    immA={<:Concept::Invariant 
      type method
      Outer0 (Outer0 that) ( Invariant.checkInvariant(that) that )
      }
    mutA={<:Concept::Invariant 
      type method
      mut Outer0 (mut Outer0 that) ( Invariant.checkInvariant(that) that )
      }
    lentA={<:Concept::Invariant 
      type method
      mut Outer0 (mut Outer0 that) ( Invariant.checkInvariant(that) that )
      }
    readA={<:Concept::Invariant 
      type method
      mut Outer0 (mut Outer0 that) ( Invariant.checkInvariant(that) that )
      }
    capsuleA={<:Concept::Invariant 
      type method
      capsule Outer0 (capsule Outer0 that) ( Invariant.checkInvariant(that) that )
      }
    with mdf=that.returnType().mdf() (
      case mdf==S"" return immA
      case mdf==S"mut" return mutA
      case mdf==S"lent" return lentA
      case mdf==S"read" return readA
      case mdf==S"capsule" return capsuleA
      default error Default::DecorationUnfeasable(
        text:S"unidentified mdf:"[mdf]"!")
      )
    }
  }
  type method
  Library setterAction() {<:Concept::Invariant 
    mut method
    Void (Void that) (
      Invariant.checkInvariant(this) 
      that
      )
    }
  
  type method
  Library idAction(Introspection::Type that){
    classA={ type method type T (type T that) that T:{}}
    immA={ type method T (T that) that T:{}}
    mutA={ type method mut T (mut T that) that T:{}}
    lentA={ type method lent T (lent T that) that T:{}}
    readA={ type method read T (read T that) that T:{}}
    mdfA={with mdf=that.mdf() (
      case mdf==S"type" return classA
      case mdf==S"" return immA
      case mdf==S"mut" return mutA
      case mdf==S"lent" return lentA
      case mdf==S"read" return readA
      default error Default::DecorationUnfeasable(
        text:S"unidentified mdf:"[mdf]"!")
      )}
    nc=that.referencedPath()
    if nc.hasExternalType() (
      return Refactor::Redirect[
        Path"T" to:nc.externalType()]<<mdfA
      )
    return Refactor::RenamePath
      [Path"T" to:nc.pathFromRoot()]<<mdfA
    }
    
  'main decoration method
  type method
  Library<<(Library that)
  exception Default::DecorationUnfeasable
    this.stateDecoration(that,state:this.extractOkState(that))
  
  'decoration after pre checking
  type method
  Library stateDecoration(Library that,Introspection::Methods state){
    if state.isEmpty() (return that)
    p=Path"Outer0"
    kSel=state.top().selector()
    kName=kSel.name()
    kNames=kSel.names()
    kNameF=SafeOperators.freshName(kName)
    kNamesF=Strings[with n in kNames.vals() (
      SafeOperators.freshName(n))]
    kSelF=Selector.from(name:kNameF,names:kNamesF)
    var acc=that
    with m in state.vals() (
      s=m.selector()
      mdf=m.getMdf()
      zeroArgs=s.names().isEmpty()
      if mdf==S"type" (
        acc:=PostAction(s of:p 
          action:this.constructorAction()
          deprecated: kSelF)<<acc
        )
      else if zeroArgs (
        acc:=PostAction(s of:p 
          action:this.idAction()
          deprecated:Outer0.stateFname(s,old:kNames, fresh:kNamesF)
          )<<acc
        )
      else (
        acc:=PostAction(s of:p 
          action:this.setterAction()
          deprecated:Outer0.stateFname(s,old:kNames, fresh:kNamesF)
          )<<acc
        )
      )
    acc:=Refactor::MakePrivateSelector[kSelF of:p]<<acc
    return acc
    catch exception cnr(
      on MetaGuard error Assert::CodeNotReachable"Invariant"(cnr)
      )
    }
    
    type method
    Selector stateFName(
      Selector that, Strings old,Strings fresh){
      name=that.nameAsField()
      prefix=that.prefixAsField()
      names=that.names()
      with o in old.vals(), f in fresh.vals() (
        if name==o (return Selector.from(name:prefix++f,names:names))
        )
      error Assert::CodeNotReachable"stateFName"      
      }
 
  
  '-#n diventa privato? controlla cosa succede in add doc private constr.
  '-fare un operatre di delega generale, che prende un post oporation optionale e fa anche rename e lascia il vecchio come deprecated
  'tmp={type method mdf Outer0 k(args) }[rename k.selector() in fresh]+
    '  {<:Concept::Invariant 
    '  type method
    '  mdf Outer0 (mdf Outer0 new) {
    '  if !new.invariant() error ...
    '  return new}
    '  }[rename #apply(new) in k.selector()#]
    ' sumMethod Outer0 fresh k.selector()#
    'for  setters:
    '{ mut method Void (Void fresh){
    '  if !this.invariant() error ...
    '  return fresh
    '  }}
    

C:Invariant<<{a(N n)<:Concept::Invariant
  method invariant() this.n()>10N
  }
Main:{
  C c1=C.a(n:20N)
  Debug(S"Ok 20")
  C c2=C.a(n:5N)
  Debug(S"Ok 5")
  return ExitCode.failure()
  catch error err (
    on Invariant::InvariantFailure
      return ExitCode.normal()
    )
  }
' method Bool isConcrete() true iff all non state methods are implemented and
' all the interface methods are implemented.

'add a printableOutline() to nested class
' all public methods lv1,
' for all public nc lv*, if not annotated '@importanceX with x 1-*, with indented methods
' otherwise with all methods inline, nested after?

'Patch:{'no, remove metaguard entirelly, make methClash and co as 
'nested in Refactor, and specific errors as nested in the operator?
'remove also the general DecorationUnfeasable?
'or on the opposite, have DecorationUnfeasable take a class, and print itself in a fancy way to look like a nested?
'  MetaGuard:{interface
'    DecorationUnfeasable:Message::$[]<<{<:MetaGuard}
'    }
'make [] works for Message messages
'throws shortcuts: return { return }  exception errorOn/exceptionOn
    ' on Metaguard, Guard error e
    ' exceptionOn Metaguard InvalidAction"YEP"  
' method Bool isConcrete() true iff all non state methods are implemented and
' all the interface methods are implemented.

'add a printableOutline() to nested class
' all public methods lv1,
' for all public nc lv*, if not annotated '@importanceX with x 1-*, with indented methods
' otherwise with all methods inline, nested after?
}

