{reuse L42.is/AdamTowel02

Invariant:{

  ' error handling
  InvariantFailure:Message::$[]<<{<:MetaGuard}
  type method Bool isInvariant(Introspection::NestedClass that) {
    interf=that.transitivelyImplementedInterfaces()
    with ti in interf.vals() (
      with tAny=ti.referencedPath().externalType() (
        on type Concept::Invariant return Bool.true()
        )
      catch error (on Guard::Operation void)
      void
      )
    return Bool.false()
    }
  type method
  Introspection::Methods extractOkState(Library that)
  exception Default::DecorationUnfeasable{
    i=Introspection(lib:that)
    isInv=this.isInvariant(i)
    if !isInv (return Introspection::Methods[])
    state=i.state()
    if state.isEmpty() (exception Default::DecorationUnfeasable"State is empty")
    k=state.top()
    if k.isPrivate() (exception Default::DecorationUnfeasable"State is private")
    return state
    }
  
  'invariant checking and actions
  type method
  Void checkInvariant(read Concept::Invariant that) (
    if !that.invariant() (
      error InvariantFailure(
        text:S"invalid object detected "++Refactor::Tools.getToSOrName(that) )
      )
    )
  type method
  Library constructorAction(Introspection::Type that) {
    immA={<:Concept::Invariant 
      type method
      Outer0 (Outer0 that) ( Invariant.checkInvariant(that) that )
      }
    mutA={<:Concept::Invariant 
      type method
      mut Outer0 (mut Outer0 that) ( Invariant.checkInvariant(that) that )
      }
    lentA={<:Concept::Invariant 
      type method
      mut Outer0 (mut Outer0 that) ( Invariant.checkInvariant(that) that )
      }
    readA={<:Concept::Invariant 
      type method
      mut Outer0 (mut Outer0 that) ( Invariant.checkInvariant(that) that )
      }
    capsuleA={<:Concept::Invariant 
      type method
      capsule Outer0 (capsule Outer0 that) ( 
        mut Outer0 open=that
        Invariant.checkInvariant(open)
        open
        )
      }
    with mdf=that.mdf() (
      case mdf==S"" return immA
      case mdf==S"mut" return mutA
      case mdf==S"lent" return lentA
      case mdf==S"read" return readA
      case mdf==S"capsule" return capsuleA
      default error Default::DecorationUnfeasable(
        text:S"unidentified mdf:"[mdf]"!")
      )
    }
  type method
  Library setterAction() {<:Concept::Invariant 
    mut method
    Void (Void that) (
      Invariant.checkInvariant(this) 
      that
      )
    }
  
  type method
  Library idAction(Introspection::Type that){
    classA={ type method type T (type T that) that T:{}}
    immA={ type method T (T that) that T:{}}
    mutA={ type method mut T (mut T that) that T:{}}
    lentA={ type method lent T (lent T that) that T:{}}
    readA={ type method read T (read T that) that T:{}}
    Library mdfA={with mdf=that.mdf() (
      case mdf==S"type" return classA
      case mdf==S"" return immA
      case mdf==S"mut" return mutA
      case mdf==S"lent" return lentA
      case mdf==S"read" return readA
      default error Default::DecorationUnfeasable(
        text:S"unidentified mdf:"[mdf]"!")
      )}
    nc=that.referencedPath()
    if nc.hasExternalType() (
      return Refactor::Redirect[
        Path"T" to:nc.externalType()]<<mdfA
      )
    return Refactor::RenamePath
      [Path"T" to:nc.pathFromRoot()]<<mdfA
    catch exception cnr(
      on MetaGuard error Assert::CodeNotReachable"idAction"(cnr)
      )
    }
    
  'main decoration method
  type method
  Library<<(Library that)
  exception Default::DecorationUnfeasable
    this.stateDecoration(that,state:this.extractOkState(that))
  
  'decoration after pre checking
  type method
  Library stateDecoration(Library that,Introspection::Methods state){
    if state.isEmpty() (return that)
    p=Path"Outer0"
    kSel=state.top().selector()
    kName=kSel.name()
    kNames=kSel.names()
    kNameF=SafeOperators.freshName(kName)
    kNamesF=Strings[with n in kNames.vals() (
      SafeOperators.freshName(n))]
    kSelF=Selector.from(name:kNameF,names:kNamesF)
    var acc=that
    with m in state.vals() (
      s=m.selector()
      mdf=m.thisMdf()
      zeroArgs=s.names().isEmpty()
      'Debug(S"zeroArgs"[zeroArgs]"")
      if mdf==S"type" (
        'Debug(S"is k "[s]"")
        acc:=PostAction(s of:p 
          action:this.constructorAction(m.returnType())
          deprecated: kSelF)<<acc
        )
      else (
        newSel=Outer0.stateFName(s,old:kNames, fresh:kNamesF)
        'Debug(S"!!")
        if zeroArgs (
          'Debug(S"is getter/exposer "[s]" "[newSel]"")
          acc:=PostAction(s of:p 
            action:this.idAction(m.returnType())
            deprecated:newSel
            )<<acc
          )
        else (
          'Debug(S"is setter "[s]" "[newSel]" "[with ni in s.names().vals() (S"{"++ni++S"}")]"!!")
          acc:=PostAction(s of:p 
            action:this.setterAction()
            deprecated:newSel
            )<<acc
          )
        )
      )
    acc:=Refactor::MakePrivateSelector[kSelF of:p]<<acc
    return acc
    catch exception cnr(
      on MetaGuard error Assert::CodeNotReachable"Invariant"(cnr)
      )
    }
    
  type method
  Selector stateFName(
  Selector that, Strings old,Strings fresh){
    name=that.nameAsField()
    prefix=that.prefixAsField()
    names=that.names()
    with o in old.vals(), f in fresh.vals() (
      if name==o (return Selector.from(name:prefix++f,names:names))
      )
    error Assert::CodeNotReachable(text:S"stateFName ["[name]"]"
    [with o1 in old.vals(), f1 in fresh.vals() (o1++S"!"++f1)]"")      
    }
  }
   

C:Invariant<<{a(N n)<:Concept::Invariant
  method invariant() this.n()>10N
  }
'D:Invariant<<{( var C c)<:Concept::Invariant
'  method invariant() this.c().n()>15N
'  }

Main:{
  Debug(Introspection(clazz:C).allAsString())
  C c12=C.a(n:12N)
  (
    C c1=C.a(n:20N) void
  ) (
   C c2=C.a(n:5N) Debug(S"Fail")
   catch error ( on Invariant::InvariantFailure void ) void
  )' (
'    D d1=D(c:C.a(n:20N)) void
'  ) (
'   D d2=D(c:c12) Debug(S"Fail")
'   catch error ( on Invariant::InvariantFailure void ) void
'   )
  Debug(S"OK")
  return ExitCode.normal()
  }
' make multiple normalization not insert multiple %$ stuff
' method Bool isConcrete() true iff all non state methods are implemented and
' all the interface methods are implemented.

'add a printableOutline() to nested class
' all public methods lv1,
' for all public nc lv*, if not annotated '@importanceX with x 1-*, with indented methods
' otherwise with all methods inline, nested after?

'Patch:{'no, remove metaguard entirelly, make methClash and co as 
'nested in Refactor, and specific errors as nested in the operator?
'remove also the general DecorationUnfeasable?
'or on the opposite, have DecorationUnfeasable take a class, and print itself in a fancy way to look like a nested?
'  MetaGuard:{interface
'    DecorationUnfeasable:Message::$[]<<{<:MetaGuard}
'    }
'make [] works for Message messages
'throws shortcuts: return { return }  exception errorOn/exceptionOn
    ' on Metaguard, Guard error e
    ' exceptionOn Metaguard InvalidAction"YEP"  
' method Bool isConcrete() true iff all non state methods are implemented and
' all the interface methods are implemented.

'add a printableOutline() to nested class
' all public methods lv1,
' for all public nc lv*, if not annotated '@importanceX with x 1-*, with indented methods
' otherwise with all methods inline, nested after?
}

