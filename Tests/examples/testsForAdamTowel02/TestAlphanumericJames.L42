{reuse L42.is/AdamTowel02

Alphanumeric:{
  ParseFail: Message.$<<{implements Guard.ParseFail}

  class method
  Library <<(Library that){
    lib=(,{
      S that

      class method
      This #from(S.SBuilder builder)
        This.parse(S.#from(builder:builder))

      class method
      mut S.SBuilder #builder()
        S.SBuilder.empty()

      class method
      This parse(S that)
      },)

    res=Extends[lib]<<that

    error on MetaGuard.ClassClash
      Assert.ObservedBug"Someone redefined part of the implementation of AlphaNumeric"

    error on MetaGuard.MethodClash
      Assert.ObservedBug"Someone redefined parts of the implementation of Alphanumeric badly"

    return K<<res
    }
  }

Email: Data << Alphanumeric << {
  S local //fields
  S domain

  class method
  This parse(S that) {
    index= that.indexOfLeft(val:S"@") //works only for simple emails
    if index < 0N (error Alphanumeric.ParseFail"@ not found")
    local= that(end: index) //string slicing
    domain= that(start: index+1N ) //string slicing
    if domain.contains(S"@") (error Alphanumeric.ParseFail"multiple @ found")
    return This(that,local: local,domain: domain)
    } //call the factory with fields plus the original string
  }

Main:{
myEmail= Email"arthur.dent@gmail.com"
//TODO: the three claims below should be assertions
Debug(myEmail.local() ==S"arthur.dent") //holds
Debug(myEmail.domain() ==S"gmail.com") //holds
Debug(myEmail.toS() ==S"arthur.dent@gmail.com") //holds
Debug(myEmail.toS())

  Debug(S"Email parsing complete")

  // Try to exercise the catch on ClassClash

  var Assert.ObservedBug bb={
    lib=Alphanumeric << {interface}
    catch error Assert.ObservedBug b (return b)
    error S"unable to exercise ClassClash in Alphanumeric"
  }
  var Message.Opt e = bb.responseOf()  // TODO: understand why this unexpectedly needed a stated type

  if !e.isPresent() (
    error S"ClassClash result does not have a responseOf()"
    )

 // TODO: the #tilde method will become a get() method
 // TODO: some time, it will be possible to get a name from the class of an arbitrary instance
 /*
  if e.#tilde().classAny().readableName() != MetaGuard.ClassClash.readableName() (
    error S"Alphanumeric{interface} response != ClassClash"
    )
  */

  // Try to exercise the catch on MethodClash
  bb := {
    lib=Alphanumeric << {class method Void #builder()}
    catch error Assert.ObservedBug b (return b)
    error S"unable to exercise MethodClash in Alphanumeric"
  }
  e := bb.responseOf()

  if !e.isPresent() (
    error S"MethodClash result does not have a responseOf()"
    )
  // TODO: some time it will be possible to test the type of e.get()

  Debug(S"Mis-metaprogramming tests complete")

  return ExitCode.normal()
  }
}