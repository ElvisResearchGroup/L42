{reuse L42.is/AdamTowel02

Alphanumeric:{
  ParseFail: Message.$<<{implements Guard.ParseFail}
  LiteralMethodConflict: Message.$<<{implements MetaGuard}
  class method
  Library <<(Library that) exception LiteralMethodConflict{
    lib=(,{
      implements Concept.Base
      S that
    
      method toS() this.that()
      method classAny() This
      //method class() This
      method readableName()GetMyName(This)
      method is(subtype){  with subtype (on class This return Bool.true()) return Bool.false()}
      method equals(that){
        with that (on This return this==that)
        return Bool.false()
        }
      method Bool ==(This that) this.that()==that.that()
      //method !=(that) !(this==that)
      
      class method
      This #from(S.SBuilder builder)
        This.parse(S.#from(builder:builder))

      class method
      mut S.SBuilder #builder()
        S.SBuilder.empty()

      class method
      This parse(S that)
      },)
    return K<<Extends[lib]<<that
    exception on MetaGuard.MethodClash, MetaGuard.ClassClash
      LiteralMethodConflict"Invalid components into provided code"
    }
  }
Email: Alphanumeric << {
  S local //fields
  S domain

  class method
  This parse(S that) {
    index= that.indexOfLeft(val:S"@") //works only for simple emails
    if index<0N (error Alphanumeric.ParseFail"@ not found")
    local= that(end: index) //string slicing
    domain= that(start: index+1N ) //string slicing
    if domain.contains(S"@") (error Alphanumeric.ParseFail"multiple @ found")
    return This(that,local: local,domain: domain)
    } //call the factory with fields plus the original string
}
Main:{
  myEmail= Email"arthur.dent@gmail.com"
  b1=myEmail.local() ==S"arthur.dent" //holds
  b2=myEmail.domain() ==S"gmail.com" //holds
  b3=myEmail.toS() ==S"arthur.dent@gmail.com" //holds

  with n in Range(3N) (Debug(S"hi"++n.toS()))
  with n in Range(3\) (Debug(S"hi"++n.toS()))
  return ExitCode.normal()
  }
}