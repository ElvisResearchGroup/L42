{(Mirror mirror)
type method Outer0(Library lib) Outer0(mirror:MirrorLibrary(lib:lib))
'type method Outer0(Library cls) Outer0(mirror:MirrorClass(cls:cls))
method NodeReport query(Path that)exception TargetUnavailable this.mirror().introspectionGiveInfo(path:that)

MemberReports:LinkedList.list(MemberReport)
MethodReports:LinkedList.list(MethodReport)
NestedClassReports:LinkedList.list(NestedClassReport)
method
MemberReports members(Path that) exception TargetUnavailable(
  var result=MemberReports[]
  var mN=1N
  while Bool.true() (' to be able to break
    result:=result.#add(this.mirror()
      .introspectionGiveInfoMember(path:that,memberN:mN))
    mN+=1N
    )
  result)
method
MethodReports methods(Path that) exception TargetUnavailable
  MethodReports[with m in this.members(that).vals() ( on MethodReport m)]
method
NestedClassReports nestedClasses(Path that) exception TargetUnavailable
  NestedClassReports[with m in this.members(that).vals() ( on NestedClassReport m)]

method MethodReports methods() {
  return this.methods(Path"Outer0")
  catch exception x (on TargetUnavailable error x )
  }
method NestedClassReports nestedClasses() {
  return this.nestedClasses(Path"Outer0")
  catch exception x (on TargetUnavailable error x )
  }
method MemberReports members(){
  return this.members(Path"Outer0")
  catch exception x (on TargetUnavailable error x )
  }

'design other methods to put here
Mirror :{interface 
  method NodeReport introspectionGiveInfo(Path path) exception TargetUnavailable 
  method MemberReport introspectionGiveInfoMember(Path path, N memberN) exception TargetUnavailable,Void
  method TypeReport introspectionGiveInfoType(Path path, N memberN, N typeN) exception TargetUnavailable,Void
  method S introspectionDocAsString(Path path) exception TargetUnavailable
  method S introspectionDocAsString(Path path, N annotationN) exception TargetUnavailable,Void
  method type Any introspectionDocPath(Path path, N annotationN) exception TargetUnavailable,Void
  }
MirrorLibrary:{(Library lib)<:Mirror
  method introspectionGiveInfo(path)
    NodeReport(report: MirrorLibrary(lib: using SafeOperators
      check introspectionGiveInfo(this.lib(), path:path.binaryRepr())
      error SafeOperators.mkError(S"introspectionGiveInfo")))
      
  method introspectionGiveInfoMember(path,memberN)
    Outer1.dispatchReport(using SafeOperators
      check introspectionGiveInfoMember(this.lib(), path:path.binaryRepr(),memberN:memberN.binaryRepr())
      exception void)
  
  method introspectionGiveInfoType(path,memberN,typeN)
    TypeReport(report: MirrorLibrary(lib: using SafeOperators
      check introspectionGiveInfoType(this.lib(), path:path.binaryRepr(),memberN:memberN.binaryRepr(),typeN:typeN.binaryRepr())
      exception void))
  
  method introspectionDocAsString(path,annotationN)
    S.#stringParser(using SafeOperators
      check introspectionDocAsString(this.lib(), path:path.binaryRepr(),annotationN:(1N+annotationN).binaryRepr())
      exception void)
  method introspectionDocAsString(path)
    S.#stringParser(using SafeOperators
      check introspectionDocAsString(this.lib(), path:path.binaryRepr(),annotationN:0N.binaryRepr())
      error SafeOperators.mkError(S"introspectionDocAsString"))
  
  method introspectionDocPath(path,annotationN)
    using SafeOperators
      check introspectionDocPath(this.lib(), path:path.binaryRepr(),annotationN:annotationN.binaryRepr())
      error SafeOperators.mkError(S"introspectionDocPath")
  
  }
'make program hosting pairs cb,ct, then do this part
'MirrorClass:{(type Any lib)<:Mirror
'  method introspectionGiveInfo(path)
'  method introspectionGiveInfoMember(path,memberN)
'  method introspectionGiveInfoType(path,memberN,typeN)
'  method introspectionDocAsString(path,annotationN)
'  method introspectionDocPath(path,annotationN)  
'  }
NodeReport:{(Mirror report)
  method
  S classKind()
    Outer1(this.report(),p:Path"ClassKind")
  }
TypeReport:{(Mirror report)}
MemberReport:{interface}
MethodReport:{(Mirror report)<:MemberReport
  method
  Selector key()
    Selector.#stringParser(Outer1(this.report(),p:Path"Key").binaryRepr())
  }
NestedClassReport:{(Mirror report)<:MemberReport}
type method MemberReport dispatchReport(Library that) {
  mirror=MirrorLibrary(lib:that)
  with x=Outer0(mirror,p:Path"MemberKind") (
    case x== S"NestedClass"  (return NestedClassReport(report:mirror))
    case x== S"InterfaceImplementedMethod" (return MethodReport(report:mirror))
    case x== S"ImplementedMethod" (return MethodReport(report:mirror))
    case x== S"AbstractMethod" (return MethodReport(report:mirror))
    default error S"invalid member kind "++x
    )
  }
type method S (Mirror that,Path p) (
  result=that.introspectionDocAsString(path:p)
  catch exception x (on TargetUnavailable error x )
  result 
  )
}