{
DecorationUnfeasable:Message::$<<{<:MetaGuard}


Parsable:{
  type method Library<<(Library that)
  exception DecorationUnfeasable{
    return Extends[{
      'ParseFailure:Message:S[]<<{<:Guard} no need, related to invariant?
      type method' if you do not implement it, it is a constructor?
      Outer0 fromS(read Concept::ToS that)    
      'will be in the interface when there is type refinement,
      'and will be imm in the interface, and classes can refine to their outer0, and to capsule if makes sense
      
      type method
      Outer0 #from(S::SBuilder builder)
        Outer0.fromS(S.#from(binaryRepr: builder.binaryRepr()))
    
      type method
      S::SBuilder #builder() S::SBuilder.empty()
     }]<<that
    exception on MetaGuard
      DecorationUnfeasable"Parsable"
    }
  }
SealState:{
  ' how to specify which factory to keep out? what getters
  type method Library<<(Library that){
    i=Introspection(lib:that)
    return that
    }
  }
  
DataFromToS:{' in the future we can add also hashCode and > =>
  type method Library<<(Library that) exception DecorationUnfeasable{
    return Extends[{<:Concept::ToS
    method Bool != (Outer0 that) !(this==that)
    read method Bool ==(read Outer0 that) this.toS()==that.toS()
    }]<<Equals<<that
    catch exception DecorationUnfeasable mg
      exception mg
    exception on MetaGuard
      DecorationUnfeasable""
    }
  }

Equals:{
  type method Library<<(Library that) exception DecorationUnfeasable{
    return Extends[{<:Concept::Equals
      method equals(that){
        with that (on Outer0 return this==that)
        return Bool.false()
        }
      read method Bool ==(read Outer0 that)
      }]<<that
    exception on MetaGuard
      DecorationUnfeasable"Equals"
    }
  }
Named:{
  type method Library<<(Library that) exception DecorationUnfeasable{
    return Extends[{<:Concept::Named
        method myName()
          Introspection(clazz:Outer0).externalTypeToS()
        }]<<that
    'can improve error: if is method defined against method implemented
    exception on MetaGuard
      DecorationUnfeasable"Named"
    }
  }
}