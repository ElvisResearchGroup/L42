{ _private(Library _binaryRepr, Annotations annotations)<:Concept::ToS,Concept::Named '@private
  method myName()GetMyName(Outer0)
  Annotation:{(Library _binaryRepr, S text, N index)<:Concept::ToS,Concept::Named
    method myName()GetMyName(Outer0)
    method toS() this.text()
    method type Any referredClass() {
      return Introspection::Record(lib:this._binaryRepr()).that()
        .introspectDocPath(path:Path"Outer0",annotationN:this.index())
      catch exception x (
        on MetaGuard::NestedClassUnavailable error Assert::CodeNotReachable""(x)
        on Void error Assert::ObservedBug"Plugin introspection bug"
        )
      }
    method Bool hasReferredClass() (
      res=this.text()!=S"" &
        this.text().isASCIIUpperCase(0N)
      'Debug(S"Doc::hasReferredClass(this:"[this]")="[res]"")
      res
      )
    }
  Annotations:LinkedList.list(Annotation)
  type method Outer0 (Library that) (
    var result=Annotations[]
    var aN=1N
    while Bool.true() (' to be able to break
      result:=result.#add(Annotation(
        _binaryRepr:that,
        text:Introspection::Record(lib:that).that()
          .introspectDocAsString(path:Path"Outer0",annotationN:aN)
        index:aN
        ))
      aN+=1N
      )
    catch exception x (on MetaGuard::NestedClassUnavailable error Assert::CodeNotReachable""(x))
    result:=result.#end() 'reverse the list
    Outer0._private(_binaryRepr:that, annotations:result)
    )
  type method Outer0 #stringParser(Library that) Outer0(that)
    
  method Library binaryRepr() this._binaryRepr()
  
  
  method toS() {
    return Introspection::Record(lib:this._binaryRepr()).that()
      .introspectDocAsString(path:Path"Outer0")
    catch exception x (on MetaGuard::NestedClassUnavailable error Assert::CodeNotReachable""(x)) 
   }
  }