{'findMeNestedClass
(fwd NestedClass root,Path path,MirrorPr mirror, Record record)<:Member '@private
method myName()GetMyName(Outer0)
method toS() Outer0.myName()++S"["[this.allAsString()]"]"
method Bool ==(Outer0 that){
  if this.path()!=that.path() (return Bool.false())
  'else equal paths
  if this.path()!=Path"Outer0" (return this.root()==that.root())
  'else, both paths are Outer0
  ext=this.hasExternalType()
  if ext!=that.hasExternalType() (return Bool.false())
  if ext (return this.externalTypeToS()==that.externalTypeToS())
  return this.allAsString()==that.allAsString()
  }
method Bool != (Outer0 that) !(this==that)
method equals(that){
  with that (on Outer0 return this==that)
  return Bool.false()
  }
method 'error for Outer0
Doc nestedDoc()(
  if this.path()==Path"Outer0" (
    error Guard::Operation"NestedClass.nestedDoc()  The NestedClass Object refers to Outer0"
    )
  this.record().docOf(path:Path"MemberDoc")
  )
method 'of the library literal
Doc doc() this.record().docOf(path:Path"Doc")

method Path pathFromRoot()
  this.path() ' invariant NestedClass(...).nestedClassFromRoot(path).pathFromRoot()==path

method Bool hasExternalType(){
  if this.path()!=Path"Outer0" (return Bool.false())
   with mirror=this.mirror() (
    on MirrorPr::Class return Bool.true()
    )
  return Bool.false()
  }
method type Any externalType(){
  if this.path()!=Path"Outer0" (
    error Guard::Operation(text:S"NestedClass.externalType() The NestedClass Object refers to "[this.path()]"")
    )
  with mirror=this.mirror() (
    on MirrorPr::Class return mirror.lib()
    on MirrorPr::Lib error Guard::Operation"NestedClass.externalType() The NestedClass Object is unbound"
    default error Assert::CodeNotReachable""
    )
  }
method S externalTypeToS() {
  if this.path()!=Path"Outer0" (
    error Guard::Operation(text:S"NestedClass.externalTypeToS() The NestedClass Object refers to "[this.path()]"")
    )
  doc=this.record().docOf(path:Path"MyClass")
  nameAndPrefix=doc.annotations().top().toS()
  sep=nameAndPrefix.firstIndexOf(S"::")
  name= nameAndPrefix(start:sep+2N)
  prefix=N.fromS(nameAndPrefix(start:5N, end:sep)) '5N== S"Outer".size()
  Assert::$[prefix>0N]
  'if prefix == 1N (return name)
  return S"Outer"[prefix-1N]"::"++name
}

method S classKind() this.record()"ClassKind"
method S allAsString() this.record()"AllAsString"  'just the library literal
method
Members members() (
  var result=Members[]
  var mN=1N
  while Bool.true() (' to be able to break
    result:=result.#add(this.mirror()
      .introspectReportMember(root:this,path:this.path(),memberN:mN))
    mN+=1N
    )
  catch exception x (on MetaGuard::MemberUnavailable error Assert::CodeNotReachable(x))
  result)

method
Methods methods()
  Methods[with m in this.members().vals() ( on Method m)]

method
NestedClasses nestedClasses()
  NestedClasses[with m in this.members().vals() ( on NestedClass m)]

method
NestedClasses transitivelyNestedClasses() (
  var result=NestedClasses[this]
  with nc in this.nestedClasses().vals() (result++=nc.transitivelyNestedClasses())
  result
  )

'add transitivellyImplementedInterfaces(), note, there can be circle! does require == on stuff?  
method Types implementedInterfaces() (
  var result=Types[]
  var tN=-1N
  while Bool.true() (' to be able to break
    result:=result.#add(this.record().that()
      .introspectReportType(root:this,path:this.path(),memberN:0N,typeN:tN))
    tN-=1N
    )
  catch exception x (on MetaGuard::MemberUnavailable error Assert::CodeNotReachable(x))
  result)
method Types transitivelyImplementedInterfaces() {
  var result=this.removeDup(this.implementedInterfaces())
  var new=result
  loop (
    var extra=Types[]
    with t in new.vals() (
      impl=t.referencedPath().implementedInterfaces()
      extra++=this.remove(impl, from:result)
      )
    if extra.isEmpty() (return result)
    new:=extra
    result++=extra    
    )
  }
method'@private
Types removeDup(Types that) (
  var result=Types[]
  with t in that.vals() (
    if this.select(t,from:result) (result:=result.#add(t))
    )
  result
  )
method'@private
Bool select(Type that,Types from) (
  rp=that.referencedPath()
  Count[with t in from.vals() (t.referencedPath() == rp)]==0N
  )
method'@private
Types remove(Types that,Types from)
  Types[with t in that.vals() (case this.select(t,from:from) t)]
  
method
Methods stateCandidate() (
  var havePrivate=Bool.false()
  var absMethods=Methods[with m in this.methods().vals() (
    case m.methodKind()==S"AbstractMethod" (
      havePrivate|=m.isPrivate()
      m
      )
    )]
  if havePrivate (
    absMethods:=Methods[with a in absMethods.vals() (
      case a.isPrivate() a
      )]
    )
  absMethods
  )  
method
Methods state() {
  var result=Methods[]
  stateCandidate=this.stateCandidate()
  constr=(
    classMethods=Methods[with m in stateCandidate.vals() (
      case m.thisMdf()==S"Type" m
      )]
    if classMethods.isEmpty() (return result)
    if !classMethods.pop().isEmpty() (return result)
    classMethods.top()
    )
  result:=result.#add(constr)
  names=constr.selector().names()
  with name in names.vals() (
    getter=Selector.fromS(name++S"()")
    exposer=Selector.fromS(S"#"++name++S"()")
    setter=Selector.fromS(name++S"(that)")
    with f in stateCandidate.vals() (
      if f.selector()==getter |f.selector()==exposer |f.selector()==setter (
        result:=result.#add(f)
        )
      )
    )
  return result.#end()
  }
method
Method methodFromSelector(Selector that) exception MetaGuard::MethodUnavailable {
  with meth in this.methods().vals() (
    if meth.selector()==that (return meth)
    )
  exception MetaGuard::MethodUnavailable(path:this.pathFromRoot(),selector:that,isPrivate:Bool.false())
  'note: it can return a private method
  }
method
Bool has(Selector selector){
  unused=this.methodFromSelector(selector)
  catch exception (on MetaGuard::MemberUnavailable return Bool.false())
  return Bool.true()
  }
  
method
NestedClass nestedClassFromRoot(Path that) exception MetaGuard::NestedClassUnavailable {
  if that==Path"Outer0" (return this.root())
   'could be, but ugly with m=this.mirror() ( case Mirror::Class
  myClass=this.record().docOf(path:Path"MyClass").annotations().top()
  if !myClass.hasReferredClass() (
     return this.mirror().introspectReport(root:this.root(),path:that)
    )
  return Introspection(clazz:myClass.referredClass(),path:that)
  }
  
method
Bool has(Path fromRoot) (
  unused=this.nestedClassFromRoot(fromRoot)
  catch exception (on MetaGuard::MemberUnavailable Bool.false() )
  Bool.true()
  )
  
method
Bool isPrivate() {
  with ann in this.nestedDoc().annotations().vals() (
    case ann.toS()==S"private" return Bool.true()
    )
  return Bool.false()
  }
}
