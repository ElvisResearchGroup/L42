{(NestedClass root,Path path, N memberN, N typeN,Record record)<:S::ToS
method toS() S"Type["[this.allAsString()]"]"
method S allAsString() this.record()"AllAsString"  'just the library literal

method S typeKind() this.record()"TypeKind" '{Normal,Alias,AliasUnresolvable}
method S mdf() {'error on AliasUnresolvable
  if this.typeKind()!=S"AliasUnresolvable" (return this.record()"Mdf")
  error Report::UnsupportedOperation"AliasUnresolvable type, mdf unknown" 
  }

method '@private
NestedClass  referencedPath(Doc::Annotation ann) {
  if ann.hasReferredClass() (return Introspection(clazz:ann.referredClass()))
  S sPath=ann.toS()(start:2N)
  Path path={if sPath==S"" (return Path"Outer0") return Path.fromS(sPath)}
  return this.root().nestedClassFromRoot(path)
  catch exception x ( on Report::MemberUnavailable error Report::ObservedBug"Type refers to unexistent path")
  }
method NestedClass referencedPath()
  this.referencedPath(ann:this.record().docOf(path:Path"Path").annotations().top())
  
method NestedClass resolvedReferencedPath() {'error on AliasUnresolvable
  if this.typeKind()!=S"AliasUnresolvable" (
    return this.referencedPath(ann:this.record().docOf(path:Path"ResolvedPath").annotations().top())
    )
  error Report::UnsupportedOperation"AliasUnresolvable type, mdf unknown" 
  }

method Bool partial() this.record()"Ph"==S"true"
method Bool resolvedPartial() this.record()"ResolvedPh"==S"true" 'error on Normal? or the same of partial()
method S suffix() { 'error on Normal
  if this.typeKind()==S"Normal" (
    error Report::UnsupportedOperation"Normal types have no suffix" 
    )
  return this.record()"Ph"
  }
method Doc doc() this.record().docOf(path:Path"Doc")
}


