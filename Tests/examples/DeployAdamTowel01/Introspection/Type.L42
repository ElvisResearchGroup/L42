{(fwd NestedClass root,Path path, N memberN, N typeN,Record record)<:Concept.ToS,Concept.Named //@private
method myName()GetMyName(This)
method toS() This.myName()++S"["[this.allAsString()]"]"
method S allAsString() this.record()"AllAsString"  //just the library literal
method S strRepr() { //should become toS? is toS ok?
  n=this.referencedPath()
  S s={if n.hasExternalType() (return n.externalTypeToS())
    return S"@."[n.pathFromRoot()]""
    }
  return this.mdf()++S" "++s
  }
method S typeKind() this.record()"TypeKind" //{Normal,Alias,AliasUnresolvable}
method S mdf() {//error on AliasUnresolvable
  if this.typeKind()!=S"AliasUnresolvable" (return this.record()"Mdf")
  error Guard.Operation"AliasUnresolvable class, mdf unknown" 
  }

method //@private
NestedClass  referencedPath(Doc.Annotation ann) {
  if ann.hasReferredClass() (return Introspection(clazz:ann.referredClass()))
  S sPath=ann.toS()(start:1N)
  if sPath==S"" (return this.root())
  Path path=Path.fromS(sPath)
  return this.root().nestedClassFromRoot(path)
  catch exception MetaGuard.NestedClassUnavailable x error Assert.ObservedBug"Type refers to unexistent path"
  }
method NestedClass referencedPath()
  this.referencedPath(ann:this.record().docOf(path:Path"Path").annotations().left())
  
method NestedClass resolvedReferencedPath() {//error on AliasUnresolvable
  if this.typeKind()!=S"AliasUnresolvable" (
    return this.referencedPath(ann:this.record().docOf(path:Path"ResolvedPath").annotations().left())
    )
  error Guard.Operation"AliasUnresolvable class, mdf unknown" 
  }

method Bool partial() this.record()"Ph"==S"true"
method Bool resolvedPartial() this.record()"ResolvedPh"==S"true" //error on Normal? or the same of partial()
method S suffix() { //error on Normal
  if this.typeKind()==S"Normal" (
    error Guard.Operation"Normal types have no suffix" 
    )
  return this.record()"Ph"
  }
method Doc doc() this.record().docOf(path:Path"Doc")
}


