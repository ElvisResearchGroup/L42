{'findMeIntrospection

type method
NestedClass(Library lib)(
  root=MirrorPr::Lib(lib:lib).introspectReport(root:root,path:Path"Outer0")
  catch exception x (on Report::TargetUnavailable error Report::CodeNotReachable())
  root
  )
type method
NestedClass(Library lib,Path path) exception Report::TargetUnavailable
  Outer0(lib:lib).nestedClassFromRoot(path)

'type method
'NestedClass(type Any cls) NestedClass(mirror:MirrorPr::Class(lib:cls))

MirrorPr:... 'Todo:remove Pr later.


Record:
  {(MirrorPr that)

  type method
  Outer0 (Library lib)
    Outer0(Introspection(lib:lib).mirror())
  method Void dbg()
    with x=this.that() (
      on MirrorPr::Lib Debug(lib:x.lib())
      default Debug(S"Sorry, can not print class mirrors")
      )

  method S #stringParser(Library that) {
    path=Path.#stringParser(that)
    return this.that().introspectDocAsString(path:path)
    catch exception x (on Report::TargetUnavailable error x )
    }
  method
  Doc docOf(Path path){
    with mirror=this.that() (
      on MirrorPr::Lib return Doc(
        SafeOperators.renameClass(mirror.lib(), src:path, dest:Path"Outer0")
        'This can not be done for circular reference Refactor::RenamePath[path to:Path"Outer0"]<<mirror.lib()
        )
      )
    error Report::CodeNotReachable()
    }
  'this is how I would like it to be
  'type method Member dispatch(NestedClass^ root,Path path,MirrorPr mirror, N memberN,Library report) {
  '  _report =Introspection(lib:report).report()
  '  with x=_report"MemberKind" (
  '    case x== S"NestedClass"  (return NestedClass(root:root,path:path,mirror:mirror,report:_report))
  '    case x== S"InterfaceImplementedMethod" (return Method(root:root,path:path,memberN:memberN,report:_report))
  '    case x== S"ImplementedMethod" (return Method(root:root,path:path,memberN:memberN,report:_report))
  '    case x== S"AbstractMethod" (return Method(root:root,path:path,memberN:memberN,report:_report))
  '    default error Report::ObservedBug(S"invalid member kind "++x)
  '    )
  '  }
  'instead, I have to write this :-(
  RootForMember:'@private
    {interface method Member (NestedClass^ root)}
  RootForNested:'@private
    {(Path path,MirrorPr mirror,Record _report)<:RootForMember
      method(root) (
      'Debug(S"logRootForNested")
      NestedClass(root:root,path:this.path(),mirror:this.mirror(),report:this._report())
      )}
  RootForMethod:'@private
    {(Path path,N memberN,Record _report)<:RootForMember
      method(root) (
        'Debug(S"logRootForMethod")
        Method(root:root,path:this.path(),memberN:this.memberN(),report:this._report())
        )}
  type method Member dispatch(NestedClass^ root,Path path,MirrorPr mirror, N memberN,Library report) (
    _report =Record(lib:report)
    'Debug(S"MemberKind(in dispatch) is"++_report"MemberKind")
    'Debug(S"ReportAsString is ")
    'Debug(lib:report)
    RootForMember result={ with x=_report"MemberKind" (
      case x== S"InterfaceImplementedMethod" (
        return RootForMethod(path:path,memberN:memberN,_report:_report)
        )
      case x== S"ImplementedMethod" (
        return RootForMethod(path:path,memberN:memberN,_report:_report)
        )
      case x== S"AbstractMethod" (
        return RootForMethod(path:path,memberN:memberN,_report:_report)
        )
      case x== S"NestedClass" (
        return RootForNested(path:path,mirror:mirror,_report:_report)
        )

      default error Report::ObservedBug(S"invalid member kind "++x)
      )}
    result(root:root)
    )
  }
Member:{interface<:S::ToS}
Members:LinkedList.list(Member)
Method:...
Methods:LinkedList.list(Method)
NestedClass:...
NestedClasses:LinkedList.list(NestedClass)
Type:...
Types:LinkedList.list(Type)
}