{'findMeIntrospection
(MirrorPr mirror)
type method
Outer0(Library lib) Outer0(mirror:MirrorPr::Lib(lib:lib))
'type method Outer0(type Any cls) Outer0(mirror:MirrorPr::Class(cls:cls))

method
 Report::Path query(Path that)exception TargetUnavailable
   this.mirror().introspectionGiveInfo(root:this,path:that)

method
Report::Members members(Path that) exception TargetUnavailable(
  var result=Report::Members[]
  var mN=1N
  while Bool.true() (' to be able to break
    result:=result.#add(this.mirror()
      .introspectionGiveInfoMember(root:this,path:that,memberN:mN))
    mN+=1N
    )
  result)
method
Report::Methods methods(Path that) exception TargetUnavailable
  Report::Methods[with m in this.members(that).vals() ( on Report::Method m)]
method
Report::NestedClasses nestedClasses(Path that) exception TargetUnavailable
  Report::NestedClasses[with m in this.members(that).vals() ( on Report::NestedClass m)]

method Report::Methods methods() {
  return this.methods(Path"Outer0")
  catch exception x (on TargetUnavailable error x )
  }
method Report::NestedClasses nestedClasses() {
  return this.nestedClasses(Path"Outer0")
  catch exception x (on TargetUnavailable error x )
  }
method Report::Members members(){
  return this.members(Path"Outer0")
  catch exception x (on TargetUnavailable error x )
  }

method S #stringParser(Library that) {
  path=Path.#stringParser(that)
  return this.mirror().introspectionDocAsString(path:path)
  catch exception x (on TargetUnavailable error x )
  }

'design other methods to put here
Report:...
MirrorPr:... 'remove Pr later.
}