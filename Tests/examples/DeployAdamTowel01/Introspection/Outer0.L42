{'findMeIntrospection

type method
NestedClass(Library lib) NestedClass(mirror:MirrorPr::Lib(lib:lib))
type method
NestedClass(type Any cls) NestedClass(mirror:MirrorPr::Class(lib:cls))

MirrorPr:... 'remove Pr later.


type method Member dispatch(Introspection root,Outer2::Path path, N memberN,Library report) {
  _report =Introspection(lib:report)
  with x=_report"MemberKind" (
    case x== S"NestedClass"  (return NestedClass(root:root,path:path,memberN:memberN,report:_report))
    case x== S"InterfaceImplementedMethod" (return Method(root:root,path:path,memberN:memberN,report:_report))
    case x== S"ImplementedMethod" (return Method(root:root,path:path,memberN:memberN,report:_report))
    case x== S"AbstractMethod" (return Method(root:root,path:path,memberN:memberN,report:_report))
    default error S"invalid member kind "++x
    )
  }

Record:'@private
  {(Mirror that)
  method S #stringParser(Library that) {
  path=Path.#stringParser(that)
  return this.mirror().introspectDocAsString(path:path)
  catch exception x (on TargetUnavailable error x )
  }
  method
  Doc docOf(Path path){
    with mirror=this.mirror() (
      on Mirror::Lib return Doc(Refactor::RenamePath[path to:Path"Outer0"]<<mirror.lib())
      )
    error S"UnreachableCode"
    }
  }
Member:{interface}
Members:LinkedList.list(Member)
Method:...
Methods:LinkedList.list(Method)
NestedClass:...
NestedClasses:LinkedList.list(NestedClass)
Type:...
Types:LinkedList.list(Type)
}