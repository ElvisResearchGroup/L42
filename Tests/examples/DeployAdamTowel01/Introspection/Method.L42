{(NestedClass nestedClass,N memberN,Record report)<:Member

method
NestedClass root()
  this.myNested().root()

method
Doc doc()
  this.report().docOf(path:Path"Doc")

method
S thisMdf()
  this.report()"ThisMdf"

method ' invariant NestedClass(...).nestedClassFromRoot(path).pathFromRoot()==path
Path pathFromRoot()
  this.nestedClass().pathFromRoot()

method
Selector selector()
  Selector.#stringParser(this.report()"Key".binaryRepr())

method
S methodKind()
  this.report()"MemberKind"

method
S allAsString()
  this.report()"AllAsString"
  
method
Type returnType() this.root().mirror()
      .introspectReportType(

method
Types exceptions() error S"NotImplementedYet"

method
Types parameterTypes()    
  var result=Types[]
  var pN=1N
  while Bool.true() (' to be able to break
    Type ti=this.root().mirror()
      .introspectReportType(root:this.root(),'TODO: no, we need a mirror?
      path:this.pathFromRoot(),memberN:this.memberN(),typeN:pN)
    result:=result.#add(ti)
    pN+=1N
    )
  return result
  catch exception err (on TargetUnavailable error err)
  }
 
  method
  Selector key()
    Selector.#stringParser(this.report()"Key".binaryRepr())

}

