{(NestedClass nestedClass,N memberN,Record report)<:Member

method
NestedClass root()
  this.myNested().root()

method
Doc doc()
  this.report().docOf(path:Path"Doc")

method
S thisMdf()
  this.report()"ThisMdf"

method ' invariant NestedClass(...).nestedClassFromRoot(path).pathFromRoot()==path
Path pathFromRoot()
  this.nestedClass().pathFromRoot()
    method Selector selector()
    method S memberKind()
    method S allAsString()
    method Type returnType()
    method Types exceptions()
    method Types parameterTypes()    
 
  method
  Selector key()
    Selector.#stringParser(this.report()"Key".binaryRepr())

  method 'need to be called only on methodWithType
  Parameters parameters() {
    var result=Parameters[]
    var pN=1N
    while Bool.true() (' to be able to break
      Type ti=this.root().mirror()
        .introspectReportType(root:this.root(),path:this.path(),memberN:this.memberN(),typeN:pN)
      result:=result.#add(Parameter(_type:ti,name:ti.root()"ParName"))
      pN+=1N
      )
    return result
    catch exception err (on TargetUnavailable error err)
    }
  }

