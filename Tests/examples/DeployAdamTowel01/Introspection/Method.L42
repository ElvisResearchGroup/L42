{(fwd NestedClass root,Path path,N memberN,Record record)<:Member '@private
method myName()GetMyName(Outer0)
method toS() Outer0.myName()++S"["[this.allAsString()]"]"
method Bool ==(Outer0 that){
  if this.path()!=that.path() (return Bool.false())
  if this.memberN()!=this.memberN() (return Bool.false())
  return this.root()==that.root()
  }
method Bool != (Outer0 that) !(this==that)
method equals(that){
  with that (on Outer0 return this==that)
  return Bool.false()
  }

method
Doc doc()
  this.record().docOf(path:Path"MemberDoc")

method
S thisMdf()
  this.record()"ThisMdf"

method ' invariant NestedClass(...).nestedClassFromRoot(path).pathFromRoot()==path
Path pathFromRoot()
  this.path()


method
Selector selector()
  Selector.#stringParser(this.record()"Key".binaryRepr())

method
S methodKind()
  this.record()"MemberKind"

method
S allAsString()
  this.record()"AllAsString"

method
Type returnType() {
  return this.root().mirror().introspectReportType(
    root:this.root(),
    path:this.path(),
    memberN:this.memberN(),
    typeN:0N)
  catch exception x (
    on MetaGuard::MemberUnavailable error Assert::CodeNotReachable""(x)
    on Void error Assert::CodeNotReachable"void was thrown"
    )
  }



method
Types exceptions() error Assert::NotImplementedYet""

method
Types parameterTypes() {
  var result=Types[]
  var pN=1N
  while Bool.true() (' to be able to break
    Type ti=this.root().record().that()
      .introspectReportType(root:this.root(),'TODO: no, we need a mirror?
      path:this.pathFromRoot(),memberN:this.memberN(),typeN:pN)
    result:=result.#add(ti)
    pN+=1N
    )
  return result
  catch exception err (on MetaGuard::MemberUnavailable error Assert::CodeNotReachable""(err))
  }

method
Bool isPrivate() {
  with ann in this.doc().annotations().vals() (
    case ann.toS()==S"private" return Bool.true()
    )
  return Bool.false()
  }
}

