{(NestedClass root,Path path,N memberN,Record report)<:Member
method toS() S"Method["[this.allAsString()]"]"

method
Doc doc()
  this.report().docOf(path:Path"Doc")

method
S thisMdf()
  this.report()"ThisMdf"

method ' invariant NestedClass(...).nestedClassFromRoot(path).pathFromRoot()==path
Path pathFromRoot()
  this.path()


method
Selector selector()
  Selector.#stringParser(this.report()"Key".binaryRepr())

method
S methodKind()
  this.report()"MemberKind"

method
S allAsString()
  this.report()"AllAsString"

method
Type returnType() {
  return this.root().mirror().introspectReportType(
    root:this.root(),
    path:this.path(),
    memberN:this.memberN(),
    typeN:0N)
  catch exception x (
    on Report::MemberUnavailable error Report::CodeNotReachable()
    on Void error Report::CodeNotReachable()
    )
  }



method
Types exceptions() error Report::NotImplementedYet()

method
Types parameterTypes() {
  var result=Types[]
  var pN=1N
  while Bool.true() (' to be able to break
    Type ti=this.root().report().that()
      .introspectReportType(root:this.root(),'TODO: no, we need a mirror?
      path:this.pathFromRoot(),memberN:this.memberN(),typeN:pN)
    result:=result.#add(ti)
    pN+=1N
    )
  return result
  catch exception err (on Report::MemberUnavailable error err)
  }
}

