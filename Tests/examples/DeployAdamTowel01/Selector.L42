{ _private(Library _binaryRepr)<:Concept.ToS Concept.Equals Concept.Named'@private
  method myName()GetMyName(Outer0)

  type method
  Outer0 fromS(Concept.ToS that)
    Outer0.#from(binaryRepr: that.toS().binaryRepr())
  
  type method Outer0 #from(S.SBuilder builder) 
    Outer0.#from(binaryRepr: builder.binaryRepr())
  
  type method mut S.SBuilder #builder() S.SBuilder.empty()
  
  type method
  Outer0 #from(Library binaryRepr) (
    use SafeOperators
      check ifInvalidDo(selector:binaryRepr)
      error Outer0.parseError(S.#from(binaryRepr: binaryRepr))
    Outer0._private(_binaryRepr:binaryRepr)
    )
  type method
  Any parseError(S that)
    S"Selector.UnsatisfactoryErrorToAvoidCycle, replace in AdamT2"
  
  type method 
  Outer0 from(S name,Strings names) {
    if names.isEmpty() (return Outer0.fromS(name++S"()"))
    pars=S"("[with n in names.vals() (use[n++S","])]""
    return Outer0.fromS(name++pars(end:pars.size()-1N)++S")")
    'Outer0.fromS(name[pars(end:#-1N)]")")
    }
  method S nameAsField() {
    n=this.name()
    if n(0N)==S"#" (return n(start:1N))
    return n
    }
  method S prefixAsField() {
    if this.toS()(0N)==S"#" (return S"#")
    return S""
    }
  method Library binaryRepr() this._binaryRepr()


  method toS() S.#from(binaryRepr: this._binaryRepr())


  method Bool != (Outer0 that) !(this==that)

  method
  Bool == (Outer0 that) {
    use Alu
      check ifStringEqualDo(s1:this.binaryRepr(),s2:that.binaryRepr())
      return Bool.true()
    return Bool.false()
    }
  method equals(that){
    with that (on Outer0 return this==that)
    return Bool.false()
    }

  method
  Bool isOperator(){
    if this.name().size()==0N (return Bool.true() )
    return this.name()(0N)==S"#"
    }
  method
  S name() (
    str=this.toS()
    str(end:str.firstIndexOf(S"("))
    )

  method
  Strings names(){
    var str=this.toS()
    str:=str(start:str.firstIndexOf(S"(")+1N, end:str.size()-1N)++S","
    ' from foo(a,b,c) to a,b,c,
    var result=Strings[]
    if str==S"," (return result)
    while str!=S"" (
      pos=str.firstIndexOf(S",")
      result:=result.#add(str(end:pos))
      str:=str(start:pos+1N)
      )
    return result.#end()'reverse the linked list
  }
  
  type method
  Selector fresh(Selector that) {
    var name=that.name()
    if name==S"" (name:= S"fresh")
    fName=SafeOperators.freshName(name)
    var tot=fName++S"("
    with n in that.names().vals() (
      tot++=n++S","
      )
    tot:=tot(start:0N end:tot.size()-1N)++S")"
    return Selector.fromS(tot)
    }
  'we still need to add check validity, and fields name, list parameters, and ways to add/remove parameters
  }