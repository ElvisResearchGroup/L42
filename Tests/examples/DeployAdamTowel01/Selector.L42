{ _private(Library _binaryRepr)<:Concept::ToS Concept::Equals Concept::Named'@private
  method myName()GetMyName(Outer0)

  type method
  Outer0 fromS(Concept::ToS that)
    Outer0.#stringParser(that.toS().binaryRepr())
  type method Outer0 #stringParser(Library that) (
    using SafeOperators
      check ifInvalidDo(path:that)
      error InvalidFormat(S.#stringParser(that))
    Outer0._private(_binaryRepr:that)
    )
  InvalidFormat:{(S that)}
  method Library binaryRepr() this._binaryRepr()


  method toS() S.#stringParser(this._binaryRepr())


  method Bool != (Outer0 that) !(this==that)

  method
  Bool == (Outer0 that) {
    using Alu
      check ifStringEqualDo(s1:this.binaryRepr(),s2:that.binaryRepr())
      return Bool.true()
    return Bool.false()
    }
  method equals(that){
    with that (on Outer0 return this==that)
    return Bool.false()
    }

  method
  S name() (
    str=this.toS()
    str(end:str.firstIndexOf(S"("))
    )

  method
  Strings names(){
    var str=this.toS()
    str:=str(start:str.firstIndexOf(S"(")+1N, end:str.size()-1N)++S","
    ' from foo(a,b,c) to a,b,c,
    var result=Strings[]
    while str!=S"" (
      pos=str.firstIndexOf(S",")
      result:=result.#add(str(end:pos))
      str:=str(start:pos+1N)
      )
    return result.#end()'reverse the linked list
  }
  'we still need to add check validity, and fields name, list parameters, bool isOperator
  'and ways to add/remove parameters
  }