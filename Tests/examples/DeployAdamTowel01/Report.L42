{interface<:S::ToS

Misuse:
'as exceptions, Misuse objects are a way to report/guard complex operations,
' where checking the shape of the input can be unconvenient.
'as errors, they represent precondition violations. 
'Turning an exception Misuse into an error Misuse
' is equivalent of declaring that such misuse should not happen (responsability of the caller)
' an error Misuse is like a Precondition Violation in other systems.
'If the violation is because the "this" parameter is not suitable to perform the requested operation,
'consider using UnsupportedOperation instead
  {interface<:S::ToS
  $$:'@private
    {(S reason)<:Outer1
    type method Outer0 #stringParser(Library that) Outer0(reason:S.#stringParser(that))
    type method Outer0 () Outer0(S"")
    type method Outer0 (S that) Outer0(reason:that)
    method toS()  S"Misuse["[this.reason()]"]"
    }
  $:{'pattern to allow interfaces to have static methods
    type method Outer1 () $$(S"")
    type method Outer1 (S that) $$(reason:that)
        type method Outer1 #stringParser(Library that) $$(reason:S.#stringParser(that))
    } 
  }
UnsupportedOperation:
'to report that a target do not support a certain selector.
'to be used when a class have a method available only on certain instances.
'For example, getting the element out of an optional type that is not present.
'is this a kind of misuse?
{(S reason)<:S::ToS
  type method Outer0 #stringParser(Library that) Outer0(reason:S.#stringParser(that))
  type method Outer0 () Outer0(S"")
  type method Outer0 (S that) Outer0(reason:that)
  method toS()  S"UnsupportedOperation["[this.reason()]"]"
  }
InvalidParameter:
'to report that a parameter (different from 'this') is not
' as needed to perform the operation normally
StringableU[]<<{ method Void invariant() void method S myName() S"InvalidParameter"}




PluginFailure:
'to report the inability of a plugin to act
  {(S reason)<:S::ToS
  type method Outer0 #stringParser(Library that) Outer0(reason:S.#stringParser(that))
  type method Outer0 () Outer0(S"")
  type method Outer0 (S that) Outer0(reason:that)
  method toS()  S"PluginFailure["[this.reason()]"]"
  }
  
ObservedBug:
'if this happens, then the programmer had wrong assumption on the code behaviour.
{(S reason)<:S::ToS
  type method Outer0 #stringParser(Library that) Outer0(reason:S.#stringParser(that))
  type method Outer0 () Outer0(S"")
  type method Outer0 (S that) Outer0(reason:that)
  method toS()  S"ObservedBug["[this.reason()]"]"
  }
  
CodeNotReachable:{(S reason)<:S::ToS
  type method Outer0 #stringParser(Library that) Outer0(reason:S.#stringParser(that))
  type method Outer0 () Outer0(S"")
  type method Outer0 (S that) Outer0(reason:that)
  method toS()  S"CodeNotReachable["[this.reason()]"]"
  }
NotImplementedYet:{(S reason)<:S::ToS
  type method Outer0 #stringParser(Library that) Outer0(reason:S.#stringParser(that))
  type method Outer0 () Outer0(S"")
  type method Outer0 (S that) Outer0(reason:that)
  method toS()  S"NotImplementedYet["[this.reason()]"]"
  }
'in the following, a set of reports for composition operators

SourceUnfit:{(Introspection::Record record) <:Report 'TODO: here, when typechecking introspection, for bug introspection can not see itself back. fix tomorrow. ADDED Has been fixed?
  method toS() S"SourceUnfit"
  }
ClassClash:{'findMeClassClash
(Introspection::Record record) <:Report
  method toS() S"ClassClash"
  }
MethodClash:{(Introspection::Record record) <:Report
  method toS() S"MethodClash"
  }
InvalidOnTopLevel:{(Introspection::Record record) <:Report
  method toS() S"InvalidOnTopLevel"
  }
MemberUnavailable:{(Path path,S _selector,InvalidKind invalidKind)<:Report
  InvalidKind:{(S inner)<:S::ToS method toS() this.inner()}
  type method
  Outer0 privatePath(Path path)
    Outer0(path:path,_selector:S"",invalidKind:InvalidKind(inner:S"PrivatePath"))
  type method
  Outer0 privateMethod(Path path, Selector selector)
    Outer0(path:path, _selector:selector.toS(), invalidKind:InvalidKind(inner:S"PrivateMethod"))
  type method
  Outer0 nonExistentPath(Path path)
    Outer0(path:path,_selector:S"",invalidKind:InvalidKind(inner:S"NonExistentPath"))
  type method 
  Outer0 nonExistentMethod(Path path, Selector selector)
    Outer0(path:path, _selector:selector.toS(), invalidKind:InvalidKind(inner:S"NonExistentMethod"))    
  
  type method
  Outer0 (Introspection::Record record) 
    Outer0(
      path:Path.fromS(record"Path"),
      _selector:record"Selector", 'selector may not exists, would be S""
      invalidKind:InvalidKind(inner:record"InvalidKind")
      )
  method
  Selector selector() {
    if this.hasSelector() (return Selector.fromS(this._selector()))
    error Report::UnsupportedOperation"the MemberUnavailable is a path"
    }
  method
  Bool hasSelector() this._selector()!=S""
  method toS() S"MemberUnavailable[path:"[this.path();{
    if this.hasSelector() (return S" selector:"[this.selector()]"")
    return S""
    }]" kind:"[this.invalidKind()]"]"
  }
PrivacyCoupuled:{(Introspection::Record record) <:Report
  method toS() S"PrivacyCoupuled"
  }
NSBMissing:{(Report report) <:Report
  method toS() S"NSBMissing "[this.report()]""
  }
'New:{(type Any super)
'  type method type Outer0 #begin() Outer0
'  type method Outer0 #add(type Any that) Outer0(super:that)
'  method Outer0 #end() this
'} 'nah, we are just happy with a Stringable plus injecting interfaces together with the invariant

}