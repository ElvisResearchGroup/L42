{
  type method
  Library compose(Library left,Library right)
  exception MetaGuard::ClassClash, MetaGuard::MethodClash {
    return SafeOperators.compose(left:left,right:right)
    catch error Library err (
      record=Introspection::Record(lib:err)
      x=record"Kind"
      if x== S"ClassClash"  (exception MetaGuard::ClassClash(record:record))
      if x== S"MethodClash"  (exception MetaGuard::MethodClash(record:record))
      error err)
    }
  type method
  Void checkTargetExists(Library that,Path path) exception MetaGuard::NestedClassUnavailable (
    unused=AddDocumentationPath[path doc:Introspection::Doc"JustToSeeIfItIsThere"]<<that
    catch exception MetaGuard::InvalidOnTopLevel x
      error Assert::CodeNotReachable"Refactor4" 'TODO: if you omit Assert:: the error reporting is horrible
    void
    )
    
  Squares:'  toPutAs private
    {'findMeSquares
    type method
    Library << (Library that)
      SafeOperatorsAccess.compose(left:that,right:{
        type method
        type Outer0 #begin() Outer0
        method
        Outer0 #end() this
        })
    }
  Redirect:Squares<<{#add(Path that, type Any to)
    method
    Library << (Library that)
    exception
        MetaGuard::NestedClassUnavailable,
        MetaGuard::InvalidOnTopLevel,
        MetaGuard::SourceUnfit,
        MetaGuard::MethodClash,
        MetaGuard::IncoherentRedirectMapping{
      return SafeOperators.redirect(that,src:this.that(),dest:this.to())
      catch error Library err (
        record=Introspection::Record(lib:err)
        x=record"Kind"
        if x== S"MemberUnavailable"  (exception MetaGuard::NestedClassUnavailable(record:record))
        if x== S"InvalidOnTopLevel"  (exception MetaGuard::InvalidOnTopLevel(record:record))
        if x== S"MethodClash"  (exception MetaGuard::MethodClash(record:record))
        if x== S"SourceUnfit"  (exception MetaGuard::SourceUnfit(record:record))
        if x== S"IncoherentRedirectMapping" (exception MetaGuard::IncoherentRedirectMapping(record:record))
        error err)
      }
    }
  RenameSelector:Squares<<{#add(Selector that, Path of, Selector to)
    method
    Library << (Library that)exception MetaGuard::MemberUnavailable,MetaGuard::MethodClash{
      return SafeOperators.renameMethod(that,path:this.of() src:this.that(),dest:this.to())
      catch error Library err (
        record=Introspection::Record(lib:err)
        x=record"Kind"
        if x== S"MemberUnavailable"  (exception MetaGuard::DispatchMemberUnavailable(err))
        if x== S"MethodClash"  (exception MetaGuard::MethodClash(record:record))
        error err)
      }
    }
  RenamePath:Squares<<{#add(Path that, Path to)
    method
    Library << (Library that)exception MetaGuard::NestedClassUnavailable,MetaGuard::MethodClash,MetaGuard::ClassClash{
      return SafeOperators.renameClass(that,src:this.that(),dest:this.to())
      catch error Library err (
        record=Introspection::Record(lib:err)
        x=record"Kind"
        if x== S"MemberUnavailable"  (exception MetaGuard::NestedClassUnavailable(record:record))
        if x== S"MethodClash"  (exception MetaGuard::MethodClash(record:record))
        if x== S"ClassClash"  (exception MetaGuard::ClassClash(record:record))
        Debug(S"critical failure in capturing plugin primitive error")
        Debug(x)
        error err
        )
      }
    }
  RemoveImplementationSelector:Squares<<{#add(Selector that, Path of)
    method
    Library << (Library that)exception MetaGuard::MemberUnavailable{
      return SafeOperators.removeImplementation(that,path:this.of(),selector:this.that())
      catch error Library err (
        record=Introspection::Record(lib:err)
        x=record"Kind"
        if x== S"MemberUnavailable"  (exception MetaGuard::DispatchMemberUnavailable(err))
        error err)
      }
    }
  MoveImplementationSelector:Squares<<{#add(Selector that, Path of,Selector to)
    method
    Library << (Library that)exception MetaGuard::MemberUnavailable,MetaGuard::MethodClash{
      return SafeOperators.moveImplementation(that,path:this.of(),src:this.that(),dest:this.to())
      catch error Library err (
        record=Introspection::Record(lib:err)
        x=record"Kind"
        if x== S"MemberUnavailable"  (exception MetaGuard::DispatchMemberUnavailable(err))
        if x== S"MethodClash"  (exception MetaGuard::MethodClash(record:record))
        error err)
      }
    }
  RemoveImplementationPath:Squares<<{#add(Path that)
    method
    Library << (Library that)exception MetaGuard::NestedClassUnavailable,MetaGuard::PrivacyCoupuled{
      return SafeOperators.removeImplementation(that,path:this.that())
      catch error Library err (
        record=Introspection::Record(lib:err)
        x=record"Kind"
        if x== S"MemberUnavailable"  (exception MetaGuard::NestedClassUnavailable(record:record))
        if x== S"PrivacyCoupuled"  (exception MetaGuard::PrivacyCoupuled(record:record))
        error err)
      }
    }
  AddDocumentationSelector:Squares<<{#add(Selector that, Path of,Introspection::Doc doc)
    method
    Library << (Library that)exception MetaGuard::MemberUnavailable{
      return SafeOperators.addDocumentation(that,path:this.of() selector:this.that(),doc:this.doc())
      catch error Library err (
        record=Introspection::Record(lib:err)
        x=record"Kind"
        if x== S"MemberUnavailable"  (exception MetaGuard::DispatchMemberUnavailable(err))
        error err)
      }
    }
  AddDocumentationPath:Squares<<{#add(Path that,Introspection::Doc doc)
    method
    Library << (Library that)exception MetaGuard::NestedClassUnavailable,MetaGuard::InvalidOnTopLevel{
      return SafeOperators.addDocumentation(that,path:this.that(),doc:this.doc())
      catch error Library err (
        record=Introspection::Record(lib:err)
        x=record"Kind"
        if x== S"MemberUnavailable"  (exception MetaGuard::NestedClassUnavailable(record:record))
        if x== S"InvalidOnTopLevel"  (exception MetaGuard::InvalidOnTopLevel(record:record))
        error err)
      }
    }
  MakePrivatePath:Squares<<{#add(Path that)
    method
    Library << (Library that)exception MetaGuard::MemberUnavailable,MetaGuard::InvalidOnTopLevel
      AddDocumentationPath[this.that(),doc:Introspection::Doc.#stringParser({'@private
        })]<<that'string parser works, but we can not use the sugar, that would add @stringU
    }
  MakePrivateSelector:Squares<<{#add(Selector that, Path of)
    method
    Library << (Library that)exception MetaGuard::MemberUnavailable
      AddDocumentationSelector[this.that() of:this.of() doc:Introspection::Doc.#stringParser({'@private
        })]<<that
    }
  
  SumMethods:Squares<<{
    '#add(Selector that,Selector and, Path of, Selector to)
    #add(Selector that,Selector and, Path of, S over, Selector to)
    
    method
    Library << (Library that)exception MetaGuard::MemberUnavailable,MetaGuard::MethodClash, MetaGuard::ParameterMismatch{
      return SafeOperators.sumMethods(that,path:this.of() src1:this.that(),src2:this.and(), dest:this.to(),name:this.over())
      catch error Library err (
        record=Introspection::Record(lib:err)
        x=record"Kind"
        if x== S"MemberUnavailable"  (exception MetaGuard::DispatchMemberUnavailable(err))
        if x== S"MethodClash"  (exception MetaGuard::MethodClash(record:record))
        if x== S"ParameterMismatch"  (exception MetaGuard::ParameterMismatch(record:record))
        error err)
      }
    }
  Tools:...
  
}