{
  type method
  Library compose(Library left,Library right)
  exception MetaGuard::ClassClash, MetaGuard::MethodClash {
    return SafeOperators.compose(left:left,right:right)
    catch error err (on Library (
      record=Introspection::Record(lib:err) 'Introspection(lib:err).record()
      with x=record"Kind" (
        case x== S"ClassClash"  (exception MetaGuard::ClassClash(record:record))
        case x== S"MethodClash"  (exception MetaGuard::MethodClash(record:record))
        default error err)))
    }
    
  Squares:'  toPutAs private
    {'findMeSquares
    type method
    Library << (Library that)
      SafeOperatorsAccess.compose(left:that,right:{
        type method
        type Outer0 #begin() Outer0
        method
        Outer0 #end() this
        })
    }
  Redirect:Squares<<{#add(Path that, type Any to)
    method
    Library << (Library that)exception MetaGuard::NestedClassUnavailable,MetaGuard::InvalidOnTopLevel,MetaGuard::SourceUnfit,MetaGuard::MethodClash{
      return SafeOperators.redirect(that,src:this.that(),dest:this.to())
      catch error err (on Library (
        record=Introspection(lib:err).record()
        with x=record"Kind" (
          case x== S"MemberUnavailable"  (exception MetaGuard::NestedClassUnavailable(record:record))
          case x== S"InvalidOnTopLevel"  (exception MetaGuard::InvalidOnTopLevel(record:record))
          case x== S"MethodClash"  (exception MetaGuard::MethodClash(record:record))
          case x== S"SourceUnfit"  (exception MetaGuard::SourceUnfit(record:record))
          default error err)))
      }
    }
  RenameSelector:Squares<<{#add(Selector that, Path of, Selector to)
    method
    Library << (Library that)exception MetaGuard::MemberUnavailable,MetaGuard::MethodClash{
      return SafeOperators.renameMethod(that,path:this.of() src:this.that(),dest:this.to())
      catch error err (on Library (
        record=Introspection(lib:err).record()
        with x=record"Kind" (
          case x== S"MemberUnavailable"  (exception MetaGuard::DispatchMemberUnavailable(err))
          case x== S"MethodClash"  (exception MetaGuard::MethodClash(record:record))
          default error err)))
      }
    }
  RenamePath:Squares<<{#add(Path that, Path to)
    method
    Library << (Library that)exception MetaGuard::NestedClassUnavailable,MetaGuard::MethodClash,MetaGuard::ClassClash{
      return SafeOperators.renameClass(that,src:this.that(),dest:this.to())
      catch error err (on Library (
        record=Introspection(lib:err).record()
        with x=record"Kind" (
          case x== S"MemberUnavailable"  (exception MetaGuard::NestedClassUnavailable(record:record))
          case x== S"MethodClash"  (exception MetaGuard::MethodClash(record:record))
          case x== S"ClassClash"  (exception MetaGuard::ClassClash(record:record))
          default error err)))
      }
    }
  RemoveImplementationSelector:Squares<<{#add(Selector that, Path of)
    method
    Library << (Library that)exception MetaGuard::MemberUnavailable{
      return SafeOperators.removeImplementation(that,path:this.of(),selector:this.that())
      catch error err (on Library (
        record=Introspection(lib:err).record()
        with x=record"Kind" (
          case x== S"MemberUnavailable"  (exception MetaGuard::DispatchMemberUnavailable(err))
          default error err)))
      }
    }
  RemoveImplementationPath:Squares<<{#add(Path that)
    method
    Library << (Library that)exception MetaGuard::NestedClassUnavailable,MetaGuard::PrivacyCoupuled{
      return SafeOperators.removeImplementation(that,path:this.that())
      catch error err (on Library (
        record=Introspection(lib:err).record()
        with x=record"Kind" (
          case x== S"MemberUnavailable"  (exception MetaGuard::NestedClassUnavailable(record:record))
          case x== S"PrivacyCoupuled"  (exception MetaGuard::PrivacyCoupuled(record:record))
          default error err)))
      }
    }
  AddDocumentationSelector:Squares<<{#add(Selector that, Path of,Introspection::Doc doc)
    method
    Library << (Library that)exception MetaGuard::MemberUnavailable{
      return SafeOperators.addDocumentation(that,path:this.of() selector:this.that(),doc:this.doc())
      catch error err (on Library (
        record=Introspection(lib:err).record()
        with x=record"Kind" (
          case x== S"MemberUnavailable"  (exception MetaGuard::DispatchMemberUnavailable(err))
          default error err)))
      }
    }
  AddDocumentationPath:Squares<<{#add(Path that,Introspection::Doc doc)
    method
    Library << (Library that)exception MetaGuard::NestedClassUnavailable,MetaGuard::InvalidOnTopLevel{
      return SafeOperators.addDocumentation(that,path:this.that(),doc:this.doc())
      catch error err (on Library (
        record=Introspection(lib:err).record()
        with x=record"Kind" (
          case x== S"MemberUnavailable"  (exception MetaGuard::NestedClassUnavailable(record:record))
          case x== S"InvalidOnTopLevel"  (exception MetaGuard::InvalidOnTopLevel(record:record))
          default error err)))
      }
    }
  MakePrivatePath:Squares<<{#add(Path that)
    method
    Library << (Library that)exception MetaGuard::MemberUnavailable,MetaGuard::InvalidOnTopLevel
      AddDocumentationPath[this.that(),doc:Introspection::Doc.#stringParser({'@private
        })]<<that'string parser works, but we can not use the sugar, that would add @stringU
    }
  MakePrivateSelector:Squares<<{#add(Selector that, Path of,)
    method
    Library << (Library that)exception MetaGuard::MemberUnavailable
      AddDocumentationSelector[this.that() of:this.of() doc:Introspection::Doc.#stringParser({'@private
        })]<<that
    }
  ExposeAsLibrary:Squares<<{#add(Path that)
    method
    Library << (Library that)exception MetaGuard::NestedClassUnavailable,MetaGuard::PrivacyCoupuled {
      if this.that()==Path"Outer0" (return that)
      this.checkTargetExists(that)'throws MemberUnavailable
      var res=that
      res:=RenamePath[Path"Outer0" to:Path"PrImpl"]<<res'MemberUnavailable,MethodClash,ClassClash can not happen on Outer0
      catch exception (on MetaGuard error Assert::CodeNotReachable"")
      res:=RenamePath[Path"PrImpl::N" to:Path"BNS::N"]<<res
      res:=RenamePath[Path"PrImpl::S" to:Path"BNS::S"]<<res'fails here
      res:=RenamePath[Path"PrImpl::Bool" to:Path"BNS::Bool"]<<res
      res:=RenamePath[Path"PrImpl::Debug" to:Path"BNS::Debug"]<<res
      catch exception r (on MetaGuard error Assert::CodeNotReachable"Was NSB missing, to refactor for new load")
      res:=RemoveImplementationPath[Path"BNS"]<<res'leak PrivacyCoupuled
      catch exception (on MetaGuard::MemberUnavailable error Assert::CodeNotReachable"")
      res:=RenamePath[Path"PrImpl"++this.that() to:Path"Outer0"]<<res
      res:=RenamePath[Path"BNS" to:Path"Outer0"]<<res
      res:=MakePrivatePath[Path"PrImpl"]<<res
      catch exception (on MetaGuard error Assert::CodeNotReachable"")
      return res
      }
    method
    Void checkTargetExists(Library that) exception MetaGuard::MemberUnavailable (
      unused=AddDocumentationPath[this.that() doc:Introspection::Doc"JustToSeeIfItIsThere"]<<that
      catch exception x (
        on MetaGuard::InvalidOnTopLevel error Assert::CodeNotReachable"" 'TODO: if you omit Guard:: the error reporting is horrible
        )
      void
      )
    }
}