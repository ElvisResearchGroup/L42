{
  type method
  Library compose(Library left,Library right)
  exception MetaGuard::ClassClash, MetaGuard::MethodClash {
    return SafeOperators.compose(left:left,right:right)
    catch error err (on Library (
      record=Introspection::Record(lib:err)
      with x=record"Kind" (
        case x== S"ClassClash"  (exception MetaGuard::ClassClash(record:record))
        case x== S"MethodClash"  (exception MetaGuard::MethodClash(record:record))
        default error err)))
    }
  type method
  Void checkTargetExists(Library that,Path path) exception MetaGuard::NestedClassUnavailable (
    unused=AddDocumentationPath[path doc:Introspection::Doc"JustToSeeIfItIsThere"]<<that
    catch exception x (
      on MetaGuard::InvalidOnTopLevel error Assert::CodeNotReachable"Refactor4" 'TODO: if you omit Assert:: the error reporting is horrible
      )
    void
    )
    
  Squares:'  toPutAs private
    {'findMeSquares
    type method
    Library << (Library that)
      SafeOperatorsAccess.compose(left:that,right:{
        type method
        type Outer0 #begin() Outer0
        method
        Outer0 #end() this
        })
    }
  Redirect:Squares<<{#add(Path that, type Any to)
    method
    Library << (Library that)
    exception
        MetaGuard::NestedClassUnavailable,
        MetaGuard::InvalidOnTopLevel,
        MetaGuard::SourceUnfit,
        MetaGuard::MethodClash,
        MetaGuard::IncoherentRedirectMapping{
      return SafeOperators.redirect(that,src:this.that(),dest:this.to())
      catch error err (on Library (
        record=Introspection::Record(lib:err)
        with x=record"Kind" (
          case x== S"MemberUnavailable"  (exception MetaGuard::NestedClassUnavailable(record:record))
          case x== S"InvalidOnTopLevel"  (exception MetaGuard::InvalidOnTopLevel(record:record))
          case x== S"MethodClash"  (exception MetaGuard::MethodClash(record:record))
          case x== S"SourceUnfit"  (exception MetaGuard::SourceUnfit(record:record))
          case x== S"IncoherentRedirectMapping" (exception MetaGuard::IncoherentRedirectMapping(record:record))
          default error err)))
      }
    }
  RenameSelector:Squares<<{#add(Selector that, Path of, Selector to)
    method
    Library << (Library that)exception MetaGuard::MemberUnavailable,MetaGuard::MethodClash{
      return SafeOperators.renameMethod(that,path:this.of() src:this.that(),dest:this.to())
      catch error err (on Library (
        record=Introspection::Record(lib:err)
        with x=record"Kind" (
          case x== S"MemberUnavailable"  (exception MetaGuard::DispatchMemberUnavailable(err))
          case x== S"MethodClash"  (exception MetaGuard::MethodClash(record:record))
          default error err)))
      }
    }
  RenamePath:Squares<<{#add(Path that, Path to)
    method
    Library << (Library that)exception MetaGuard::NestedClassUnavailable,MetaGuard::MethodClash,MetaGuard::ClassClash{
      Debug(S"Started RenamePath")
      return SafeOperators.renameClass(that,src:this.that(),dest:this.to())
      catch error err (on Library (
        record=Introspection::Record(lib:err)
        with x=record"Kind" (
          case x== S"MemberUnavailable"  (exception MetaGuard::NestedClassUnavailable(record:record))
          case x== S"MethodClash"  (exception MetaGuard::MethodClash(record:record))
          case x== S"ClassClash"  (exception MetaGuard::ClassClash(record:record))
          default (
            Debug(S"critical failure in capturing plugin primitive error")
            Debug(x)
            error err
          ))))
      }
    }
  RemoveImplementationSelector:Squares<<{#add(Selector that, Path of)
    method
    Library << (Library that)exception MetaGuard::MemberUnavailable{
      return SafeOperators.removeImplementation(that,path:this.of(),selector:this.that())
      catch error err (on Library (
        record=Introspection::Record(lib:err)
        with x=record"Kind" (
          case x== S"MemberUnavailable"  (exception MetaGuard::DispatchMemberUnavailable(err))
          default error err)))
      }
    }
  MoveImplementationSelector:Squares<<{#add(Selector that, Path of,Selector to)
    method
    Library << (Library that)exception MetaGuard::MemberUnavailable,MetaGuard::MethodClash{
      return SafeOperators.moveImplementation(that,path:this.of(),src:this.that(),dest:this.to())
      catch error err (on Library (
        record=Introspection::Record(lib:err)
        with x=record"Kind" (
          case x== S"MemberUnavailable"  (exception MetaGuard::DispatchMemberUnavailable(err))
          case x== S"MethodClash"  (exception MetaGuard::MethodClash(record:record))
          default error err)))
      }
    }
  RemoveImplementationPath:Squares<<{#add(Path that)
    method
    Library << (Library that)exception MetaGuard::NestedClassUnavailable,MetaGuard::PrivacyCoupuled{
      return SafeOperators.removeImplementation(that,path:this.that())
      catch error err (on Library (
        record=Introspection::Record(lib:err)
        with x=record"Kind" (
          case x== S"MemberUnavailable"  (exception MetaGuard::NestedClassUnavailable(record:record))
          case x== S"PrivacyCoupuled"  (exception MetaGuard::PrivacyCoupuled(record:record))
          default error err)))
      }
    }
  AddDocumentationSelector:Squares<<{#add(Selector that, Path of,Introspection::Doc doc)
    method
    Library << (Library that)exception MetaGuard::MemberUnavailable{
      return SafeOperators.addDocumentation(that,path:this.of() selector:this.that(),doc:this.doc())
      catch error err (on Library (
        record=Introspection::Record(lib:err)
        with x=record"Kind" (
          case x== S"MemberUnavailable"  (exception MetaGuard::DispatchMemberUnavailable(err))
          default error err)))
      }
    }
  AddDocumentationPath:Squares<<{#add(Path that,Introspection::Doc doc)
    method
    Library << (Library that)exception MetaGuard::NestedClassUnavailable,MetaGuard::InvalidOnTopLevel{
      return SafeOperators.addDocumentation(that,path:this.that(),doc:this.doc())
      catch error err (on Library (
        record=Introspection::Record(lib:err)
        with x=record"Kind" (
          case x== S"MemberUnavailable"  (exception MetaGuard::NestedClassUnavailable(record:record))
          case x== S"InvalidOnTopLevel"  (exception MetaGuard::InvalidOnTopLevel(record:record))
          default error err)))
      }
    }
  MakePrivatePath:Squares<<{#add(Path that)
    method
    Library << (Library that)exception MetaGuard::MemberUnavailable,MetaGuard::InvalidOnTopLevel
      AddDocumentationPath[this.that(),doc:Introspection::Doc.#stringParser({'@private
        })]<<that'string parser works, but we can not use the sugar, that would add @stringU
    }
  MakePrivateSelector:Squares<<{#add(Selector that, Path of)
    method
    Library << (Library that)exception MetaGuard::MemberUnavailable
      AddDocumentationSelector[this.that() of:this.of() doc:Introspection::Doc.#stringParser({'@private
        })]<<that
    }
  
  SumMethods:Squares<<{#add(Selector that, Path of, Selector to)
    method
    Library << (Library that)exception MetaGuard::MemberUnavailable,MetaGuard::MethodClash, MetaGuard::ParameterMismatch{
      return SafeOperators.sumMethods(that,path:this.of() src:this.that(),dest:this.to())
      catch error err (on Library (
        record=Introspection::Record(lib:err)
        with x=record"Kind" (
          case x== S"MemberUnavailable"  (exception MetaGuard::DispatchMemberUnavailable(err))
          case x== S"MethodClash"  (exception MetaGuard::MethodClash(record:record))
          case x== S"ParameterMismatch"  (exception MetaGuard::ParameterMismatch(record:record))
          default error err)))
      }
    }
    
  
}