{interface<:Concept.ToS, Concept.Equals, Concept.Classable, Concept.Named
type method S kind()
method S text()
method Opt responseOf()
read method type This clazz()
Opt:{#new(TOpt that)
  TOpt:{interface method This2 get() }
  TEmpty:{()<:TOpt method get() 
    error S"UnsatisfactoryErrorToAvoidCycle, replace in Adam2"
    'error Guard.Operation"TEmpty.get() Value not present in Optional" 
    }
  TOf:{(This2 that)<:TOpt method get() this.that()}
  method This1 ~() this.that().get()
  method Bool isPresent() {
    unused=~this  'unused=~this
    return Bool.true()
    catch error Any return Bool.false()
    }
  type method This () This.#new(TEmpty())
  type method This (This1 that) This.#new(TOf(that))
  }
EqualMessages:{
  type method Bool (Message that,Message other){
  'assuming they have the same type
  res=that.clazz().kind()==other.clazz().kind() 
    & that.text()==other.text()
    & that.responseOf().isPresent()==other.responseOf().isPresent()
  if !res (return Bool.false())
  if !that.responseOf().isPresent() (return Bool.true())
  'i know both are present
  return (~that.responseOf()).equals(~other.responseOf()) ' this calls  equals in message,
  'that check for equal type and then call EqualMessages
  }}
$:{()
  type method Library <<(Library that)
    SafeOperatorsAccess.compose(left:that, right:This.messageTrait())
  type method Library messageTrait() {(S _text, Message.Opt cause)<:Message
    method myName()GetMyName(This)
    method kind() this.myName()
    method text() this._text()
    method responseOf() this.cause()
    method equals(that){
      with that (on This return this==that)
      return Bool.false()
      }
  method
  This (Message that)
    This(text:this.text(),cause:that)

    method toS() {
      if !this.cause().isPresent() (
        return This.kind()++S.doubleQuote()++this.text()++S.doubleQuote()
        )
      var res=This.kind()
      if this.text()!=S"" (
        res:=res++S"[text:"++S.doubleQuote()++this.text()++S.doubleQuote()
          ++S", cause:"
        )
      else (res:=res++S"[")
      return res[~this.cause()]"]"
      }
    method Bool != (This that)
      !(this==that)
    method Bool == (This that)
      Message.EqualMessages(this,other:that)
    method classAny() This
    method clazz() This
    type method
    This (S text)
      This(_text:text,cause:Message.Opt())
    type method
    This(S text, Message cause)
      This(_text:text,cause:Message.Opt(cause))
    'next part could become a trait on its own (but S must keep its version)
    
    type method mut S.SBuilder #builder()S.SBuilder.empty()
      type method This #from(S.SBuilder builder)
        This(text:S.#from(builder:builder))
        
    method
    SConcat #begin()
      SConcat(old:this,accumulator:S"")
      
    SConcat:{(Concept.ToS old,S accumulator)
      method SConcat #add(Concept.ToS that)
        SConcat(old:this.old(),accumulator:this.accumulator()++that.toS())
      method SConcat #add(Concept.ToS that, Concept.ToS separedBy) (
        var newAcc=that.toS()
        if this.accumulator()!=S"" (
          newAcc:=this.accumulator()++separedBy.toS()++newAcc
          )
        SConcat(old:this.old(),accumulator:newAcc)
        )
      method
      SConcat #end() this
      method mut S.SBuilder #builder()S.SBuilder.empty()
      method This1 #from(S.SBuilder builder)
        This1(text:this.old().toS()++this.accumulator()++S.#from(builder:builder))
      }
    }
  }
}