{
'members of PreferentialComposition
$:{interface
  method
  Library solveConflict(Library that,SrcDest location)exception MetaGuard
  }
SrcDest:{(Path path, Selector src,Selector dest)}
SrcDests:LinkedList.list(SrcDest)
Libs:'@private
  LinkedList.list(Library)

type method '@private
SrcDests renameMap(Library that,S prefix,Introspection::NestedClasses intros) {
  var acc=SrcDests[]
  with intro in intros.vals() (
    acc++=this.renameMap(that,prefix:prefix,
      path:intro.pathFromRoot()
      ms:intro.methods()) 
    )
  return acc
  }
type method
SrcDests renameMap(
Library that,S prefix,Path path, Introspection::Methods ms) {
  thatI=Introspection(lib:that, path:path)
  catch exception (on MetaGuard::MemberUnavailable return SrcDests[])
  return SrcDests[with meth in ms.vals() (
    if this.needRename(that:thatI,meth:meth) (
      destSel=Selector.fromS(prefix++meth.selector().toS())
      use[SrcDest(path:path,src:meth.selector(),dest:destSel)]
      ))]
  }      
type method
Bool needRename(
Introspection::NestedClass that,Introspection::Method meth) {
  if meth.isPrivate() (return Bool.false() )
  if meth.methodKind()==S"AbstractMethod" (return Bool.false() )
  meth2=that.methodFromSelector(meth.selector())
  catch exception (on MetaGuard::MemberUnavailable
    return Bool.false()
    )
  if meth2.isPrivate() (return Bool.false() )
  if meth2.methodKind()==S"AbstractMethod" (return Bool.false() )    
  return Bool.true()
  }
 
type method
Library <<(Library that) exception MetaGuard::ClassClash,MetaGuard::MethodClash
  Refactor.compose(left:that,right:{
  'members of each produced class
 (Libs myLibs)<:$ '@private

  method
  Outer0 #add(Library that)
    Outer0(myLibs:this.myLibs().#add(that))
    
  type method
  Outer0 #begin()
    Outer0(myLibs:Libs[])

  method
  Outer0 #end()
    Outer0(myLibs:this.myLibs().#end())

    
  method
  Library << (Library that) exception MetaGuard::ClassClash,MetaGuard::MethodClash{
    i=Introspection(lib:that)
    var map=SrcDests[]
    var acc={}
    with lib in this.myLibs().vals(), index in 0N.vals() (
      var libi=lib
      rens=Outer1.renameMap(lib,prefix:S"#"[index]"", intros:i.transitivelyNestedClasses())
      with ren in rens.vals() (
        map:=map.#add(ren)
        libi:=this.solveConflict(libi,location:ren)
        catch exception (on MetaGuard error Assert::ObservedBug(text:{
          return S"solveConflict does not follow the specification: it throws exceptions"
          ' yes, exception can be handled by type system, but it is an example of
          'wrong behaviour for metaprogrammed code?
          'if ... check if ren is well formed w.r.t. libi, otherwise blame S"renameMap"
          }))
        void
        )
      acc:=Refactor.compose(left:acc,right:libi)
      )
    acc:=Refactor.compose(left:acc,right:that)
    with mapi in map.vals() (
      acc:=Refactor::MakePrivateSelector[mapi.dest() of:mapi.path()]<<acc
      )
    return acc
    catch exception (on MetaGuard::MemberUnavailable error Assert::CodeNotReachable"PreferentialComposition1")
    }  
  method Outer0 ++ (Outer0 that)
    Outer0(myLibs:this.myLibs()++that.myLibs())
  })
}