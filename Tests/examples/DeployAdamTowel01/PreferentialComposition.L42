{
'members of PreferentialComposition
$:{interface
  method
  Library solveConflict(Library that,SrcDest location)
  }
SrcDest:{(Path path, Selector src,Selector dest)}
SrcDests:Collections.vector(of:SrcDest)
Libs:'@private
  Collections.vector(of:Library)

class method '@private
SrcDests renameMap(Library that,S prefix,Introspection.NestedClasses intros) {
  var acc=SrcDests[]
  with intro in intros.vals() (
    acc++=this.renameMap(that,prefix:prefix,
      path:intro.pathFromRoot()
      ms:intro.methods())
    )
  return acc
  }
class method
SrcDests renameMap(
Library that,S prefix,Path path, Introspection.Methods ms) {
  thatI=Introspection(lib:that, path:path)
  catch exception MetaGuard.MemberUnavailable return SrcDests[]
  return SrcDests[with meth in ms.vals() (
    if this.needRename(that:thatI,meth:meth) (
      destSel=Selector.fromS(prefix++meth.selector().toS())
      use[SrcDest(path:path,src:meth.selector(),dest:destSel)]
      ))]
  }
class method
Bool needRename(
Introspection.NestedClass that,Introspection.Method meth) {
  if meth.isPrivate() (return Bool.false() )
  if meth.methodKind()==S"AbstractMethod" (return Bool.false() )
  meth2=that.methodFromSelector(meth.selector())
  catch exception  MetaGuard.MemberUnavailable
    return Bool.false()
  if meth2.isPrivate() (return Bool.false() )
  if meth2.methodKind()==S"AbstractMethod" (return Bool.false() )
  return Bool.true()
  }

class method
Library <<(Library that) exception MetaGuard.ClassClash,MetaGuard.MethodClash
  Refactor.compose(left:that,right:{
  'members of each produced class
 (Libs myLibs)<:$ '@private

  method
  This #add(Library that)
    This(myLibs:this.myLibs().#add(that))

  class method
  This #begin()
    This(myLibs:Libs[])

  method
  This #end()
    This(myLibs:this.myLibs().#end())


  method
  Library << (Library that)
  exception MetaGuard.ClassClash,MetaGuard.MethodClash{
    i=Introspection(lib:that)
    var map=SrcDests[]
    var acc={}
    with lib in this.myLibs().vals(), index in 1N.vals() (
      var libi=lib
      rens=This1.renameMap(lib,prefix:S"#"[index]"", intros:i.transitivelyNestedClasses())
      with ren in rens.vals() (
        map:=map.#add(ren)
        libi:=this.solveConflict(libi,location:ren)
        )
      acc:=Refactor.compose(left:acc,right:libi)
      )
    acc:=Refactor.compose(left:acc,right:that)
    with mapi in map.vals() (
      acc:=Refactor.MakePrivateSelector(mapi.dest() of:mapi.path())<<acc
      )
    return acc
    error on MetaGuard.MemberUnavailable
      Assert.CodeNotReachable"PreferentialComposition1"
    }
  method This ++ (This that)
    This(myLibs:this.myLibs()++that.myLibs())
  })
}