{ _private(Library _binaryRepr)<:Concept::ToS Concept::Equals Concept::Named'@private
  method myName()GetMyName(Outer0)
  
  type method 
  Outer0 fromDocInternalizedS(S that){
    if that==S"@::"++S.nl() (return Outer0.fromS(S"Outer0"))
    'Debug(S"["++that++S"]")
    return Outer0.fromS(that(start:3N end:that.size()-1N))
    catch error x ( on Message 
      error Outer0.parseError(that,cause:x)
      )
    }
  type method
  Outer0 fromS(Concept::ToS that)
    Outer0.#stringParser(that.toS().binaryRepr())
  type method Outer0 #stringParser(Library that) (
    use SafeOperators 
      check ifInvalidDo(path:that)
      error Outer0.parseError(S.#stringParser(that))
    Outer0._private(_binaryRepr:that)
    )
  type method
  Any parseError(S that)
    S"UnsatisfactoryErrorToAvoidCycle, replace in AdamT2"
  type method
  Any parseError(S that, Message cause)
    S"UnsatisfactoryErrorToAvoidCycle, replace in AdamT2"

  method Library binaryRepr() this._binaryRepr()


  method toS() S.#stringParser(this._binaryRepr())


  method Bool != (Outer0 that) !(this==that)

  method
  Bool == (Outer0 that) {
    use Alu
      check ifStringEqualDo(s1:this.binaryRepr(),s2:that.binaryRepr())
      return Bool.true()
    return Bool.false()
    }
  method equals(that){
    with that (on Outer0 return this==that)
    return Bool.false()
    }
  method
  Path ++(Path that){
    if this==Path"Outer0" (return that)
    if that==Path"Outer0" (return this)
    return Path.#stringParser(
      this.toS()[S"::";that]"".binaryRepr()
      )
    }
  method
  Strings names(){
    var str=this.toS()
    if str==S"Outer0" (return Strings[])
    str++=S"::"
    var result=Strings[]
    while str!=S"" (
      pos=str.firstIndexOf(S"::")
      result:=result.#add(str(end:pos))
      str:=str(start:pos+2N)
      )
    return result.#end()
    }
  type method
  Path from(Strings names) {
    if names.isEmpty() (return Path"Outer0")
    s=S""[with n in names.vals() (use[n++S"::"])]""
    return Outer0.fromS(s(end:s.size()-2N))
    }
  type method
  Path fresh(S name)
    Path.fromS(SafeOperators.freshName(name))
  
  type method
  Path fresh()
    this.fresh(name:S"Fresh")
    
  type method
  Path fresh(Path path){
    names=path.names().#end()
    if names.isEmpty() (return this.fresh())
    Path last=this.fresh(name:names.top())
    var Path acc=Path"Outer0"
    with n in names.pop().#end().vals() (acc++=Path.fromS(n))
    acc++=last
    return acc
    }
  }