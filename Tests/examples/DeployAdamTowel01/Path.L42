{ _private(Library _binaryRepr)<:Concept.ToS Concept.Equals Concept.Named'@private
  method myName()GetMyName(This)
  
  type method 
  This fromDocInternalizedS(S that){
    if that==S"@."++S.nl() (return This.fromS(S"This"))
    'Debug(S"["++that++S"]")
    return This.fromS(that(start:2N end:that.size()-1N))
    catch error Message x 
      error This.parseError(that,cause:x)
    }
  type method
  This fromS(Concept.ToS that)
    This.#from(binaryRepr: that.toS().binaryRepr())
  
  type method This #from(S.SBuilder builder) 
    This.#from(binaryRepr: builder.binaryRepr())
  type method mut S.SBuilder #builder() S.SBuilder.empty()
  
  type method This #from(Library binaryRepr) (
    use SafeOperators 
      check ifInvalidDo(path:binaryRepr)
      error This.parseError(S.#from(binaryRepr: binaryRepr))
    This._private(_binaryRepr:binaryRepr)
    )
  type method
  Any parseError(S that)
    S"Path1.["[that]"] UnsatisfactoryErrorToAvoidCycle, replace in AdamT2"
  type method
  Any parseError(S that, Message cause)
    S"Path2.["[that]"] UnsatisfactoryErrorToAvoidCycle, replace in AdamT2"

  method Library binaryRepr() this._binaryRepr()


  method toS() S.#from(binaryRepr: this._binaryRepr())


  method Bool != (This that) !(this==that)

  method
  Bool == (This that) {
    use Alu
      check ifStringEqualDo(s1:this.binaryRepr(),s2:that.binaryRepr())
      return Bool.true()
    return Bool.false()
    }
  method equals(that){
    with that (on This return this==that)
    return Bool.false()
    }
  method
  Path ++(Path that){
    if this==Path"This" (return that)
    if that==Path"This" (return this)
    return Path.#from(binaryRepr: 
      this.toS()[S".";that]"".binaryRepr()
      )
    }
  method
  Strings names(){
    var str=this.toS()
    if str==S"This" (return Strings[])
    str++=S"."
    var result=Strings[]
    while str!=S"" (
      pos=str.firstIndexOf(S".")
      result:=result.#add(str(end:pos))
      str:=str(start:pos+1N)
      )
    return result.#end()
    }
  type method
  Path from(Strings names) {
    if names.isEmpty() (return Path"This")
    s=S""[with n in names.vals() (use[n separedBy:S"."])]""
    return This.fromS(s) '(end:s.size()-1N)
    }
  type method
  Path fresh(S name)
    Path.fromS(SafeOperators.freshName(name))
  
  type method
  Path fresh()
    this.fresh(name:S"Fresh")
    
  type method
  Path fresh(Path path){
    names=path.names().#end()
    if names.isEmpty() (return this.fresh())
    Path last=this.fresh(name:names.top())
    var Path acc=Path"This"
    with n in names.pop().#end().vals() (acc++=Path.fromS(n))
    acc++=last
    return acc
    }
  }