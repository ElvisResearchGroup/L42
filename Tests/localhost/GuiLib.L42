 {/*@untrusted
*/
read method 
This0.Abstract.S id() 
class method 
This0.Abstract.S jsEscape(This0.Abstract.S that) (
  var This0.Abstract.S tmp=that
  Void unused39907=tmp := tmp.replace(that:This0.Abstract.S.#from(builder:(
    mut This0.Abstract.S.SBuilder b875=This0.Abstract.S.#builder()
    Void unused39911=b875.#backslash()
    b875
    )), into:This0.Abstract.S.#from(builder:(
    mut This0.Abstract.S.SBuilder b876=This0.Abstract.S.#builder()
    Void unused39912=b876.#backslash()
    Void unused39913=b876.#backslash()
    b876
    )))
  Void unused39908=tmp := tmp.replace(that:This0.Abstract.S.doubleQuote(), into:(
    This0.Abstract.S imm$opPar488=This0.Abstract.S.#from(builder:(
      mut This0.Abstract.S.SBuilder b877=This0.Abstract.S.#builder()
      Void unused39914=b877.#backslash()
      b877
      ))
    This0.Abstract.S imm$opPar489=This0.Abstract.S.doubleQuote()
    imm$opPar488.#plusplus#0left(right:imm$opPar489)
    ))
  Void unused39909=tmp := tmp.replace(that:This0.Abstract.S.#from(builder:(
    mut This0.Abstract.S.SBuilder b878=This0.Abstract.S.#builder()
    Void unused39915=b878.#sQuote()
    b878
    )), into:This0.Abstract.S.#from(builder:(
    mut This0.Abstract.S.SBuilder b879=This0.Abstract.S.#builder()
    Void unused39916=b879.#backslash()
    Void unused39917=b879.#sQuote()
    b879
    )))
  Void unused39910=tmp := (//tmp:=tmp.replace(S"\u" into:S"\u005cu")
tmp.replace(that:This0.Abstract.S.nl(), into:This0.Abstract.S.#from(builder:(
    mut This0.Abstract.S.SBuilder b880=This0.Abstract.S.#builder()
    Void unused39918=b880.#backslash()
    Void unused39919=b880.#n()
    b880
    ))))
  tmp
  )
mut method 
Void close() use This0.GuiPlugin check close(wName:this.id().#binaryRepr()) error void
mut method 
Void open(This0.Abstract.S title, This0.Abstract.S body, This0.Abstract.Size x, This0.Abstract.Size y) this.open(html:(
  This0.Abstract.S.Continue rcv1=(
    This0.Abstract.S rcv2=(
      This0.Abstract.S.Continue rcv3=(
        This0.Abstract.S rcv4=(
          This0.Abstract.S.Continue rcv5=(
            This0.Abstract.S rcv6=This0.Abstract.S.#from(builder:(
              mut This0.Abstract.S.SBuilder b881=This0.Abstract.S.#builder()
              b881
              ))
            rcv6.#from(seqBuilder:(
              mut This0.Abstract.S.SConcat b882=rcv6.#seqBuilder()
              Void unused39920=b882.#add(that:This0.htmlHeader())
              b882
              ))
            )
          rcv5.#from(builder:(
            mut This0.Abstract.S.SBuilder b883=rcv5.#builder()
            Void unused39921=b883.#left()
            Void unused39922=b883.#t()
            Void unused39923=b883.#i()
            Void unused39924=b883.#t()
            Void unused39925=b883.#l()
            Void unused39926=b883.#e()
            Void unused39927=b883.#right()
            b883
            ))
          )
        rcv4.#from(seqBuilder:(
          mut This0.Abstract.S.SConcat b884=rcv4.#seqBuilder()
          Void unused39928=b884.#add(that:title)
          b884
          ))
        )
      rcv3.#from(builder:(
        mut This0.Abstract.S.SBuilder b885=rcv3.#builder()
        Void unused39929=b885.#left()
        Void unused39930=b885.#divide()
        Void unused39931=b885.#t()
        Void unused39932=b885.#i()
        Void unused39933=b885.#t()
        Void unused39934=b885.#l()
        Void unused39935=b885.#e()
        Void unused39936=b885.#right()
        Void unused39937=b885.#left()
        Void unused39938=b885.#divide()
        Void unused39939=b885.#h()
        Void unused39940=b885.#e()
        Void unused39941=b885.#a()
        Void unused39942=b885.#d()
        Void unused39943=b885.#right()
        Void unused39944=b885.#left()
        Void unused39945=b885.#b()
        Void unused39946=b885.#o()
        Void unused39947=b885.#d()
        Void unused39948=b885.#y()
        Void unused39949=b885.#right()
        b885
        ))
      )
    rcv2.#from(seqBuilder:(
      mut This0.Abstract.S.SConcat b886=rcv2.#seqBuilder()
      Void unused39950=b886.#add(that:body)
      b886
      ))
    )
  rcv1.#from(builder:(
    mut This0.Abstract.S.SBuilder b887=rcv1.#builder()
    Void unused39951=b887.#left()
    Void unused39952=b887.#divide()
    Void unused39953=b887.#b()
    Void unused39954=b887.#o()
    Void unused39955=b887.#d()
    Void unused39956=b887.#y()
    Void unused39957=b887.#right()
    Void unused39958=b887.#left()
    Void unused39959=b887.#divide()
    Void unused39960=b887.#h()
    Void unused39961=b887.#t()
    Void unused39962=b887.#m()
    Void unused39963=b887.#l()
    Void unused39964=b887.#right()
    b887
    ))
  ), x:x, y:y)
class method 
This0.Abstract.S htmlHeader() (//        '<script>
//        '
//        "[Debug.readFile(fileName:Debug.localToAbsolute(fileName:S"examples/resources/js.js"))]"
//        '
//        '</script>
//        "
This0.Abstract.S.#from(builder:(
  mut This0.Abstract.S.SBuilder b888=This0.Abstract.S.#builder()
  Void unused39965=b888.#left()
  Void unused39966=b888.#bang()
  Void unused39967=b888.#D()
  Void unused39968=b888.#O()
  Void unused39969=b888.#C()
  Void unused39970=b888.#T()
  Void unused39971=b888.#Y()
  Void unused39972=b888.#P()
  Void unused39973=b888.#E()
  Void unused39974=b888.#space()
  Void unused39975=b888.#h()
  Void unused39976=b888.#t()
  Void unused39977=b888.#m()
  Void unused39978=b888.#l()
  Void unused39979=b888.#right()
  Void unused39980=b888.#left()
  Void unused39981=b888.#h()
  Void unused39982=b888.#t()
  Void unused39983=b888.#m()
  Void unused39984=b888.#l()
  Void unused39985=b888.#right()
  Void unused39986=b888.#left()
  Void unused39987=b888.#h()
  Void unused39988=b888.#e()
  Void unused39989=b888.#a()
  Void unused39990=b888.#d()
  Void unused39991=b888.#right()
  Void unused39992=b888.#left()
  Void unused39993=b888.#m()
  Void unused39994=b888.#e()
  Void unused39995=b888.#t()
  Void unused39996=b888.#a()
  Void unused39997=b888.#space()
  Void unused39998=b888.#h()
  Void unused39999=b888.#t()
  Void unused40000=b888.#t()
  Void unused40001=b888.#p()
  Void unused40002=b888.#less()
  Void unused40003=b888.#e()
  Void unused40004=b888.#q()
  Void unused40005=b888.#u()
  Void unused40006=b888.#i()
  Void unused40007=b888.#v()
  Void unused40008=b888.#equal()
  Void unused40009=b888.#dQuote()
  Void unused40010=b888.#c()
  Void unused40011=b888.#o()
  Void unused40012=b888.#n()
  Void unused40013=b888.#t()
  Void unused40014=b888.#e()
  Void unused40015=b888.#n()
  Void unused40016=b888.#t()
  Void unused40017=b888.#less()
  Void unused40018=b888.#c()
  Void unused40019=b888.#l()
  Void unused40020=b888.#a()
  Void unused40021=b888.#s()
  Void unused40022=b888.#s()
  Void unused40023=b888.#dQuote()
  Void unused40024=b888.#space()
  Void unused40025=b888.#c()
  Void unused40026=b888.#o()
  Void unused40027=b888.#n()
  Void unused40028=b888.#t()
  Void unused40029=b888.#e()
  Void unused40030=b888.#n()
  Void unused40031=b888.#t()
  Void unused40032=b888.#equal()
  Void unused40033=b888.#dQuote()
  Void unused40034=b888.#t()
  Void unused40035=b888.#e()
  Void unused40036=b888.#x()
  Void unused40037=b888.#t()
  Void unused40038=b888.#divide()
  Void unused40039=b888.#h()
  Void unused40040=b888.#t()
  Void unused40041=b888.#m()
  Void unused40042=b888.#l()
  Void unused40043=b888.#semicolon()
  Void unused40044=b888.#space()
  Void unused40045=b888.#c()
  Void unused40046=b888.#h()
  Void unused40047=b888.#a()
  Void unused40048=b888.#r()
  Void unused40049=b888.#s()
  Void unused40050=b888.#e()
  Void unused40051=b888.#t()
  Void unused40052=b888.#equal()
  Void unused40053=b888.#U()
  Void unused40054=b888.#T()
  Void unused40055=b888.#F()
  Void unused40056=b888.#less()
  Void unused40057=b888.#8()
  Void unused40058=b888.#dQuote()
  Void unused40059=b888.#right()
  Void unused40060=b888.#newline()
  b888
  )))
mut method 
Void open(This0.Abstract.S html, This0.Abstract.Size x, This0.Abstract.Size y) (/*Debug(html)
*/use This0.GuiPlugin check open(wName:this.id().#binaryRepr(), html:html.#binaryRepr(), x:x.#binaryRepr(), y:y.#binaryRepr()) error void)
mut method 
Void set(This0.Abstract.S that, This0.Abstract.S id) (
  Void unused40061=(/*$('#Alpha').replaceWith('htmlstring')
*/
    This0.Abstract.S qid=(
      This0.Abstract.S.Continue rcv7=(
        This0.Abstract.S rcv8=This0.Abstract.S.#from(builder:(
          mut This0.Abstract.S.SBuilder b889=This0.Abstract.S.#builder()
          Void unused40063=b889.#sQuote()
          b889
          ))
        rcv8.#from(seqBuilder:(
          mut This0.Abstract.S.SConcat b890=rcv8.#seqBuilder()
          Void unused40064=b890.#add(that:This0.jsEscape(that:id))
          b890
          ))
        )
      rcv7.#from(builder:(
        mut This0.Abstract.S.SBuilder b891=rcv7.#builder()
        Void unused40065=b891.#sQuote()
        b891
        ))
      )
    This0.Abstract.S qText=(
      This0.Abstract.S.Continue rcv9=(
        This0.Abstract.S rcv10=This0.Abstract.S.#from(builder:(
          mut This0.Abstract.S.SBuilder b892=This0.Abstract.S.#builder()
          Void unused40066=b892.#sQuote()
          b892
          ))
        rcv10.#from(seqBuilder:(
          mut This0.Abstract.S.SConcat b893=rcv10.#seqBuilder()
          Void unused40067=b893.#add(that:This0.jsEscape(that:that))
          b893
          ))
        )
      rcv9.#from(builder:(
        mut This0.Abstract.S.SBuilder b894=rcv9.#builder()
        Void unused40068=b894.#sQuote()
        b894
        ))
      )
    This0.Abstract.S cmd=(
      This0.Abstract.S.Continue rcv11=(
        This0.Abstract.S rcv12=(
          This0.Abstract.S.Continue rcv13=(
            This0.Abstract.S rcv14=This0.Abstract.S.#from(builder:(
              mut This0.Abstract.S.SBuilder b895=This0.Abstract.S.#builder()
              Void unused40069=b895.#v()
              Void unused40070=b895.#a()
              Void unused40071=b895.#r()
              Void unused40072=b895.#space()
              Void unused40073=b895.#o()
              Void unused40074=b895.#l()
              Void unused40075=b895.#d()
              Void unused40076=b895.#E()
              Void unused40077=b895.#l()
              Void unused40078=b895.#e()
              Void unused40079=b895.#m()
              Void unused40080=b895.#space()
              Void unused40081=b895.#equal()
              Void unused40082=b895.#space()
              Void unused40083=b895.#d()
              Void unused40084=b895.#o()
              Void unused40085=b895.#c()
              Void unused40086=b895.#u()
              Void unused40087=b895.#m()
              Void unused40088=b895.#e()
              Void unused40089=b895.#n()
              Void unused40090=b895.#t()
              Void unused40091=b895.#dot()
              Void unused40092=b895.#g()
              Void unused40093=b895.#e()
              Void unused40094=b895.#t()
              Void unused40095=b895.#E()
              Void unused40096=b895.#l()
              Void unused40097=b895.#e()
              Void unused40098=b895.#m()
              Void unused40099=b895.#e()
              Void unused40100=b895.#n()
              Void unused40101=b895.#t()
              Void unused40102=b895.#B()
              Void unused40103=b895.#y()
              Void unused40104=b895.#I()
              Void unused40105=b895.#d()
              Void unused40106=b895.#oRound()
              Void unused40107=b895.#newline()
              b895
              ))
            rcv14.#from(seqBuilder:(
              mut This0.Abstract.S.SConcat b896=rcv14.#seqBuilder()
              Void unused40108=b896.#add(that:qid)
              b896
              ))
            )
          rcv13.#from(builder:(
            mut This0.Abstract.S.SBuilder b897=rcv13.#builder()
            Void unused40109=b897.#cRound()
            Void unused40110=b897.#semicolon()
            Void unused40111=b897.#newline()
            Void unused40112=b897.#o()
            Void unused40113=b897.#l()
            Void unused40114=b897.#d()
            Void unused40115=b897.#E()
            Void unused40116=b897.#l()
            Void unused40117=b897.#e()
            Void unused40118=b897.#m()
            Void unused40119=b897.#dot()
            Void unused40120=b897.#i()
            Void unused40121=b897.#n()
            Void unused40122=b897.#n()
            Void unused40123=b897.#e()
            Void unused40124=b897.#r()
            Void unused40125=b897.#H()
            Void unused40126=b897.#T()
            Void unused40127=b897.#M()
            Void unused40128=b897.#L()
            Void unused40129=b897.#space()
            Void unused40130=b897.#equal()
            Void unused40131=b897.#newline()
            b897
            ))
          )
        rcv12.#from(seqBuilder:(
          mut This0.Abstract.S.SConcat b898=rcv12.#seqBuilder()
          Void unused40132=b898.#add(that:qText)
          b898
          ))
        )
      rcv11.#from(builder:(
        mut This0.Abstract.S.SBuilder b899=rcv11.#builder()
        Void unused40133=b899.#semicolon()
        Void unused40134=b899.#newline()
        Void unused40135=b899.#v()
        Void unused40136=b899.#a()
        Void unused40137=b899.#r()
        Void unused40138=b899.#space()
        Void unused40139=b899.#p()
        Void unused40140=b899.#a()
        Void unused40141=b899.#r()
        Void unused40142=b899.#e()
        Void unused40143=b899.#n()
        Void unused40144=b899.#t()
        Void unused40145=b899.#E()
        Void unused40146=b899.#l()
        Void unused40147=b899.#e()
        Void unused40148=b899.#m()
        Void unused40149=b899.#space()
        Void unused40150=b899.#equal()
        Void unused40151=b899.#space()
        Void unused40152=b899.#o()
        Void unused40153=b899.#l()
        Void unused40154=b899.#d()
        Void unused40155=b899.#E()
        Void unused40156=b899.#l()
        Void unused40157=b899.#e()
        Void unused40158=b899.#m()
        Void unused40159=b899.#dot()
        Void unused40160=b899.#p()
        Void unused40161=b899.#a()
        Void unused40162=b899.#r()
        Void unused40163=b899.#e()
        Void unused40164=b899.#n()
        Void unused40165=b899.#t()
        Void unused40166=b899.#N()
        Void unused40167=b899.#o()
        Void unused40168=b899.#d()
        Void unused40169=b899.#e()
        Void unused40170=b899.#semicolon()
        Void unused40171=b899.#newline()
        Void unused40172=b899.#v()
        Void unused40173=b899.#a()
        Void unused40174=b899.#r()
        Void unused40175=b899.#space()
        Void unused40176=b899.#i()
        Void unused40177=b899.#n()
        Void unused40178=b899.#n()
        Void unused40179=b899.#e()
        Void unused40180=b899.#r()
        Void unused40181=b899.#E()
        Void unused40182=b899.#l()
        Void unused40183=b899.#e()
        Void unused40184=b899.#m()
        Void unused40185=b899.#semicolon()
        Void unused40186=b899.#newline()
        Void unused40187=b899.#w()
        Void unused40188=b899.#h()
        Void unused40189=b899.#i()
        Void unused40190=b899.#l()
        Void unused40191=b899.#e()
        Void unused40192=b899.#space()
        Void unused40193=b899.#oRound()
        Void unused40194=b899.#i()
        Void unused40195=b899.#n()
        Void unused40196=b899.#n()
        Void unused40197=b899.#e()
        Void unused40198=b899.#r()
        Void unused40199=b899.#E()
        Void unused40200=b899.#l()
        Void unused40201=b899.#e()
        Void unused40202=b899.#m()
        Void unused40203=b899.#space()
        Void unused40204=b899.#equal()
        Void unused40205=b899.#space()
        Void unused40206=b899.#o()
        Void unused40207=b899.#l()
        Void unused40208=b899.#d()
        Void unused40209=b899.#E()
        Void unused40210=b899.#l()
        Void unused40211=b899.#e()
        Void unused40212=b899.#m()
        Void unused40213=b899.#dot()
        Void unused40214=b899.#f()
        Void unused40215=b899.#i()
        Void unused40216=b899.#r()
        Void unused40217=b899.#s()
        Void unused40218=b899.#t()
        Void unused40219=b899.#C()
        Void unused40220=b899.#h()
        Void unused40221=b899.#i()
        Void unused40222=b899.#l()
        Void unused40223=b899.#d()
        Void unused40224=b899.#cRound()
        Void unused40225=b899.#oCurly()
        Void unused40226=b899.#newline()
        Void unused40227=b899.#space()
        Void unused40228=b899.#space()
        Void unused40229=b899.#p()
        Void unused40230=b899.#a()
        Void unused40231=b899.#r()
        Void unused40232=b899.#e()
        Void unused40233=b899.#n()
        Void unused40234=b899.#t()
        Void unused40235=b899.#E()
        Void unused40236=b899.#l()
        Void unused40237=b899.#e()
        Void unused40238=b899.#m()
        Void unused40239=b899.#dot()
        Void unused40240=b899.#i()
        Void unused40241=b899.#n()
        Void unused40242=b899.#s()
        Void unused40243=b899.#e()
        Void unused40244=b899.#r()
        Void unused40245=b899.#t()
        Void unused40246=b899.#B()
        Void unused40247=b899.#e()
        Void unused40248=b899.#f()
        Void unused40249=b899.#o()
        Void unused40250=b899.#r()
        Void unused40251=b899.#e()
        Void unused40252=b899.#oRound()
        Void unused40253=b899.#i()
        Void unused40254=b899.#n()
        Void unused40255=b899.#n()
        Void unused40256=b899.#e()
        Void unused40257=b899.#r()
        Void unused40258=b899.#E()
        Void unused40259=b899.#l()
        Void unused40260=b899.#e()
        Void unused40261=b899.#m()
        Void unused40262=b899.#comma()
        Void unused40263=b899.#space()
        Void unused40264=b899.#o()
        Void unused40265=b899.#l()
        Void unused40266=b899.#d()
        Void unused40267=b899.#E()
        Void unused40268=b899.#l()
        Void unused40269=b899.#e()
        Void unused40270=b899.#m()
        Void unused40271=b899.#cRound()
        Void unused40272=b899.#semicolon()
        Void unused40273=b899.#newline()
        Void unused40274=b899.#space()
        Void unused40275=b899.#space()
        Void unused40276=b899.#cCurly()
        Void unused40277=b899.#newline()
        Void unused40278=b899.#p()
        Void unused40279=b899.#a()
        Void unused40280=b899.#r()
        Void unused40281=b899.#e()
        Void unused40282=b899.#n()
        Void unused40283=b899.#t()
        Void unused40284=b899.#E()
        Void unused40285=b899.#l()
        Void unused40286=b899.#e()
        Void unused40287=b899.#m()
        Void unused40288=b899.#dot()
        Void unused40289=b899.#r()
        Void unused40290=b899.#e()
        Void unused40291=b899.#m()
        Void unused40292=b899.#o()
        Void unused40293=b899.#v()
        Void unused40294=b899.#e()
        Void unused40295=b899.#C()
        Void unused40296=b899.#h()
        Void unused40297=b899.#i()
        Void unused40298=b899.#l()
        Void unused40299=b899.#d()
        Void unused40300=b899.#oRound()
        Void unused40301=b899.#o()
        Void unused40302=b899.#l()
        Void unused40303=b899.#d()
        Void unused40304=b899.#E()
        Void unused40305=b899.#l()
        Void unused40306=b899.#e()
        Void unused40307=b899.#m()
        Void unused40308=b899.#cRound()
        Void unused40309=b899.#semicolon()
        Void unused40310=b899.#newline()
        b899
        ))
      )
    This0.Abstract.S x=(//Debug(cmd)
//if x!=S"" (Debug(x))
this.executeJs(that:cmd))
    Void unused40062=return void
    void
    )
  
  catch return Void result168 result168
  
  error  {/*@stringU
CurlyBlock-Should be unreachable code
*/}
  )
mut method 
Void add(This0.Abstract.S that, This0.Abstract.S id) (
  Void unused40311=(
    This0.Abstract.S qid=(
      This0.Abstract.S.Continue rcv15=(
        This0.Abstract.S rcv16=This0.Abstract.S.#from(builder:(
          mut This0.Abstract.S.SBuilder b900=This0.Abstract.S.#builder()
          Void unused40313=b900.#sQuote()
          b900
          ))
        rcv16.#from(seqBuilder:(
          mut This0.Abstract.S.SConcat b901=rcv16.#seqBuilder()
          Void unused40314=b901.#add(that:This0.jsEscape(that:id))
          b901
          ))
        )
      rcv15.#from(builder:(
        mut This0.Abstract.S.SBuilder b902=rcv15.#builder()
        Void unused40315=b902.#sQuote()
        b902
        ))
      )
    This0.Abstract.S qText=(
      This0.Abstract.S.Continue rcv17=(
        This0.Abstract.S rcv18=This0.Abstract.S.#from(builder:(
          mut This0.Abstract.S.SBuilder b903=This0.Abstract.S.#builder()
          Void unused40316=b903.#sQuote()
          b903
          ))
        rcv18.#from(seqBuilder:(
          mut This0.Abstract.S.SConcat b904=rcv18.#seqBuilder()
          Void unused40317=b904.#add(that:This0.jsEscape(that:that))
          b904
          ))
        )
      rcv17.#from(builder:(
        mut This0.Abstract.S.SBuilder b905=rcv17.#builder()
        Void unused40318=b905.#sQuote()
        b905
        ))
      )
    This0.Abstract.S cmd=(
      This0.Abstract.S.Continue rcv19=(
        This0.Abstract.S rcv20=(
          This0.Abstract.S.Continue rcv21=(
            This0.Abstract.S rcv22=This0.Abstract.S.#from(builder:(
              mut This0.Abstract.S.SBuilder b906=This0.Abstract.S.#builder()
              Void unused40319=b906.#v()
              Void unused40320=b906.#a()
              Void unused40321=b906.#r()
              Void unused40322=b906.#space()
              Void unused40323=b906.#t()
              Void unused40324=b906.#e()
              Void unused40325=b906.#m()
              Void unused40326=b906.#p()
              Void unused40327=b906.#l()
              Void unused40328=b906.#a()
              Void unused40329=b906.#t()
              Void unused40330=b906.#e()
              Void unused40331=b906.#space()
              Void unused40332=b906.#equal()
              Void unused40333=b906.#space()
              Void unused40334=b906.#d()
              Void unused40335=b906.#o()
              Void unused40336=b906.#c()
              Void unused40337=b906.#u()
              Void unused40338=b906.#m()
              Void unused40339=b906.#e()
              Void unused40340=b906.#n()
              Void unused40341=b906.#t()
              Void unused40342=b906.#dot()
              Void unused40343=b906.#c()
              Void unused40344=b906.#r()
              Void unused40345=b906.#e()
              Void unused40346=b906.#a()
              Void unused40347=b906.#t()
              Void unused40348=b906.#e()
              Void unused40349=b906.#E()
              Void unused40350=b906.#l()
              Void unused40351=b906.#e()
              Void unused40352=b906.#m()
              Void unused40353=b906.#e()
              Void unused40354=b906.#n()
              Void unused40355=b906.#t()
              Void unused40356=b906.#oRound()
              Void unused40357=b906.#sQuote()
              Void unused40358=b906.#d()
              Void unused40359=b906.#i()
              Void unused40360=b906.#v()
              Void unused40361=b906.#sQuote()
              Void unused40362=b906.#cRound()
              Void unused40363=b906.#semicolon()
              Void unused40364=b906.#newline()
              Void unused40365=b906.#t()
              Void unused40366=b906.#e()
              Void unused40367=b906.#m()
              Void unused40368=b906.#p()
              Void unused40369=b906.#l()
              Void unused40370=b906.#a()
              Void unused40371=b906.#t()
              Void unused40372=b906.#e()
              Void unused40373=b906.#dot()
              Void unused40374=b906.#i()
              Void unused40375=b906.#n()
              Void unused40376=b906.#n()
              Void unused40377=b906.#e()
              Void unused40378=b906.#r()
              Void unused40379=b906.#H()
              Void unused40380=b906.#T()
              Void unused40381=b906.#M()
              Void unused40382=b906.#L()
              Void unused40383=b906.#space()
              Void unused40384=b906.#equal()
              Void unused40385=b906.#newline()
              b906
              ))
            rcv22.#from(seqBuilder:(
              mut This0.Abstract.S.SConcat b907=rcv22.#seqBuilder()
              Void unused40386=b907.#add(that:qText)
              b907
              ))
            )
          rcv21.#from(builder:(
            mut This0.Abstract.S.SBuilder b908=rcv21.#builder()
            Void unused40387=b908.#semicolon()
            Void unused40388=b908.#newline()
            Void unused40389=b908.#d()
            Void unused40390=b908.#o()
            Void unused40391=b908.#c()
            Void unused40392=b908.#u()
            Void unused40393=b908.#m()
            Void unused40394=b908.#e()
            Void unused40395=b908.#n()
            Void unused40396=b908.#t()
            Void unused40397=b908.#dot()
            Void unused40398=b908.#g()
            Void unused40399=b908.#e()
            Void unused40400=b908.#t()
            Void unused40401=b908.#E()
            Void unused40402=b908.#l()
            Void unused40403=b908.#e()
            Void unused40404=b908.#m()
            Void unused40405=b908.#e()
            Void unused40406=b908.#n()
            Void unused40407=b908.#t()
            Void unused40408=b908.#B()
            Void unused40409=b908.#y()
            Void unused40410=b908.#I()
            Void unused40411=b908.#d()
            Void unused40412=b908.#oRound()
            Void unused40413=b908.#newline()
            b908
            ))
          )
        rcv20.#from(seqBuilder:(
          mut This0.Abstract.S.SConcat b909=rcv20.#seqBuilder()
          Void unused40414=b909.#add(that:qid)
          b909
          ))
        )
      rcv19.#from(builder:(
        mut This0.Abstract.S.SBuilder b910=rcv19.#builder()
        Void unused40415=b910.#cRound()
        Void unused40416=b910.#dot()
        Void unused40417=b910.#a()
        Void unused40418=b910.#p()
        Void unused40419=b910.#p()
        Void unused40420=b910.#e()
        Void unused40421=b910.#n()
        Void unused40422=b910.#d()
        Void unused40423=b910.#C()
        Void unused40424=b910.#h()
        Void unused40425=b910.#i()
        Void unused40426=b910.#l()
        Void unused40427=b910.#d()
        Void unused40428=b910.#oRound()
        Void unused40429=b910.#t()
        Void unused40430=b910.#e()
        Void unused40431=b910.#m()
        Void unused40432=b910.#p()
        Void unused40433=b910.#l()
        Void unused40434=b910.#a()
        Void unused40435=b910.#t()
        Void unused40436=b910.#e()
        Void unused40437=b910.#dot()
        Void unused40438=b910.#f()
        Void unused40439=b910.#i()
        Void unused40440=b910.#r()
        Void unused40441=b910.#s()
        Void unused40442=b910.#t()
        Void unused40443=b910.#C()
        Void unused40444=b910.#h()
        Void unused40445=b910.#i()
        Void unused40446=b910.#l()
        Void unused40447=b910.#d()
        Void unused40448=b910.#cRound()
        Void unused40449=b910.#semicolon()
        Void unused40450=b910.#newline()
        b910
        ))
      )
    This0.Abstract.S x=(//Debug(cmd)
//if x!=S"" (Debug(x))
this.executeJs(that:cmd))
    Void unused40312=return void
    void
    )
  
  catch return Void result169 result169
  
  error  {/*@stringU
CurlyBlock-Should be unreachable code
*/}
  )
mut method 
This0.Abstract.S executeJs(This0.Abstract.S that) This0.Abstract.S.#from(binaryRepr:use This0.GuiPlugin check executeJs(wName:this.id().#binaryRepr(), command:that.#binaryRepr()) error void)
mut method 
mut This0.Iterator events() This0.Iterator.#$(id:this.id(), current:This0.Abstract.S.#from(builder:(
  mut This0.Abstract.S.SBuilder b911=This0.Abstract.S.#builder()
  b911
  )))
class method 
mut This0 #$(fwd This0.Abstract.S id) 
Abstract: {
Alu: {/*@plugin
L42.is/connected/withAlu
*/}
ExitCode: {
class method /*To signal normal program completion
*/Library normal() 
class method /*To signal a failure in program completion
*/Library failure() }
Bool: {implements This1.Concept.Base, This1.Concept.ToS, This1.Concept.Classable, This1.Concept.Equals
read method 
Library _binaryRepr() 
class method 
mut This0 #apply(Library _binaryRepr) 
read method 
This0 clone() 
read method 
Library #binaryRepr() 
class method 
mut This0 #from(Library binaryRepr) 
refine class method 
read This0 cast(read This1.Concept.Classable that) 
refine class method 
mut This0 #cast(mut This1.Concept.Classable that) 
refine class method /*
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  */This0 is(class This1.Concept.Classable subtype) 
refine read method 
class This0 class() 
refine class method /*
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  */This1.S readableName() 
refine read method 
This1.S toS() 
refine read method 
This0 #equalequal#0left(read Any right) 
read method 
Void #checkTrue() exception Void 
class method 
This0 true() 
class method 
This0 false() 
method 
This0 #and#0left(This0 right) 
method 
This0 #or#0left(This0 right) 
method 
This0 #bang() 
read method 
This0 equals(read This0 that) 
class method 
This0 fromS(read This1.Concept.ToS that) 
class method 
Any parseError(This1.S that) 
ParseFail: {implements This2.Guard.ParseFail, This2.Guard, This2.Message, This2.Concept.Base, This2.Concept.ToS, This2.Concept.Classable, This2.Concept.Equals
refine read method 
class This0 class() 
refine class method /*
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  */This2.S readableName() 
refine class method /*
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  */This1 is(class This2.Concept.Classable subtype) 
refine read method 
This1 #equalequal#0left(read Any right) 
refine class method 
read This0 cast(read This2.Concept.Classable that) 
refine class method 
mut This0 #cast(mut This2.Concept.Classable that) 
read method 
This2.S _text() 
read method 
This2.Message.Opt cause() 
class method 
This0 #apply(This2.S _text, This2.Message.Opt cause) 
refine class method 
This2.S kind() 
refine read method 
This2.S text() 
refine read method 
This2.Message.Opt responseOf() 
method 
This0 #apply(This2.Message that) 
refine read method 
This2.S toS() 
read method 
This1 equals(read This0 that) 
class method 
This0 #apply(This2.S text) 
class method 
This0 #apply(This2.S text, This2.Message cause) 
class method 
mut This2.S.SBuilder #builder() 
class method 
This0 #from(This2.S.SBuilder builder) 
method 
This0.Continue #from(This2.S.SConcat seqBuilder) 
method 
mut This2.S.SConcat #seqBuilder() 
Continue: {
read method 
This3.S that() 
class method 
This0 #apply(This3.S that) 
method 
mut This3.S.SBuilder #builder() 
method 
This1 #from(This3.S.SBuilder builder) }}}
Size: {implements This1.Concept.ToS, This1.Concept.Equals, This1.Concept.Classable/*@_private
*/
class method 
mut This0 _private(Library _binaryRepr) 
read method 
Library _binaryRepr() 
refine class method 
read This0 cast(read This1.Concept.Classable that) 
refine class method 
mut This0 #cast(mut This1.Concept.Classable that) 
refine class method /*
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  */This1.Bool is(class This1.Concept.Classable subtype) 
refine read method 
class This0 class() 
refine class method /*
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  */This1.S readableName() 
class method 
This0 fromS(This1.Concept.ToS that) 
class method 
mut This0 #from(Library binaryRepr) 
read method 
Library #binaryRepr() 
class method 
mut This1.S.SBuilder #builder() 
class method 
This0 #from(This1.S.SBuilder builder) 
refine read method 
This1.S toS() 
method 
This0 #plus#0left(This0 right) 
method 
This0 #less#0left(This0 right) 
method 
This0 #times#0left(This0 right) 
method 
This0 #divide#0left(This0 right) 
read method 
This1.Bool equals(read This0 that) 
refine read method 
This1.Bool #equalequal#0left(read Any right) 
method 
This1.Bool #right#0left(This0 right) 
method 
This1.Bool #rightequal#0left(This0 right) 
method 
mut This0.Iterator vals() 
method 
mut This0.Iterator vals(This0 upTo) 
class method 
This0 #0() 
class method 
This0 #1() 
class method 
This0 #2() 
class method 
This0 #3() 
class method 
This0 #4() 
class method 
This0 #5() 
class method 
This0 #6() 
class method 
This0 #7() 
class method 
This0 #8() 
class method 
This0 #9() 
class method 
This0 #10() 
class method 
This0 #11() 
class method 
This0 #12() 
class method 
This0 #13() 
class method 
This0 #14() 
class method 
This0 #15() 
class method 
This0 #16() 
class method 
This0 #17() 
class method 
This0 #18() 
class method 
This0 #19() 
class method 
This0 #20() 
class method 
This0 #21() 
class method 
This0 #22() 
class method 
This0 #23() 
class method 
This0 #24() 
class method 
This0 #25() 
class method 
This0 #26() 
class method 
This0 #27() 
class method 
This0 #28() 
class method 
This0 #29() 
class method 
This0 #30() 
class method 
This0 #31() 
class method 
This0 #32() 
class method 
This0 #33() 
class method 
This0 #34() 
class method 
This0 #35() 
class method 
This0 #36() 
class method 
This0 #37() 
class method 
This0 #38() 
class method 
This0 #39() 
class method 
This0 #40() 
class method 
This0 #41() 
class method 
This0 #42() 
class method 
This0 #43() 
class method 
This0 #44() 
class method 
This0 #45() 
class method 
This0 #46() 
class method 
This0 #47() 
class method 
This0 #48() 
class method 
This0 #49() 
class method 
This0 #50() 
class method 
This0 #51() 
class method 
This0 #52() 
class method 
This0 #53() 
class method 
This0 #54() 
class method 
This0 #55() 
class method 
This0 #56() 
class method 
This0 #57() 
class method 
This0 #58() 
class method 
This0 #59() 
class method 
This0 #60() 
class method 
This0 #61() 
class method 
This0 #62() 
class method 
This0 #63() 
class method 
Any parseError(This1.S that) 
Iterator: {
mut method 
Void start(This1 that) 
read method 
This1 start() 
read method 
This1 end() 
class method 
mut This0 #apply(This1 start, This1 end) 
mut method 
Void #next() exception Void 
read method 
Void #checkEnd() 
read method 
This1 #inner() 
read method 
Void #close() }
ParseFail: {implements This2.Guard.ParseFail, This2.Guard, This2.Message, This2.Concept.Base, This2.Concept.ToS, This2.Concept.Classable, This2.Concept.Equals
refine read method 
class This0 class() 
refine class method /*
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  */This2.S readableName() 
refine class method /*
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  */This2.Bool is(class This2.Concept.Classable subtype) 
refine read method 
This2.Bool #equalequal#0left(read Any right) 
refine class method 
read This0 cast(read This2.Concept.Classable that) 
refine class method 
mut This0 #cast(mut This2.Concept.Classable that) 
read method 
This2.S _text() 
read method 
This2.Message.Opt cause() 
class method 
This0 #apply(This2.S _text, This2.Message.Opt cause) 
refine class method 
This2.S kind() 
refine read method 
This2.S text() 
refine read method 
This2.Message.Opt responseOf() 
method 
This0 #apply(This2.Message that) 
refine read method 
This2.S toS() 
read method 
This2.Bool equals(read This0 that) 
class method 
This0 #apply(This2.S text) 
class method 
This0 #apply(This2.S text, This2.Message cause) 
class method 
mut This2.S.SBuilder #builder() 
class method 
This0 #from(This2.S.SBuilder builder) 
method 
This0.Continue #from(This2.S.SConcat seqBuilder) 
method 
mut This2.S.SConcat #seqBuilder() 
Continue: {
read method 
This3.S that() 
class method 
This0 #apply(This3.S that) 
method 
mut This3.S.SBuilder #builder() 
method 
This1 #from(This3.S.SBuilder builder) }}}
Num: {implements This1.Concept.Base, This1.Concept.ToS, This1.Concept.Classable, This1.Concept.Equals
refine class method /*
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  */This1.S readableName() 
refine class method /*
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  */This1.Bool is(class This1.Concept.Classable subtype) 
refine read method 
This1.Bool #equalequal#0left(read Any right) 
refine read method 
class This0 class() 
refine class method 
read This0 cast(read This1.Concept.Classable that) 
refine class method 
mut This0 #cast(mut This1.Concept.Classable that) 
class method 
mut This0 _private(Library _binaryRepr) 
read method 
Library _binaryRepr() 
class method 
This0 fromS(This1.Concept.ToS that) 
class method 
This0 #from(Library binaryRepr) 
read method 
Library #binaryRepr() 
class method 
mut This1.S.SBuilder #builder() 
class method 
This0 #from(This1.S.SBuilder builder) 
class method 
Any parseError(This1.S that) 
refine read method 
This1.S toS() 
method 
This0 #plus#0left(This0 right) 
method 
This0 #less#0left(This0 right) 
method 
This0 #times#0left(This0 right) 
method 
This0 #divide#0left(This0 right) 
read method 
This1.Bool equals(read This0 that) 
method 
This1.Bool #right#0left(This0 right) 
method 
This1.Bool #rightequal#0left(This0 right) 
Plg: {/*@plugin
L42.is/connected/withNumbers
*/}
ParseFail: {implements This2.Guard.ParseFail, This2.Guard, This2.Message, This2.Concept.Base, This2.Concept.ToS, This2.Concept.Classable, This2.Concept.Equals
refine read method 
class This0 class() 
refine class method /*
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  */This2.S readableName() 
refine class method /*
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  */This2.Bool is(class This2.Concept.Classable subtype) 
refine read method 
This2.Bool #equalequal#0left(read Any right) 
refine class method 
read This0 cast(read This2.Concept.Classable that) 
refine class method 
mut This0 #cast(mut This2.Concept.Classable that) 
read method 
This2.S _text() 
read method 
This2.Message.Opt cause() 
class method 
This0 #apply(This2.S _text, This2.Message.Opt cause) 
refine class method 
This2.S kind() 
refine read method 
This2.S text() 
refine read method 
This2.Message.Opt responseOf() 
method 
This0 #apply(This2.Message that) 
refine read method 
This2.S toS() 
read method 
This2.Bool equals(read This0 that) 
class method 
This0 #apply(This2.S text) 
class method 
This0 #apply(This2.S text, This2.Message cause) 
class method 
mut This2.S.SBuilder #builder() 
class method 
This0 #from(This2.S.SBuilder builder) 
method 
This0.Continue #from(This2.S.SConcat seqBuilder) 
method 
mut This2.S.SConcat #seqBuilder() 
Continue: {
read method 
This3.S that() 
class method 
This0 #apply(This3.S that) 
method 
mut This3.S.SBuilder #builder() 
method 
This1 #from(This3.S.SBuilder builder) }}}
S: {implements This1.Concept.Base/*, Concept.Equals //needed until we do (also refine) normalization
*/, This1.Concept.ToS, This1.Concept.Classable, This1.Concept.Equals, This1.Concept.ToS
class method 
mut This0 _private(Library _binaryRepr) 
read method 
Library _binaryRepr() 
read method 
This0 clone() 
refine class method 
read This0 cast(read This1.Concept.Classable that) 
refine class method 
mut This0 #cast(mut This1.Concept.Classable that) 
refine class method /*
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  */This1.Bool is(class This1.Concept.Classable subtype) 
refine read method 
class This0 class() 
refine class method /*
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  */This0 readableName() 
class method 
mut This0 #from(Library binaryRepr) 
read method 
Library #binaryRepr() 
refine read method 
This1.Bool #equalequal#0left(read Any right) 
method 
This0 #plusplus#0left(This0 right) 
read method 
This1.Bool equals(read This0 that) 
method 
This0 #less#0left(This0 right) 
method 
This1.Bool #rightright#0left(This0 right) 
method 
This1.Bool #rightrightequal#0left(This0 right) 
method 
This1.Bool #right#0left(This0 right) 
method 
This1.Size indexOfLeft(This0 val) 
method 
This1.Size indexOfLeft(This0 val, This1.Size start) 
method 
This1.Size indexOfRight(This0 val) 
method 
This0 withoutLeft(This0 val) 
method 
This0 withoutRight(This0 val) 
method 
This0 withoutAll(This0 val) 
method 
This1.Bool isEmpty() 
method 
This0 val(This1.Size that) 
method 
This1.Size #default#val(Void that) 
method 
This0 left() 
method 
This0 right() 
method 
This0 with(This1.Size that, This0 val) 
method 
This1.Size #default#with(Void that) 
method 
This0 withLeft(This0 that) 
method 
This0 withRight(This0 that) 
method 
This0 withAlso(This1.Size that, This0 val) 
method 
This1.Size #default#withAlso(Void that) 
method 
This0 withAlsoLeft(This0 that) 
method 
This0 withAlsoRight(This0 that) 
method 
This0 without(This1.Size index) 
method 
This1.Size #default#without(Void index) 
method 
This0 without(This1.Size index, This1.Size skipNum) 
method 
This0 withoutLeft() 
method 
This0 withoutRight() 
method 
This1.Bool contains(This0 that) 
method 
This0 #apply(This1.Size start, This1.Size end) 
method 
This0 #apply(This1.Size that) 
method 
This0 #apply(This1.Size start) 
method 
This0 #apply(This1.Size end) 
method 
This1.Size #default##apply(Void that) 
method 
This1.Size #default##apply(Void end) 
method 
This1.Size #default##apply(Void start) 
method 
This1.Size size() 
method 
This1.Bool subStrEq(This0 that, This1.Size start) 
method 
This1.Bool beginsWith(This0 that) 
class method 
This0 aSCIILowerCase() 
class method 
This0 aSCIIUpperCase() 
method 
This1.Bool isASCIILowerCase(This1.Size that) 
method 
This1.Bool isASCIIUpperCase(This1.Size that) 
class method 
This0 doubleQuote() 
class method 
This0 nl() 
method 
This0 replace(This0 that, This0 into) 
method 
This0 as42MultilineString() 
method 
This0.Continue #from(This0.SConcat seqBuilder) 
method 
mut This0.SConcat #seqBuilder() 
class method 
This0 #from(This0.SBuilder builder) 
class method 
mut This0.SBuilder #builder() 
refine read method 
This0 toS() 
method 
This1.Strings splitOn(This0 chars) 
Continue: {
read method 
This1 that() 
class method 
This0 #apply(This1 that) 
method 
mut This1.SBuilder #builder() 
method 
This1 #from(This1.SBuilder builder) }
SConcat: {
read method 
This1 old() 
mut method 
Void accumulator(This1 that) 
read method 
This1 accumulator() 
class method 
mut This0 #apply(This1 old, This1 accumulator) 
mut method 
Void #add(read This2.Concept.ToS that) 
mut method 
Void #add(read This2.Concept.ToS that, This2.Concept.ToS sep) }
SBuilder: {
mut method 
Void _binaryRepr(Library that) 
read method 
Library _binaryRepr() 
class method 
mut This0 _private(Library _binaryRepr) 
read method 
Library #binaryRepr() 
mut method 
Void acc(Library that) 
class method 
mut This0 empty() 
mut method 
Void #0() 
mut method 
Void #1() 
mut method 
Void #2() 
mut method 
Void #3() 
mut method 
Void #4() 
mut method 
Void #5() 
mut method 
Void #6() 
mut method 
Void #7() 
mut method 
Void #8() 
mut method 
Void #9() 
mut method 
Void #q() 
mut method 
Void #w() 
mut method 
Void #e() 
mut method 
Void #r() 
mut method 
Void #t() 
mut method 
Void #y() 
mut method 
Void #u() 
mut method 
Void #i() 
mut method 
Void #o() 
mut method 
Void #p() 
mut method 
Void #a() 
mut method 
Void #s() 
mut method 
Void #d() 
mut method 
Void #f() 
mut method 
Void #g() 
mut method 
Void #h() 
mut method 
Void #j() 
mut method 
Void #k() 
mut method 
Void #l() 
mut method 
Void #z() 
mut method 
Void #x() 
mut method 
Void #c() 
mut method 
Void #v() 
mut method 
Void #b() 
mut method 
Void #n() 
mut method 
Void #m() 
mut method 
Void #Q() 
mut method 
Void #W() 
mut method 
Void #E() 
mut method 
Void #R() 
mut method 
Void #T() 
mut method 
Void #Y() 
mut method 
Void #U() 
mut method 
Void #I() 
mut method 
Void #O() 
mut method 
Void #P() 
mut method 
Void #A() 
mut method 
Void #S() 
mut method 
Void #D() 
mut method 
Void #F() 
mut method 
Void #G() 
mut method 
Void #H() 
mut method 
Void #J() 
mut method 
Void #K() 
mut method 
Void #L() 
mut method 
Void #Z() 
mut method 
Void #X() 
mut method 
Void #C() 
mut method 
Void #V() 
mut method 
Void #B() 
mut method 
Void #N() 
mut method 
Void #M() 
mut method 
Void #%() 
mut method 
Void #left() 
mut method 
Void #right() 
mut method 
Void #bang() 
mut method 
Void #tilde() 
mut method 
Void #plus() 
mut method 
Void #times() 
mut method 
Void #divide() 
mut method 
Void #less() 
mut method 
Void #and() 
mut method 
Void #or() 
mut method 
Void #oRound() 
mut method 
Void #cRound() 
mut method 
Void #oSquare() 
mut method 
Void #cSquare() 
mut method 
Void #oCurly() 
mut method 
Void #cCurly() 
mut method 
Void #dQuote() 
mut method 
Void #sQuote() 
mut method 
Void #hQuote() 
mut method 
Void #equal() 
mut method 
Void #qMark() 
mut method 
Void #hat() 
mut method 
Void #comma() 
mut method 
Void #semicolon() 
mut method 
Void #colon() 
mut method 
Void #dot() 
mut method 
Void #underscore() 
mut method 
Void #hash() 
mut method 
Void #at() 
mut method 
Void #backslash() 
mut method 
Void #dollar() 
mut method 
Void #space() 
mut method 
Void #newline() }
U: {
class method 
mut This1.SBuilder #builder() 
class method 
This1 #from(This1.SBuilder builder) }}
Concept: {
ToS: {interface 
read method 
This2.S toS() }
Classable: {interface 
class method /*
  Cast a (read/imm) object to this type.
  A class implementing this method should refine the return type to This.
  if is(subtype) is true, then cast(that) must produce a result.
  */read This0 cast(read This0 that) 
class method /*
  Cast a (mutable) object to this type.
  A class implementing this method should refine the return type to This.
  if cast(that) produces a result, then #cast(that) also must produce a result.
  */mut This0 #cast(mut This0 that) 
read method /*
  Extracts the class singleton from another instance of this class
  */class This0 class() 
class method /*
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  */This2.S readableName() 
class method /*
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  */This2.Bool is(class This0 subtype) }
Base: {interface implements This1.ToS, This1.Classable, This1.Equals
refine read method 
This2.S toS() 
refine class method /*
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  */This2.S readableName() 
refine class method /*
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  */This2.Bool is(class This1.Classable subtype) 
refine read method 
This2.Bool #equalequal#0left(read Any right) 
refine read method 
class This0 class() 
refine class method 
read This0 cast(read This1.Classable that) 
refine class method 
mut This0 #cast(mut This1.Classable that) }
Wrapper: {interface 
read method 
Any inner() }
ClassWrapper: {interface 
read method 
class Any inner() }
MutWrapper: {interface 
read method 
read Any inner() 
mut method 
mut Any #inner() }
Equals: {interface 
read method 
This2.Bool #equalequal#0left(read Any right) }
Comparable: {interface 
read method 
This2.Bool greater(read Any that) }
Boollable: {interface 
read method 
Void #checkTrue() exception Void }
Decorator: {interface }
Contains: {interface 
read method 
This2.Bool contains(read Any that) }
Parsable: {interface }
RandomAccess: {interface 
read method 
read Any get(This2.Size that) 
mut method 
mut Any #get(This2.Size that) }
Sizable: {interface 
read method 
This2.Size size() 
read method 
This2.Bool isEmpty() }
Iterator: {interface 
mut method 
Void #next() exception Void 
read method 
Void #checkEnd() 
read method 
Void #close() }}
Message: {interface implements This1.Concept.Base, This1.Concept.ToS, This1.Concept.Classable, This1.Concept.Equals
refine read method 
This1.S toS() 
refine class method /*
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  */This1.S readableName() 
refine class method /*
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  */This1.Bool is(class This1.Concept.Classable subtype) 
refine read method 
This1.Bool #equalequal#0left(read Any right) 
refine class method 
read This1.Concept.Base cast(read This1.Concept.Classable that) 
refine class method 
mut This1.Concept.Base #cast(mut This1.Concept.Classable that) 
class method 
This1.S kind() 
read method 
This1.S text() 
read method 
This0.Opt responseOf() 
refine read method 
class This0 class() 
EqualMessages: {
class method 
This2.Bool #apply(read This1 that, read This1 other) }
$: {
class method 
This0 #apply() 
class method 
Library #leftrightleft#0left(Library right) 
class method 
Library messageTrait() }
Opt: {/*will be Fixed in AdamTowel02
*/
method 
This0.TOpt that() 
class method 
This0 #new(This0.TOpt that) 
method 
This1 get() exception This2.Guard.Operation 
method 
This1 #get() 
method 
This2.Bool isPresent() 
class method 
This0 #apply() 
class method 
This0 #apply(This1 that) 
TOpt: {interface 
method 
This2 get() }
TEmpty: {implements This1.TOpt
class method 
This0 #apply() 
refine method 
This2 get() }
TOf: {implements This1.TOpt
method 
This2 that() 
class method 
This0 #apply(This2 that) 
refine method 
This2 get() }}}
Guard: {/* exception as Guard bureocracy, error as Guard detection
-is a check guarenteed to be performed, program logic can rely on this being enforced.
  as exceptions, Guards objects are a way to report/guard complex operations,
 where checking the shape of the input can be unconvenient.
as errors, they represent precondition violations.
Turning an exception Guard into an error Guard
 is equivalent of declaring that such misuse should not happen (blame on the caller),
 still, there is no bug in the program at this stage. Is legit for the caller to try and be blamed
*/interface implements This1.Message, This1.Concept.Base, This1.Concept.ToS, This1.Concept.Classable, This1.Concept.Equals
refine read method 
This1.S toS() 
refine class method /*
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  */This1.S readableName() 
refine class method /*
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  */This1.Bool is(class This1.Concept.Classable subtype) 
refine read method 
This1.Bool #equalequal#0left(read Any right) 
refine class method 
read This1.Concept.Base cast(read This1.Concept.Classable that) 
refine class method 
mut This1.Concept.Base #cast(mut This1.Concept.Classable that) 
refine class method 
This1.S kind() 
refine read method 
This1.S text() 
refine read method 
This1.Message.Opt responseOf() 
refine read method 
class This1.Message class() 
Operation: {implements This1, This2.Message, This2.Concept.Base, This2.Concept.ToS, This2.Concept.Classable, This2.Concept.Equals
refine read method 
class This0 class() 
refine class method /*
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  */This2.S readableName() 
refine class method /*
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  */This2.Bool is(class This2.Concept.Classable subtype) 
refine read method 
This2.Bool #equalequal#0left(read Any right) 
refine class method 
read This0 cast(read This2.Concept.Classable that) 
refine class method 
mut This0 #cast(mut This2.Concept.Classable that) 
read method 
This2.S _text() 
read method 
This2.Message.Opt cause() 
class method 
This0 #apply(This2.S _text, This2.Message.Opt cause) 
refine class method 
This2.S kind() 
refine read method 
This2.S text() 
refine read method 
This2.Message.Opt responseOf() 
method 
This0 #apply(This2.Message that) 
refine read method 
This2.S toS() 
read method 
This2.Bool equals(read This0 that) 
class method 
This0 #apply(This2.S text) 
class method 
This0 #apply(This2.S text, This2.Message cause) 
class method 
mut This2.S.SBuilder #builder() 
class method 
This0 #from(This2.S.SBuilder builder) 
method 
This0.Continue #from(This2.S.SConcat seqBuilder) 
method 
mut This2.S.SConcat #seqBuilder() 
Continue: {
read method 
This3.S that() 
class method 
This0 #apply(This3.S that) 
method 
mut This3.S.SBuilder #builder() 
method 
This1 #from(This3.S.SBuilder builder) }}
Parameter: {implements This1, This2.Message, This2.Concept.Base, This2.Concept.ToS, This2.Concept.Classable, This2.Concept.Equals
refine read method 
class This0 class() 
refine class method /*
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  */This2.S readableName() 
refine class method /*
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  */This2.Bool is(class This2.Concept.Classable subtype) 
refine read method 
This2.Bool #equalequal#0left(read Any right) 
refine class method 
read This0 cast(read This2.Concept.Classable that) 
refine class method 
mut This0 #cast(mut This2.Concept.Classable that) 
read method 
This2.S _text() 
read method 
This2.Message.Opt cause() 
class method 
This0 #apply(This2.S _text, This2.Message.Opt cause) 
refine class method 
This2.S kind() 
refine read method 
This2.S text() 
refine read method 
This2.Message.Opt responseOf() 
method 
This0 #apply(This2.Message that) 
refine read method 
This2.S toS() 
read method 
This2.Bool equals(read This0 that) 
class method 
This0 #apply(This2.S text) 
class method 
This0 #apply(This2.S text, This2.Message cause) 
class method 
mut This2.S.SBuilder #builder() 
class method 
This0 #from(This2.S.SBuilder builder) 
method 
This0.Continue #from(This2.S.SConcat seqBuilder) 
method 
mut This2.S.SConcat #seqBuilder() 
Continue: {
read method 
This3.S that() 
class method 
This0 #apply(This3.S that) 
method 
mut This3.S.SBuilder #builder() 
method 
This1 #from(This3.S.SBuilder builder) }}
Precondition: {implements This1, This2.Message, This2.Concept.Base, This2.Concept.ToS, This2.Concept.Classable, This2.Concept.Equals
refine read method 
class This0 class() 
refine class method /*
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  */This2.S readableName() 
refine class method /*
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  */This2.Bool is(class This2.Concept.Classable subtype) 
refine read method 
This2.Bool #equalequal#0left(read Any right) 
refine class method 
read This0 cast(read This2.Concept.Classable that) 
refine class method 
mut This0 #cast(mut This2.Concept.Classable that) 
read method 
This2.S _text() 
read method 
This2.Message.Opt cause() 
class method 
This0 #apply(This2.S _text, This2.Message.Opt cause) 
refine class method 
This2.S kind() 
refine read method 
This2.S text() 
refine read method 
This2.Message.Opt responseOf() 
method 
This0 #apply(This2.Message that) 
refine read method 
This2.S toS() 
read method 
This2.Bool equals(read This0 that) 
class method 
This0 #apply(This2.S text) 
class method 
This0 #apply(This2.S text, This2.Message cause) 
class method 
mut This2.S.SBuilder #builder() 
class method 
This0 #from(This2.S.SBuilder builder) 
method 
This0.Continue #from(This2.S.SConcat seqBuilder) 
method 
mut This2.S.SConcat #seqBuilder() 
Continue: {
read method 
This3.S that() 
class method 
This0 #apply(This3.S that) 
method 
mut This3.S.SBuilder #builder() 
method 
This1 #from(This3.S.SBuilder builder) }}
ParseFail: {interface implements This1, This2.Message, This2.Concept.Base, This2.Concept.ToS, This2.Concept.Classable, This2.Concept.Equals
refine read method 
This2.S toS() 
refine class method /*
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  */This2.S readableName() 
refine class method /*
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  */This2.Bool is(class This2.Concept.Classable subtype) 
refine read method 
This2.Bool #equalequal#0left(read Any right) 
refine class method 
read This2.Concept.Base cast(read This2.Concept.Classable that) 
refine class method 
mut This2.Concept.Base #cast(mut This2.Concept.Classable that) 
refine class method 
This2.S kind() 
refine read method 
This2.S text() 
refine read method 
This2.Message.Opt responseOf() 
refine read method 
class This2.Message class() }
CastFail: {implements This1, This2.Message, This2.Concept.Base, This2.Concept.ToS, This2.Concept.Classable, This2.Concept.Equals
refine read method 
class This0 class() 
refine class method /*
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  */This2.S readableName() 
refine class method /*
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  */This2.Bool is(class This2.Concept.Classable subtype) 
refine read method 
This2.Bool #equalequal#0left(read Any right) 
refine class method 
read This0 cast(read This2.Concept.Classable that) 
refine class method 
mut This0 #cast(mut This2.Concept.Classable that) 
read method 
This2.S _text() 
read method 
This2.Message.Opt cause() 
class method 
This0 #apply(This2.S _text, This2.Message.Opt cause) 
refine class method 
This2.S kind() 
refine read method 
This2.S text() 
refine read method 
This2.Message.Opt responseOf() 
method 
This0 #apply(This2.Message that) 
refine read method 
This2.S toS() 
read method 
This2.Bool equals(read This0 that) 
class method 
This0 #apply(This2.S text) 
class method 
This0 #apply(This2.S text, This2.Message cause) 
class method 
mut This2.S.SBuilder #builder() 
class method 
This0 #from(This2.S.SBuilder builder) 
method 
This0.Continue #from(This2.S.SConcat seqBuilder) 
method 
mut This2.S.SConcat #seqBuilder() 
Continue: {
read method 
This3.S that() 
class method 
This0 #apply(This3.S that) 
method 
mut This3.S.SBuilder #builder() 
method 
This1 #from(This3.S.SBuilder builder) }}}
System: {
Guard: {/* implements Outer.Guard soon (remove "interface" for a bad translation bug: This1_System_Guard is not abstract and does not override abstract method MtoS()
*/interface implements This2.Guard, This2.Message, This2.Concept.Base, This2.Concept.ToS, This2.Concept.Classable, This2.Concept.Equals
refine read method 
This2.S toS() 
refine class method /*
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  */This2.S readableName() 
refine class method /*
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  */This2.Bool is(class This2.Concept.Classable subtype) 
refine read method 
This2.Bool #equalequal#0left(read Any right) 
refine class method 
read This2.Concept.Base cast(read This2.Concept.Classable that) 
refine class method 
mut This2.Concept.Base #cast(mut This2.Concept.Classable that) 
refine class method 
This2.S kind() 
refine read method 
This2.S text() 
refine read method 
This2.Message.Opt responseOf() 
refine read method 
class This2.Message class() 
PluginFailure: {implements This1, This3.Guard, This3.Message, This3.Concept.Base, This3.Concept.ToS, This3.Concept.Classable, This3.Concept.Equals
refine read method 
class This0 class() 
refine class method /*
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  */This3.S readableName() 
refine class method /*
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  */This3.Bool is(class This3.Concept.Classable subtype) 
refine read method 
This3.Bool #equalequal#0left(read Any right) 
refine class method 
read This0 cast(read This3.Concept.Classable that) 
refine class method 
mut This0 #cast(mut This3.Concept.Classable that) 
read method 
This3.S _text() 
read method 
This3.Message.Opt cause() 
class method 
This0 #apply(This3.S _text, This3.Message.Opt cause) 
refine class method 
This3.S kind() 
refine read method 
This3.S text() 
refine read method 
This3.Message.Opt responseOf() 
method 
This0 #apply(This3.Message that) 
refine read method 
This3.S toS() 
read method 
This3.Bool equals(read This0 that) 
class method 
This0 #apply(This3.S text) 
class method 
This0 #apply(This3.S text, This3.Message cause) 
class method 
mut This3.S.SBuilder #builder() 
class method 
This0 #from(This3.S.SBuilder builder) 
method 
This0.Continue #from(This3.S.SConcat seqBuilder) 
method 
mut This3.S.SConcat #seqBuilder() 
Continue: {
read method 
This4.S that() 
class method 
This0 #apply(This4.S that) 
method 
mut This4.S.SBuilder #builder() 
method 
This1 #from(This4.S.SBuilder builder) }}}}
X: {
class method 
This0.AssertionFail #from(This1.S.SBuilder builder) 
class method 
mut This1.S.SBuilder #builder() 
class method 
mut This0.Tests #seqBuilder() 
class method 
Void #from(This0.Tests seqBuilder) 
NotImplementedYet: {implements This2.Message, This2.Concept.Base, This2.Concept.ToS, This2.Concept.Classable, This2.Concept.Equals
refine read method 
class This0 class() 
refine class method /*
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  */This2.S readableName() 
refine class method /*
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  */This2.Bool is(class This2.Concept.Classable subtype) 
refine read method 
This2.Bool #equalequal#0left(read Any right) 
refine class method 
read This0 cast(read This2.Concept.Classable that) 
refine class method 
mut This0 #cast(mut This2.Concept.Classable that) 
read method 
This2.S _text() 
read method 
This2.Message.Opt cause() 
class method 
This0 #apply(This2.S _text, This2.Message.Opt cause) 
refine class method 
This2.S kind() 
refine read method 
This2.S text() 
refine read method 
This2.Message.Opt responseOf() 
method 
This0 #apply(This2.Message that) 
refine read method 
This2.S toS() 
read method 
This2.Bool equals(read This0 that) 
class method 
This0 #apply(This2.S text) 
class method 
This0 #apply(This2.S text, This2.Message cause) 
class method 
mut This2.S.SBuilder #builder() 
class method 
This0 #from(This2.S.SBuilder builder) 
method 
This0.Continue #from(This2.S.SConcat seqBuilder) 
method 
mut This2.S.SConcat #seqBuilder() 
Continue: {
read method 
This3.S that() 
class method 
This0 #apply(This3.S that) 
method 
mut This3.S.SBuilder #builder() 
method 
This1 #from(This3.S.SBuilder builder) }}
AssertionFail: {implements This2.Message, This2.Concept.Base, This2.Concept.ToS, This2.Concept.Classable, This2.Concept.Equals
refine read method 
class This0 class() 
refine class method /*
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  */This2.S readableName() 
refine class method /*
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  */This2.Bool is(class This2.Concept.Classable subtype) 
refine read method 
This2.Bool #equalequal#0left(read Any right) 
refine class method 
read This0 cast(read This2.Concept.Classable that) 
refine class method 
mut This0 #cast(mut This2.Concept.Classable that) 
read method 
This2.S _text() 
read method 
This2.Message.Opt cause() 
class method 
This0 #apply(This2.S _text, This2.Message.Opt cause) 
refine class method 
This2.S kind() 
refine read method 
This2.S text() 
refine read method 
This2.Message.Opt responseOf() 
method 
This0 #apply(This2.Message that) 
refine read method 
This2.S toS() 
read method 
This2.Bool equals(read This0 that) 
class method 
This0 #apply(This2.S text) 
class method 
This0 #apply(This2.S text, This2.Message cause) 
class method 
mut This2.S.SBuilder #builder() 
class method 
This0 #from(This2.S.SBuilder builder) 
method 
This0.Continue #from(This2.S.SConcat seqBuilder) 
method 
mut This2.S.SConcat #seqBuilder() 
Continue: {
read method 
This3.S that() 
class method 
This0 #apply(This3.S that) 
method 
mut This3.S.SBuilder #builder() 
method 
This1 #from(This3.S.SBuilder builder) }}
Pre: {
class method 
mut This1.Tests #seqBuilder() 
class method 
Void #from(This1.Tests seqBuilder) }
Test: {
read method 
This2.Bool that() 
read method 
This2.S msg() 
class method 
This0 #apply(This2.Bool that, This2.S msg) }
Tests: {implements This2.Concept.ToS, This2.Concept.Classable
refine class method /*
  Cast a (read/imm) object to this type.
  A class implementing this method should refine the return type to This.
  if is(subtype) is true, then cast(that) must produce a result.
  */read This0 cast(read This2.Concept.Classable that) 
refine class method /*
  Cast a (mutable) object to this type.
  A class implementing this method should refine the return type to This.
  if cast(that) produces a result, then #cast(that) also must produce a result.
  */mut This0 #cast(mut This2.Concept.Classable that) 
refine read method /*
  Extracts the class singleton from another instance of this class
  */class This0 class() 
refine class method /*
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  */This2.S readableName() 
refine class method /*
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  */This2.Bool is(class This2.Concept.Classable subtype) 
read method 
read This2.Collections.MutListAny inner() 
mut method 
mut This2.Collections.MutListAny #inner() 
class method 
mut This0 #apply(fwd mut This2.Collections.MutListAny inner) 
class method 
This0 #immK(This2.Collections.MutListAny inner) 
class method 
mut This0 empty() 
class method 
mut This0 #seqBuilder() 
class method 
mut This0 #from(mut This0 seqBuilder) 
read method 
mut This0 reverse() 
read method 
This2.Size size() 
read method 
This2.Bool isEmpty() 
read method 
This1.Test val(This2.Size that) 
read method 
class This2.Size #default#val(Void that) 
read method 
This1.Test left() 
read method 
This1.Test right() 
mut method 
Void #apply(This2.Size that, This1.Test val) 
mut method 
Void left(This1.Test that) 
mut method 
Void right(This1.Test that) 
mut method 
Void add(This2.Size that, This1.Test val) 
mut method 
Void add(This1.Test right) 
mut method 
Void add(This1.Test left) 
mut method 
Void remove(This2.Size that) 
mut method 
Void removeLeft() 
mut method 
Void removeRight() 
method 
This0 #plus#0left(This1.Test right) 
method 
This0 #plusplus#0left(This0 right) 
method 
This0 with(This2.Size that, This1.Test val) 
method 
This0 withLeft(This1.Test that) 
method 
This0 withRight(This1.Test that) 
method 
This0 withAlso(This2.Size that, This1.Test val) 
method 
This0 withAlsoLeft(This1.Test that) 
method 
This0 withAlsoRight(This1.Test that) 
method 
This0 without(This2.Size index) 
method 
This0 withoutLeft() 
method 
This0 withoutRight() 
read method 
lent This0.IteratorVal vals(This2.Size from, This2.Size maxTo, This2.Size minTo) 
read method 
lent This0.IteratorVal vals(This2.Size minTo) 
read method 
lent This0.IteratorVal vals(This2.Size from, This2.Size to) 
read method 
lent This0.IteratorVal vals() 
read method 
lent This0.IteratorValFill vals(This2.Size from, This2.Size maxTo, This2.Size minTo, This1.Test filled) 
read method 
lent This0.IteratorValFill vals(This2.Size minTo, This1.Test filled) 
read method 
lent This0.IteratorValFill vals(This2.Size from, This2.Size to, This1.Test filled) 
read method 
lent This0.IteratorValFill vals(This1.Test filled) 
mut method 
lent This0.IteratorVar #vals(This2.Size from, This2.Size maxTo, This2.Size minTo) 
mut method 
lent This0.IteratorVar #vals(This2.Size minTo) 
mut method 
lent This0.IteratorVar #vals(This2.Size from, This2.Size to) 
mut method 
lent This0.IteratorVar #vals() 
refine read method 
This2.S toS() 
mut method 
Void #add(This2.Bool that, This2.Concept.ToS msg) 
mut method 
Void #add(This2.Bool that) 
read method 
This2.S collapse() 
Cast: {
class method 
This2.Test #apply(Any that) }
IteratorTrait: {
class method 
Library #apply() }
IteratorVal: {
mut method 
Void #next() exception Void 
read method 
Void #checkEnd() 
read method 
This2.Test #inner() 
read method 
Void #close() 
read method 
read This3.Collections.MutListAny _that() 
mut method 
Void from(This3.Size that) 
read method 
This3.Size from() 
read method 
This3.Size maxTo() 
read method 
This3.Size minTo() 
read method 
read This3.Collections.MutListAny that() 
class method 
lent This0 #apply(read This3.Collections.MutListAny _that, This3.Size from, This3.Size maxTo, This3.Size minTo) 
class method 
lent This0 #apply(read This3.Collections.MutListAny that, This3.Size from, This3.Size maxTo, This3.Size minTo) 
read method 
This3.Bool isFill() 
read method 
This2.Test filled() }
IteratorValFill: {
mut method 
Void #next() exception Void 
read method 
Void #checkEnd() 
read method 
This2.Test #inner() 
read method 
Void #close() 
read method 
read This3.Collections.MutListAny _that() 
mut method 
Void from(This3.Size that) 
read method 
This3.Size from() 
read method 
This3.Size maxTo() 
read method 
This3.Size minTo() 
read method 
This2.Test filled() 
read method 
read This3.Collections.MutListAny that() 
class method 
lent This0 #apply(read This3.Collections.MutListAny _that, This3.Size from, This3.Size maxTo, This3.Size minTo, This2.Test filled) 
class method 
lent This0 #apply(read This3.Collections.MutListAny that, This3.Size from, This3.Size maxTo, This3.Size minTo, This2.Test filled) 
read method 
This3.Bool isFill() }
IteratorVar: {
mut method 
Void #next() exception Void 
read method 
Void #checkEnd() 
read method 
This2.Test #inner() 
read method 
Void #close() 
read method 
read This3.Collections.MutListAny that() 
mut method 
mut This3.Collections.MutListAny #that() 
mut method 
Void from(This3.Size that) 
read method 
This3.Size from() 
read method 
This3.Size maxTo() 
read method 
This3.Size minTo() 
class method 
mut This0 #apply(mut This3.Collections.MutListAny that, This3.Size from, This3.Size maxTo, This3.Size minTo) 
mut method 
Void inner(This2.Test that) 
read method 
This3.Bool isFill() 
read method 
This2.Test filled() }}}
Strings: {implements This1.Concept.ToS, This1.Concept.Classable, This1.Concept.Equals
refine class method /*
  Cast a (read/imm) object to this type.
  A class implementing this method should refine the return type to This.
  if is(subtype) is true, then cast(that) must produce a result.
  */read This0 cast(read This1.Concept.Classable that) 
refine class method /*
  Cast a (mutable) object to this type.
  A class implementing this method should refine the return type to This.
  if cast(that) produces a result, then #cast(that) also must produce a result.
  */mut This0 #cast(mut This1.Concept.Classable that) 
refine read method /*
  Extracts the class singleton from another instance of this class
  */class This0 class() 
refine class method /*
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  */This1.S readableName() 
refine class method /*
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  */This1.Bool is(class This1.Concept.Classable subtype) 
read method 
read This1.Collections.MutListAny inner() 
mut method 
mut This1.Collections.MutListAny #inner() 
class method 
mut This0 #apply(fwd mut This1.Collections.MutListAny inner) 
class method 
This0 #immK(This1.Collections.MutListAny inner) 
class method 
mut This0 empty() 
read method 
mut This0 reverse() 
read method 
This1.Bool isEmpty() 
read method 
class This1.Size #default#val(Void that) 
read method 
This1.S left() 
read method 
This1.S right() 
mut method 
Void #apply(This1.Size that, This1.S val) 
mut method 
Void left(This1.S that) 
mut method 
Void right(This1.S that) 
mut method 
Void add(This1.Size that, This1.S val) 
mut method 
Void add(This1.S right) 
mut method 
Void add(This1.S left) 
mut method 
Void removeLeft() 
mut method 
Void removeRight() 
method 
This0 #plus#0left(This1.S right) 
method 
This0 #plusplus#0left(This0 right) 
method 
This0 with(This1.Size that, This1.S val) 
method 
This0 withLeft(This1.S that) 
method 
This0 withRight(This1.S that) 
method 
This0 withAlso(This1.Size that, This1.S val) 
method 
This0 withAlsoLeft(This1.S that) 
method 
This0 withAlsoRight(This1.S that) 
method 
This0 withoutLeft() 
method 
This0 withoutRight() 
read method 
lent This0.IteratorVal vals(This1.Size from, This1.Size maxTo, This1.Size minTo) 
read method 
lent This0.IteratorVal vals(This1.Size minTo) 
read method 
lent This0.IteratorVal vals(This1.Size from, This1.Size to) 
read method 
lent This0.IteratorValFill vals(This1.Size from, This1.Size maxTo, This1.Size minTo, This1.S filled) 
read method 
lent This0.IteratorValFill vals(This1.Size minTo, This1.S filled) 
read method 
lent This0.IteratorValFill vals(This1.Size from, This1.Size to, This1.S filled) 
read method 
lent This0.IteratorValFill vals(This1.S filled) 
mut method 
lent This0.IteratorVar #vals(This1.Size from, This1.Size maxTo, This1.Size minTo) 
mut method 
lent This0.IteratorVar #vals(This1.Size minTo) 
mut method 
lent This0.IteratorVar #vals(This1.Size from, This1.Size to) 
mut method 
lent This0.IteratorVar #vals() 
refine read method 
This1.S toS() 
read method 
This1.Size size() 
read method 
This1.S val(This1.Size that) 
class method 
mut This0 #seqBuilder() 
class method 
mut This0 #from(mut This0 seqBuilder) 
mut method 
Void #add(This1.S that) 
read method 
lent This0.IteratorVal vals() 
read method 
This1.Bool contains(This1.S that) 
method 
This0 #less#0left(This1.S right) 
method 
This0 #lessless#0left(This0 right) 
method 
This0 #and#0left(This0 right) 
method 
This1.Bool #rightright#0left(This0 right) 
method 
This1.Bool #rightrightequal#0left(This0 right) 
method 
This1.Bool #right#0left(This1.S right) 
read method 
This1.Bool equals(read This0 that) 
refine read method 
This1.Bool #equalequal#0left(read Any right) 
read method 
This1.Size indexOfLeft(This1.S val) 
read method 
This1.Size indexOfRight(This1.S val) 
method /*from VectorTrait
*/This0 without(This1.Size index) 
method 
This0 withoutLeft(This1.S val) 
method 
This0 withoutRight(This1.S val) 
method 
This0 withoutAll(This1.S val) 
mut method /*from VectorTrait
*/Void remove(This1.Size that) 
mut method 
Void removeAll(This1.S val) 
mut method 
Void removeLeft(This1.S val) 
mut method 
Void removeRight(This1.S val) 
Cast: {
class method 
This2.S #apply(Any that) }
IteratorTrait: {
class method 
Library #apply() }
IteratorValFill: {
mut method 
Void #next() exception Void 
read method 
Void #checkEnd() 
read method 
This2.S #inner() 
read method 
Void #close() 
read method 
read This2.Collections.MutListAny _that() 
mut method 
Void from(This2.Size that) 
read method 
This2.Size from() 
read method 
This2.Size maxTo() 
read method 
This2.Size minTo() 
read method 
This2.S filled() 
read method 
read This2.Collections.MutListAny that() 
class method 
lent This0 #apply(read This2.Collections.MutListAny _that, This2.Size from, This2.Size maxTo, This2.Size minTo, This2.S filled) 
class method 
lent This0 #apply(read This2.Collections.MutListAny that, This2.Size from, This2.Size maxTo, This2.Size minTo, This2.S filled) 
read method 
This2.Bool isFill() }
IteratorVar: {
mut method 
Void #next() exception Void 
read method 
Void #checkEnd() 
read method 
This2.S #inner() 
read method 
Void #close() 
read method 
read This2.Collections.MutListAny that() 
mut method 
mut This2.Collections.MutListAny #that() 
mut method 
Void from(This2.Size that) 
read method 
This2.Size from() 
read method 
This2.Size maxTo() 
read method 
This2.Size minTo() 
class method 
mut This0 #apply(mut This2.Collections.MutListAny that, This2.Size from, This2.Size maxTo, This2.Size minTo) 
mut method 
Void inner(This2.S that) 
read method 
This2.Bool isFill() 
read method 
This2.S filled() }
IteratorVal: {
read method 
read This2.Collections.MutListAny _that() 
mut method 
Void from(This2.Size that) 
read method 
This2.Size from() 
read method 
This2.Size maxTo() 
read method 
This2.Size minTo() 
read method 
read This2.Collections.MutListAny that() 
class method 
lent This0 #apply(read This2.Collections.MutListAny _that, This2.Size from, This2.Size maxTo, This2.Size minTo) 
class method 
lent This0 #apply(read This2.Collections.MutListAny that, This2.Size from, This2.Size maxTo, This2.Size minTo) 
read method 
This2.Bool isFill() 
read method 
This2.S filled() 
mut method 
Void #next() exception Void 
read method 
Void #checkEnd() 
read method 
This2.S #inner() 
read method 
Void #close() }}
Debug: {
class method 
Void #apply(read This1.Concept.ToS that) 
class method 
Void incrementCounter(read This1.Concept.ToS that) 
class method 
Void printCounter(read This1.Concept.ToS that) 
class method 
Void #apply(Library lib) 
class method 
Void #$(This1.Concept.ToS fileName, This1.Concept.ToS content) 
class method 
This1.S #$readFile(This1.Concept.ToS fileName) 
class method 
This1.S #$localToAbsolute(This1.Concept.ToS fileName) 
class method 
Void test(read This1.Concept.ToS that, read This1.Concept.ToS expected, This1.S message) 
class method 
Void test(read This1.Concept.ToS that, read This1.Concept.ToS expected) 
Test: {/* Builder to look like a list and run a series of debug.test calls.
 Does not actually make an instance or store the list of calls anywhere :-)
*/
class method 
class This0 #seqBuilder() 
class method 
Void #from(class This0 seqBuilder) 
class method 
Void #add(read This2.Concept.ToS that, read This2.Concept.ToS expected) 
class method 
Void #add(read This2.Concept.ToS that, read This2.Concept.ToS expected, This2.S message) }}
ConceptMap: {interface 
method 
This1.Alu _Alu() 
method 
This1.ExitCode _ExitCode() 
method 
This1.Bool _Bool() 
method 
This1.Size _Size() 
method 
This1.Num _Num() 
method 
This1.S _S() 
method 
This1.Concept _Concept() 
method 
This1.Message _Message() 
method 
This1.Guard _Guard() 
method 
This1.System _System() 
method 
This1.X _X() 
method 
This1.Strings _Strings() 
method 
This1.Debug _Debug() 
method 
This0 _ConceptMap() 
method 
This1.Url _Url() 
method 
This1.Path _Path() 
method 
This1.Selector _Selector() 
method 
This1.Location _Location() 
method 
This1.Refactor2 _Refactor2() 
method 
This1.Optimize _Optimize() 
method 
This1.Opt _Opt() 
method 
This1.Use _Use() 
method 
This1.Collections _Collections() 
method 
This1.CollectionsMut _CollectionsMut() 
method 
This1.K _K() 
method 
This1.Alphanumeric _Alphanumeric() 
method 
This1.DeployTowel _DeployTowel() 
method 
This1.Composers _Composers() 
method 
This1.Load _Load() }
Url: {implements This1.Concept.ToS
read method 
This1.S inner() 
class method 
This0 #apply(This1.S inner) 
refine read method 
This1.S toS() 
method 
Library #binaryRepr() 
class method /* if you do not implement it, it is a constructor?
may become an interface Concept.Parsable method?
*/This0 from(This1.Concept.ToS string) 
class method 
This0 #from(This1.S.SBuilder builder) 
class method 
mut This1.S.SBuilder #builder() }
Path: {/*@plugin is.L42.connected.withSafeOperators
@pluginPart java.util.List
*/implements This1.Concept.Base, This1.Concept.ToS, This1.Concept.Classable, This1.Concept.Equals
class method 
mut This0 #from(Library binaryRepr) 
read method 
Library #binaryRepr() 
class method 
Void #exceptionIf(Library binaryRepr) exception This0 
read method 
This1.Bool equals(read This0 that) 
refine class method /*
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  */This1.S readableName() 
refine class method /*
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  */This1.Bool is(class This1.Concept.Classable subtype) 
refine read method 
This1.Bool #equalequal#0left(read Any right) 
refine read method 
class This0 class() 
refine class method 
read This0 cast(read This1.Concept.Classable that) 
refine class method 
mut This0 #cast(mut This1.Concept.Classable that) 
class method 
Library #pluginUnresponsive(Library binaryRepr) 
class method 
This0 from(This1.Concept.ToS string) 
class method 
This0 #from(This1.S.SBuilder builder) 
class method 
mut This1.S.SBuilder #builder() 
method 
This1.Strings names() 
class method 
This0 from(read This1.Strings names) 
class method 
This0 fresh() 
method 
This1.S name(This1.Size that) 
method 
This1.Size nameSize() 
refine read method 
This1.S toS() 
method 
This0 #plusplus#0left(This0 right) 
method 
This1.Bool isUnique() 
class method 
This0 fresh(This0 like) 
method 
This1.Size size() 
class method 
Any parseError(This1.S that) 
class method 
Any parseError(This1.S that, This1.Message cause) 
PlgPath: {/*@plugin is.L42.connected.withSafeOperators
@pluginPart is.L42.connected.withSafeOperators.refactor.PathAdapter
*/
class method 
mut This0 #from(Library binaryRepr) 
read method 
Library #binaryRepr() 
class method 
Void #exceptionIf(Library binaryRepr) exception This0 
class method 
Library #pluginUnresponsive(Library binaryRepr) 
class method 
This2.S name(This1 that, This2.Size index) 
class method 
This1 concat(This1 that, This1 and) 
class method 
This2.Bool isUnique(This1 that) 
class method 
This1 fresh(This1 that) 
class method 
This1 rawFromS(This2.S that) 
class method 
This2.S toS(read This1 that) }
ParseFail: {implements This2.Guard.ParseFail, This2.Guard, This2.Message, This2.Concept.Base, This2.Concept.ToS, This2.Concept.Classable, This2.Concept.Equals, This2.Guard.ParseFail, This2.Guard, This2.Message, This2.Concept.Base, This2.Concept.ToS, This2.Concept.Classable, This2.Concept.Equals
refine read method 
class This0 class() 
refine class method /*
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  */This2.S readableName() 
refine class method /*
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  */This2.Bool is(class This2.Concept.Classable subtype) 
refine read method 
This2.Bool #equalequal#0left(read Any right) 
refine class method 
read This0 cast(read This2.Concept.Classable that) 
refine class method 
mut This0 #cast(mut This2.Concept.Classable that) 
read method 
This2.S _text() 
read method 
This2.Message.Opt cause() 
class method 
This0 #apply(This2.S _text, This2.Message.Opt cause) 
refine class method 
This2.S kind() 
refine read method 
This2.S text() 
refine read method 
This2.Message.Opt responseOf() 
method 
This0 #apply(This2.Message that) 
refine read method 
This2.S toS() 
read method 
This2.Bool equals(read This0 that) 
class method 
This0 #apply(This2.S text) 
class method 
This0 #apply(This2.S text, This2.Message cause) 
class method 
mut This2.S.SBuilder #builder() 
class method 
This0 #from(This2.S.SBuilder builder) 
method 
This0.Continue #from(This2.S.SConcat seqBuilder) 
method 
mut This2.S.SConcat #seqBuilder() 
Continue: {
read method 
This3.S that() 
class method 
This0 #apply(This3.S that) 
method 
mut This3.S.SBuilder #builder() 
method 
This1 #from(This3.S.SBuilder builder) }}}
Selector: {/*@plugin  toFix 
@pluginPart ast.Ast$MethodSelector
*/implements This1.Concept.Base, This1.Concept.ToS, This1.Concept.Classable, This1.Concept.Equals
class method 
mut This0 #from(Library binaryRepr) 
read method 
Library #binaryRepr() 
class method 
Void #exceptionIf(Library binaryRepr) exception This0 
read method 
This1.Bool equals(read This0 that) 
refine read method 
This1.S toS() 
refine class method /*
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  */This1.S readableName() 
refine class method /*
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  */This1.Bool is(class This1.Concept.Classable subtype) 
refine read method 
This1.Bool #equalequal#0left(read Any right) 
refine read method 
class This0 class() 
refine class method 
read This0 cast(read This1.Concept.Classable that) 
refine class method 
mut This0 #cast(mut This1.Concept.Classable that) 
class method 
Library #pluginUnresponsive(Library binaryRepr) 
class method 
This0 parse(This1.S that) 
class method 
This0 from(This1.Concept.ToS string) 
class method 
This0 #from(This1.S.SBuilder builder) 
class method 
mut This1.S.SBuilder #builder() 
class method 
This0 from(This1.S name, This1.Strings names) 
method 
This1.S nameAsField() 
method 
This1.S prefixAsField() 
method 
This1.Bool isOperator() 
method 
This1.Bool isUnique() 
method 
This1.S nameToS() 
method 
This1.S name() 
method 
This1.Size nameSize() 
method 
This1.S name(This1.Size that) 
method 
This1.Strings names() 
class method 
This0 fresh(This0 like) 
class method /*will be private
*/This1.S leftAsASCIIUpperCase(This1.S that) 
method 
This0 with(This1.S prefix) 
method 
This0 with(This1.S name) 
method 
This0 with(This1.Strings names) 
class method 
Any parseError(This1.S that) 
ParseFail: {implements This2.Guard.ParseFail, This2.Guard, This2.Message, This2.Concept.Base, This2.Concept.ToS, This2.Concept.Classable, This2.Concept.Equals, This2.Guard.ParseFail, This2.Guard, This2.Message, This2.Concept.Base, This2.Concept.ToS, This2.Concept.Classable, This2.Concept.Equals
refine read method 
class This0 class() 
refine class method /*
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  */This2.S readableName() 
refine class method /*
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  */This2.Bool is(class This2.Concept.Classable subtype) 
refine read method 
This2.Bool #equalequal#0left(read Any right) 
refine class method 
read This0 cast(read This2.Concept.Classable that) 
refine class method 
mut This0 #cast(mut This2.Concept.Classable that) 
read method 
This2.S _text() 
read method 
This2.Message.Opt cause() 
class method 
This0 #apply(This2.S _text, This2.Message.Opt cause) 
refine class method 
This2.S kind() 
refine read method 
This2.S text() 
refine read method 
This2.Message.Opt responseOf() 
method 
This0 #apply(This2.Message that) 
refine read method 
This2.S toS() 
read method 
This2.Bool equals(read This0 that) 
class method 
This0 #apply(This2.S text) 
class method 
This0 #apply(This2.S text, This2.Message cause) 
class method 
mut This2.S.SBuilder #builder() 
class method 
This0 #from(This2.S.SBuilder builder) 
method 
This0.Continue #from(This2.S.SConcat seqBuilder) 
method 
mut This2.S.SConcat #seqBuilder() 
Continue: {
read method 
This3.S that() 
class method 
This0 #apply(This3.S that) 
method 
mut This3.S.SBuilder #builder() 
method 
This1 #from(This3.S.SBuilder builder) }}}
Location: {interface implements This1.Concept.Base/*that is equals, toS and "know your class"
*/, This1.Concept.ToS, This1.Concept.Classable, This1.Concept.Equals
refine read method 
This1.S toS() 
refine class method /*
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  */This1.S readableName() 
refine class method /*
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  */This1.Bool is(class This1.Concept.Classable subtype) 
refine read method 
This1.Bool #equalequal#0left(read Any right) 
refine read method 
class This1.Concept.Base class() 
refine class method 
read This1.Concept.Base cast(read This1.Concept.Classable that) 
refine class method 
mut This1.Concept.Base #cast(mut This1.Concept.Classable that) 
method 
This1.Size originSize() 
method 
This0.Origin origin(This1.Size that) 
method 
This0 location() 
method 
This0.Doc doc() 
NotAvailable: {implements This2.Guard, This2.Message, This2.Concept.Base, This2.Concept.ToS, This2.Concept.Classable, This2.Concept.Equals
refine read method 
class This0 class() 
refine class method /*
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  */This2.S readableName() 
refine class method /*
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  */This2.Bool is(class This2.Concept.Classable subtype) 
refine read method 
This2.Bool #equalequal#0left(read Any right) 
refine class method 
read This0 cast(read This2.Concept.Classable that) 
refine class method 
mut This0 #cast(mut This2.Concept.Classable that) 
read method 
This2.S _text() 
read method 
This2.Message.Opt cause() 
class method 
This0 #apply(This2.S _text, This2.Message.Opt cause) 
refine class method 
This2.S kind() 
refine read method 
This2.S text() 
refine read method 
This2.Message.Opt responseOf() 
method 
This0 #apply(This2.Message that) 
refine read method 
This2.S toS() 
read method 
This2.Bool equals(read This0 that) 
class method 
This0 #apply(This2.S text) 
class method 
This0 #apply(This2.S text, This2.Message cause) 
class method 
mut This2.S.SBuilder #builder() 
class method 
This0 #from(This2.S.SBuilder builder) 
method 
This0.Continue #from(This2.S.SConcat seqBuilder) 
method 
mut This2.S.SConcat #seqBuilder() 
Continue: {
read method 
This3.S that() 
class method 
This0 #apply(This3.S that) 
method 
mut This3.S.SBuilder #builder() 
method 
This1 #from(This3.S.SBuilder builder) }}
Mdf: {implements This2.Concept.Base, This2.Concept.ToS, This2.Concept.Classable, This2.Concept.Equals
read method 
This2.Size inner() 
class method 
This0 #apply(This2.Size inner) 
read method 
This2.S name() 
read method 
This2.Bool equals(read This0 that) 
class method 
This0 fromS(This2.S that) 
class method 
This2.Strings names() 
class method 
This0 cmpImm() 
method 
This2.Bool isCmpImm() 
class method 
This0 cmpMut() 
method 
This2.Bool isCmpMut() 
class method 
This0 cmpRead() 
method 
This2.Bool isCmpRead() 
class method 
This0 cmpLent() 
method 
This2.Bool isCmpLent() 
class method 
This0 cmpCapsule() 
method 
This2.Bool isCmpCapsule() 
class method 
This0 cmpClass() 
method 
This2.Bool isCmpClass() 
class method 
This0 fwdImm() 
method 
This2.Bool isFwdImm() 
class method 
This0 fwdMut() 
method 
This2.Bool isFwdMut() 
refine read method 
This2.S toS() 
refine class method /*
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  */This2.S readableName() 
refine class method /*
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  */This2.Bool is(class This2.Concept.Classable subtype) 
refine read method 
This2.Bool #equalequal#0left(read Any right) 
refine read method 
class This0 class() 
refine class method 
read This0 cast(read This2.Concept.Classable that) 
refine class method 
mut This0 #cast(mut This2.Concept.Classable that) 
ParseFail: {implements This3.Guard.ParseFail, This3.Guard, This3.Message, This3.Concept.Base, This3.Concept.ToS, This3.Concept.Classable, This3.Concept.Equals
refine read method 
class This0 class() 
refine class method /*
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  */This3.S readableName() 
refine class method /*
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  */This3.Bool is(class This3.Concept.Classable subtype) 
refine read method 
This3.Bool #equalequal#0left(read Any right) 
refine class method 
read This0 cast(read This3.Concept.Classable that) 
refine class method 
mut This0 #cast(mut This3.Concept.Classable that) 
read method 
This3.S _text() 
read method 
This3.Message.Opt cause() 
class method 
This0 #apply(This3.S _text, This3.Message.Opt cause) 
refine class method 
This3.S kind() 
refine read method 
This3.S text() 
refine read method 
This3.Message.Opt responseOf() 
method 
This0 #apply(This3.Message that) 
refine read method 
This3.S toS() 
read method 
This3.Bool equals(read This0 that) 
class method 
This0 #apply(This3.S text) 
class method 
This0 #apply(This3.S text, This3.Message cause) 
class method 
mut This3.S.SBuilder #builder() 
class method 
This0 #from(This3.S.SBuilder builder) 
method 
This0.Continue #from(This3.S.SConcat seqBuilder) 
method 
mut This3.S.SConcat #seqBuilder() 
Continue: {
read method 
This4.S that() 
class method 
This0 #apply(This4.S that) 
method 
mut This4.S.SBuilder #builder() 
method 
This1 #from(This4.S.SBuilder builder) }}
List: {implements This3.Concept.ToS, This3.Concept.Classable, This3.Concept.Equals
refine class method /*
  Cast a (read/imm) object to this type.
  A class implementing this method should refine the return type to This.
  if is(subtype) is true, then cast(that) must produce a result.
  */read This0 cast(read This3.Concept.Classable that) 
refine class method /*
  Cast a (mutable) object to this type.
  A class implementing this method should refine the return type to This.
  if cast(that) produces a result, then #cast(that) also must produce a result.
  */mut This0 #cast(mut This3.Concept.Classable that) 
refine read method /*
  Extracts the class singleton from another instance of this class
  */class This0 class() 
refine class method /*
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  */This3.S readableName() 
refine class method /*
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  */This3.Bool is(class This3.Concept.Classable subtype) 
read method 
read This3.Collections.MutListAny inner() 
mut method 
mut This3.Collections.MutListAny #inner() 
class method 
mut This0 #apply(fwd mut This3.Collections.MutListAny inner) 
class method 
This0 #immK(This3.Collections.MutListAny inner) 
class method 
mut This0 empty() 
read method 
mut This0 reverse() 
read method 
This3.Bool isEmpty() 
read method 
class This3.Size #default#val(Void that) 
read method 
This1 left() 
read method 
This1 right() 
mut method 
Void #apply(This3.Size that, This1 val) 
mut method 
Void left(This1 that) 
mut method 
Void right(This1 that) 
mut method 
Void add(This3.Size that, This1 val) 
mut method 
Void add(This1 right) 
mut method 
Void add(This1 left) 
mut method 
Void removeLeft() 
mut method 
Void removeRight() 
method 
This0 #plus#0left(This1 right) 
method 
This0 #plusplus#0left(This0 right) 
method 
This0 with(This3.Size that, This1 val) 
method 
This0 withLeft(This1 that) 
method 
This0 withRight(This1 that) 
method 
This0 withAlso(This3.Size that, This1 val) 
method 
This0 withAlsoLeft(This1 that) 
method 
This0 withAlsoRight(This1 that) 
method 
This0 withoutLeft() 
method 
This0 withoutRight() 
read method 
lent This0.IteratorVal vals(This3.Size from, This3.Size maxTo, This3.Size minTo) 
read method 
lent This0.IteratorVal vals(This3.Size minTo) 
read method 
lent This0.IteratorVal vals(This3.Size from, This3.Size to) 
read method 
lent This0.IteratorValFill vals(This3.Size from, This3.Size maxTo, This3.Size minTo, This1 filled) 
read method 
lent This0.IteratorValFill vals(This3.Size minTo, This1 filled) 
read method 
lent This0.IteratorValFill vals(This3.Size from, This3.Size to, This1 filled) 
read method 
lent This0.IteratorValFill vals(This1 filled) 
mut method 
lent This0.IteratorVar #vals(This3.Size from, This3.Size maxTo, This3.Size minTo) 
mut method 
lent This0.IteratorVar #vals(This3.Size minTo) 
mut method 
lent This0.IteratorVar #vals(This3.Size from, This3.Size to) 
mut method 
lent This0.IteratorVar #vals() 
refine read method 
This3.S toS() 
read method 
This3.Size size() 
read method 
This1 val(This3.Size that) 
class method 
mut This0 #seqBuilder() 
class method 
mut This0 #from(mut This0 seqBuilder) 
mut method 
Void #add(This1 that) 
read method 
lent This0.IteratorVal vals() 
read method 
This3.Bool contains(This1 that) 
method 
This0 #less#0left(This1 right) 
method 
This0 #lessless#0left(This0 right) 
method 
This0 #and#0left(This0 right) 
method 
This3.Bool #rightright#0left(This0 right) 
method 
This3.Bool #rightrightequal#0left(This0 right) 
method 
This3.Bool #right#0left(This1 right) 
read method 
This3.Bool equals(read This0 that) 
refine read method 
This3.Bool #equalequal#0left(read Any right) 
read method 
This3.Size indexOfLeft(This1 val) 
read method 
This3.Size indexOfRight(This1 val) 
method /*from VectorTrait
*/This0 without(This3.Size index) 
method 
This0 withoutLeft(This1 val) 
method 
This0 withoutRight(This1 val) 
method 
This0 withoutAll(This1 val) 
mut method /*from VectorTrait
*/Void remove(This3.Size that) 
mut method 
Void removeAll(This1 val) 
mut method 
Void removeLeft(This1 val) 
mut method 
Void removeRight(This1 val) 
Cast: {
class method 
This2 #apply(Any that) }
IteratorTrait: {
class method 
Library #apply() }
IteratorValFill: {
mut method 
Void #next() exception Void 
read method 
Void #checkEnd() 
read method 
This2 #inner() 
read method 
Void #close() 
read method 
read This4.Collections.MutListAny _that() 
mut method 
Void from(This4.Size that) 
read method 
This4.Size from() 
read method 
This4.Size maxTo() 
read method 
This4.Size minTo() 
read method 
This2 filled() 
read method 
read This4.Collections.MutListAny that() 
class method 
lent This0 #apply(read This4.Collections.MutListAny _that, This4.Size from, This4.Size maxTo, This4.Size minTo, This2 filled) 
class method 
lent This0 #apply(read This4.Collections.MutListAny that, This4.Size from, This4.Size maxTo, This4.Size minTo, This2 filled) 
read method 
This4.Bool isFill() }
IteratorVar: {
mut method 
Void #next() exception Void 
read method 
Void #checkEnd() 
read method 
This2 #inner() 
read method 
Void #close() 
read method 
read This4.Collections.MutListAny that() 
mut method 
mut This4.Collections.MutListAny #that() 
mut method 
Void from(This4.Size that) 
read method 
This4.Size from() 
read method 
This4.Size maxTo() 
read method 
This4.Size minTo() 
class method 
mut This0 #apply(mut This4.Collections.MutListAny that, This4.Size from, This4.Size maxTo, This4.Size minTo) 
mut method 
Void inner(This2 that) 
read method 
This4.Bool isFill() 
read method 
This2 filled() }
IteratorVal: {
read method 
read This4.Collections.MutListAny _that() 
mut method 
Void from(This4.Size that) 
read method 
This4.Size from() 
read method 
This4.Size maxTo() 
read method 
This4.Size minTo() 
read method 
read This4.Collections.MutListAny that() 
class method 
lent This0 #apply(read This4.Collections.MutListAny _that, This4.Size from, This4.Size maxTo, This4.Size minTo) 
class method 
lent This0 #apply(read This4.Collections.MutListAny that, This4.Size from, This4.Size maxTo, This4.Size minTo) 
read method 
This4.Bool isFill() 
read method 
This2 filled() 
mut method 
Void #next() exception Void 
read method 
Void #checkEnd() 
read method 
This2 #inner() 
read method 
Void #close() }}}
Origin: {/*@plugin  toFix 
@pluginPart is.L42.connected.withSafeOperators.location.Origin
*/implements This2.Concept.Base, This2.Concept.ToS, This2.Concept.Classable, This2.Concept.Equals
class method 
mut This0 #from(Library binaryRepr) 
read method 
Library #binaryRepr() 
class method 
Void #exceptionIf(Library binaryRepr) exception This0 
read method 
This2.Bool equals(read This0 that) 
read method 
This2.S fileName() 
read method 
This2.Size lineStart() 
read method 
This2.Size lineEnd() 
read method 
This2.Size columnStart() 
read method 
This2.Size columnEnd() 
class method 
Library #pluginUnresponsive(Library binaryRepr) 
class method 
This0 #apply(This2.S fileName, This2.Size lineStart, This2.Size lineEnd, This2.Size columnStart, This2.Size columnEnd) 
refine read method 
This2.S toS() 
refine class method /*
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  */This2.S readableName() 
refine class method /*
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  */This2.Bool is(class This2.Concept.Classable subtype) 
refine read method 
This2.Bool #equalequal#0left(read Any right) 
refine class method 
read This0 cast(read This2.Concept.Classable that) 
refine class method 
mut This0 #cast(mut This2.Concept.Classable that) 
refine read method 
class This0 class() 
List: {implements This3.Concept.ToS, This3.Concept.Classable, This3.Concept.Equals
refine class method /*
  Cast a (read/imm) object to this type.
  A class implementing this method should refine the return type to This.
  if is(subtype) is true, then cast(that) must produce a result.
  */read This0 cast(read This3.Concept.Classable that) 
refine class method /*
  Cast a (mutable) object to this type.
  A class implementing this method should refine the return type to This.
  if cast(that) produces a result, then #cast(that) also must produce a result.
  */mut This0 #cast(mut This3.Concept.Classable that) 
refine read method /*
  Extracts the class singleton from another instance of this class
  */class This0 class() 
refine class method /*
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  */This3.S readableName() 
refine class method /*
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  */This3.Bool is(class This3.Concept.Classable subtype) 
read method 
read This3.Collections.MutListAny inner() 
mut method 
mut This3.Collections.MutListAny #inner() 
class method 
mut This0 #apply(fwd mut This3.Collections.MutListAny inner) 
class method 
This0 #immK(This3.Collections.MutListAny inner) 
class method 
mut This0 empty() 
read method 
mut This0 reverse() 
read method 
This3.Bool isEmpty() 
read method 
class This3.Size #default#val(Void that) 
read method 
This1 left() 
read method 
This1 right() 
mut method 
Void #apply(This3.Size that, This1 val) 
mut method 
Void left(This1 that) 
mut method 
Void right(This1 that) 
mut method 
Void add(This3.Size that, This1 val) 
mut method 
Void add(This1 right) 
mut method 
Void add(This1 left) 
mut method 
Void removeLeft() 
mut method 
Void removeRight() 
method 
This0 #plus#0left(This1 right) 
method 
This0 #plusplus#0left(This0 right) 
method 
This0 with(This3.Size that, This1 val) 
method 
This0 withLeft(This1 that) 
method 
This0 withRight(This1 that) 
method 
This0 withAlso(This3.Size that, This1 val) 
method 
This0 withAlsoLeft(This1 that) 
method 
This0 withAlsoRight(This1 that) 
method 
This0 withoutLeft() 
method 
This0 withoutRight() 
read method 
lent This0.IteratorVal vals(This3.Size from, This3.Size maxTo, This3.Size minTo) 
read method 
lent This0.IteratorVal vals(This3.Size minTo) 
read method 
lent This0.IteratorVal vals(This3.Size from, This3.Size to) 
read method 
lent This0.IteratorValFill vals(This3.Size from, This3.Size maxTo, This3.Size minTo, This1 filled) 
read method 
lent This0.IteratorValFill vals(This3.Size minTo, This1 filled) 
read method 
lent This0.IteratorValFill vals(This3.Size from, This3.Size to, This1 filled) 
read method 
lent This0.IteratorValFill vals(This1 filled) 
mut method 
lent This0.IteratorVar #vals(This3.Size from, This3.Size maxTo, This3.Size minTo) 
mut method 
lent This0.IteratorVar #vals(This3.Size minTo) 
mut method 
lent This0.IteratorVar #vals(This3.Size from, This3.Size to) 
mut method 
lent This0.IteratorVar #vals() 
refine read method 
This3.S toS() 
read method 
This3.Size size() 
read method 
This1 val(This3.Size that) 
class method 
mut This0 #seqBuilder() 
class method 
mut This0 #from(mut This0 seqBuilder) 
mut method 
Void #add(This1 that) 
read method 
lent This0.IteratorVal vals() 
read method 
This3.Bool contains(This1 that) 
method 
This0 #less#0left(This1 right) 
method 
This0 #lessless#0left(This0 right) 
method 
This0 #and#0left(This0 right) 
method 
This3.Bool #rightright#0left(This0 right) 
method 
This3.Bool #rightrightequal#0left(This0 right) 
method 
This3.Bool #right#0left(This1 right) 
read method 
This3.Bool equals(read This0 that) 
refine read method 
This3.Bool #equalequal#0left(read Any right) 
read method 
This3.Size indexOfLeft(This1 val) 
read method 
This3.Size indexOfRight(This1 val) 
method /*from VectorTrait
*/This0 without(This3.Size index) 
method 
This0 withoutLeft(This1 val) 
method 
This0 withoutRight(This1 val) 
method 
This0 withoutAll(This1 val) 
mut method /*from VectorTrait
*/Void remove(This3.Size that) 
mut method 
Void removeAll(This1 val) 
mut method 
Void removeLeft(This1 val) 
mut method 
Void removeRight(This1 val) 
Cast: {
class method 
This2 #apply(Any that) }
IteratorTrait: {
class method 
Library #apply() }
IteratorValFill: {
mut method 
Void #next() exception Void 
read method 
Void #checkEnd() 
read method 
This2 #inner() 
read method 
Void #close() 
read method 
read This4.Collections.MutListAny _that() 
mut method 
Void from(This4.Size that) 
read method 
This4.Size from() 
read method 
This4.Size maxTo() 
read method 
This4.Size minTo() 
read method 
This2 filled() 
read method 
read This4.Collections.MutListAny that() 
class method 
lent This0 #apply(read This4.Collections.MutListAny _that, This4.Size from, This4.Size maxTo, This4.Size minTo, This2 filled) 
class method 
lent This0 #apply(read This4.Collections.MutListAny that, This4.Size from, This4.Size maxTo, This4.Size minTo, This2 filled) 
read method 
This4.Bool isFill() }
IteratorVar: {
mut method 
Void #next() exception Void 
read method 
Void #checkEnd() 
read method 
This2 #inner() 
read method 
Void #close() 
read method 
read This4.Collections.MutListAny that() 
mut method 
mut This4.Collections.MutListAny #that() 
mut method 
Void from(This4.Size that) 
read method 
This4.Size from() 
read method 
This4.Size maxTo() 
read method 
This4.Size minTo() 
class method 
mut This0 #apply(mut This4.Collections.MutListAny that, This4.Size from, This4.Size maxTo, This4.Size minTo) 
mut method 
Void inner(This2 that) 
read method 
This4.Bool isFill() 
read method 
This2 filled() }
IteratorVal: {
read method 
read This4.Collections.MutListAny _that() 
mut method 
Void from(This4.Size that) 
read method 
This4.Size from() 
read method 
This4.Size maxTo() 
read method 
This4.Size minTo() 
read method 
read This4.Collections.MutListAny that() 
class method 
lent This0 #apply(read This4.Collections.MutListAny _that, This4.Size from, This4.Size maxTo, This4.Size minTo) 
class method 
lent This0 #apply(read This4.Collections.MutListAny that, This4.Size from, This4.Size maxTo, This4.Size minTo) 
read method 
This4.Bool isFill() 
read method 
This2 filled() 
mut method 
Void #next() exception Void 
read method 
Void #checkEnd() 
read method 
This2 #inner() 
read method 
Void #close() }}}
PUnresponsive: {
class method 
Library #leftrightleft#0left(Library right) 
class method 
Library #apply() }
This$Impl: {
class method 
Library #leftrightleft#0left(Library right) 
class method 
Library #apply() }
PlgClass: {
class method 
Library #leftrightleft#0left(Library right) }
Lib: {/*@plugin  toFix
@pluginPart is.L42.connected.withSafeOperators.location.Lib
*/implements This1, This2.Concept.Base, This2.Concept.ToS, This2.Concept.Classable, This2.Concept.Equals
class method 
mut This0 #from(Library binaryRepr) 
read method 
Library #binaryRepr() 
class method 
Void #exceptionIf(Library binaryRepr) exception This0 
class method 
Library #pluginUnresponsive(Library binaryRepr) 
read method 
This2.Bool equals(read This0 that) 
method 
This1.Origin.List origins() 
refine method 
This2.Size originSize() 
refine method 
This1.Origin origin(This2.Size that) 
refine method 
This1.Doc doc() 
method 
This0.List nesteds() 
method 
This0.List allNesteds() 
method 
class This2.Path #default#nested(Void path) 
method 
This0 nested(This2.Path path) exception This1.NotAvailable 
method 
class This2.Path #default#has(Void path) 
method 
This2.Bool has(This2.Path path) 
method 
This1.Method.List methods() 
method 
class This2.Selector #default#method(Void selector) 
method 
This1.Method method(This2.Selector selector) exception This1.NotAvailable 
method 
class This2.Selector #default#has(Void selector) 
method 
This2.Bool has(This2.Selector selector) 
method 
This1.Type.Implemented.List implements() 
method 
This2.Bool implements(class Any classObj) 
method 
class This2.Path #default#implements(Void path) 
method 
This2.Bool implements(This2.Path path) 
class method 
This0 #apply(class Any classObj) 
class method 
This0 #apply(Library that) 
method 
This0 navigate(This2.Path that) 
class method 
This0 newFromClass(class Any that) 
class method 
This0 newFromLibrary(Library that) 
method 
This1.Type.Implemented implemented(This2.Size that) 
method 
This2.Size implementedSize() 
method 
This2.Bool isBinded() 
method 
This2.Bool isCloseState() 
method /*as in EnsureCoherent<><
*/This2.Bool isEnsuredCoherent() 
method 
This2.Bool isInterface() 
method 
This2.Bool isPotentialInterface() 
method 
This2.Bool isRedirectable() 
method 
This1.Method method(This2.Size that) 
method 
This2.Size methodSize() 
method 
This0 nested(This2.Size that) 
method /*empty doc if it is root
*/This1.Doc nestedDoc() 
method 
This2.Size nestedSize() 
method /*last is its name, empty path for root
*/This2.Path path() 
method 
This0 root() 
refine method /*implemented but refined
*/This0 location() 
refine read method 
This2.S toS() 
refine class method /*
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  */This2.S readableName() 
refine class method /*
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  */This2.Bool is(class This2.Concept.Classable subtype) 
refine read method 
This2.Bool #equalequal#0left(read Any right) 
refine class method 
read This0 cast(read This2.Concept.Classable that) 
refine class method 
mut This0 #cast(mut This2.Concept.Classable that) 
refine read method 
class This0 class() 
List: {implements This3.Concept.ToS, This3.Concept.Classable, This3.Concept.Equals
refine class method /*
  Cast a (read/imm) object to this type.
  A class implementing this method should refine the return type to This.
  if is(subtype) is true, then cast(that) must produce a result.
  */read This0 cast(read This3.Concept.Classable that) 
refine class method /*
  Cast a (mutable) object to this type.
  A class implementing this method should refine the return type to This.
  if cast(that) produces a result, then #cast(that) also must produce a result.
  */mut This0 #cast(mut This3.Concept.Classable that) 
refine read method /*
  Extracts the class singleton from another instance of this class
  */class This0 class() 
refine class method /*
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  */This3.S readableName() 
refine class method /*
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  */This3.Bool is(class This3.Concept.Classable subtype) 
read method 
read This3.Collections.MutListAny inner() 
mut method 
mut This3.Collections.MutListAny #inner() 
class method 
mut This0 #apply(fwd mut This3.Collections.MutListAny inner) 
class method 
This0 #immK(This3.Collections.MutListAny inner) 
class method 
mut This0 empty() 
read method 
mut This0 reverse() 
read method 
This3.Bool isEmpty() 
read method 
class This3.Size #default#val(Void that) 
read method 
This1 left() 
read method 
This1 right() 
mut method 
Void #apply(This3.Size that, This1 val) 
mut method 
Void left(This1 that) 
mut method 
Void right(This1 that) 
mut method 
Void add(This3.Size that, This1 val) 
mut method 
Void add(This1 right) 
mut method 
Void add(This1 left) 
mut method 
Void removeLeft() 
mut method 
Void removeRight() 
method 
This0 #plus#0left(This1 right) 
method 
This0 #plusplus#0left(This0 right) 
method 
This0 with(This3.Size that, This1 val) 
method 
This0 withLeft(This1 that) 
method 
This0 withRight(This1 that) 
method 
This0 withAlso(This3.Size that, This1 val) 
method 
This0 withAlsoLeft(This1 that) 
method 
This0 withAlsoRight(This1 that) 
method 
This0 withoutLeft() 
method 
This0 withoutRight() 
read method 
lent This0.IteratorVal vals(This3.Size from, This3.Size maxTo, This3.Size minTo) 
read method 
lent This0.IteratorVal vals(This3.Size minTo) 
read method 
lent This0.IteratorVal vals(This3.Size from, This3.Size to) 
read method 
lent This0.IteratorValFill vals(This3.Size from, This3.Size maxTo, This3.Size minTo, This1 filled) 
read method 
lent This0.IteratorValFill vals(This3.Size minTo, This1 filled) 
read method 
lent This0.IteratorValFill vals(This3.Size from, This3.Size to, This1 filled) 
read method 
lent This0.IteratorValFill vals(This1 filled) 
mut method 
lent This0.IteratorVar #vals(This3.Size from, This3.Size maxTo, This3.Size minTo) 
mut method 
lent This0.IteratorVar #vals(This3.Size minTo) 
mut method 
lent This0.IteratorVar #vals(This3.Size from, This3.Size to) 
mut method 
lent This0.IteratorVar #vals() 
refine read method 
This3.S toS() 
read method 
This3.Size size() 
read method 
This1 val(This3.Size that) 
class method 
mut This0 #seqBuilder() 
class method 
mut This0 #from(mut This0 seqBuilder) 
mut method 
Void #add(This1 that) 
read method 
lent This0.IteratorVal vals() 
read method 
This3.Bool contains(This1 that) 
method 
This0 #less#0left(This1 right) 
method 
This0 #lessless#0left(This0 right) 
method 
This0 #and#0left(This0 right) 
method 
This3.Bool #rightright#0left(This0 right) 
method 
This3.Bool #rightrightequal#0left(This0 right) 
method 
This3.Bool #right#0left(This1 right) 
read method 
This3.Bool equals(read This0 that) 
refine read method 
This3.Bool #equalequal#0left(read Any right) 
read method 
This3.Size indexOfLeft(This1 val) 
read method 
This3.Size indexOfRight(This1 val) 
method /*from VectorTrait
*/This0 without(This3.Size index) 
method 
This0 withoutLeft(This1 val) 
method 
This0 withoutRight(This1 val) 
method 
This0 withoutAll(This1 val) 
mut method /*from VectorTrait
*/Void remove(This3.Size that) 
mut method 
Void removeAll(This1 val) 
mut method 
Void removeLeft(This1 val) 
mut method 
Void removeRight(This1 val) 
Cast: {
class method 
This2 #apply(Any that) }
IteratorTrait: {
class method 
Library #apply() }
IteratorValFill: {
mut method 
Void #next() exception Void 
read method 
Void #checkEnd() 
read method 
This2 #inner() 
read method 
Void #close() 
read method 
read This4.Collections.MutListAny _that() 
mut method 
Void from(This4.Size that) 
read method 
This4.Size from() 
read method 
This4.Size maxTo() 
read method 
This4.Size minTo() 
read method 
This2 filled() 
read method 
read This4.Collections.MutListAny that() 
class method 
lent This0 #apply(read This4.Collections.MutListAny _that, This4.Size from, This4.Size maxTo, This4.Size minTo, This2 filled) 
class method 
lent This0 #apply(read This4.Collections.MutListAny that, This4.Size from, This4.Size maxTo, This4.Size minTo, This2 filled) 
read method 
This4.Bool isFill() }
IteratorVar: {
mut method 
Void #next() exception Void 
read method 
Void #checkEnd() 
read method 
This2 #inner() 
read method 
Void #close() 
read method 
read This4.Collections.MutListAny that() 
mut method 
mut This4.Collections.MutListAny #that() 
mut method 
Void from(This4.Size that) 
read method 
This4.Size from() 
read method 
This4.Size maxTo() 
read method 
This4.Size minTo() 
class method 
mut This0 #apply(mut This4.Collections.MutListAny that, This4.Size from, This4.Size maxTo, This4.Size minTo) 
mut method 
Void inner(This2 that) 
read method 
This4.Bool isFill() 
read method 
This2 filled() }
IteratorVal: {
read method 
read This4.Collections.MutListAny _that() 
mut method 
Void from(This4.Size that) 
read method 
This4.Size from() 
read method 
This4.Size maxTo() 
read method 
This4.Size minTo() 
read method 
read This4.Collections.MutListAny that() 
class method 
lent This0 #apply(read This4.Collections.MutListAny _that, This4.Size from, This4.Size maxTo, This4.Size minTo) 
class method 
lent This0 #apply(read This4.Collections.MutListAny that, This4.Size from, This4.Size maxTo, This4.Size minTo) 
read method 
This4.Bool isFill() 
read method 
This2 filled() 
mut method 
Void #next() exception Void 
read method 
Void #checkEnd() 
read method 
This2 #inner() 
read method 
Void #close() }}}
Method: {/*@plugin  toFix 
@pluginPart is.L42.connected.withSafeOperators.location.Method
*/implements This1, This2.Concept.Base, This2.Concept.ToS, This2.Concept.Classable, This2.Concept.Equals
class method 
mut This0 #from(Library binaryRepr) 
read method 
Library #binaryRepr() 
class method 
Void #exceptionIf(Library binaryRepr) exception This0 
class method 
Library #pluginUnresponsive(Library binaryRepr) 
read method 
This2.Bool equals(read This0 that) 
method 
This1.Origin.List origins() 
refine method 
This2.Size originSize() 
refine method 
This1.Origin origin(This2.Size that) 
refine method 
This1.Doc doc() 
refine method 
This1.Lib location() 
method 
This2.Bool isAbstract() 
method 
This2.Bool isRefine() 
method 
This2.Selector selector() 
method 
This1.Type.Return returnType() 
method 
This2.Size parameterTypeSize() 
method 
This1.Type.Parameter parameterType(This2.Size that) 
method 
This1.Type.Parameter.List parameterTypes() 
method 
This2.Size exceptionTypeSize() 
method 
This1.Type.Exception exceptionType(This2.Size that) 
method 
This1.Type.Exception.List exceptionTypes() 
refine read method 
This2.S toS() 
refine class method /*
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  */This2.S readableName() 
refine class method /*
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  */This2.Bool is(class This2.Concept.Classable subtype) 
refine read method 
This2.Bool #equalequal#0left(read Any right) 
refine class method 
read This0 cast(read This2.Concept.Classable that) 
refine class method 
mut This0 #cast(mut This2.Concept.Classable that) 
refine read method 
class This0 class() 
List: {implements This3.Concept.ToS, This3.Concept.Classable, This3.Concept.Equals
refine class method /*
  Cast a (read/imm) object to this type.
  A class implementing this method should refine the return type to This.
  if is(subtype) is true, then cast(that) must produce a result.
  */read This0 cast(read This3.Concept.Classable that) 
refine class method /*
  Cast a (mutable) object to this type.
  A class implementing this method should refine the return type to This.
  if cast(that) produces a result, then #cast(that) also must produce a result.
  */mut This0 #cast(mut This3.Concept.Classable that) 
refine read method /*
  Extracts the class singleton from another instance of this class
  */class This0 class() 
refine class method /*
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  */This3.S readableName() 
refine class method /*
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  */This3.Bool is(class This3.Concept.Classable subtype) 
read method 
read This3.Collections.MutListAny inner() 
mut method 
mut This3.Collections.MutListAny #inner() 
class method 
mut This0 #apply(fwd mut This3.Collections.MutListAny inner) 
class method 
This0 #immK(This3.Collections.MutListAny inner) 
class method 
mut This0 empty() 
read method 
mut This0 reverse() 
read method 
This3.Bool isEmpty() 
read method 
class This3.Size #default#val(Void that) 
read method 
This1 left() 
read method 
This1 right() 
mut method 
Void #apply(This3.Size that, This1 val) 
mut method 
Void left(This1 that) 
mut method 
Void right(This1 that) 
mut method 
Void add(This3.Size that, This1 val) 
mut method 
Void add(This1 right) 
mut method 
Void add(This1 left) 
mut method 
Void removeLeft() 
mut method 
Void removeRight() 
method 
This0 #plus#0left(This1 right) 
method 
This0 #plusplus#0left(This0 right) 
method 
This0 with(This3.Size that, This1 val) 
method 
This0 withLeft(This1 that) 
method 
This0 withRight(This1 that) 
method 
This0 withAlso(This3.Size that, This1 val) 
method 
This0 withAlsoLeft(This1 that) 
method 
This0 withAlsoRight(This1 that) 
method 
This0 withoutLeft() 
method 
This0 withoutRight() 
read method 
lent This0.IteratorVal vals(This3.Size from, This3.Size maxTo, This3.Size minTo) 
read method 
lent This0.IteratorVal vals(This3.Size minTo) 
read method 
lent This0.IteratorVal vals(This3.Size from, This3.Size to) 
read method 
lent This0.IteratorValFill vals(This3.Size from, This3.Size maxTo, This3.Size minTo, This1 filled) 
read method 
lent This0.IteratorValFill vals(This3.Size minTo, This1 filled) 
read method 
lent This0.IteratorValFill vals(This3.Size from, This3.Size to, This1 filled) 
read method 
lent This0.IteratorValFill vals(This1 filled) 
mut method 
lent This0.IteratorVar #vals(This3.Size from, This3.Size maxTo, This3.Size minTo) 
mut method 
lent This0.IteratorVar #vals(This3.Size minTo) 
mut method 
lent This0.IteratorVar #vals(This3.Size from, This3.Size to) 
mut method 
lent This0.IteratorVar #vals() 
refine read method 
This3.S toS() 
read method 
This3.Size size() 
read method 
This1 val(This3.Size that) 
class method 
mut This0 #seqBuilder() 
class method 
mut This0 #from(mut This0 seqBuilder) 
mut method 
Void #add(This1 that) 
read method 
lent This0.IteratorVal vals() 
read method 
This3.Bool contains(This1 that) 
method 
This0 #less#0left(This1 right) 
method 
This0 #lessless#0left(This0 right) 
method 
This0 #and#0left(This0 right) 
method 
This3.Bool #rightright#0left(This0 right) 
method 
This3.Bool #rightrightequal#0left(This0 right) 
method 
This3.Bool #right#0left(This1 right) 
read method 
This3.Bool equals(read This0 that) 
refine read method 
This3.Bool #equalequal#0left(read Any right) 
read method 
This3.Size indexOfLeft(This1 val) 
read method 
This3.Size indexOfRight(This1 val) 
method /*from VectorTrait
*/This0 without(This3.Size index) 
method 
This0 withoutLeft(This1 val) 
method 
This0 withoutRight(This1 val) 
method 
This0 withoutAll(This1 val) 
mut method /*from VectorTrait
*/Void remove(This3.Size that) 
mut method 
Void removeAll(This1 val) 
mut method 
Void removeLeft(This1 val) 
mut method 
Void removeRight(This1 val) 
Cast: {
class method 
This2 #apply(Any that) }
IteratorTrait: {
class method 
Library #apply() }
IteratorValFill: {
mut method 
Void #next() exception Void 
read method 
Void #checkEnd() 
read method 
This2 #inner() 
read method 
Void #close() 
read method 
read This4.Collections.MutListAny _that() 
mut method 
Void from(This4.Size that) 
read method 
This4.Size from() 
read method 
This4.Size maxTo() 
read method 
This4.Size minTo() 
read method 
This2 filled() 
read method 
read This4.Collections.MutListAny that() 
class method 
lent This0 #apply(read This4.Collections.MutListAny _that, This4.Size from, This4.Size maxTo, This4.Size minTo, This2 filled) 
class method 
lent This0 #apply(read This4.Collections.MutListAny that, This4.Size from, This4.Size maxTo, This4.Size minTo, This2 filled) 
read method 
This4.Bool isFill() }
IteratorVar: {
mut method 
Void #next() exception Void 
read method 
Void #checkEnd() 
read method 
This2 #inner() 
read method 
Void #close() 
read method 
read This4.Collections.MutListAny that() 
mut method 
mut This4.Collections.MutListAny #that() 
mut method 
Void from(This4.Size that) 
read method 
This4.Size from() 
read method 
This4.Size maxTo() 
read method 
This4.Size minTo() 
class method 
mut This0 #apply(mut This4.Collections.MutListAny that, This4.Size from, This4.Size maxTo, This4.Size minTo) 
mut method 
Void inner(This2 that) 
read method 
This4.Bool isFill() 
read method 
This2 filled() }
IteratorVal: {
read method 
read This4.Collections.MutListAny _that() 
mut method 
Void from(This4.Size that) 
read method 
This4.Size from() 
read method 
This4.Size maxTo() 
read method 
This4.Size minTo() 
read method 
read This4.Collections.MutListAny that() 
class method 
lent This0 #apply(read This4.Collections.MutListAny _that, This4.Size from, This4.Size maxTo, This4.Size minTo) 
class method 
lent This0 #apply(read This4.Collections.MutListAny that, This4.Size from, This4.Size maxTo, This4.Size minTo) 
read method 
This4.Bool isFill() 
read method 
This2 filled() 
mut method 
Void #next() exception Void 
read method 
Void #checkEnd() 
read method 
This2 #inner() 
read method 
Void #close() }}}
Type: {interface implements This1, This2.Concept.Base, This2.Concept.ToS, This2.Concept.Classable, This2.Concept.Equals
refine read method 
This2.S toS() 
refine class method /*
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  */This2.S readableName() 
refine class method /*
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  */This2.Bool is(class This2.Concept.Classable subtype) 
refine read method 
This2.Bool #equalequal#0left(read Any right) 
refine read method 
class This2.Concept.Base class() 
refine class method 
read This2.Concept.Base cast(read This2.Concept.Classable that) 
refine class method 
mut This2.Concept.Base #cast(mut This2.Concept.Classable that) 
refine method 
This2.Size originSize() 
refine method 
This1.Origin origin(This2.Size that) 
refine method 
This1 location() 
refine method 
This1.Doc doc() 
method 
This0.RefTo refTo() 
method 
This2.Size mdfS() 
method 
This1.Mdf mdf() 
DispatchRefTo: {
class method 
This1.RefTo #apply(Library that) }
Return: {/*@plugin  toFix 
@pluginPart is.L42.connected.withSafeOperators.location.Type$Return
*/implements This1, This2, This3.Concept.Base, This3.Concept.ToS, This3.Concept.Classable, This3.Concept.Equals
class method 
mut This0 #from(Library binaryRepr) 
read method 
Library #binaryRepr() 
class method 
Void #exceptionIf(Library binaryRepr) exception This0 
class method 
Library #pluginUnresponsive(Library binaryRepr) 
read method 
This3.Bool equals(read This0 that) 
method 
This2.Origin.List origins() 
refine method 
This3.Size originSize() 
refine method 
This2.Origin origin(This3.Size that) 
refine method 
This2.Doc doc() 
refine method 
This3.Size mdfS() 
refine method 
This2.Method location() 
refine method 
This1.RefTo refTo() 
refine method 
This2.Mdf mdf() 
refine read method 
This3.S toS() 
refine class method /*
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  */This3.S readableName() 
refine class method /*
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  */This3.Bool is(class This3.Concept.Classable subtype) 
refine read method 
This3.Bool #equalequal#0left(read Any right) 
refine class method 
read This0 cast(read This3.Concept.Classable that) 
refine class method 
mut This0 #cast(mut This3.Concept.Classable that) 
refine read method 
class This0 class() }
Parameter: {/*@plugin  toFix 
@pluginPart is.L42.connected.withSafeOperators.location.Type$Parameter     
*/implements This1, This2, This3.Concept.Base, This3.Concept.ToS, This3.Concept.Classable, This3.Concept.Equals
class method 
mut This0 #from(Library binaryRepr) 
read method 
Library #binaryRepr() 
class method 
Void #exceptionIf(Library binaryRepr) exception This0 
class method 
Library #pluginUnresponsive(Library binaryRepr) 
read method 
This3.Bool equals(read This0 that) 
method 
This2.Origin.List origins() 
refine method 
This3.Size originSize() 
refine method 
This2.Origin origin(This3.Size that) 
refine method 
This2.Doc doc() 
refine method 
This3.Size mdfS() 
refine method 
This2.Method location() 
refine method 
This1.RefTo refTo() 
refine method 
This2.Mdf mdf() 
method 
This3.Size pos() 
refine read method 
This3.S toS() 
refine class method /*
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  */This3.S readableName() 
refine class method /*
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  */This3.Bool is(class This3.Concept.Classable subtype) 
refine read method 
This3.Bool #equalequal#0left(read Any right) 
refine class method 
read This0 cast(read This3.Concept.Classable that) 
refine class method 
mut This0 #cast(mut This3.Concept.Classable that) 
refine read method 
class This0 class() 
List: {implements This4.Concept.ToS, This4.Concept.Classable, This4.Concept.Equals
refine class method /*
  Cast a (read/imm) object to this type.
  A class implementing this method should refine the return type to This.
  if is(subtype) is true, then cast(that) must produce a result.
  */read This0 cast(read This4.Concept.Classable that) 
refine class method /*
  Cast a (mutable) object to this type.
  A class implementing this method should refine the return type to This.
  if cast(that) produces a result, then #cast(that) also must produce a result.
  */mut This0 #cast(mut This4.Concept.Classable that) 
refine read method /*
  Extracts the class singleton from another instance of this class
  */class This0 class() 
refine class method /*
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  */This4.S readableName() 
refine class method /*
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  */This4.Bool is(class This4.Concept.Classable subtype) 
read method 
read This4.Collections.MutListAny inner() 
mut method 
mut This4.Collections.MutListAny #inner() 
class method 
mut This0 #apply(fwd mut This4.Collections.MutListAny inner) 
class method 
This0 #immK(This4.Collections.MutListAny inner) 
class method 
mut This0 empty() 
read method 
mut This0 reverse() 
read method 
This4.Bool isEmpty() 
read method 
class This4.Size #default#val(Void that) 
read method 
This1 left() 
read method 
This1 right() 
mut method 
Void #apply(This4.Size that, This1 val) 
mut method 
Void left(This1 that) 
mut method 
Void right(This1 that) 
mut method 
Void add(This4.Size that, This1 val) 
mut method 
Void add(This1 right) 
mut method 
Void add(This1 left) 
mut method 
Void removeLeft() 
mut method 
Void removeRight() 
method 
This0 #plus#0left(This1 right) 
method 
This0 #plusplus#0left(This0 right) 
method 
This0 with(This4.Size that, This1 val) 
method 
This0 withLeft(This1 that) 
method 
This0 withRight(This1 that) 
method 
This0 withAlso(This4.Size that, This1 val) 
method 
This0 withAlsoLeft(This1 that) 
method 
This0 withAlsoRight(This1 that) 
method 
This0 withoutLeft() 
method 
This0 withoutRight() 
read method 
lent This0.IteratorVal vals(This4.Size from, This4.Size maxTo, This4.Size minTo) 
read method 
lent This0.IteratorVal vals(This4.Size minTo) 
read method 
lent This0.IteratorVal vals(This4.Size from, This4.Size to) 
read method 
lent This0.IteratorValFill vals(This4.Size from, This4.Size maxTo, This4.Size minTo, This1 filled) 
read method 
lent This0.IteratorValFill vals(This4.Size minTo, This1 filled) 
read method 
lent This0.IteratorValFill vals(This4.Size from, This4.Size to, This1 filled) 
read method 
lent This0.IteratorValFill vals(This1 filled) 
mut method 
lent This0.IteratorVar #vals(This4.Size from, This4.Size maxTo, This4.Size minTo) 
mut method 
lent This0.IteratorVar #vals(This4.Size minTo) 
mut method 
lent This0.IteratorVar #vals(This4.Size from, This4.Size to) 
mut method 
lent This0.IteratorVar #vals() 
refine read method 
This4.S toS() 
read method 
This4.Size size() 
read method 
This1 val(This4.Size that) 
class method 
mut This0 #seqBuilder() 
class method 
mut This0 #from(mut This0 seqBuilder) 
mut method 
Void #add(This1 that) 
read method 
lent This0.IteratorVal vals() 
read method 
This4.Bool contains(This1 that) 
method 
This0 #less#0left(This1 right) 
method 
This0 #lessless#0left(This0 right) 
method 
This0 #and#0left(This0 right) 
method 
This4.Bool #rightright#0left(This0 right) 
method 
This4.Bool #rightrightequal#0left(This0 right) 
method 
This4.Bool #right#0left(This1 right) 
read method 
This4.Bool equals(read This0 that) 
refine read method 
This4.Bool #equalequal#0left(read Any right) 
read method 
This4.Size indexOfLeft(This1 val) 
read method 
This4.Size indexOfRight(This1 val) 
method /*from VectorTrait
*/This0 without(This4.Size index) 
method 
This0 withoutLeft(This1 val) 
method 
This0 withoutRight(This1 val) 
method 
This0 withoutAll(This1 val) 
mut method /*from VectorTrait
*/Void remove(This4.Size that) 
mut method 
Void removeAll(This1 val) 
mut method 
Void removeLeft(This1 val) 
mut method 
Void removeRight(This1 val) 
Cast: {
class method 
This2 #apply(Any that) }
IteratorTrait: {
class method 
Library #apply() }
IteratorValFill: {
mut method 
Void #next() exception Void 
read method 
Void #checkEnd() 
read method 
This2 #inner() 
read method 
Void #close() 
read method 
read This5.Collections.MutListAny _that() 
mut method 
Void from(This5.Size that) 
read method 
This5.Size from() 
read method 
This5.Size maxTo() 
read method 
This5.Size minTo() 
read method 
This2 filled() 
read method 
read This5.Collections.MutListAny that() 
class method 
lent This0 #apply(read This5.Collections.MutListAny _that, This5.Size from, This5.Size maxTo, This5.Size minTo, This2 filled) 
class method 
lent This0 #apply(read This5.Collections.MutListAny that, This5.Size from, This5.Size maxTo, This5.Size minTo, This2 filled) 
read method 
This5.Bool isFill() }
IteratorVar: {
mut method 
Void #next() exception Void 
read method 
Void #checkEnd() 
read method 
This2 #inner() 
read method 
Void #close() 
read method 
read This5.Collections.MutListAny that() 
mut method 
mut This5.Collections.MutListAny #that() 
mut method 
Void from(This5.Size that) 
read method 
This5.Size from() 
read method 
This5.Size maxTo() 
read method 
This5.Size minTo() 
class method 
mut This0 #apply(mut This5.Collections.MutListAny that, This5.Size from, This5.Size maxTo, This5.Size minTo) 
mut method 
Void inner(This2 that) 
read method 
This5.Bool isFill() 
read method 
This2 filled() }
IteratorVal: {
read method 
read This5.Collections.MutListAny _that() 
mut method 
Void from(This5.Size that) 
read method 
This5.Size from() 
read method 
This5.Size maxTo() 
read method 
This5.Size minTo() 
read method 
read This5.Collections.MutListAny that() 
class method 
lent This0 #apply(read This5.Collections.MutListAny _that, This5.Size from, This5.Size maxTo, This5.Size minTo) 
class method 
lent This0 #apply(read This5.Collections.MutListAny that, This5.Size from, This5.Size maxTo, This5.Size minTo) 
read method 
This5.Bool isFill() 
read method 
This2 filled() 
mut method 
Void #next() exception Void 
read method 
Void #checkEnd() 
read method 
This2 #inner() 
read method 
Void #close() }}}
Exception: {/*@plugin  toFix 
@pluginPart is.L42.connected.withSafeOperators.location.Type$Exception
*/implements This1, This2, This3.Concept.Base, This3.Concept.ToS, This3.Concept.Classable, This3.Concept.Equals
class method 
mut This0 #from(Library binaryRepr) 
read method 
Library #binaryRepr() 
class method 
Void #exceptionIf(Library binaryRepr) exception This0 
class method 
Library #pluginUnresponsive(Library binaryRepr) 
read method 
This3.Bool equals(read This0 that) 
method 
This2.Origin.List origins() 
refine method 
This3.Size originSize() 
refine method 
This2.Origin origin(This3.Size that) 
refine method 
This2.Doc doc() 
refine method 
This3.Size mdfS() 
refine method 
This2.Method location() 
refine method 
This1.RefTo refTo() 
refine method 
This2.Mdf mdf() 
method 
This3.Size pos() 
refine read method 
This3.S toS() 
refine class method /*
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  */This3.S readableName() 
refine class method /*
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  */This3.Bool is(class This3.Concept.Classable subtype) 
refine read method 
This3.Bool #equalequal#0left(read Any right) 
refine class method 
read This0 cast(read This3.Concept.Classable that) 
refine class method 
mut This0 #cast(mut This3.Concept.Classable that) 
refine read method 
class This0 class() 
List: {implements This4.Concept.ToS, This4.Concept.Classable, This4.Concept.Equals
refine class method /*
  Cast a (read/imm) object to this type.
  A class implementing this method should refine the return type to This.
  if is(subtype) is true, then cast(that) must produce a result.
  */read This0 cast(read This4.Concept.Classable that) 
refine class method /*
  Cast a (mutable) object to this type.
  A class implementing this method should refine the return type to This.
  if cast(that) produces a result, then #cast(that) also must produce a result.
  */mut This0 #cast(mut This4.Concept.Classable that) 
refine read method /*
  Extracts the class singleton from another instance of this class
  */class This0 class() 
refine class method /*
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  */This4.S readableName() 
refine class method /*
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  */This4.Bool is(class This4.Concept.Classable subtype) 
read method 
read This4.Collections.MutListAny inner() 
mut method 
mut This4.Collections.MutListAny #inner() 
class method 
mut This0 #apply(fwd mut This4.Collections.MutListAny inner) 
class method 
This0 #immK(This4.Collections.MutListAny inner) 
class method 
mut This0 empty() 
read method 
mut This0 reverse() 
read method 
This4.Bool isEmpty() 
read method 
class This4.Size #default#val(Void that) 
read method 
This1 left() 
read method 
This1 right() 
mut method 
Void #apply(This4.Size that, This1 val) 
mut method 
Void left(This1 that) 
mut method 
Void right(This1 that) 
mut method 
Void add(This4.Size that, This1 val) 
mut method 
Void add(This1 right) 
mut method 
Void add(This1 left) 
mut method 
Void removeLeft() 
mut method 
Void removeRight() 
method 
This0 #plus#0left(This1 right) 
method 
This0 #plusplus#0left(This0 right) 
method 
This0 with(This4.Size that, This1 val) 
method 
This0 withLeft(This1 that) 
method 
This0 withRight(This1 that) 
method 
This0 withAlso(This4.Size that, This1 val) 
method 
This0 withAlsoLeft(This1 that) 
method 
This0 withAlsoRight(This1 that) 
method 
This0 withoutLeft() 
method 
This0 withoutRight() 
read method 
lent This0.IteratorVal vals(This4.Size from, This4.Size maxTo, This4.Size minTo) 
read method 
lent This0.IteratorVal vals(This4.Size minTo) 
read method 
lent This0.IteratorVal vals(This4.Size from, This4.Size to) 
read method 
lent This0.IteratorValFill vals(This4.Size from, This4.Size maxTo, This4.Size minTo, This1 filled) 
read method 
lent This0.IteratorValFill vals(This4.Size minTo, This1 filled) 
read method 
lent This0.IteratorValFill vals(This4.Size from, This4.Size to, This1 filled) 
read method 
lent This0.IteratorValFill vals(This1 filled) 
mut method 
lent This0.IteratorVar #vals(This4.Size from, This4.Size maxTo, This4.Size minTo) 
mut method 
lent This0.IteratorVar #vals(This4.Size minTo) 
mut method 
lent This0.IteratorVar #vals(This4.Size from, This4.Size to) 
mut method 
lent This0.IteratorVar #vals() 
refine read method 
This4.S toS() 
read method 
This4.Size size() 
read method 
This1 val(This4.Size that) 
class method 
mut This0 #seqBuilder() 
class method 
mut This0 #from(mut This0 seqBuilder) 
mut method 
Void #add(This1 that) 
read method 
lent This0.IteratorVal vals() 
read method 
This4.Bool contains(This1 that) 
method 
This0 #less#0left(This1 right) 
method 
This0 #lessless#0left(This0 right) 
method 
This0 #and#0left(This0 right) 
method 
This4.Bool #rightright#0left(This0 right) 
method 
This4.Bool #rightrightequal#0left(This0 right) 
method 
This4.Bool #right#0left(This1 right) 
read method 
This4.Bool equals(read This0 that) 
refine read method 
This4.Bool #equalequal#0left(read Any right) 
read method 
This4.Size indexOfLeft(This1 val) 
read method 
This4.Size indexOfRight(This1 val) 
method /*from VectorTrait
*/This0 without(This4.Size index) 
method 
This0 withoutLeft(This1 val) 
method 
This0 withoutRight(This1 val) 
method 
This0 withoutAll(This1 val) 
mut method /*from VectorTrait
*/Void remove(This4.Size that) 
mut method 
Void removeAll(This1 val) 
mut method 
Void removeLeft(This1 val) 
mut method 
Void removeRight(This1 val) 
Cast: {
class method 
This2 #apply(Any that) }
IteratorTrait: {
class method 
Library #apply() }
IteratorValFill: {
mut method 
Void #next() exception Void 
read method 
Void #checkEnd() 
read method 
This2 #inner() 
read method 
Void #close() 
read method 
read This5.Collections.MutListAny _that() 
mut method 
Void from(This5.Size that) 
read method 
This5.Size from() 
read method 
This5.Size maxTo() 
read method 
This5.Size minTo() 
read method 
This2 filled() 
read method 
read This5.Collections.MutListAny that() 
class method 
lent This0 #apply(read This5.Collections.MutListAny _that, This5.Size from, This5.Size maxTo, This5.Size minTo, This2 filled) 
class method 
lent This0 #apply(read This5.Collections.MutListAny that, This5.Size from, This5.Size maxTo, This5.Size minTo, This2 filled) 
read method 
This5.Bool isFill() }
IteratorVar: {
mut method 
Void #next() exception Void 
read method 
Void #checkEnd() 
read method 
This2 #inner() 
read method 
Void #close() 
read method 
read This5.Collections.MutListAny that() 
mut method 
mut This5.Collections.MutListAny #that() 
mut method 
Void from(This5.Size that) 
read method 
This5.Size from() 
read method 
This5.Size maxTo() 
read method 
This5.Size minTo() 
class method 
mut This0 #apply(mut This5.Collections.MutListAny that, This5.Size from, This5.Size maxTo, This5.Size minTo) 
mut method 
Void inner(This2 that) 
read method 
This5.Bool isFill() 
read method 
This2 filled() }
IteratorVal: {
read method 
read This5.Collections.MutListAny _that() 
mut method 
Void from(This5.Size that) 
read method 
This5.Size from() 
read method 
This5.Size maxTo() 
read method 
This5.Size minTo() 
read method 
read This5.Collections.MutListAny that() 
class method 
lent This0 #apply(read This5.Collections.MutListAny _that, This5.Size from, This5.Size maxTo, This5.Size minTo) 
class method 
lent This0 #apply(read This5.Collections.MutListAny that, This5.Size from, This5.Size maxTo, This5.Size minTo) 
read method 
This5.Bool isFill() 
read method 
This2 filled() 
mut method 
Void #next() exception Void 
read method 
Void #checkEnd() 
read method 
This2 #inner() 
read method 
Void #close() }}}
Implemented: {/*@plugin  toFix 
@pluginPart is.L42.connected.withSafeOperators.location.Type$Implemented
*/implements This1, This2, This3.Concept.Base, This3.Concept.ToS, This3.Concept.Classable, This3.Concept.Equals
class method 
mut This0 #from(Library binaryRepr) 
read method 
Library #binaryRepr() 
class method 
Void #exceptionIf(Library binaryRepr) exception This0 
class method 
Library #pluginUnresponsive(Library binaryRepr) 
read method 
This3.Bool equals(read This0 that) 
method 
This2.Origin.List origins() 
refine method 
This3.Size originSize() 
refine method 
This2.Origin origin(This3.Size that) 
refine method 
This2.Doc doc() 
refine method 
This3.Size mdfS() 
refine method 
This2.Lib location() 
refine method 
This1.RefTo refTo() 
refine method 
This2.Mdf mdf() 
method 
This3.Size pos() 
refine read method 
This3.S toS() 
refine class method /*
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  */This3.S readableName() 
refine class method /*
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  */This3.Bool is(class This3.Concept.Classable subtype) 
refine read method 
This3.Bool #equalequal#0left(read Any right) 
refine class method 
read This0 cast(read This3.Concept.Classable that) 
refine class method 
mut This0 #cast(mut This3.Concept.Classable that) 
refine read method 
class This0 class() 
List: {implements This4.Concept.ToS, This4.Concept.Classable, This4.Concept.Equals
refine class method /*
  Cast a (read/imm) object to this type.
  A class implementing this method should refine the return type to This.
  if is(subtype) is true, then cast(that) must produce a result.
  */read This0 cast(read This4.Concept.Classable that) 
refine class method /*
  Cast a (mutable) object to this type.
  A class implementing this method should refine the return type to This.
  if cast(that) produces a result, then #cast(that) also must produce a result.
  */mut This0 #cast(mut This4.Concept.Classable that) 
refine read method /*
  Extracts the class singleton from another instance of this class
  */class This0 class() 
refine class method /*
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  */This4.S readableName() 
refine class method /*
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  */This4.Bool is(class This4.Concept.Classable subtype) 
read method 
read This4.Collections.MutListAny inner() 
mut method 
mut This4.Collections.MutListAny #inner() 
class method 
mut This0 #apply(fwd mut This4.Collections.MutListAny inner) 
class method 
This0 #immK(This4.Collections.MutListAny inner) 
class method 
mut This0 empty() 
read method 
mut This0 reverse() 
read method 
This4.Bool isEmpty() 
read method 
class This4.Size #default#val(Void that) 
read method 
This1 left() 
read method 
This1 right() 
mut method 
Void #apply(This4.Size that, This1 val) 
mut method 
Void left(This1 that) 
mut method 
Void right(This1 that) 
mut method 
Void add(This4.Size that, This1 val) 
mut method 
Void add(This1 right) 
mut method 
Void add(This1 left) 
mut method 
Void removeLeft() 
mut method 
Void removeRight() 
method 
This0 #plus#0left(This1 right) 
method 
This0 #plusplus#0left(This0 right) 
method 
This0 with(This4.Size that, This1 val) 
method 
This0 withLeft(This1 that) 
method 
This0 withRight(This1 that) 
method 
This0 withAlso(This4.Size that, This1 val) 
method 
This0 withAlsoLeft(This1 that) 
method 
This0 withAlsoRight(This1 that) 
method 
This0 withoutLeft() 
method 
This0 withoutRight() 
read method 
lent This0.IteratorVal vals(This4.Size from, This4.Size maxTo, This4.Size minTo) 
read method 
lent This0.IteratorVal vals(This4.Size minTo) 
read method 
lent This0.IteratorVal vals(This4.Size from, This4.Size to) 
read method 
lent This0.IteratorValFill vals(This4.Size from, This4.Size maxTo, This4.Size minTo, This1 filled) 
read method 
lent This0.IteratorValFill vals(This4.Size minTo, This1 filled) 
read method 
lent This0.IteratorValFill vals(This4.Size from, This4.Size to, This1 filled) 
read method 
lent This0.IteratorValFill vals(This1 filled) 
mut method 
lent This0.IteratorVar #vals(This4.Size from, This4.Size maxTo, This4.Size minTo) 
mut method 
lent This0.IteratorVar #vals(This4.Size minTo) 
mut method 
lent This0.IteratorVar #vals(This4.Size from, This4.Size to) 
mut method 
lent This0.IteratorVar #vals() 
refine read method 
This4.S toS() 
read method 
This4.Size size() 
read method 
This1 val(This4.Size that) 
class method 
mut This0 #seqBuilder() 
class method 
mut This0 #from(mut This0 seqBuilder) 
mut method 
Void #add(This1 that) 
read method 
lent This0.IteratorVal vals() 
read method 
This4.Bool contains(This1 that) 
method 
This0 #less#0left(This1 right) 
method 
This0 #lessless#0left(This0 right) 
method 
This0 #and#0left(This0 right) 
method 
This4.Bool #rightright#0left(This0 right) 
method 
This4.Bool #rightrightequal#0left(This0 right) 
method 
This4.Bool #right#0left(This1 right) 
read method 
This4.Bool equals(read This0 that) 
refine read method 
This4.Bool #equalequal#0left(read Any right) 
read method 
This4.Size indexOfLeft(This1 val) 
read method 
This4.Size indexOfRight(This1 val) 
method /*from VectorTrait
*/This0 without(This4.Size index) 
method 
This0 withoutLeft(This1 val) 
method 
This0 withoutRight(This1 val) 
method 
This0 withoutAll(This1 val) 
mut method /*from VectorTrait
*/Void remove(This4.Size that) 
mut method 
Void removeAll(This1 val) 
mut method 
Void removeLeft(This1 val) 
mut method 
Void removeRight(This1 val) 
Cast: {
class method 
This2 #apply(Any that) }
IteratorTrait: {
class method 
Library #apply() }
IteratorValFill: {
mut method 
Void #next() exception Void 
read method 
Void #checkEnd() 
read method 
This2 #inner() 
read method 
Void #close() 
read method 
read This5.Collections.MutListAny _that() 
mut method 
Void from(This5.Size that) 
read method 
This5.Size from() 
read method 
This5.Size maxTo() 
read method 
This5.Size minTo() 
read method 
This2 filled() 
read method 
read This5.Collections.MutListAny that() 
class method 
lent This0 #apply(read This5.Collections.MutListAny _that, This5.Size from, This5.Size maxTo, This5.Size minTo, This2 filled) 
class method 
lent This0 #apply(read This5.Collections.MutListAny that, This5.Size from, This5.Size maxTo, This5.Size minTo, This2 filled) 
read method 
This5.Bool isFill() }
IteratorVar: {
mut method 
Void #next() exception Void 
read method 
Void #checkEnd() 
read method 
This2 #inner() 
read method 
Void #close() 
read method 
read This5.Collections.MutListAny that() 
mut method 
mut This5.Collections.MutListAny #that() 
mut method 
Void from(This5.Size that) 
read method 
This5.Size from() 
read method 
This5.Size maxTo() 
read method 
This5.Size minTo() 
class method 
mut This0 #apply(mut This5.Collections.MutListAny that, This5.Size from, This5.Size maxTo, This5.Size minTo) 
mut method 
Void inner(This2 that) 
read method 
This5.Bool isFill() 
read method 
This2 filled() }
IteratorVal: {
read method 
read This5.Collections.MutListAny _that() 
mut method 
Void from(This5.Size that) 
read method 
This5.Size from() 
read method 
This5.Size maxTo() 
read method 
This5.Size minTo() 
read method 
read This5.Collections.MutListAny that() 
class method 
lent This0 #apply(read This5.Collections.MutListAny _that, This5.Size from, This5.Size maxTo, This5.Size minTo) 
class method 
lent This0 #apply(read This5.Collections.MutListAny that, This5.Size from, This5.Size maxTo, This5.Size minTo) 
read method 
This5.Bool isFill() 
read method 
This2 filled() 
mut method 
Void #next() exception Void 
read method 
Void #checkEnd() 
read method 
This2 #inner() 
read method 
Void #close() }}}
RefTo: {interface implements This3.Concept.Base, This3.Concept.ToS, This3.Concept.Classable, This3.Concept.Equals
refine read method 
This3.S toS() 
refine class method /*
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  */This3.S readableName() 
refine class method /*
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  */This3.Bool is(class This3.Concept.Classable subtype) 
refine read method 
This3.Bool #equalequal#0left(read Any right) 
refine read method 
class This3.Concept.Base class() 
refine class method 
read This3.Concept.Base cast(read This3.Concept.Classable that) 
refine class method 
mut This3.Concept.Base #cast(mut This3.Concept.Classable that) 
Lib: {/*@plugin  toFix 
@pluginPart is.L42.connected.withSafeOperators.location.TypeRefTo$Lib
*/implements This4.Concept.Base, This4.Concept.ToS, This4.Concept.Classable, This4.Concept.Equals, This1
class method 
mut This0 #from(Library binaryRepr) 
read method 
Library #binaryRepr() 
class method 
Void #exceptionIf(Library binaryRepr) exception This0 
class method 
Library #pluginUnresponsive(Library binaryRepr) 
read method 
This4.Bool equals(read This0 that) 
method 
This3.Lib referredLib() 
refine read method 
This4.S toS() 
refine class method /*
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  */This4.S readableName() 
refine class method /*
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  */This4.Bool is(class This4.Concept.Classable subtype) 
refine read method 
This4.Bool #equalequal#0left(read Any right) 
refine class method 
read This0 cast(read This4.Concept.Classable that) 
refine class method 
mut This0 #cast(mut This4.Concept.Classable that) 
refine read method 
class This0 class() }
Unavailable: {/*@plugin  toFix 
@pluginPart is.L42.connected.withSafeOperators.location.TypeRefTo$Unavailable
*/implements This4.Concept.Base, This4.Concept.ToS, This4.Concept.Classable, This4.Concept.Equals, This1
class method 
mut This0 #from(Library binaryRepr) 
read method 
Library #binaryRepr() 
class method 
Void #exceptionIf(Library binaryRepr) exception This0 
class method 
Library #pluginUnresponsive(Library binaryRepr) 
read method 
This4.Bool equals(read This0 that) 
refine read method 
This4.S toS() 
refine class method /*
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  */This4.S readableName() 
refine class method /*
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  */This4.Bool is(class This4.Concept.Classable subtype) 
refine read method 
This4.Bool #equalequal#0left(read Any right) 
refine class method 
read This0 cast(read This4.Concept.Classable that) 
refine class method 
mut This0 #cast(mut This4.Concept.Classable that) 
refine read method 
class This0 class() }
Binded: {/*@plugin  toFix 
@pluginPart is.L42.connected.withSafeOperators.location.TypeRefTo$Binded
*/implements This4.Concept.Base, This4.Concept.ToS, This4.Concept.Classable, This4.Concept.Equals, This1/*includes primitives
*/
class method 
mut This0 #from(Library binaryRepr) 
read method 
Library #binaryRepr() 
class method 
Void #exceptionIf(Library binaryRepr) exception This0 
class method 
Library #pluginUnresponsive(Library binaryRepr) 
read method 
This4.Bool equals(read This0 that) 
method 
class Any referredClassObj() 
class method 
This0 #apply(class Any classObj) 
class method 
This4.Bool equalsClassObj(class Any that, class Any and) 
refine read method 
This4.S toS() 
refine class method /*
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  */This4.S readableName() 
refine class method /*
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  */This4.Bool is(class This4.Concept.Classable subtype) 
refine read method 
This4.Bool #equalequal#0left(read Any right) 
refine class method 
read This0 cast(read This4.Concept.Classable that) 
refine class method 
mut This0 #cast(mut This4.Concept.Classable that) 
refine read method 
class This0 class() }
Missing: {/*@plugin  toFix 
@pluginPart is.L42.connected.withSafeOperators.location.TypeRefTo$Missing
*/implements This4.Concept.Base, This4.Concept.ToS, This4.Concept.Classable, This4.Concept.Equals, This1
class method 
mut This0 #from(Library binaryRepr) 
read method 
Library #binaryRepr() 
class method 
Void #exceptionIf(Library binaryRepr) exception This0 
class method 
Library #pluginUnresponsive(Library binaryRepr) 
read method 
This4.Bool equals(read This0 that) 
refine read method 
This4.S toS() 
refine class method /*
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  */This4.S readableName() 
refine class method /*
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  */This4.Bool is(class This4.Concept.Classable subtype) 
refine read method 
This4.Bool #equalequal#0left(read Any right) 
refine class method 
read This0 cast(read This4.Concept.Classable that) 
refine class method 
mut This0 #cast(mut This4.Concept.Classable that) 
refine read method 
class This0 class() }}}
Doc: {/*user will need typecase to discover precise type, location() not refined
@plugin  toFix 
@pluginPart is.L42.connected.withSafeOperators.location.Doc
*/implements This1, This2.Concept.Base, This2.Concept.ToS, This2.Concept.Classable, This2.Concept.Equals
class method 
mut This0 #from(Library binaryRepr) 
read method 
Library #binaryRepr() 
class method 
Void #exceptionIf(Library binaryRepr) exception This0 
class method 
Library #pluginUnresponsive(Library binaryRepr) 
read method 
This2.Bool equals(read This0 that) 
method 
This1.Origin.List origins() 
refine method 
This2.Size originSize() 
refine method 
This1.Origin origin(This2.Size that) 
refine method 
This0 doc() 
refine method 
This1 location() 
method 
This2.Size annotationSize() 
method 
This0.Annotation annotation(This2.Size that) 
method 
This0.Annotation.List annotations() 
refine read method 
This2.S toS() 
refine class method /*
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  */This2.S readableName() 
refine class method /*
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  */This2.Bool is(class This2.Concept.Classable subtype) 
refine read method 
This2.Bool #equalequal#0left(read Any right) 
refine class method 
read This0 cast(read This2.Concept.Classable that) 
refine class method 
mut This0 #cast(mut This2.Concept.Classable that) 
refine read method 
class This0 class() 
Annotation: {/*@plugin  toFix 
@pluginPart is.L42.connected.withSafeOperators.location.Doc$Annotation
*/implements This3.Concept.Base, This3.Concept.ToS, This3.Concept.Classable, This3.Concept.Equals
class method 
mut This0 #from(Library binaryRepr) 
read method 
Library #binaryRepr() 
class method 
Void #exceptionIf(Library binaryRepr) exception This0 
read method 
This3.Bool equals(read This0 that) 
method 
This2.Type.RefTo title() 
method 
This3.S text() 
class method 
Library #pluginUnresponsive(Library binaryRepr) 
refine read method 
This3.S toS() 
refine class method /*
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  */This3.S readableName() 
refine class method /*
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  */This3.Bool is(class This3.Concept.Classable subtype) 
refine read method 
This3.Bool #equalequal#0left(read Any right) 
refine class method 
read This0 cast(read This3.Concept.Classable that) 
refine class method 
mut This0 #cast(mut This3.Concept.Classable that) 
refine read method 
class This0 class() 
List: {implements This4.Concept.ToS, This4.Concept.Classable, This4.Concept.Equals
refine class method /*
  Cast a (read/imm) object to this type.
  A class implementing this method should refine the return type to This.
  if is(subtype) is true, then cast(that) must produce a result.
  */read This0 cast(read This4.Concept.Classable that) 
refine class method /*
  Cast a (mutable) object to this type.
  A class implementing this method should refine the return type to This.
  if cast(that) produces a result, then #cast(that) also must produce a result.
  */mut This0 #cast(mut This4.Concept.Classable that) 
refine read method /*
  Extracts the class singleton from another instance of this class
  */class This0 class() 
refine class method /*
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  */This4.S readableName() 
refine class method /*
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  */This4.Bool is(class This4.Concept.Classable subtype) 
read method 
read This4.Collections.MutListAny inner() 
mut method 
mut This4.Collections.MutListAny #inner() 
class method 
mut This0 #apply(fwd mut This4.Collections.MutListAny inner) 
class method 
This0 #immK(This4.Collections.MutListAny inner) 
class method 
mut This0 empty() 
read method 
mut This0 reverse() 
read method 
This4.Bool isEmpty() 
read method 
class This4.Size #default#val(Void that) 
read method 
This1 left() 
read method 
This1 right() 
mut method 
Void #apply(This4.Size that, This1 val) 
mut method 
Void left(This1 that) 
mut method 
Void right(This1 that) 
mut method 
Void add(This4.Size that, This1 val) 
mut method 
Void add(This1 right) 
mut method 
Void add(This1 left) 
mut method 
Void removeLeft() 
mut method 
Void removeRight() 
method 
This0 #plus#0left(This1 right) 
method 
This0 #plusplus#0left(This0 right) 
method 
This0 with(This4.Size that, This1 val) 
method 
This0 withLeft(This1 that) 
method 
This0 withRight(This1 that) 
method 
This0 withAlso(This4.Size that, This1 val) 
method 
This0 withAlsoLeft(This1 that) 
method 
This0 withAlsoRight(This1 that) 
method 
This0 withoutLeft() 
method 
This0 withoutRight() 
read method 
lent This0.IteratorVal vals(This4.Size from, This4.Size maxTo, This4.Size minTo) 
read method 
lent This0.IteratorVal vals(This4.Size minTo) 
read method 
lent This0.IteratorVal vals(This4.Size from, This4.Size to) 
read method 
lent This0.IteratorValFill vals(This4.Size from, This4.Size maxTo, This4.Size minTo, This1 filled) 
read method 
lent This0.IteratorValFill vals(This4.Size minTo, This1 filled) 
read method 
lent This0.IteratorValFill vals(This4.Size from, This4.Size to, This1 filled) 
read method 
lent This0.IteratorValFill vals(This1 filled) 
mut method 
lent This0.IteratorVar #vals(This4.Size from, This4.Size maxTo, This4.Size minTo) 
mut method 
lent This0.IteratorVar #vals(This4.Size minTo) 
mut method 
lent This0.IteratorVar #vals(This4.Size from, This4.Size to) 
mut method 
lent This0.IteratorVar #vals() 
refine read method 
This4.S toS() 
read method 
This4.Size size() 
read method 
This1 val(This4.Size that) 
class method 
mut This0 #seqBuilder() 
class method 
mut This0 #from(mut This0 seqBuilder) 
mut method 
Void #add(This1 that) 
read method 
lent This0.IteratorVal vals() 
read method 
This4.Bool contains(This1 that) 
method 
This0 #less#0left(This1 right) 
method 
This0 #lessless#0left(This0 right) 
method 
This0 #and#0left(This0 right) 
method 
This4.Bool #rightright#0left(This0 right) 
method 
This4.Bool #rightrightequal#0left(This0 right) 
method 
This4.Bool #right#0left(This1 right) 
read method 
This4.Bool equals(read This0 that) 
refine read method 
This4.Bool #equalequal#0left(read Any right) 
read method 
This4.Size indexOfLeft(This1 val) 
read method 
This4.Size indexOfRight(This1 val) 
method /*from VectorTrait
*/This0 without(This4.Size index) 
method 
This0 withoutLeft(This1 val) 
method 
This0 withoutRight(This1 val) 
method 
This0 withoutAll(This1 val) 
mut method /*from VectorTrait
*/Void remove(This4.Size that) 
mut method 
Void removeAll(This1 val) 
mut method 
Void removeLeft(This1 val) 
mut method 
Void removeRight(This1 val) 
Cast: {
class method 
This2 #apply(Any that) }
IteratorTrait: {
class method 
Library #apply() }
IteratorValFill: {
mut method 
Void #next() exception Void 
read method 
Void #checkEnd() 
read method 
This2 #inner() 
read method 
Void #close() 
read method 
read This5.Collections.MutListAny _that() 
mut method 
Void from(This5.Size that) 
read method 
This5.Size from() 
read method 
This5.Size maxTo() 
read method 
This5.Size minTo() 
read method 
This2 filled() 
read method 
read This5.Collections.MutListAny that() 
class method 
lent This0 #apply(read This5.Collections.MutListAny _that, This5.Size from, This5.Size maxTo, This5.Size minTo, This2 filled) 
class method 
lent This0 #apply(read This5.Collections.MutListAny that, This5.Size from, This5.Size maxTo, This5.Size minTo, This2 filled) 
read method 
This5.Bool isFill() }
IteratorVar: {
mut method 
Void #next() exception Void 
read method 
Void #checkEnd() 
read method 
This2 #inner() 
read method 
Void #close() 
read method 
read This5.Collections.MutListAny that() 
mut method 
mut This5.Collections.MutListAny #that() 
mut method 
Void from(This5.Size that) 
read method 
This5.Size from() 
read method 
This5.Size maxTo() 
read method 
This5.Size minTo() 
class method 
mut This0 #apply(mut This5.Collections.MutListAny that, This5.Size from, This5.Size maxTo, This5.Size minTo) 
mut method 
Void inner(This2 that) 
read method 
This5.Bool isFill() 
read method 
This2 filled() }
IteratorVal: {
read method 
read This5.Collections.MutListAny _that() 
mut method 
Void from(This5.Size that) 
read method 
This5.Size from() 
read method 
This5.Size maxTo() 
read method 
This5.Size minTo() 
read method 
read This5.Collections.MutListAny that() 
class method 
lent This0 #apply(read This5.Collections.MutListAny _that, This5.Size from, This5.Size maxTo, This5.Size minTo) 
class method 
lent This0 #apply(read This5.Collections.MutListAny that, This5.Size from, This5.Size maxTo, This5.Size minTo) 
read method 
This5.Bool isFill() 
read method 
This2 filled() 
mut method 
Void #next() exception Void 
read method 
Void #checkEnd() 
read method 
This2 #inner() 
read method 
Void #close() }}}}}
Refactor2: {/*------------------------------
Infrastructure
------------------------------
*/
class method 
Library compose(Library that, Library and) exception This0.MethodClash, This0.ClassClash, This0.SubtleSubtypeViolation 
class method 
class This1.Path #default#rename(Void path) 
class method 
class This1.Path #default#rename(Void into) 
class method 
This0.RenameClass rename(This1.Path path, This1.Path into) 
class method 
class This1.Path #default#hide(Void path) 
class method 
This0.HideClass hide(This1.Path path) 
class method 
class This1.Path #default#toAbstract(Void path) 
class method 
This0.ToAbstractClass toAbstract(This1.Path path) 
class method 
This0.ToAbstract toAbstract(This1.Selector selector) 
class method 
This0.ToAbstractDest toAbstract(This1.Selector selector, This1.Selector into) 
class method 
This0.ToAbstractPath toAbstract(This1.Selector selector, This1.Path of) 
class method 
This0.ToAbstractPathDest toAbstract(This1.Selector selector, This1.Path of, This1.Selector into) 
class method 
class This1.Selector #default#toAbstract(Void selector) 
class method 
class This1.Selector #default#toAbstract(Void into) 
class method 
class This1.Path #default#toAbstract(Void of) 
class method 
class This1.Path #default#redirect(Void path) 
class method 
This0.Redirect redirect(This1.Path path, class Any into) 
class method 
This0.RedirectRefTo redirect(This1.Path path, This1.Location.Type.RefTo intoRefTo) 
class method 
Library makeDoc(This1.S that) 
class method 
This0.SumMethods sumMethods(This1.Selector that, This1.Selector and, This1.Path of, This1.S over, This1.Selector into) 
Fail: {interface implements This2.Guard, This2.Message, This2.Concept.Base, This2.Concept.ToS, This2.Concept.Classable, This2.Concept.Equals
refine read method 
This2.S toS() 
refine class method /*
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  */This2.S readableName() 
refine class method /*
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  */This2.Bool is(class This2.Concept.Classable subtype) 
refine read method 
This2.Bool #equalequal#0left(read Any right) 
refine class method 
read This2.Concept.Base cast(read This2.Concept.Classable that) 
refine class method 
mut This2.Concept.Base #cast(mut This2.Concept.Classable that) 
refine class method 
This2.S kind() 
refine read method 
This2.S text() 
refine read method 
This2.Message.Opt responseOf() 
refine read method 
class This2.Message class() }
ErrorW: {
class method 
Library trait() 
class method 
Library #leftrightleft#0left(Library right) }
ParseFail: {/*@pluginPart is.L42.connected.withSafeOperators.pluginWrapper.RefactorErrors$ParseFail
@plugin is.L42.connected.withSafeOperators
*/implements This1.Fail, This2.Guard, This2.Message, This2.Concept.Base, This2.Concept.ToS, This2.Concept.Classable, This2.Concept.Equals
class method 
mut This0 #from(Library binaryRepr) 
read method 
Library #binaryRepr() 
class method 
Void #exceptionIf(Library binaryRepr) exception This0 
read method 
This2.Bool equals(read This0 that) 
method 
This2.S string() 
method 
This2.S expected() 
refine class method /*
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  */This2.S readableName() 
refine class method /*
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  */This2.Bool is(class This2.Concept.Classable subtype) 
refine read method 
This2.Bool #equalequal#0left(read Any right) 
refine class method 
read This0 cast(read This2.Concept.Classable that) 
refine class method 
mut This0 #cast(mut This2.Concept.Classable that) 
refine read method 
This2.S text() 
refine read method 
class This0 class() 
refine class method 
This2.S kind() 
refine read method 
This2.Message.Opt responseOf() 
refine read method 
This2.S toS() 
class method 
Library #pluginUnresponsive(Library binaryRepr) }
UnresolvedOverloading: {/*@pluginPart is.L42.connected.withSafeOperators.pluginWrapper.RefactorErrors$UnresolvedOverloading
@plugin is.L42.connected.withSafeOperators
*/implements This1.Fail, This2.Guard, This2.Message, This2.Concept.Base, This2.Concept.ToS, This2.Concept.Classable, This2.Concept.Equals
class method 
mut This0 #from(Library binaryRepr) 
read method 
Library #binaryRepr() 
class method 
Void #exceptionIf(Library binaryRepr) exception This0 
read method 
This2.Bool equals(read This0 that) 
refine class method /*
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  */This2.S readableName() 
refine class method /*
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  */This2.Bool is(class This2.Concept.Classable subtype) 
refine read method 
This2.Bool #equalequal#0left(read Any right) 
refine class method 
read This0 cast(read This2.Concept.Classable that) 
refine class method 
mut This0 #cast(mut This2.Concept.Classable that) 
refine read method 
This2.S text() 
refine read method 
class This0 class() 
refine class method 
This2.S kind() 
refine read method 
This2.Message.Opt responseOf() 
refine read method 
This2.S toS() 
class method 
Library #pluginUnresponsive(Library binaryRepr) }
ClassUnfit: {/*@pluginPart is.L42.connected.withSafeOperators.pluginWrapper.RefactorErrors$ClassUnfit
@plugin is.L42.connected.withSafeOperators
*/implements This1.Fail, This2.Guard, This2.Message, This2.Concept.Base, This2.Concept.ToS, This2.Concept.Classable, This2.Concept.Equals
class method 
mut This0 #from(Library binaryRepr) 
read method 
Library #binaryRepr() 
class method 
Void #exceptionIf(Library binaryRepr) exception This0 
read method 
This2.Bool equals(read This0 that) 
refine class method /*
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  */This2.S readableName() 
refine class method /*
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  */This2.Bool is(class This2.Concept.Classable subtype) 
refine read method 
This2.Bool #equalequal#0left(read Any right) 
refine class method 
read This0 cast(read This2.Concept.Classable that) 
refine class method 
mut This0 #cast(mut This2.Concept.Classable that) 
refine read method 
This2.S text() 
refine read method 
class This0 class() 
refine class method 
This2.S kind() 
refine read method 
This2.Message.Opt responseOf() 
refine read method 
This2.S toS() 
class method 
Library #pluginUnresponsive(Library binaryRepr) }
MethodUnfit: {/*@pluginPart is.L42.connected.withSafeOperators.pluginWrapper.RefactorErrors$MethodUnfit
@plugin is.L42.connected.withSafeOperators
*/implements This1.Fail, This2.Guard, This2.Message, This2.Concept.Base, This2.Concept.ToS, This2.Concept.Classable, This2.Concept.Equals
class method 
mut This0 #from(Library binaryRepr) 
read method 
Library #binaryRepr() 
class method 
Void #exceptionIf(Library binaryRepr) exception This0 
read method 
This2.Bool equals(read This0 that) 
refine class method /*
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  */This2.S readableName() 
refine class method /*
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  */This2.Bool is(class This2.Concept.Classable subtype) 
refine read method 
This2.Bool #equalequal#0left(read Any right) 
refine class method 
read This0 cast(read This2.Concept.Classable that) 
refine class method 
mut This0 #cast(mut This2.Concept.Classable that) 
refine read method 
This2.S text() 
refine read method 
class This0 class() 
refine class method 
This2.S kind() 
refine read method 
This2.Message.Opt responseOf() 
refine read method 
This2.S toS() 
class method 
Library #pluginUnresponsive(Library binaryRepr) }
ClassClash: {/*@pluginPart is.L42.connected.withSafeOperators.pluginWrapper.RefactorErrors$ClassClash
@plugin is.L42.connected.withSafeOperators
*/implements This1.Fail, This2.Guard, This2.Message, This2.Concept.Base, This2.Concept.ToS, This2.Concept.Classable, This2.Concept.Equals
class method 
mut This0 #from(Library binaryRepr) 
read method 
Library #binaryRepr() 
class method 
Void #exceptionIf(Library binaryRepr) exception This0 
read method 
This2.Bool equals(read This0 that) 
method 
This2.Location.Lib left() 
method 
This2.Location.Lib right() 
refine class method /*
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  */This2.S readableName() 
refine class method /*
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  */This2.Bool is(class This2.Concept.Classable subtype) 
refine read method 
This2.Bool #equalequal#0left(read Any right) 
refine class method 
read This0 cast(read This2.Concept.Classable that) 
refine class method 
mut This0 #cast(mut This2.Concept.Classable that) 
refine read method 
This2.S text() 
refine read method 
class This0 class() 
refine class method 
This2.S kind() 
refine read method 
This2.Message.Opt responseOf() 
refine read method 
This2.S toS() 
class method 
Library #pluginUnresponsive(Library binaryRepr) }
MethodClash: {/*@pluginPart is.L42.connected.withSafeOperators.pluginWrapper.RefactorErrors$MethodClash
@plugin is.L42.connected.withSafeOperators
*/implements This1.Fail, This2.Guard, This2.Message, This2.Concept.Base, This2.Concept.ToS, This2.Concept.Classable, This2.Concept.Equals
class method 
mut This0 #from(Library binaryRepr) 
read method 
Library #binaryRepr() 
class method 
Void #exceptionIf(Library binaryRepr) exception This0 
read method 
This2.Bool equals(read This0 that) 
method 
This2.Location.Method left() 
method 
This2.Location.Method right() 
refine class method /*
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  */This2.S readableName() 
refine class method /*
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  */This2.Bool is(class This2.Concept.Classable subtype) 
refine read method 
This2.Bool #equalequal#0left(read Any right) 
refine class method 
read This0 cast(read This2.Concept.Classable that) 
refine class method 
mut This0 #cast(mut This2.Concept.Classable that) 
refine read method 
This2.S text() 
refine read method 
class This0 class() 
refine class method 
This2.S kind() 
refine read method 
This2.Message.Opt responseOf() 
refine read method 
This2.S toS() 
class method 
Library #pluginUnresponsive(Library binaryRepr) }
PathUnfit: {/*@pluginPart is.L42.connected.withSafeOperators.pluginWrapper.RefactorErrors$PathUnfit
@plugin is.L42.connected.withSafeOperators
*/implements This1.Fail, This2.Guard, This2.Message, This2.Concept.Base, This2.Concept.ToS, This2.Concept.Classable, This2.Concept.Equals
class method 
mut This0 #from(Library binaryRepr) 
read method 
Library #binaryRepr() 
class method 
Void #exceptionIf(Library binaryRepr) exception This0 
read method 
This2.Bool equals(read This0 that) 
method 
This2.Path path() 
refine class method /*
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  */This2.S readableName() 
refine class method /*
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  */This2.Bool is(class This2.Concept.Classable subtype) 
refine read method 
This2.Bool #equalequal#0left(read Any right) 
refine class method 
read This0 cast(read This2.Concept.Classable that) 
refine class method 
mut This0 #cast(mut This2.Concept.Classable that) 
refine read method 
This2.S text() 
refine read method 
class This0 class() 
refine class method 
This2.S kind() 
refine read method 
This2.Message.Opt responseOf() 
refine read method 
This2.S toS() 
class method 
Library #pluginUnresponsive(Library binaryRepr) }
SelectorUnfit: {/*@pluginPart is.L42.connected.withSafeOperators.pluginWrapper.RefactorErrors$SelectorUnfit
@plugin is.L42.connected.withSafeOperators
*/implements This1.Fail, This2.Guard, This2.Message, This2.Concept.Base, This2.Concept.ToS, This2.Concept.Classable, This2.Concept.Equals
class method 
mut This0 #from(Library binaryRepr) 
read method 
Library #binaryRepr() 
class method 
Void #exceptionIf(Library binaryRepr) exception This0 
read method 
This2.Bool equals(read This0 that) 
method 
This2.Path path() 
method 
This2.Selector selector() 
refine class method /*
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  */This2.S readableName() 
refine class method /*
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  */This2.Bool is(class This2.Concept.Classable subtype) 
refine read method 
This2.Bool #equalequal#0left(read Any right) 
refine class method 
read This0 cast(read This2.Concept.Classable that) 
refine class method 
mut This0 #cast(mut This2.Concept.Classable that) 
refine read method 
This2.S text() 
refine read method 
class This0 class() 
refine class method 
This2.S kind() 
refine read method 
This2.Message.Opt responseOf() 
refine read method 
This2.S toS() 
class method 
Library #pluginUnresponsive(Library binaryRepr) }
IncoherentMapping: {/*@pluginPart is.L42.connected.withSafeOperators.pluginWrapper.RefactorErrors$SelectorUnfit
@plugin is.L42.connected.withSafeOperators
*/implements This1.Fail, This2.Guard, This2.Message, This2.Concept.Base, This2.Concept.ToS, This2.Concept.Classable, This2.Concept.Equals
class method 
mut This0 #from(Library binaryRepr) 
read method 
Library #binaryRepr() 
class method 
Void #exceptionIf(Library binaryRepr) exception This0 
read method 
This2.Bool equals(read This0 that) 
refine class method /*
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  */This2.S readableName() 
refine class method /*
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  */This2.Bool is(class This2.Concept.Classable subtype) 
refine read method 
This2.Bool #equalequal#0left(read Any right) 
refine class method 
read This0 cast(read This2.Concept.Classable that) 
refine class method 
mut This0 #cast(mut This2.Concept.Classable that) 
refine read method 
This2.S text() 
refine read method 
class This0 class() 
refine class method 
This2.S kind() 
refine read method 
This2.Message.Opt responseOf() 
refine read method 
This2.S toS() 
class method 
Library #pluginUnresponsive(Library binaryRepr) }
PrivacyCoupuled: {/*@pluginPart is.L42.connected.withSafeOperators.pluginWrapper.RefactorErrors$PrivacyCoupuled
@plugin is.L42.connected.withSafeOperators
*/implements This1.Fail, This2.Guard, This2.Message, This2.Concept.Base, This2.Concept.ToS, This2.Concept.Classable, This2.Concept.Equals
class method 
mut This0 #from(Library binaryRepr) 
read method 
Library #binaryRepr() 
class method 
Void #exceptionIf(Library binaryRepr) exception This0 
read method 
This2.Bool equals(read This0 that) 
refine class method /*
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  */This2.S readableName() 
refine class method /*
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  */This2.Bool is(class This2.Concept.Classable subtype) 
refine read method 
This2.Bool #equalequal#0left(read Any right) 
refine class method 
read This0 cast(read This2.Concept.Classable that) 
refine class method 
mut This0 #cast(mut This2.Concept.Classable that) 
refine read method 
This2.S text() 
refine read method 
class This0 class() 
refine class method 
This2.S kind() 
refine read method 
This2.Message.Opt responseOf() 
refine read method 
This2.S toS() 
class method 
Library #pluginUnresponsive(Library binaryRepr) }
SubtleSubtypeViolation: {/*@pluginPart is.L42.connected.withSafeOperators.pluginWrapper.RefactorErrors$SubtleSubtypeViolation
@plugin is.L42.connected.withSafeOperators
*/implements This1.Fail, This2.Guard, This2.Message, This2.Concept.Base, This2.Concept.ToS, This2.Concept.Classable, This2.Concept.Equals
class method 
mut This0 #from(Library binaryRepr) 
read method 
Library #binaryRepr() 
class method 
Void #exceptionIf(Library binaryRepr) exception This0 
read method 
This2.Bool equals(read This0 that) 
refine class method /*
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  */This2.S readableName() 
refine class method /*
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  */This2.Bool is(class This2.Concept.Classable subtype) 
refine read method 
This2.Bool #equalequal#0left(read Any right) 
refine class method 
read This0 cast(read This2.Concept.Classable that) 
refine class method 
mut This0 #cast(mut This2.Concept.Classable that) 
refine read method 
This2.S text() 
refine read method 
class This0 class() 
refine class method 
This2.S kind() 
refine read method 
This2.Message.Opt responseOf() 
refine read method 
This2.S toS() 
class method 
Library #pluginUnresponsive(Library binaryRepr) }
DeployL42TypeError: {/*@pluginPart is.L42.connected.withSafeOperators.pluginWrapper.RefactorErrors$DeployL42TypeError
@plugin is.L42.connected.withSafeOperators
*/implements This1.Fail, This2.Guard, This2.Message, This2.Concept.Base, This2.Concept.ToS, This2.Concept.Classable, This2.Concept.Equals
class method 
mut This0 #from(Library binaryRepr) 
read method 
Library #binaryRepr() 
class method 
Void #exceptionIf(Library binaryRepr) exception This0 
read method 
This2.Bool equals(read This0 that) 
refine class method /*
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  */This2.S readableName() 
refine class method /*
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  */This2.Bool is(class This2.Concept.Classable subtype) 
refine read method 
This2.Bool #equalequal#0left(read Any right) 
refine class method 
read This0 cast(read This2.Concept.Classable that) 
refine class method 
mut This0 #cast(mut This2.Concept.Classable that) 
refine read method 
This2.S text() 
refine read method 
class This0 class() 
refine class method 
This2.S kind() 
refine read method 
This2.Message.Opt responseOf() 
refine read method 
This2.S toS() 
class method 
Library #pluginUnresponsive(Library binaryRepr) }
JavaImport: {/*@plugin is.L42.connected.withSafeOperators
@pluginPart is.L42.connected.withSafeOperators.pluginWrapper.PlgWrapperGenerator
*/
class method 
mut This0 #from(Library binaryRepr) 
read method 
Library #binaryRepr() 
class method 
Void #exceptionIf(Library binaryRepr) exception This0 
class method 
Library #pluginUnresponsive(Library binaryRepr) 
class method 
Library #leftrightleft#0left(Library right) exception This1.UnresolvedOverloading, This1.ClassUnfit, This1.MethodUnfit 
class method 
Library main(Library that) exception This1.UnresolvedOverloading, This1.ClassUnfit, This1.MethodUnfit }
Compose: {/*@plugin  toFix
@pluginPart is.L42.connected.withSafeOperators.refactor.Compose
*/
class method 
mut This0 #from(Library binaryRepr) 
read method 
Library #binaryRepr() 
class method 
Void #exceptionIf(Library binaryRepr) exception This0 
class method 
Void #pluginUnresponsive(Library binaryRepr) 
class method 
Library compose(Library left, Library right) exception This1.MethodClash, This1.ClassClash, This1.SubtleSubtypeViolation }
PlgRenameClass: {/*@plugin  toFix
@pluginPart is.L42.connected.withSafeOperators.refactor.Rename
*/
class method 
mut This0 #from(Library binaryRepr) 
read method 
Library #binaryRepr() 
class method 
Void #exceptionIf(Library binaryRepr) exception This0 
class method 
Void #pluginUnresponsive(Library binaryRepr) 
class method 
Library renameClassJ(Library that, This2.Path src, This2.Path dest) exception This1.PathUnfit, This1.MethodClash, This1.ClassClash, This1.SubtleSubtypeViolation 
class method 
Library hideClassJ(Library that, This2.Path src) exception This1.PathUnfit, This1.ClassUnfit }
RenameClass: {
method 
This2.Path src() 
method 
This2.Path dest() 
class method 
This0 #apply(This2.Path src, This2.Path dest) 
method 
Library #leftrightleft#0left(Library right) exception This1.PathUnfit, This1.MethodClash, This1.ClassClash, This1.SubtleSubtypeViolation }
HideClass: {
method 
This2.Path src() 
class method 
This0 #apply(This2.Path src) 
method 
Library #leftrightleft#0left(Library right) exception This1.PathUnfit, This1.ClassUnfit }
PlgAbstractClass: {/*@plugin  toFix
@pluginPart is.L42.connected.withSafeOperators.refactor.AbstractClass
*/
class method 
mut This0 #from(Library binaryRepr) 
read method 
Library #binaryRepr() 
class method 
Void #exceptionIf(Library binaryRepr) exception This0 
class method 
Void #pluginUnresponsive(Library binaryRepr) 
class method 
Library toAbstractJ(Library that, This2.Path src) exception This1.PathUnfit, This1.PrivacyCoupuled }
ToAbstractClass: {
read method 
This2.Path src() 
class method 
This0 #apply(This2.Path src) 
method 
Library #leftrightleft#0left(Library right) exception This1.PathUnfit, This1.PrivacyCoupuled }
PlgToAbstract: {/*@plugin  toFix
@pluginPart is.L42.connected.withSafeOperators.refactor.ToAbstract
*/
class method 
mut This0 #from(Library binaryRepr) 
read method 
Library #binaryRepr() 
class method 
Void #exceptionIf(Library binaryRepr) exception This0 
class method 
Void #pluginUnresponsive(Library binaryRepr) 
class method 
Library toAbstractPathDestJ(Library that, This2.Path path, This2.Selector src, This2.Selector dest) exception This1.SelectorUnfit, This1.PathUnfit, This1.MethodClash 
class method 
Library toAbstractPathJ(Library that, This2.Path path, This2.Selector src) exception This1.SelectorUnfit, This1.PathUnfit 
class method 
Library toAbstractDestJ(Library that, This2.Selector src, This2.Selector dest) exception This1.SelectorUnfit, This1.MethodClash 
class method 
Library toAbstractJ(Library that, This2.Selector src) exception This1.SelectorUnfit }
ToAbstract: {
method 
This2.Selector src() 
class method 
This0 #apply(This2.Selector src) 
method 
Library #leftrightleft#0left(Library right) exception This1.SelectorUnfit }
ToAbstractDest: {
method 
This2.Selector src() 
method 
This2.Selector dest() 
class method 
This0 #apply(This2.Selector src, This2.Selector dest) 
method 
Library #leftrightleft#0left(Library right) exception This1.SelectorUnfit, This1.MethodClash }
ToAbstractPath: {
method 
This2.Path path() 
method 
This2.Selector src() 
class method 
This0 #apply(This2.Path path, This2.Selector src) 
method 
Library #leftrightleft#0left(Library right) exception This1.SelectorUnfit, This1.PathUnfit }
ToAbstractPathDest: {
method 
This2.Path path() 
method 
This2.Selector src() 
method 
This2.Selector dest() 
class method 
This0 #apply(This2.Path path, This2.Selector src, This2.Selector dest) 
method 
Library #leftrightleft#0left(Library right) exception This1.SelectorUnfit, This1.PathUnfit, This1.MethodClash }
PlgRedirect: {/*@plugin  toFix
@pluginPart is.L42.connected.withSafeOperators.refactor.Redirect
*/
class method 
mut This0 #from(Library binaryRepr) 
read method 
Library #binaryRepr() 
class method 
Void #exceptionIf(Library binaryRepr) exception This0 
class method 
Void #pluginUnresponsive(Library binaryRepr) 
class method 
Library redirectJ(Library that, This2.Path src, class Any dest) exception This1.ClassUnfit, This1.IncoherentMapping, This1.MethodClash, This1.PathUnfit }
Redirect: {
method 
This2.Path src() 
method 
class Any dest() 
class method 
This0 #apply(This2.Path src, class Any dest) 
method 
Library #leftrightleft#0left(Library right) exception This1.ClassUnfit, This1.IncoherentMapping, This1.MethodClash, This1.PathUnfit }
RefToUnfit: {implements This1.Fail, This2.Guard, This2.Message, This2.Concept.Base, This2.Concept.ToS, This2.Concept.Classable, This2.Concept.Equals
refine read method 
class This0 class() 
refine class method /*
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  */This2.S readableName() 
refine class method /*
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  */This2.Bool is(class This2.Concept.Classable subtype) 
refine read method 
This2.Bool #equalequal#0left(read Any right) 
refine class method 
read This0 cast(read This2.Concept.Classable that) 
refine class method 
mut This0 #cast(mut This2.Concept.Classable that) 
read method 
This2.S _text() 
read method 
This2.Message.Opt cause() 
class method 
This0 #apply(This2.S _text, This2.Message.Opt cause) 
refine class method 
This2.S kind() 
refine read method 
This2.S text() 
refine read method 
This2.Message.Opt responseOf() 
method 
This0 #apply(This2.Message that) 
refine read method 
This2.S toS() 
read method 
This2.Bool equals(read This0 that) 
class method 
This0 #apply(This2.S text) 
class method 
This0 #apply(This2.S text, This2.Message cause) 
class method 
mut This2.S.SBuilder #builder() 
class method 
This0 #from(This2.S.SBuilder builder) 
method 
This0.Continue #from(This2.S.SConcat seqBuilder) 
method 
mut This2.S.SConcat #seqBuilder() 
Continue: {
read method 
This3.S that() 
class method 
This0 #apply(This3.S that) 
method 
mut This3.S.SBuilder #builder() 
method 
This1 #from(This3.S.SBuilder builder) }}
RedirectRefTo: {
read method 
This2.Path src() 
read method 
This2.Location.Type.RefTo into() 
class method 
This0 #apply(This2.Path src, This2.Location.Type.RefTo into) 
method 
Library #leftrightleft#0left(Library right) exception This1.ClassUnfit, This1.IncoherentMapping, This1.MethodClash, This1.ClassClash, This1.PathUnfit, This1.RefToUnfit, This1.SubtleSubtypeViolation }
PlgMethod: {/*@plugin  toFix
@pluginPart is.L42.connected.withSafeOperators.refactor.RenameMethods
*/
class method 
mut This0 #from(Library binaryRepr) 
read method 
Library #binaryRepr() 
class method 
Void #exceptionIf(Library binaryRepr) exception This0 
class method 
Void #pluginUnresponsive(Library binaryRepr) 
class method 
This0 #apply() 
method 
Library act(Library that) exception This1.PathUnfit, This1.SelectorUnfit, This1.MethodClash, This1.ClassUnfit 
method 
This0 addRenameJ(This2.Path path, This2.Selector src, This2.Selector dest) 
method 
This0 addHideJ(This2.Path path, This2.Selector src) 
method 
This0 addCloseJ(This2.Path path) 
method 
This0 addAbstractJ(This2.Path path, This2.Selector src) 
method 
This0 addAbstractAliasJ(This2.Path path, This2.Selector src, This2.Selector dest) }
Method: {
mut method 
Void inner(This1.PlgMethod that) 
read method 
This1.PlgMethod inner() 
class method 
mut This0 #apply(This1.PlgMethod inner) 
read method 
Library #leftrightleft#0left(Library right) exception This1.PathUnfit, This1.SelectorUnfit, This1.MethodClash, This1.ClassUnfit 
class method 
mut This0 #seqBuilder() 
class method 
mut This0 #from(mut This0 seqBuilder) 
class method 
class This2.Path #default##square(Void of) 
class method 
class This2.Path #default##square(Void closeState) 
class method 
class This2.Selector #default##square(Void hide) 
class method 
class This2.Selector #default##square(Void rename) 
class method 
class This2.Selector #default##square(Void into) 
class method 
class This2.Selector #default##square(Void abstract) 
class method 
class This2.Selector #default##square(Void alias) 
mut method 
Void #add(This2.Selector hide, This2.Path of) 
mut method 
Void #add(This2.Selector hide) 
mut method 
Void #add(This2.Selector rename, This2.Path of, This2.Selector into) 
mut method 
Void #add(This2.Selector rename, This2.Selector into) 
mut method 
Void #add(This2.Path closeState) 
mut method 
Void #add(This2.Selector abstract, This2.Path of) 
mut method 
Void #add(This2.Selector abstract, This2.Path of, This2.Selector alias) 
mut method 
Void #add(This2.Selector abstract) 
mut method 
Void #add(This2.Selector abstract, This2.Selector alias) }
MakeDoc: {/*@plugin  toFix
@pluginPart is.L42.connected.withSafeOperators.refactor.MakeDoc
*/
class method 
mut This0 #from(Library binaryRepr) 
read method 
Library #binaryRepr() 
class method 
Void #exceptionIf(Library binaryRepr) exception This0 
class method 
Void #pluginUnresponsive(Library binaryRepr) 
class method 
Library makeDoc(This2.S that) }
PlgSumMethods: {/*@plugin  toFix
@pluginPart is.L42.connected.withSafeOperators.refactor.SumMethods
*/
class method 
mut This0 #from(Library binaryRepr) 
read method 
Library #binaryRepr() 
class method 
Void #exceptionIf(Library binaryRepr) exception This0 
class method 
Void #pluginUnresponsive(Library binaryRepr) 
class method 
Library sumMethodsJ(Library lib, This2.Path path, This2.Selector src1, This2.Selector src2, This2.Selector dest, This2.S name) exception This1.MethodClash, This1.PathUnfit, This1.SelectorUnfit }
SumMethods: {
read method 
This2.Selector that() 
read method 
This2.Selector and() 
read method 
This2.Path of() 
read method 
This2.S over() 
read method 
This2.Selector into() 
class method 
This0 #apply(This2.Selector that, This2.Selector and, This2.Path of, This2.S over, This2.Selector into) 
method 
Library #leftrightleft#0left(Library right) exception This1.MethodClash, This1.PathUnfit, This1.SelectorUnfit }}
Optimize: {
RemoveUnreachableCode: {
class method 
Library #leftrightleft#0left(Library right) }}
Opt: {
class method 
Library #apply(class Any that) 
class method 
Library optTrait() }
Use: {
mut method 
Void fillMaps() 
mut method 
Void fillMaps(This1.Location.Lib li, This1.Size i) 
mut method 
Void fillMaps(This1.Location.Lib lij, This1.Composers.Selectors ssj, This1.Path pj, This1.Size i) 
mut method 
This1.Selector superName(This1.Selector selector, This1.Size i) 
class method 
mut This1.Composers.Libs #seqBuilder() 
class method 
mut This0.Decorator #from(mut This1.Composers.Libs seqBuilder) 
mut method 
mut This1.Composers.RenameMethods openMaps() 
mut method 
mut This1.Refactor2.Method close() 
read method 
read This1.Composers.Libs inputs() 
mut method 
mut This1.Composers.Libs #inputs() 
read method 
Library input() 
read method 
This1.Location.Lib.List ls() 
read method 
This1.Location.Lib l0() 
read method 
This1.Location.Lib.List l0ns() 
read method 
This1.Composers.Selectorss sels() 
class method 
mut This0 #apply(mut This1.Composers.Libs libs, Library lib0) 
mut method 
mut This1.Refactor2.Method open(This1.Size that) 
mut method 
Void fillMapsPatch(This1.Location.Lib top, This1.Path fix) 
class method 
mut This0 #apply(Library top, This1.Path fix) exception This1.Location.NotAvailable 
class method 
class This1.Path #default##apply(Void patch) 
class method 
mut This0.Patcher #apply(This1.Path patch) 
class method 
mut This0 #apply(fwd mut This1.Composers.RenameMethods openMaps, fwd mut This1.Refactor2.Method close, fwd mut This1.Composers.Libs inputs, fwd Library input, fwd This1.Location.Lib.List ls, fwd This1.Location.Lib l0, fwd This1.Location.Lib.List l0ns, fwd This1.Composers.Selectorss sels) 
mut method 
Void op(This1.Path p, This1.Location.Method m, This1.Size i) 
Over: {
mut method 
Void fillMaps() 
mut method 
Void fillMaps(This2.Location.Lib li, This2.Size i) 
mut method 
Void fillMaps(This2.Location.Lib lij, This2.Composers.Selectors ssj, This2.Path pj, This2.Size i) 
mut method 
This2.Selector superName(This2.Selector selector, This2.Size i) 
class method 
mut This2.Composers.Libs #seqBuilder() 
class method 
mut This0.Decorator #from(mut This2.Composers.Libs seqBuilder) 
mut method 
mut This2.Composers.RenameMethods openMaps() 
mut method 
mut This2.Refactor2.Method close() 
read method 
read This2.Composers.Libs inputs() 
mut method 
mut This2.Composers.Libs #inputs() 
read method 
Library input() 
read method 
This2.Location.Lib.List ls() 
read method 
This2.Location.Lib l0() 
read method 
This2.Location.Lib.List l0ns() 
read method 
This2.Composers.Selectorss sels() 
class method 
mut This0 #apply(mut This2.Composers.Libs libs, Library lib0) 
mut method 
mut This2.Refactor2.Method open(This2.Size that) 
mut method 
Void fillMapsPatch(This2.Location.Lib top, This2.Path fix) 
class method 
mut This0 #apply(Library top, This2.Path fix) exception This2.Location.NotAvailable 
class method 
class This2.Path #default##apply(Void patch) 
class method 
mut This0.Patcher #apply(This2.Path patch) 
class method 
mut This0 #apply(fwd mut This2.Composers.RenameMethods openMaps, fwd mut This2.Refactor2.Method close, fwd mut This2.Composers.Libs inputs, fwd Library input, fwd This2.Location.Lib.List ls, fwd This2.Location.Lib l0, fwd This2.Location.Lib.List l0ns, fwd This2.Composers.Selectorss sels) 
mut method 
Void op(This2.Path p, This2.Location.Method m, This2.Size i) 
Decorator: {
read method 
read This3.Composers.Libs inner() 
mut method 
mut This3.Composers.Libs #inner() 
class method 
mut This0 #apply(mut This3.Composers.Libs inner) 
mut method 
Library #leftrightleft#0left(Library right) exception This3.Refactor2.MethodClash, This3.Refactor2.ClassClash, This3.Refactor2.SubtleSubtypeViolation 
method 
Library foldLeft(Library resolver) exception This3.Refactor2.MethodClash, This3.Refactor2.ClassClash, This3.Refactor2.SubtleSubtypeViolation }
Patcher: {
read method 
This3.Path patch() 
class method 
mut This0 #apply(This3.Path patch) 
mut method 
Library #leftrightleft#0left(Library right) exception This3.Refactor2.MethodClash, This3.Refactor2.ClassClash, This3.Refactor2.SubtleSubtypeViolation, This3.Refactor2.PathUnfit, This3.Refactor2.SelectorUnfit, This3.Refactor2.ClassUnfit, This3.Location.NotAvailable }}
Override: {
mut method 
Void fillMaps() 
mut method 
Void fillMaps(This2.Location.Lib li, This2.Size i) 
mut method 
Void fillMaps(This2.Location.Lib lij, This2.Composers.Selectors ssj, This2.Path pj, This2.Size i) 
mut method 
This2.Selector superName(This2.Selector selector, This2.Size i) 
class method 
mut This2.Composers.Libs #seqBuilder() 
class method 
mut This0.Decorator #from(mut This2.Composers.Libs seqBuilder) 
mut method 
mut This2.Composers.RenameMethods openMaps() 
mut method 
mut This2.Refactor2.Method close() 
read method 
read This2.Composers.Libs inputs() 
mut method 
mut This2.Composers.Libs #inputs() 
read method 
Library input() 
read method 
This2.Location.Lib.List ls() 
read method 
This2.Location.Lib l0() 
read method 
This2.Location.Lib.List l0ns() 
read method 
This2.Composers.Selectorss sels() 
class method 
mut This0 #apply(mut This2.Composers.Libs libs, Library lib0) 
mut method 
mut This2.Refactor2.Method open(This2.Size that) 
mut method 
Void fillMapsPatch(This2.Location.Lib top, This2.Path fix) 
class method 
mut This0 #apply(Library top, This2.Path fix) exception This2.Location.NotAvailable 
class method 
class This2.Path #default##apply(Void patch) 
class method 
mut This0.Patcher #apply(This2.Path patch) 
class method 
mut This0 #apply(fwd mut This2.Composers.RenameMethods openMaps, fwd mut This2.Refactor2.Method close, fwd mut This2.Composers.Libs inputs, fwd Library input, fwd This2.Location.Lib.List ls, fwd This2.Location.Lib l0, fwd This2.Location.Lib.List l0ns, fwd This2.Composers.Selectorss sels) 
mut method 
Void op(This2.Path p, This2.Location.Method m, This2.Size i) 
Decorator: {
read method 
read This3.Composers.Libs inner() 
mut method 
mut This3.Composers.Libs #inner() 
class method 
mut This0 #apply(mut This3.Composers.Libs inner) 
mut method 
Library #leftrightleft#0left(Library right) exception This3.Refactor2.MethodClash, This3.Refactor2.ClassClash, This3.Refactor2.SubtleSubtypeViolation 
method 
Library foldLeft(Library resolver) exception This3.Refactor2.MethodClash, This3.Refactor2.ClassClash, This3.Refactor2.SubtleSubtypeViolation }
Patcher: {
read method 
This3.Path patch() 
class method 
mut This0 #apply(This3.Path patch) 
mut method 
Library #leftrightleft#0left(Library right) exception This3.Refactor2.MethodClash, This3.Refactor2.ClassClash, This3.Refactor2.SubtleSubtypeViolation, This3.Refactor2.PathUnfit, This3.Refactor2.SelectorUnfit, This3.Refactor2.ClassUnfit, This3.Location.NotAvailable }}
Decorator: {
read method 
read This2.Composers.Libs inner() 
mut method 
mut This2.Composers.Libs #inner() 
class method 
mut This0 #apply(mut This2.Composers.Libs inner) 
mut method 
Library #leftrightleft#0left(Library right) exception This2.Refactor2.MethodClash, This2.Refactor2.ClassClash, This2.Refactor2.SubtleSubtypeViolation 
method 
Library foldLeft(Library resolver) exception This2.Refactor2.MethodClash, This2.Refactor2.ClassClash, This2.Refactor2.SubtleSubtypeViolation }
Patcher: {
read method 
This2.Path patch() 
class method 
mut This0 #apply(This2.Path patch) 
mut method 
Library #leftrightleft#0left(Library right) exception This2.Refactor2.MethodClash, This2.Refactor2.ClassClash, This2.Refactor2.SubtleSubtypeViolation, This2.Refactor2.PathUnfit, This2.Refactor2.SelectorUnfit, This2.Refactor2.ClassUnfit, This2.Location.NotAvailable }}
Collections: {
class method 
Library vector(class Any ofMut) 
class method 
Library vector(class Any of) 
class method 
Library minimal(class Any that) 
class method 
Library eq(class Any that) 
IterationFailure: {implements This2.Guard, This2.Message, This2.Concept.Base, This2.Concept.ToS, This2.Concept.Classable, This2.Concept.Equals
refine read method 
class This0 class() 
refine class method /*
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  */This2.S readableName() 
refine class method /*
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  */This2.Bool is(class This2.Concept.Classable subtype) 
refine read method 
This2.Bool #equalequal#0left(read Any right) 
refine class method 
read This0 cast(read This2.Concept.Classable that) 
refine class method 
mut This0 #cast(mut This2.Concept.Classable that) 
read method 
This2.S _text() 
read method 
This2.Message.Opt cause() 
class method 
This0 #apply(This2.S _text, This2.Message.Opt cause) 
refine class method 
This2.S kind() 
refine read method 
This2.S text() 
refine read method 
This2.Message.Opt responseOf() 
method 
This0 #apply(This2.Message that) 
refine read method 
This2.S toS() 
read method 
This2.Bool equals(read This0 that) 
class method 
This0 #apply(This2.S text) 
class method 
This0 #apply(This2.S text, This2.Message cause) 
class method 
mut This2.S.SBuilder #builder() 
class method 
This0 #from(This2.S.SBuilder builder) 
method 
This0.Continue #from(This2.S.SConcat seqBuilder) 
method 
mut This2.S.SConcat #seqBuilder() 
Continue: {
read method 
This3.S that() 
class method 
This0 #apply(This3.S that) 
method 
mut This3.S.SBuilder #builder() 
method 
This1 #from(This3.S.SBuilder builder) }}
CollectionErrors: {
class method 
Any negBound(This2.Size that, This2.Size listSize) 
class method 
Any outBound(This2.Size that, This2.Size listSize) 
class method 
Any cast() 
class method 
Any iterationTermination(This2.Size from, This2.Size minTo, This2.Size size) 
class method 
Void checkBound(This2.Size that, This2.Size listSize) 
class method 
Void checkBoundAdd(This2.Size that, This2.Size listSize) }
MutListAny: {implements This2.Concept.ToS
mut method 
Void head(This0.Cell that) 
read method 
This0.Cell head() 
mut method 
Void size(This2.Size that) 
read method 
This2.Size size() 
class method 
mut This0 #apply(This0.Cell head, This2.Size size) 
class method 
mut This0 empty() 
read method 
Any val(This2.Size that) 
mut method 
Void #apply(This2.Size that, Any val) 
mut method 
Void add(This2.Size that, Any val) 
mut method 
Void remove(This2.Size that) 
method 
This0 without(This2.Size that) 
method 
This0 withAlso(This2.Size that, Any val) 
method 
This0 with(This2.Size that, Any val) 
refine read method 
This2.S toS() 
Cell: {interface 
method 
Any get(This3.Size that) 
method 
This0 set(This3.Size that, Any val, This3.Bool add) 
method 
This0 remove(This3.Size that) }
CellNext: {implements This1.Cell
read method 
Any val() 
read method 
This1.Cell next() 
class method 
mut This0 #apply(Any val, This1.Cell next) 
refine method 
Any get(This3.Size that) 
refine method 
This1.Cell set(This3.Size that, Any val, This3.Bool add) 
refine method 
This1.Cell remove(This3.Size that) }
CellEnd: {implements This1.Cell
class method 
mut This0 #apply() 
refine method 
Any get(This3.Size that) 
refine method 
This1.Cell set(This3.Size that, Any val, This3.Bool add) 
refine method 
This1.Cell remove(This3.Size that) }}
VectorTrait: {
class method 
Library #apply() }
CodeEq: {
class method 
Library #apply() }}
CollectionsMut: {
class method 
Library vector(class Any of) 
class method 
Library minimal(class Any that) 
class method 
Library eq(class Any that) 
IterationFailure: {implements This2.Guard, This2.Message, This2.Concept.Base, This2.Concept.ToS, This2.Concept.Classable, This2.Concept.Equals
refine read method 
class This0 class() 
refine class method /*
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  */This2.S readableName() 
refine class method /*
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  */This2.Bool is(class This2.Concept.Classable subtype) 
refine read method 
This2.Bool #equalequal#0left(read Any right) 
refine class method 
read This0 cast(read This2.Concept.Classable that) 
refine class method 
mut This0 #cast(mut This2.Concept.Classable that) 
read method 
This2.S _text() 
read method 
This2.Message.Opt cause() 
class method 
This0 #apply(This2.S _text, This2.Message.Opt cause) 
refine class method 
This2.S kind() 
refine read method 
This2.S text() 
refine read method 
This2.Message.Opt responseOf() 
method 
This0 #apply(This2.Message that) 
refine read method 
This2.S toS() 
read method 
This2.Bool equals(read This0 that) 
class method 
This0 #apply(This2.S text) 
class method 
This0 #apply(This2.S text, This2.Message cause) 
class method 
mut This2.S.SBuilder #builder() 
class method 
This0 #from(This2.S.SBuilder builder) 
method 
This0.Continue #from(This2.S.SConcat seqBuilder) 
method 
mut This2.S.SConcat #seqBuilder() 
Continue: {
read method 
This3.S that() 
class method 
This0 #apply(This3.S that) 
method 
mut This3.S.SBuilder #builder() 
method 
This1 #from(This3.S.SBuilder builder) }}
CollectionErrors: {
class method 
Any negBound(This2.Size that, This2.Size listSize) 
class method 
Any outBound(This2.Size that, This2.Size listSize) 
class method 
Any cast() 
class method 
Any iterationTermination(This2.Size from, This2.Size minTo, This2.Size size) 
class method 
Void checkBound(This2.Size that, This2.Size listSize) 
class method 
Void checkBoundAdd(This2.Size that, This2.Size listSize) }
MutListAny: {implements This2.Concept.ToS
mut method 
Void head(mut This0.Cell that) 
read method 
read This0.Cell head() 
mut method 
mut This0.Cell #head() 
mut method 
Void size(This2.Size that) 
read method 
This2.Size size() 
class method 
mut This0 #apply(fwd mut This0.Cell head, This2.Size size) 
class method 
mut This0 empty() 
read method 
read Any val(This2.Size that) 
mut method 
mut Any #val(This2.Size that) 
mut method 
Void #apply(This2.Size that, mut Any val) 
mut method 
Void add(This2.Size that, mut Any val) 
mut method 
Void remove(This2.Size that) 
method 
This0 without(This2.Size that) 
method 
This0 withAlso(This2.Size that, Any val) 
method 
This0 with(This2.Size that, Any val) 
refine read method 
This2.S toS() 
Cell: {interface 
read method 
read Any get(This3.Size that) 
mut method 
mut Any #get(This3.Size that) 
read method 
read This0 set(This3.Size that, read Any val, This3.Bool add) 
mut method 
mut This0 #set(This3.Size that, mut Any val, This3.Bool add) 
read method 
read This0 remove(This3.Size that) 
mut method 
mut This0 #remove(This3.Size that) }
CellNext: {implements This1.Cell
read method 
read Any val() 
mut method 
mut Any #val() 
read method 
read This1.Cell next() 
mut method 
mut This1.Cell #next() 
class method 
mut This0 #apply(fwd mut Any val, fwd mut This1.Cell next) 
refine read method 
read Any get(This3.Size that) 
refine mut method 
mut Any #get(This3.Size that) 
refine read method 
read This1.Cell set(This3.Size that, read Any val, This3.Bool add) 
refine mut method 
mut This1.Cell #set(This3.Size that, mut Any val, This3.Bool add) 
refine read method 
read This1.Cell remove(This3.Size that) 
refine mut method 
mut This1.Cell #remove(This3.Size that) }
CellEnd: {implements This1.Cell
class method 
mut This0 #apply() 
refine read method 
read Any get(This3.Size that) 
refine mut method 
mut Any #get(This3.Size that) 
refine read method 
read This1.Cell set(This3.Size that, read Any val, This3.Bool add) 
refine mut method 
mut This1.Cell #set(This3.Size that, mut Any val, This3.Bool add) 
refine read method 
read This1.Cell remove(This3.Size that) 
refine mut method 
mut This1.Cell #remove(This3.Size that) }}
VectorTrait: {
class method 
Library #apply() }
CodeEq: {
class method 
Library #apply() }}
K: {
class method 
Library #leftrightleft#0left(Library right) exception This1.Refactor2.ClassUnfit 
class method 
This0.Decorator #apply(This1.S name, This1.Path path, This1.S excluded, This1.Bool immK, This1.Bool isFwd) 
PlgK: {/*@plugin is.L42.connected.withSafeOperators
@pluginPart is.L42.connected.withSafeOperators.refactor.MakeK
*/
class method 
mut This0 #from(Library binaryRepr) 
read method 
Library #binaryRepr() 
class method 
Void #exceptionIf(Library binaryRepr) exception This0 
class method 
Library makeKJ(Library that, This2.S name, This2.Path path, This2.S excluded, This2.Bool immK, This2.Bool isFwd) 
class method 
Library #pluginUnresponsive(Library binaryRepr) }
Imm: {
class method 
Library #leftrightleft#0left(Library right) exception This2.Refactor2.ClassUnfit }
$: {
class method 
Library #leftrightleft#0left(Library right) exception This2.Refactor2.ClassUnfit }
Decorator: {
read method 
This2.S name() 
read method 
This2.Path path() 
read method 
This2.S excluded() 
read method 
This2.Bool immK() 
read method 
This2.Bool isFwd() 
class method 
This0 #apply(This2.S name, This2.Path path, This2.S excluded, This2.Bool immK, This2.Bool isFwd) 
method 
Library #leftrightleft#0left(Library right) exception This2.Refactor2.ClassUnfit }}
Alphanumeric: {
class method 
Library #leftrightleft#0left(Library right) exception This0.Fail 
ParseFail: {implements This2.Guard.ParseFail, This2.Guard, This2.Message, This2.Concept.Base, This2.Concept.ToS, This2.Concept.Classable, This2.Concept.Equals
refine read method 
class This0 class() 
refine class method /*
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  */This2.S readableName() 
refine class method /*
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  */This2.Bool is(class This2.Concept.Classable subtype) 
refine read method 
This2.Bool #equalequal#0left(read Any right) 
refine class method 
read This0 cast(read This2.Concept.Classable that) 
refine class method 
mut This0 #cast(mut This2.Concept.Classable that) 
read method 
This2.S _text() 
read method 
This2.Message.Opt cause() 
class method 
This0 #apply(This2.S _text, This2.Message.Opt cause) 
refine class method 
This2.S kind() 
refine read method 
This2.S text() 
refine read method 
This2.Message.Opt responseOf() 
method 
This0 #apply(This2.Message that) 
refine read method 
This2.S toS() 
read method 
This2.Bool equals(read This0 that) 
class method 
This0 #apply(This2.S text) 
class method 
This0 #apply(This2.S text, This2.Message cause) 
class method 
mut This2.S.SBuilder #builder() 
class method 
This0 #from(This2.S.SBuilder builder) 
method 
This0.Continue #from(This2.S.SConcat seqBuilder) 
method 
mut This2.S.SConcat #seqBuilder() 
Continue: {
read method 
This3.S that() 
class method 
This0 #apply(This3.S that) 
method 
mut This3.S.SBuilder #builder() 
method 
This1 #from(This3.S.SBuilder builder) }}
Fail: {implements This2.Guard, This2.Message, This2.Concept.Base, This2.Concept.ToS, This2.Concept.Classable, This2.Concept.Equals
refine read method 
class This0 class() 
refine class method /*
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  */This2.S readableName() 
refine class method /*
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  */This2.Bool is(class This2.Concept.Classable subtype) 
refine read method 
This2.Bool #equalequal#0left(read Any right) 
refine class method 
read This0 cast(read This2.Concept.Classable that) 
refine class method 
mut This0 #cast(mut This2.Concept.Classable that) 
read method 
This2.S _text() 
read method 
This2.Message.Opt cause() 
class method 
This0 #apply(This2.S _text, This2.Message.Opt cause) 
refine class method 
This2.S kind() 
refine read method 
This2.S text() 
refine read method 
This2.Message.Opt responseOf() 
method 
This0 #apply(This2.Message that) 
refine read method 
This2.S toS() 
read method 
This2.Bool equals(read This0 that) 
class method 
This0 #apply(This2.S text) 
class method 
This0 #apply(This2.S text, This2.Message cause) 
class method 
mut This2.S.SBuilder #builder() 
class method 
This0 #from(This2.S.SBuilder builder) 
method 
This0.Continue #from(This2.S.SConcat seqBuilder) 
method 
mut This2.S.SConcat #seqBuilder() 
Continue: {
read method 
This3.S that() 
class method 
This0 #apply(This3.S that) 
method 
mut This3.S.SBuilder #builder() 
method 
This1 #from(This3.S.SBuilder builder) }}
Trait: {
class method 
Any val() 
class method 
Library #apply() }}
DeployTowel: {/*@untrusted
*/
read method 
This1.Url fileName() 
class method 
mut This0 #$(This1.Url fileName) 
mut method 
Library #leftrightleft#0left(Library right) 
FileSystemAccess:/*@_private
*/ {/*@plugin
L42.is/connected/withFileSystem
*/}}
Composers: {/*
Main feature of Composers:
you implement an
  mut method Void op(Path p, Location.Method m, Size i)
       op(p,meth,i) for example can be
         s=meth.selector()
         s2=this.superName(s,i)
         this.open(i).op(p,s,s2)//#add(rename:s of:p into:s2)
         this.close().op(p,s2)//hide selector of
*/
class method 
Library composerTrait() 
class method 
read Library #leftrightleft#0left(Library right) exception This1.Refactor2.MethodClash, This1.Refactor2.ClassClash, This1.Refactor2.SubtleSubtypeViolation 
class method 
This1.Location.Lib.List filterClash(This1.Location.Lib.List ls) 
class method 
This0.Selectors filterClash(This1.Location.Method.List ms) 
class method 
This1.Bool noClash(This1.Location.Method m) 
class method 
This1.Bool noClash(This1.Location.Lib l) 
class method 
This1.Path removePrefix(This1.Path path, This1.Path prefix) 
Selectors: {implements This2.Concept.ToS, This2.Concept.Classable, This2.Concept.Equals
refine class method /*
  Cast a (read/imm) object to this type.
  A class implementing this method should refine the return type to This.
  if is(subtype) is true, then cast(that) must produce a result.
  */read This0 cast(read This2.Concept.Classable that) 
refine class method /*
  Cast a (mutable) object to this type.
  A class implementing this method should refine the return type to This.
  if cast(that) produces a result, then #cast(that) also must produce a result.
  */mut This0 #cast(mut This2.Concept.Classable that) 
refine read method /*
  Extracts the class singleton from another instance of this class
  */class This0 class() 
refine class method /*
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  */This2.S readableName() 
refine class method /*
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  */This2.Bool is(class This2.Concept.Classable subtype) 
read method 
read This2.Collections.MutListAny inner() 
mut method 
mut This2.Collections.MutListAny #inner() 
class method 
mut This0 #apply(fwd mut This2.Collections.MutListAny inner) 
class method 
This0 #immK(This2.Collections.MutListAny inner) 
class method 
mut This0 empty() 
read method 
mut This0 reverse() 
read method 
This2.Bool isEmpty() 
read method 
class This2.Size #default#val(Void that) 
read method 
This2.Selector left() 
read method 
This2.Selector right() 
mut method 
Void #apply(This2.Size that, This2.Selector val) 
mut method 
Void left(This2.Selector that) 
mut method 
Void right(This2.Selector that) 
mut method 
Void add(This2.Size that, This2.Selector val) 
mut method 
Void add(This2.Selector right) 
mut method 
Void add(This2.Selector left) 
mut method 
Void removeLeft() 
mut method 
Void removeRight() 
method 
This0 #plus#0left(This2.Selector right) 
method 
This0 #plusplus#0left(This0 right) 
method 
This0 with(This2.Size that, This2.Selector val) 
method 
This0 withLeft(This2.Selector that) 
method 
This0 withRight(This2.Selector that) 
method 
This0 withAlso(This2.Size that, This2.Selector val) 
method 
This0 withAlsoLeft(This2.Selector that) 
method 
This0 withAlsoRight(This2.Selector that) 
method 
This0 withoutLeft() 
method 
This0 withoutRight() 
read method 
lent This0.IteratorVal vals(This2.Size from, This2.Size maxTo, This2.Size minTo) 
read method 
lent This0.IteratorVal vals(This2.Size minTo) 
read method 
lent This0.IteratorVal vals(This2.Size from, This2.Size to) 
read method 
lent This0.IteratorValFill vals(This2.Size from, This2.Size maxTo, This2.Size minTo, This2.Selector filled) 
read method 
lent This0.IteratorValFill vals(This2.Size minTo, This2.Selector filled) 
read method 
lent This0.IteratorValFill vals(This2.Size from, This2.Size to, This2.Selector filled) 
read method 
lent This0.IteratorValFill vals(This2.Selector filled) 
mut method 
lent This0.IteratorVar #vals(This2.Size from, This2.Size maxTo, This2.Size minTo) 
mut method 
lent This0.IteratorVar #vals(This2.Size minTo) 
mut method 
lent This0.IteratorVar #vals(This2.Size from, This2.Size to) 
mut method 
lent This0.IteratorVar #vals() 
refine read method 
This2.S toS() 
read method 
This2.Size size() 
read method 
This2.Selector val(This2.Size that) 
class method 
mut This0 #seqBuilder() 
class method 
mut This0 #from(mut This0 seqBuilder) 
mut method 
Void #add(This2.Selector that) 
read method 
lent This0.IteratorVal vals() 
read method 
This2.Bool contains(This2.Selector that) 
method 
This0 #less#0left(This2.Selector right) 
method 
This0 #lessless#0left(This0 right) 
method 
This0 #and#0left(This0 right) 
method 
This2.Bool #rightright#0left(This0 right) 
method 
This2.Bool #rightrightequal#0left(This0 right) 
method 
This2.Bool #right#0left(This2.Selector right) 
read method 
This2.Bool equals(read This0 that) 
refine read method 
This2.Bool #equalequal#0left(read Any right) 
read method 
This2.Size indexOfLeft(This2.Selector val) 
read method 
This2.Size indexOfRight(This2.Selector val) 
method /*from VectorTrait
*/This0 without(This2.Size index) 
method 
This0 withoutLeft(This2.Selector val) 
method 
This0 withoutRight(This2.Selector val) 
method 
This0 withoutAll(This2.Selector val) 
mut method /*from VectorTrait
*/Void remove(This2.Size that) 
mut method 
Void removeAll(This2.Selector val) 
mut method 
Void removeLeft(This2.Selector val) 
mut method 
Void removeRight(This2.Selector val) 
Cast: {
class method 
This3.Selector #apply(Any that) }
IteratorTrait: {
class method 
Library #apply() }
IteratorValFill: {
mut method 
Void #next() exception Void 
read method 
Void #checkEnd() 
read method 
This3.Selector #inner() 
read method 
Void #close() 
read method 
read This3.Collections.MutListAny _that() 
mut method 
Void from(This3.Size that) 
read method 
This3.Size from() 
read method 
This3.Size maxTo() 
read method 
This3.Size minTo() 
read method 
This3.Selector filled() 
read method 
read This3.Collections.MutListAny that() 
class method 
lent This0 #apply(read This3.Collections.MutListAny _that, This3.Size from, This3.Size maxTo, This3.Size minTo, This3.Selector filled) 
class method 
lent This0 #apply(read This3.Collections.MutListAny that, This3.Size from, This3.Size maxTo, This3.Size minTo, This3.Selector filled) 
read method 
This3.Bool isFill() }
IteratorVar: {
mut method 
Void #next() exception Void 
read method 
Void #checkEnd() 
read method 
This3.Selector #inner() 
read method 
Void #close() 
read method 
read This3.Collections.MutListAny that() 
mut method 
mut This3.Collections.MutListAny #that() 
mut method 
Void from(This3.Size that) 
read method 
This3.Size from() 
read method 
This3.Size maxTo() 
read method 
This3.Size minTo() 
class method 
mut This0 #apply(mut This3.Collections.MutListAny that, This3.Size from, This3.Size maxTo, This3.Size minTo) 
mut method 
Void inner(This3.Selector that) 
read method 
This3.Bool isFill() 
read method 
This3.Selector filled() }
IteratorVal: {
read method 
read This3.Collections.MutListAny _that() 
mut method 
Void from(This3.Size that) 
read method 
This3.Size from() 
read method 
This3.Size maxTo() 
read method 
This3.Size minTo() 
read method 
read This3.Collections.MutListAny that() 
class method 
lent This0 #apply(read This3.Collections.MutListAny _that, This3.Size from, This3.Size maxTo, This3.Size minTo) 
class method 
lent This0 #apply(read This3.Collections.MutListAny that, This3.Size from, This3.Size maxTo, This3.Size minTo) 
read method 
This3.Bool isFill() 
read method 
This3.Selector filled() 
mut method 
Void #next() exception Void 
read method 
Void #checkEnd() 
read method 
This3.Selector #inner() 
read method 
Void #close() }}
Selectorss: {implements This2.Concept.ToS, This2.Concept.Classable, This2.Concept.Equals
refine class method /*
  Cast a (read/imm) object to this type.
  A class implementing this method should refine the return type to This.
  if is(subtype) is true, then cast(that) must produce a result.
  */read This0 cast(read This2.Concept.Classable that) 
refine class method /*
  Cast a (mutable) object to this type.
  A class implementing this method should refine the return type to This.
  if cast(that) produces a result, then #cast(that) also must produce a result.
  */mut This0 #cast(mut This2.Concept.Classable that) 
refine read method /*
  Extracts the class singleton from another instance of this class
  */class This0 class() 
refine class method /*
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  */This2.S readableName() 
refine class method /*
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  */This2.Bool is(class This2.Concept.Classable subtype) 
read method 
read This2.Collections.MutListAny inner() 
mut method 
mut This2.Collections.MutListAny #inner() 
class method 
mut This0 #apply(fwd mut This2.Collections.MutListAny inner) 
class method 
This0 #immK(This2.Collections.MutListAny inner) 
class method 
mut This0 empty() 
read method 
mut This0 reverse() 
read method 
This2.Bool isEmpty() 
read method 
class This2.Size #default#val(Void that) 
read method 
This1.Selectors left() 
read method 
This1.Selectors right() 
mut method 
Void #apply(This2.Size that, This1.Selectors val) 
mut method 
Void left(This1.Selectors that) 
mut method 
Void right(This1.Selectors that) 
mut method 
Void add(This2.Size that, This1.Selectors val) 
mut method 
Void add(This1.Selectors right) 
mut method 
Void add(This1.Selectors left) 
mut method 
Void removeLeft() 
mut method 
Void removeRight() 
method 
This0 #plus#0left(This1.Selectors right) 
method 
This0 #plusplus#0left(This0 right) 
method 
This0 with(This2.Size that, This1.Selectors val) 
method 
This0 withLeft(This1.Selectors that) 
method 
This0 withRight(This1.Selectors that) 
method 
This0 withAlso(This2.Size that, This1.Selectors val) 
method 
This0 withAlsoLeft(This1.Selectors that) 
method 
This0 withAlsoRight(This1.Selectors that) 
method 
This0 withoutLeft() 
method 
This0 withoutRight() 
read method 
lent This0.IteratorVal vals(This2.Size from, This2.Size maxTo, This2.Size minTo) 
read method 
lent This0.IteratorVal vals(This2.Size minTo) 
read method 
lent This0.IteratorVal vals(This2.Size from, This2.Size to) 
read method 
lent This0.IteratorValFill vals(This2.Size from, This2.Size maxTo, This2.Size minTo, This1.Selectors filled) 
read method 
lent This0.IteratorValFill vals(This2.Size minTo, This1.Selectors filled) 
read method 
lent This0.IteratorValFill vals(This2.Size from, This2.Size to, This1.Selectors filled) 
read method 
lent This0.IteratorValFill vals(This1.Selectors filled) 
mut method 
lent This0.IteratorVar #vals(This2.Size from, This2.Size maxTo, This2.Size minTo) 
mut method 
lent This0.IteratorVar #vals(This2.Size minTo) 
mut method 
lent This0.IteratorVar #vals(This2.Size from, This2.Size to) 
mut method 
lent This0.IteratorVar #vals() 
refine read method 
This2.S toS() 
read method 
This2.Size size() 
read method 
This1.Selectors val(This2.Size that) 
class method 
mut This0 #seqBuilder() 
class method 
mut This0 #from(mut This0 seqBuilder) 
mut method 
Void #add(This1.Selectors that) 
read method 
lent This0.IteratorVal vals() 
read method 
This2.Bool contains(This1.Selectors that) 
method 
This0 #less#0left(This1.Selectors right) 
method 
This0 #lessless#0left(This0 right) 
method 
This0 #and#0left(This0 right) 
method 
This2.Bool #rightright#0left(This0 right) 
method 
This2.Bool #rightrightequal#0left(This0 right) 
method 
This2.Bool #right#0left(This1.Selectors right) 
read method 
This2.Bool equals(read This0 that) 
refine read method 
This2.Bool #equalequal#0left(read Any right) 
read method 
This2.Size indexOfLeft(This1.Selectors val) 
read method 
This2.Size indexOfRight(This1.Selectors val) 
method /*from VectorTrait
*/This0 without(This2.Size index) 
method 
This0 withoutLeft(This1.Selectors val) 
method 
This0 withoutRight(This1.Selectors val) 
method 
This0 withoutAll(This1.Selectors val) 
mut method /*from VectorTrait
*/Void remove(This2.Size that) 
mut method 
Void removeAll(This1.Selectors val) 
mut method 
Void removeLeft(This1.Selectors val) 
mut method 
Void removeRight(This1.Selectors val) 
Cast: {
class method 
This2.Selectors #apply(Any that) }
IteratorTrait: {
class method 
Library #apply() }
IteratorValFill: {
mut method 
Void #next() exception Void 
read method 
Void #checkEnd() 
read method 
This2.Selectors #inner() 
read method 
Void #close() 
read method 
read This3.Collections.MutListAny _that() 
mut method 
Void from(This3.Size that) 
read method 
This3.Size from() 
read method 
This3.Size maxTo() 
read method 
This3.Size minTo() 
read method 
This2.Selectors filled() 
read method 
read This3.Collections.MutListAny that() 
class method 
lent This0 #apply(read This3.Collections.MutListAny _that, This3.Size from, This3.Size maxTo, This3.Size minTo, This2.Selectors filled) 
class method 
lent This0 #apply(read This3.Collections.MutListAny that, This3.Size from, This3.Size maxTo, This3.Size minTo, This2.Selectors filled) 
read method 
This3.Bool isFill() }
IteratorVar: {
mut method 
Void #next() exception Void 
read method 
Void #checkEnd() 
read method 
This2.Selectors #inner() 
read method 
Void #close() 
read method 
read This3.Collections.MutListAny that() 
mut method 
mut This3.Collections.MutListAny #that() 
mut method 
Void from(This3.Size that) 
read method 
This3.Size from() 
read method 
This3.Size maxTo() 
read method 
This3.Size minTo() 
class method 
mut This0 #apply(mut This3.Collections.MutListAny that, This3.Size from, This3.Size maxTo, This3.Size minTo) 
mut method 
Void inner(This2.Selectors that) 
read method 
This3.Bool isFill() 
read method 
This2.Selectors filled() }
IteratorVal: {
read method 
read This3.Collections.MutListAny _that() 
mut method 
Void from(This3.Size that) 
read method 
This3.Size from() 
read method 
This3.Size maxTo() 
read method 
This3.Size minTo() 
read method 
read This3.Collections.MutListAny that() 
class method 
lent This0 #apply(read This3.Collections.MutListAny _that, This3.Size from, This3.Size maxTo, This3.Size minTo) 
class method 
lent This0 #apply(read This3.Collections.MutListAny that, This3.Size from, This3.Size maxTo, This3.Size minTo) 
read method 
This3.Bool isFill() 
read method 
This2.Selectors filled() 
mut method 
Void #next() exception Void 
read method 
Void #checkEnd() 
read method 
This2.Selectors #inner() 
read method 
Void #close() }}
RenameMethods: {implements This2.Concept.ToS, This2.Concept.Classable
refine class method /*
  Cast a (read/imm) object to this type.
  A class implementing this method should refine the return type to This.
  if is(subtype) is true, then cast(that) must produce a result.
  */read This0 cast(read This2.Concept.Classable that) 
refine class method /*
  Cast a (mutable) object to this type.
  A class implementing this method should refine the return type to This.
  if cast(that) produces a result, then #cast(that) also must produce a result.
  */mut This0 #cast(mut This2.Concept.Classable that) 
refine read method /*
  Extracts the class singleton from another instance of this class
  */class This0 class() 
refine class method /*
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  */This2.S readableName() 
refine class method /*
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  */This2.Bool is(class This2.Concept.Classable subtype) 
read method 
read This2.CollectionsMut.MutListAny inner() 
mut method 
mut This2.CollectionsMut.MutListAny #inner() 
class method 
mut This0 #apply(fwd mut This2.CollectionsMut.MutListAny inner) 
class method 
This0 #immK(This2.CollectionsMut.MutListAny inner) 
class method 
mut This0 empty() 
class method 
mut This0 #seqBuilder() 
class method 
mut This0 #from(mut This0 seqBuilder) 
mut method 
Void #add(mut This2.Refactor2.Method that) 
mut method 
mut This0 #reverse() 
read method 
This2.Size size() 
read method 
This2.Bool isEmpty() 
read method 
read This2.Refactor2.Method val(This2.Size that) 
mut method 
mut This2.Refactor2.Method #val(This2.Size that) 
read method 
class This2.Size #default#val(Void that) 
read method 
read This2.Refactor2.Method left() 
read method 
read This2.Refactor2.Method right() 
mut method 
mut This2.Refactor2.Method #left() 
mut method 
mut This2.Refactor2.Method #right() 
mut method 
Void #apply(This2.Size that, mut This2.Refactor2.Method val) 
mut method 
Void left(mut This2.Refactor2.Method that) 
mut method 
Void right(mut This2.Refactor2.Method that) 
mut method 
Void add(This2.Size that, mut This2.Refactor2.Method val) 
mut method 
Void add(mut This2.Refactor2.Method right) 
mut method 
Void add(mut This2.Refactor2.Method left) 
mut method 
Void remove(This2.Size that) 
mut method 
Void removeLeft() 
mut method 
Void removeRight() 
method 
This0 #plus#0left(This2.Refactor2.Method right) 
method 
This0 #plusplus#0left(This0 right) 
method 
This0 with(This2.Size that, This2.Refactor2.Method val) 
method 
This0 withLeft(This2.Refactor2.Method that) 
method 
This0 withRight(This2.Refactor2.Method that) 
method 
This0 withAlso(This2.Size that, This2.Refactor2.Method val) 
method 
This0 withAlsoLeft(This2.Refactor2.Method that) 
method 
This0 withAlsoRight(This2.Refactor2.Method that) 
method 
This0 without(This2.Size index) 
method 
This0 withoutLeft() 
method 
This0 withoutRight() 
read method 
lent This0.IteratorVal vals(This2.Size from, This2.Size maxTo, This2.Size minTo) 
read method 
lent This0.IteratorVal vals(This2.Size minTo) 
read method 
lent This0.IteratorVal vals(This2.Size from, This2.Size to) 
read method 
lent This0.IteratorVal vals() 
read method 
lent This0.IteratorValFill vals(This2.Size from, This2.Size maxTo, This2.Size minTo, read This2.Refactor2.Method filled) 
read method 
lent This0.IteratorValFill vals(This2.Size minTo, read This2.Refactor2.Method filled) 
read method 
lent This0.IteratorValFill vals(This2.Size from, This2.Size to, read This2.Refactor2.Method filled) 
read method 
lent This0.IteratorValFill vals(read This2.Refactor2.Method filled) 
mut method 
mut This0.IteratorVar #vals(This2.Size from, This2.Size maxTo, This2.Size minTo) 
mut method 
mut This0.IteratorVar #vals(This2.Size minTo) 
mut method 
mut This0.IteratorVar #vals(This2.Size from, This2.Size to) 
mut method 
mut This0.IteratorVar #vals() 
refine read method 
This2.S toS() 
Cast: {
class method 
read This3.Refactor2.Method #apply(read Any that) 
class method 
mut This3.Refactor2.Method mut(mut Any that) }
IteratorTrait: {
class method 
Library #apply() }
IteratorVal: {
mut method 
Void #next() exception Void 
read method 
Void #checkEnd() 
read method 
read This3.Refactor2.Method readInner() 
mut method 
mut This3.Refactor2.Method mutInner() 
read method 
Void #close() 
mut method 
Void from(This3.Size that) 
read method 
This3.Size from() 
read method 
This3.Size maxTo() 
read method 
This3.Size minTo() 
read method 
read This3.CollectionsMut.MutListAny that() 
mut method 
mut This3.CollectionsMut.MutListAny #that() 
class method 
lent This0 #apply(read This3.CollectionsMut.MutListAny that, This3.Size from, This3.Size maxTo, This3.Size minTo) 
read method 
read This3.Refactor2.Method #inner() 
read method 
This3.Bool isFill() 
read method 
read This3.Refactor2.Method filled() 
mut method 
mut This3.Refactor2.Method #filled() }
IteratorValFill: {
mut method 
Void #next() exception Void 
read method 
Void #checkEnd() 
read method 
read This3.Refactor2.Method readInner() 
mut method 
mut This3.Refactor2.Method mutInner() 
read method 
Void #close() 
mut method 
Void from(This3.Size that) 
read method 
This3.Size from() 
read method 
This3.Size maxTo() 
read method 
This3.Size minTo() 
read method 
read This3.Refactor2.Method filled() 
mut method 
mut This3.Refactor2.Method #filled() 
read method 
read This3.CollectionsMut.MutListAny that() 
mut method 
mut This3.CollectionsMut.MutListAny #that() 
class method 
lent This0 #apply(read This3.CollectionsMut.MutListAny that, This3.Size from, This3.Size maxTo, This3.Size minTo, read This3.Refactor2.Method filled) 
read method 
read This3.Refactor2.Method #inner() 
read method 
This3.Bool isFill() }
IteratorVar: {
mut method 
Void #next() exception Void 
read method 
Void #checkEnd() 
read method 
read This3.Refactor2.Method readInner() 
mut method 
mut This3.Refactor2.Method mutInner() 
read method 
Void #close() 
read method 
read This3.CollectionsMut.MutListAny that() 
mut method 
mut This3.CollectionsMut.MutListAny #that() 
mut method 
Void from(This3.Size that) 
read method 
This3.Size from() 
read method 
This3.Size maxTo() 
read method 
This3.Size minTo() 
class method 
mut This0 #apply(mut This3.CollectionsMut.MutListAny that, This3.Size from, This3.Size maxTo, This3.Size minTo) 
mut method 
Void inner(mut This3.Refactor2.Method that) 
mut method 
mut This3.Refactor2.Method #inner() 
read method 
This3.Bool isFill() 
read method 
read This3.Refactor2.Method filled() 
mut method 
mut This3.Refactor2.Method #filled() }}
Libs: {implements This2.Concept.ToS, This2.Concept.Classable
refine class method /*
  Cast a (read/imm) object to this type.
  A class implementing this method should refine the return type to This.
  if is(subtype) is true, then cast(that) must produce a result.
  */read This0 cast(read This2.Concept.Classable that) 
refine class method /*
  Cast a (mutable) object to this type.
  A class implementing this method should refine the return type to This.
  if cast(that) produces a result, then #cast(that) also must produce a result.
  */mut This0 #cast(mut This2.Concept.Classable that) 
refine read method /*
  Extracts the class singleton from another instance of this class
  */class This0 class() 
refine class method /*
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  */This2.S readableName() 
refine class method /*
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  */This2.Bool is(class This2.Concept.Classable subtype) 
read method 
read This2.Collections.MutListAny inner() 
mut method 
mut This2.Collections.MutListAny #inner() 
class method 
mut This0 #apply(fwd mut This2.Collections.MutListAny inner) 
class method 
This0 #immK(This2.Collections.MutListAny inner) 
class method 
mut This0 empty() 
class method 
mut This0 #seqBuilder() 
class method 
mut This0 #from(mut This0 seqBuilder) 
mut method 
Void #add(Library that) 
read method 
mut This0 reverse() 
read method 
This2.Size size() 
read method 
This2.Bool isEmpty() 
read method 
Library val(This2.Size that) 
read method 
class This2.Size #default#val(Void that) 
read method 
Library left() 
read method 
Library right() 
mut method 
Void #apply(This2.Size that, Library val) 
mut method 
Void left(Library that) 
mut method 
Void right(Library that) 
mut method 
Void add(This2.Size that, Library val) 
mut method 
Void add(Library right) 
mut method 
Void add(Library left) 
mut method 
Void remove(This2.Size that) 
mut method 
Void removeLeft() 
mut method 
Void removeRight() 
method 
This0 #plus#0left(Library right) 
method 
This0 #plusplus#0left(This0 right) 
method 
This0 with(This2.Size that, Library val) 
method 
This0 withLeft(Library that) 
method 
This0 withRight(Library that) 
method 
This0 withAlso(This2.Size that, Library val) 
method 
This0 withAlsoLeft(Library that) 
method 
This0 withAlsoRight(Library that) 
method 
This0 without(This2.Size index) 
method 
This0 withoutLeft() 
method 
This0 withoutRight() 
read method 
lent This0.IteratorVal vals(This2.Size from, This2.Size maxTo, This2.Size minTo) 
read method 
lent This0.IteratorVal vals(This2.Size minTo) 
read method 
lent This0.IteratorVal vals(This2.Size from, This2.Size to) 
read method 
lent This0.IteratorVal vals() 
read method 
lent This0.IteratorValFill vals(This2.Size from, This2.Size maxTo, This2.Size minTo, Library filled) 
read method 
lent This0.IteratorValFill vals(This2.Size minTo, Library filled) 
read method 
lent This0.IteratorValFill vals(This2.Size from, This2.Size to, Library filled) 
read method 
lent This0.IteratorValFill vals(Library filled) 
mut method 
lent This0.IteratorVar #vals(This2.Size from, This2.Size maxTo, This2.Size minTo) 
mut method 
lent This0.IteratorVar #vals(This2.Size minTo) 
mut method 
lent This0.IteratorVar #vals(This2.Size from, This2.Size to) 
mut method 
lent This0.IteratorVar #vals() 
refine read method 
This2.S toS() 
Cast: {
class method 
Library #apply(Any that) }
IteratorTrait: {
class method 
Library #apply() }
IteratorVal: {
mut method 
Void #next() exception Void 
read method 
Void #checkEnd() 
read method 
Library #inner() 
read method 
Void #close() 
read method 
read This3.Collections.MutListAny _that() 
mut method 
Void from(This3.Size that) 
read method 
This3.Size from() 
read method 
This3.Size maxTo() 
read method 
This3.Size minTo() 
read method 
read This3.Collections.MutListAny that() 
class method 
lent This0 #apply(read This3.Collections.MutListAny _that, This3.Size from, This3.Size maxTo, This3.Size minTo) 
class method 
lent This0 #apply(read This3.Collections.MutListAny that, This3.Size from, This3.Size maxTo, This3.Size minTo) 
read method 
This3.Bool isFill() 
read method 
Library filled() }
IteratorValFill: {
mut method 
Void #next() exception Void 
read method 
Void #checkEnd() 
read method 
Library #inner() 
read method 
Void #close() 
read method 
read This3.Collections.MutListAny _that() 
mut method 
Void from(This3.Size that) 
read method 
This3.Size from() 
read method 
This3.Size maxTo() 
read method 
This3.Size minTo() 
read method 
Library filled() 
read method 
read This3.Collections.MutListAny that() 
class method 
lent This0 #apply(read This3.Collections.MutListAny _that, This3.Size from, This3.Size maxTo, This3.Size minTo, Library filled) 
class method 
lent This0 #apply(read This3.Collections.MutListAny that, This3.Size from, This3.Size maxTo, This3.Size minTo, Library filled) 
read method 
This3.Bool isFill() }
IteratorVar: {
mut method 
Void #next() exception Void 
read method 
Void #checkEnd() 
read method 
Library #inner() 
read method 
Void #close() 
read method 
read This3.Collections.MutListAny that() 
mut method 
mut This3.Collections.MutListAny #that() 
mut method 
Void from(This3.Size that) 
read method 
This3.Size from() 
read method 
This3.Size maxTo() 
read method 
This3.Size minTo() 
class method 
mut This0 #apply(mut This3.Collections.MutListAny that, This3.Size from, This3.Size maxTo, This3.Size minTo) 
mut method 
Void inner(Library that) 
read method 
This3.Bool isFill() 
read method 
Library filled() }}}
Load: {/*shape of a loadable library:
 This contains actual library, but
 Abstract:{} contains abstract classes, and
 Abstract.ConceptMap maps concepts names to abstract classes
*/
class method 
Library cacheTowel() 
class method 
Library #leftrightleft#0left(Library right) exception This0.ConceptMapMismatch, This0.ConceptMapUnavailable 
ConceptMapMismatch: {implements This2.Guard, This2.Message, This2.Concept.Base, This2.Concept.ToS, This2.Concept.Classable, This2.Concept.Equals
refine read method 
class This0 class() 
refine class method /*
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  */This2.S readableName() 
refine class method /*
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  */This2.Bool is(class This2.Concept.Classable subtype) 
refine read method 
This2.Bool #equalequal#0left(read Any right) 
refine class method 
read This0 cast(read This2.Concept.Classable that) 
refine class method 
mut This0 #cast(mut This2.Concept.Classable that) 
read method 
This2.S _text() 
read method 
This2.Message.Opt cause() 
class method 
This0 #apply(This2.S _text, This2.Message.Opt cause) 
refine class method 
This2.S kind() 
refine read method 
This2.S text() 
refine read method 
This2.Message.Opt responseOf() 
method 
This0 #apply(This2.Message that) 
refine read method 
This2.S toS() 
read method 
This2.Bool equals(read This0 that) 
class method 
This0 #apply(This2.S text) 
class method 
This0 #apply(This2.S text, This2.Message cause) 
class method 
mut This2.S.SBuilder #builder() 
class method 
This0 #from(This2.S.SBuilder builder) 
method 
This0.Continue #from(This2.S.SConcat seqBuilder) 
method 
mut This2.S.SConcat #seqBuilder() 
Continue: {
read method 
This3.S that() 
class method 
This0 #apply(This3.S that) 
method 
mut This3.S.SBuilder #builder() 
method 
This1 #from(This3.S.SBuilder builder) }}
ConceptMapUnavailable: {implements This2.Guard, This2.Message, This2.Concept.Base, This2.Concept.ToS, This2.Concept.Classable, This2.Concept.Equals
refine read method 
class This0 class() 
refine class method /*
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  */This2.S readableName() 
refine class method /*
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  */This2.Bool is(class This2.Concept.Classable subtype) 
refine read method 
This2.Bool #equalequal#0left(read Any right) 
refine class method 
read This0 cast(read This2.Concept.Classable that) 
refine class method 
mut This0 #cast(mut This2.Concept.Classable that) 
read method 
This2.S _text() 
read method 
This2.Message.Opt cause() 
class method 
This0 #apply(This2.S _text, This2.Message.Opt cause) 
refine class method 
This2.S kind() 
refine read method 
This2.S text() 
refine read method 
This2.Message.Opt responseOf() 
method 
This0 #apply(This2.Message that) 
refine read method 
This2.S toS() 
read method 
This2.Bool equals(read This0 that) 
class method 
This0 #apply(This2.S text) 
class method 
This0 #apply(This2.S text, This2.Message cause) 
class method 
mut This2.S.SBuilder #builder() 
class method 
This0 #from(This2.S.SBuilder builder) 
method 
This0.Continue #from(This2.S.SConcat seqBuilder) 
method 
mut This2.S.SConcat #seqBuilder() 
Continue: {
read method 
This3.S that() 
class method 
This0 #apply(This3.S that) 
method 
mut This3.S.SBuilder #builder() 
method 
This1 #from(This3.S.SBuilder builder) }}
DeployLibrary: {/*@untrusted
*/
read method 
This2.Path path() 
read method 
This2.Url url() 
class method 
mut This0 #$(This2.Path path, This2.Url url) 
class method 
Library moveToAbstract(This2.Path that, Library of) 
class method 
This2.X.AssertionFail msg(This2.Path that, Library of) 
class method 
Library exposeAsLibrary(Library that, This2.Path path) exception This2.Refactor2.PathUnfit, This2.Refactor2.PrivacyCoupuled, This2.Location.NotAvailable 
class method 
Void checkTargetExists(Library that, This2.Path path) exception This2.Refactor2.PathUnfit 
mut method 
Library #leftrightleft#0left(Library right) exception This2.Refactor2.PathUnfit, This2.Refactor2.PrivacyCoupuled, This2.Location.NotAvailable }}}
GuiPlugin: {/*@plugin
L42.is/connected/withHtml
*/}
Iterator: {/*@untrusted
*/
read method 
This1.Abstract.S id() 
mut method 
Void current(This1.Abstract.S that) 
read method 
This1.Abstract.S current() 
class method 
This1.Abstract.S #$auxFetchEvent(This1.Abstract.S id) exception Void (
  Void unused40451=(
    Library s=use This1.GuiPlugin check eventPending(wName:id.#binaryRepr()) exception void
    
    catch error Library x exception void
    
    (
      Void unused40452=return This1.Abstract.S.#from(binaryRepr:s)
      void
      )
    )
  
  catch return capsule This1.Abstract.S result170 result170
  
  error  {/*@stringU
CurlyBlock-Should be unreachable code
*/}
  )
mut method 
Void #next() exception Void (
  Void unused40453=(
    This1.Abstract.S s=This0.#$auxFetchEvent(id:this.id())
    Void unused40454=return this.current(that:s)
    void
    )
  
  catch return Void result171 result171
  
  error  {/*@stringU
CurlyBlock-Should be unreachable code
*/}
  )
read method 
Void #checkEnd() void
read method 
This1.Abstract.S #inner() (this.current())
read method 
Void #close() void
class method 
mut This0 #$(fwd This1.Abstract.S id, fwd This1.Abstract.S current) }}