 {/*@untrusted
*/
read method 
This0.Abstract.S id() 
class method 
This0.Abstract.S jsEscape(This0.Abstract.S that) (
  var This0.Abstract.S tmp=that
  Void unused31011=tmp := tmp.replace(that:This0.Abstract.S.#from(builder:(
    mut This0.Abstract.S.SBuilder b854=This0.Abstract.S.#builder()
    Void unused31015=b854.#backslash()
    b854
    )), into:This0.Abstract.S.#from(builder:(
    mut This0.Abstract.S.SBuilder b855=This0.Abstract.S.#builder()
    Void unused31016=b855.#backslash()
    Void unused31017=b855.#backslash()
    b855
    )))
  Void unused31012=tmp := tmp.replace(that:This0.Abstract.S.doubleQuote(), into:(
    This0.Abstract.S imm$opPar471=This0.Abstract.S.#from(builder:(
      mut This0.Abstract.S.SBuilder b856=This0.Abstract.S.#builder()
      Void unused31018=b856.#backslash()
      b856
      ))
    This0.Abstract.S imm$opPar472=This0.Abstract.S.doubleQuote()
    imm$opPar471.#plusplus#0left(right:imm$opPar472)
    ))
  Void unused31013=tmp := tmp.replace(that:This0.Abstract.S.#from(builder:(
    mut This0.Abstract.S.SBuilder b857=This0.Abstract.S.#builder()
    Void unused31019=b857.#sQuote()
    b857
    )), into:This0.Abstract.S.#from(builder:(
    mut This0.Abstract.S.SBuilder b858=This0.Abstract.S.#builder()
    Void unused31020=b858.#backslash()
    Void unused31021=b858.#sQuote()
    b858
    )))
  Void unused31014=tmp := (//tmp:=tmp.replace(S"\u" into:S"\u005cu")
tmp.replace(that:This0.Abstract.S.nl(), into:This0.Abstract.S.#from(builder:(
    mut This0.Abstract.S.SBuilder b859=This0.Abstract.S.#builder()
    Void unused31022=b859.#backslash()
    Void unused31023=b859.#n()
    b859
    ))))
  tmp
  )
mut method 
Void close() use This0.GuiPlugin check close(wName:this.id().#binaryRepr()) error void
mut method 
Void open(This0.Abstract.S title, This0.Abstract.S body, This0.Abstract.Size x, This0.Abstract.Size y) this.open(html:(
  This0.Abstract.S.Continue rcv1=(
    This0.Abstract.S rcv2=(
      This0.Abstract.S.Continue rcv3=(
        This0.Abstract.S rcv4=(
          This0.Abstract.S.Continue rcv5=(
            This0.Abstract.S rcv6=This0.Abstract.S.#from(builder:(
              mut This0.Abstract.S.SBuilder b860=This0.Abstract.S.#builder()
              b860
              ))
            rcv6.#from(seqBuilder:(
              mut This0.Abstract.S.SConcat b861=rcv6.#seqBuilder()
              Void unused31024=b861.#add(that:This0.htmlHeader())
              b861
              ))
            )
          rcv5.#from(builder:(
            mut This0.Abstract.S.SBuilder b862=rcv5.#builder()
            Void unused31025=b862.#left()
            Void unused31026=b862.#t()
            Void unused31027=b862.#i()
            Void unused31028=b862.#t()
            Void unused31029=b862.#l()
            Void unused31030=b862.#e()
            Void unused31031=b862.#right()
            b862
            ))
          )
        rcv4.#from(seqBuilder:(
          mut This0.Abstract.S.SConcat b863=rcv4.#seqBuilder()
          Void unused31032=b863.#add(that:title)
          b863
          ))
        )
      rcv3.#from(builder:(
        mut This0.Abstract.S.SBuilder b864=rcv3.#builder()
        Void unused31033=b864.#left()
        Void unused31034=b864.#divide()
        Void unused31035=b864.#t()
        Void unused31036=b864.#i()
        Void unused31037=b864.#t()
        Void unused31038=b864.#l()
        Void unused31039=b864.#e()
        Void unused31040=b864.#right()
        Void unused31041=b864.#left()
        Void unused31042=b864.#divide()
        Void unused31043=b864.#h()
        Void unused31044=b864.#e()
        Void unused31045=b864.#a()
        Void unused31046=b864.#d()
        Void unused31047=b864.#right()
        Void unused31048=b864.#left()
        Void unused31049=b864.#b()
        Void unused31050=b864.#o()
        Void unused31051=b864.#d()
        Void unused31052=b864.#y()
        Void unused31053=b864.#right()
        b864
        ))
      )
    rcv2.#from(seqBuilder:(
      mut This0.Abstract.S.SConcat b865=rcv2.#seqBuilder()
      Void unused31054=b865.#add(that:body)
      b865
      ))
    )
  rcv1.#from(builder:(
    mut This0.Abstract.S.SBuilder b866=rcv1.#builder()
    Void unused31055=b866.#left()
    Void unused31056=b866.#divide()
    Void unused31057=b866.#b()
    Void unused31058=b866.#o()
    Void unused31059=b866.#d()
    Void unused31060=b866.#y()
    Void unused31061=b866.#right()
    Void unused31062=b866.#left()
    Void unused31063=b866.#divide()
    Void unused31064=b866.#h()
    Void unused31065=b866.#t()
    Void unused31066=b866.#m()
    Void unused31067=b866.#l()
    Void unused31068=b866.#right()
    b866
    ))
  ), x:x, y:y)
class method 
This0.Abstract.S htmlHeader() (//        '<script>
//        '
//        "[Debug.readFile(fileName:Debug.localToAbsolute(fileName:S"examples/resources/js.js"))]"
//        '
//        '</script>
//        "
This0.Abstract.S.#from(builder:(
  mut This0.Abstract.S.SBuilder b867=This0.Abstract.S.#builder()
  Void unused31069=b867.#left()
  Void unused31070=b867.#bang()
  Void unused31071=b867.#D()
  Void unused31072=b867.#O()
  Void unused31073=b867.#C()
  Void unused31074=b867.#T()
  Void unused31075=b867.#Y()
  Void unused31076=b867.#P()
  Void unused31077=b867.#E()
  Void unused31078=b867.#space()
  Void unused31079=b867.#h()
  Void unused31080=b867.#t()
  Void unused31081=b867.#m()
  Void unused31082=b867.#l()
  Void unused31083=b867.#right()
  Void unused31084=b867.#left()
  Void unused31085=b867.#h()
  Void unused31086=b867.#t()
  Void unused31087=b867.#m()
  Void unused31088=b867.#l()
  Void unused31089=b867.#right()
  Void unused31090=b867.#left()
  Void unused31091=b867.#h()
  Void unused31092=b867.#e()
  Void unused31093=b867.#a()
  Void unused31094=b867.#d()
  Void unused31095=b867.#right()
  Void unused31096=b867.#left()
  Void unused31097=b867.#m()
  Void unused31098=b867.#e()
  Void unused31099=b867.#t()
  Void unused31100=b867.#a()
  Void unused31101=b867.#space()
  Void unused31102=b867.#h()
  Void unused31103=b867.#t()
  Void unused31104=b867.#t()
  Void unused31105=b867.#p()
  Void unused31106=b867.#less()
  Void unused31107=b867.#e()
  Void unused31108=b867.#q()
  Void unused31109=b867.#u()
  Void unused31110=b867.#i()
  Void unused31111=b867.#v()
  Void unused31112=b867.#equal()
  Void unused31113=b867.#dQuote()
  Void unused31114=b867.#c()
  Void unused31115=b867.#o()
  Void unused31116=b867.#n()
  Void unused31117=b867.#t()
  Void unused31118=b867.#e()
  Void unused31119=b867.#n()
  Void unused31120=b867.#t()
  Void unused31121=b867.#less()
  Void unused31122=b867.#c()
  Void unused31123=b867.#l()
  Void unused31124=b867.#a()
  Void unused31125=b867.#s()
  Void unused31126=b867.#s()
  Void unused31127=b867.#dQuote()
  Void unused31128=b867.#space()
  Void unused31129=b867.#c()
  Void unused31130=b867.#o()
  Void unused31131=b867.#n()
  Void unused31132=b867.#t()
  Void unused31133=b867.#e()
  Void unused31134=b867.#n()
  Void unused31135=b867.#t()
  Void unused31136=b867.#equal()
  Void unused31137=b867.#dQuote()
  Void unused31138=b867.#t()
  Void unused31139=b867.#e()
  Void unused31140=b867.#x()
  Void unused31141=b867.#t()
  Void unused31142=b867.#divide()
  Void unused31143=b867.#h()
  Void unused31144=b867.#t()
  Void unused31145=b867.#m()
  Void unused31146=b867.#l()
  Void unused31147=b867.#semicolon()
  Void unused31148=b867.#space()
  Void unused31149=b867.#c()
  Void unused31150=b867.#h()
  Void unused31151=b867.#a()
  Void unused31152=b867.#r()
  Void unused31153=b867.#s()
  Void unused31154=b867.#e()
  Void unused31155=b867.#t()
  Void unused31156=b867.#equal()
  Void unused31157=b867.#U()
  Void unused31158=b867.#T()
  Void unused31159=b867.#F()
  Void unused31160=b867.#less()
  Void unused31161=b867.#8()
  Void unused31162=b867.#dQuote()
  Void unused31163=b867.#right()
  Void unused31164=b867.#newline()
  b867
  )))
mut method 
Void open(This0.Abstract.S html, This0.Abstract.Size x, This0.Abstract.Size y) (
  Void unused31165=This0.Abstract.Debug.#apply(that:html)
  use This0.GuiPlugin check open(wName:this.id().#binaryRepr(), html:html.#binaryRepr(), x:x.#binaryRepr(), y:y.#binaryRepr()) error void
  )
mut method 
Void set(This0.Abstract.S that, This0.Abstract.S id) (
  Void unused31166=(/*$('#Alpha').replaceWith('htmlstring')
*/
    This0.Abstract.S qid=(
      This0.Abstract.S.Continue rcv7=(
        This0.Abstract.S rcv8=This0.Abstract.S.#from(builder:(
          mut This0.Abstract.S.SBuilder b868=This0.Abstract.S.#builder()
          Void unused31170=b868.#sQuote()
          b868
          ))
        rcv8.#from(seqBuilder:(
          mut This0.Abstract.S.SConcat b869=rcv8.#seqBuilder()
          Void unused31171=b869.#add(that:This0.jsEscape(that:id))
          b869
          ))
        )
      rcv7.#from(builder:(
        mut This0.Abstract.S.SBuilder b870=rcv7.#builder()
        Void unused31172=b870.#sQuote()
        b870
        ))
      )
    This0.Abstract.S qText=(
      This0.Abstract.S.Continue rcv9=(
        This0.Abstract.S rcv10=This0.Abstract.S.#from(builder:(
          mut This0.Abstract.S.SBuilder b871=This0.Abstract.S.#builder()
          Void unused31173=b871.#sQuote()
          b871
          ))
        rcv10.#from(seqBuilder:(
          mut This0.Abstract.S.SConcat b872=rcv10.#seqBuilder()
          Void unused31174=b872.#add(that:This0.jsEscape(that:that))
          b872
          ))
        )
      rcv9.#from(builder:(
        mut This0.Abstract.S.SBuilder b873=rcv9.#builder()
        Void unused31175=b873.#sQuote()
        b873
        ))
      )
    This0.Abstract.S cmd=(
      This0.Abstract.S.Continue rcv11=(
        This0.Abstract.S rcv12=(
          This0.Abstract.S.Continue rcv13=(
            This0.Abstract.S rcv14=This0.Abstract.S.#from(builder:(
              mut This0.Abstract.S.SBuilder b874=This0.Abstract.S.#builder()
              Void unused31176=b874.#v()
              Void unused31177=b874.#a()
              Void unused31178=b874.#r()
              Void unused31179=b874.#space()
              Void unused31180=b874.#o()
              Void unused31181=b874.#l()
              Void unused31182=b874.#d()
              Void unused31183=b874.#E()
              Void unused31184=b874.#l()
              Void unused31185=b874.#e()
              Void unused31186=b874.#m()
              Void unused31187=b874.#space()
              Void unused31188=b874.#equal()
              Void unused31189=b874.#space()
              Void unused31190=b874.#d()
              Void unused31191=b874.#o()
              Void unused31192=b874.#c()
              Void unused31193=b874.#u()
              Void unused31194=b874.#m()
              Void unused31195=b874.#e()
              Void unused31196=b874.#n()
              Void unused31197=b874.#t()
              Void unused31198=b874.#dot()
              Void unused31199=b874.#g()
              Void unused31200=b874.#e()
              Void unused31201=b874.#t()
              Void unused31202=b874.#E()
              Void unused31203=b874.#l()
              Void unused31204=b874.#e()
              Void unused31205=b874.#m()
              Void unused31206=b874.#e()
              Void unused31207=b874.#n()
              Void unused31208=b874.#t()
              Void unused31209=b874.#B()
              Void unused31210=b874.#y()
              Void unused31211=b874.#I()
              Void unused31212=b874.#d()
              Void unused31213=b874.#oRound()
              Void unused31214=b874.#newline()
              b874
              ))
            rcv14.#from(seqBuilder:(
              mut This0.Abstract.S.SConcat b875=rcv14.#seqBuilder()
              Void unused31215=b875.#add(that:qid)
              b875
              ))
            )
          rcv13.#from(builder:(
            mut This0.Abstract.S.SBuilder b876=rcv13.#builder()
            Void unused31216=b876.#cRound()
            Void unused31217=b876.#semicolon()
            Void unused31218=b876.#newline()
            Void unused31219=b876.#o()
            Void unused31220=b876.#l()
            Void unused31221=b876.#d()
            Void unused31222=b876.#E()
            Void unused31223=b876.#l()
            Void unused31224=b876.#e()
            Void unused31225=b876.#m()
            Void unused31226=b876.#dot()
            Void unused31227=b876.#i()
            Void unused31228=b876.#n()
            Void unused31229=b876.#n()
            Void unused31230=b876.#e()
            Void unused31231=b876.#r()
            Void unused31232=b876.#H()
            Void unused31233=b876.#T()
            Void unused31234=b876.#M()
            Void unused31235=b876.#L()
            Void unused31236=b876.#space()
            Void unused31237=b876.#equal()
            Void unused31238=b876.#newline()
            b876
            ))
          )
        rcv12.#from(seqBuilder:(
          mut This0.Abstract.S.SConcat b877=rcv12.#seqBuilder()
          Void unused31239=b877.#add(that:qText)
          b877
          ))
        )
      rcv11.#from(builder:(
        mut This0.Abstract.S.SBuilder b878=rcv11.#builder()
        Void unused31240=b878.#semicolon()
        Void unused31241=b878.#newline()
        Void unused31242=b878.#v()
        Void unused31243=b878.#a()
        Void unused31244=b878.#r()
        Void unused31245=b878.#space()
        Void unused31246=b878.#p()
        Void unused31247=b878.#a()
        Void unused31248=b878.#r()
        Void unused31249=b878.#e()
        Void unused31250=b878.#n()
        Void unused31251=b878.#t()
        Void unused31252=b878.#E()
        Void unused31253=b878.#l()
        Void unused31254=b878.#e()
        Void unused31255=b878.#m()
        Void unused31256=b878.#space()
        Void unused31257=b878.#equal()
        Void unused31258=b878.#space()
        Void unused31259=b878.#o()
        Void unused31260=b878.#l()
        Void unused31261=b878.#d()
        Void unused31262=b878.#E()
        Void unused31263=b878.#l()
        Void unused31264=b878.#e()
        Void unused31265=b878.#m()
        Void unused31266=b878.#dot()
        Void unused31267=b878.#p()
        Void unused31268=b878.#a()
        Void unused31269=b878.#r()
        Void unused31270=b878.#e()
        Void unused31271=b878.#n()
        Void unused31272=b878.#t()
        Void unused31273=b878.#N()
        Void unused31274=b878.#o()
        Void unused31275=b878.#d()
        Void unused31276=b878.#e()
        Void unused31277=b878.#semicolon()
        Void unused31278=b878.#newline()
        Void unused31279=b878.#v()
        Void unused31280=b878.#a()
        Void unused31281=b878.#r()
        Void unused31282=b878.#space()
        Void unused31283=b878.#i()
        Void unused31284=b878.#n()
        Void unused31285=b878.#n()
        Void unused31286=b878.#e()
        Void unused31287=b878.#r()
        Void unused31288=b878.#E()
        Void unused31289=b878.#l()
        Void unused31290=b878.#e()
        Void unused31291=b878.#m()
        Void unused31292=b878.#semicolon()
        Void unused31293=b878.#newline()
        Void unused31294=b878.#w()
        Void unused31295=b878.#h()
        Void unused31296=b878.#i()
        Void unused31297=b878.#l()
        Void unused31298=b878.#e()
        Void unused31299=b878.#space()
        Void unused31300=b878.#oRound()
        Void unused31301=b878.#i()
        Void unused31302=b878.#n()
        Void unused31303=b878.#n()
        Void unused31304=b878.#e()
        Void unused31305=b878.#r()
        Void unused31306=b878.#E()
        Void unused31307=b878.#l()
        Void unused31308=b878.#e()
        Void unused31309=b878.#m()
        Void unused31310=b878.#space()
        Void unused31311=b878.#equal()
        Void unused31312=b878.#space()
        Void unused31313=b878.#o()
        Void unused31314=b878.#l()
        Void unused31315=b878.#d()
        Void unused31316=b878.#E()
        Void unused31317=b878.#l()
        Void unused31318=b878.#e()
        Void unused31319=b878.#m()
        Void unused31320=b878.#dot()
        Void unused31321=b878.#f()
        Void unused31322=b878.#i()
        Void unused31323=b878.#r()
        Void unused31324=b878.#s()
        Void unused31325=b878.#t()
        Void unused31326=b878.#C()
        Void unused31327=b878.#h()
        Void unused31328=b878.#i()
        Void unused31329=b878.#l()
        Void unused31330=b878.#d()
        Void unused31331=b878.#cRound()
        Void unused31332=b878.#oCurly()
        Void unused31333=b878.#newline()
        Void unused31334=b878.#space()
        Void unused31335=b878.#space()
        Void unused31336=b878.#p()
        Void unused31337=b878.#a()
        Void unused31338=b878.#r()
        Void unused31339=b878.#e()
        Void unused31340=b878.#n()
        Void unused31341=b878.#t()
        Void unused31342=b878.#E()
        Void unused31343=b878.#l()
        Void unused31344=b878.#e()
        Void unused31345=b878.#m()
        Void unused31346=b878.#dot()
        Void unused31347=b878.#i()
        Void unused31348=b878.#n()
        Void unused31349=b878.#s()
        Void unused31350=b878.#e()
        Void unused31351=b878.#r()
        Void unused31352=b878.#t()
        Void unused31353=b878.#B()
        Void unused31354=b878.#e()
        Void unused31355=b878.#f()
        Void unused31356=b878.#o()
        Void unused31357=b878.#r()
        Void unused31358=b878.#e()
        Void unused31359=b878.#oRound()
        Void unused31360=b878.#i()
        Void unused31361=b878.#n()
        Void unused31362=b878.#n()
        Void unused31363=b878.#e()
        Void unused31364=b878.#r()
        Void unused31365=b878.#E()
        Void unused31366=b878.#l()
        Void unused31367=b878.#e()
        Void unused31368=b878.#m()
        Void unused31369=b878.#comma()
        Void unused31370=b878.#space()
        Void unused31371=b878.#o()
        Void unused31372=b878.#l()
        Void unused31373=b878.#d()
        Void unused31374=b878.#E()
        Void unused31375=b878.#l()
        Void unused31376=b878.#e()
        Void unused31377=b878.#m()
        Void unused31378=b878.#cRound()
        Void unused31379=b878.#semicolon()
        Void unused31380=b878.#newline()
        Void unused31381=b878.#space()
        Void unused31382=b878.#space()
        Void unused31383=b878.#cCurly()
        Void unused31384=b878.#newline()
        Void unused31385=b878.#p()
        Void unused31386=b878.#a()
        Void unused31387=b878.#r()
        Void unused31388=b878.#e()
        Void unused31389=b878.#n()
        Void unused31390=b878.#t()
        Void unused31391=b878.#E()
        Void unused31392=b878.#l()
        Void unused31393=b878.#e()
        Void unused31394=b878.#m()
        Void unused31395=b878.#dot()
        Void unused31396=b878.#r()
        Void unused31397=b878.#e()
        Void unused31398=b878.#m()
        Void unused31399=b878.#o()
        Void unused31400=b878.#v()
        Void unused31401=b878.#e()
        Void unused31402=b878.#C()
        Void unused31403=b878.#h()
        Void unused31404=b878.#i()
        Void unused31405=b878.#l()
        Void unused31406=b878.#d()
        Void unused31407=b878.#oRound()
        Void unused31408=b878.#o()
        Void unused31409=b878.#l()
        Void unused31410=b878.#d()
        Void unused31411=b878.#E()
        Void unused31412=b878.#l()
        Void unused31413=b878.#e()
        Void unused31414=b878.#m()
        Void unused31415=b878.#cRound()
        Void unused31416=b878.#semicolon()
        Void unused31417=b878.#newline()
        b878
        ))
      )
    This0.Abstract.S x=this.executeJs(that:cmd)
    Void unused31167=This0.Abstract.Debug.#apply(that:cmd)
    Void unused31168=(
      This0.Abstract.Bool cond129=(
        This0.Abstract.S read$opPar114=This0.Abstract.S.#from(builder:(
          mut This0.Abstract.S.SBuilder b879=This0.Abstract.S.#builder()
          b879
          ))
        x.#equalequal#0left(right:read$opPar114)
        ).#bang()
      (
        Void unused31418=cond129.#checkTrue()
        
        catch exception Void catched41190 void
        
        (This0.Abstract.Debug.#apply(that:x))
        )
      )
    Void unused31169=return void
    void
    )
  
  catch return Void result161 result161
  
  error  {/*@stringU
CurlyBlock-Should be unreachable code
*/}
  )
mut method 
Void add(This0.Abstract.S that, This0.Abstract.S id) (
  Void unused31419=(
    This0.Abstract.S qid=(
      This0.Abstract.S.Continue rcv15=(
        This0.Abstract.S rcv16=This0.Abstract.S.#from(builder:(
          mut This0.Abstract.S.SBuilder b880=This0.Abstract.S.#builder()
          Void unused31423=b880.#sQuote()
          b880
          ))
        rcv16.#from(seqBuilder:(
          mut This0.Abstract.S.SConcat b881=rcv16.#seqBuilder()
          Void unused31424=b881.#add(that:This0.jsEscape(that:id))
          b881
          ))
        )
      rcv15.#from(builder:(
        mut This0.Abstract.S.SBuilder b882=rcv15.#builder()
        Void unused31425=b882.#sQuote()
        b882
        ))
      )
    This0.Abstract.S qText=(
      This0.Abstract.S.Continue rcv17=(
        This0.Abstract.S rcv18=This0.Abstract.S.#from(builder:(
          mut This0.Abstract.S.SBuilder b883=This0.Abstract.S.#builder()
          Void unused31426=b883.#sQuote()
          b883
          ))
        rcv18.#from(seqBuilder:(
          mut This0.Abstract.S.SConcat b884=rcv18.#seqBuilder()
          Void unused31427=b884.#add(that:This0.jsEscape(that:that))
          b884
          ))
        )
      rcv17.#from(builder:(
        mut This0.Abstract.S.SBuilder b885=rcv17.#builder()
        Void unused31428=b885.#sQuote()
        b885
        ))
      )
    This0.Abstract.S cmd=(
      This0.Abstract.S.Continue rcv19=(
        This0.Abstract.S rcv20=(
          This0.Abstract.S.Continue rcv21=(
            This0.Abstract.S rcv22=This0.Abstract.S.#from(builder:(
              mut This0.Abstract.S.SBuilder b886=This0.Abstract.S.#builder()
              Void unused31429=b886.#v()
              Void unused31430=b886.#a()
              Void unused31431=b886.#r()
              Void unused31432=b886.#space()
              Void unused31433=b886.#t()
              Void unused31434=b886.#e()
              Void unused31435=b886.#m()
              Void unused31436=b886.#p()
              Void unused31437=b886.#l()
              Void unused31438=b886.#a()
              Void unused31439=b886.#t()
              Void unused31440=b886.#e()
              Void unused31441=b886.#space()
              Void unused31442=b886.#equal()
              Void unused31443=b886.#space()
              Void unused31444=b886.#d()
              Void unused31445=b886.#o()
              Void unused31446=b886.#c()
              Void unused31447=b886.#u()
              Void unused31448=b886.#m()
              Void unused31449=b886.#e()
              Void unused31450=b886.#n()
              Void unused31451=b886.#t()
              Void unused31452=b886.#dot()
              Void unused31453=b886.#c()
              Void unused31454=b886.#r()
              Void unused31455=b886.#e()
              Void unused31456=b886.#a()
              Void unused31457=b886.#t()
              Void unused31458=b886.#e()
              Void unused31459=b886.#E()
              Void unused31460=b886.#l()
              Void unused31461=b886.#e()
              Void unused31462=b886.#m()
              Void unused31463=b886.#e()
              Void unused31464=b886.#n()
              Void unused31465=b886.#t()
              Void unused31466=b886.#oRound()
              Void unused31467=b886.#sQuote()
              Void unused31468=b886.#d()
              Void unused31469=b886.#i()
              Void unused31470=b886.#v()
              Void unused31471=b886.#sQuote()
              Void unused31472=b886.#cRound()
              Void unused31473=b886.#semicolon()
              Void unused31474=b886.#newline()
              Void unused31475=b886.#t()
              Void unused31476=b886.#e()
              Void unused31477=b886.#m()
              Void unused31478=b886.#p()
              Void unused31479=b886.#l()
              Void unused31480=b886.#a()
              Void unused31481=b886.#t()
              Void unused31482=b886.#e()
              Void unused31483=b886.#dot()
              Void unused31484=b886.#i()
              Void unused31485=b886.#n()
              Void unused31486=b886.#n()
              Void unused31487=b886.#e()
              Void unused31488=b886.#r()
              Void unused31489=b886.#H()
              Void unused31490=b886.#T()
              Void unused31491=b886.#M()
              Void unused31492=b886.#L()
              Void unused31493=b886.#space()
              Void unused31494=b886.#equal()
              Void unused31495=b886.#newline()
              b886
              ))
            rcv22.#from(seqBuilder:(
              mut This0.Abstract.S.SConcat b887=rcv22.#seqBuilder()
              Void unused31496=b887.#add(that:qText)
              b887
              ))
            )
          rcv21.#from(builder:(
            mut This0.Abstract.S.SBuilder b888=rcv21.#builder()
            Void unused31497=b888.#semicolon()
            Void unused31498=b888.#newline()
            Void unused31499=b888.#d()
            Void unused31500=b888.#o()
            Void unused31501=b888.#c()
            Void unused31502=b888.#u()
            Void unused31503=b888.#m()
            Void unused31504=b888.#e()
            Void unused31505=b888.#n()
            Void unused31506=b888.#t()
            Void unused31507=b888.#dot()
            Void unused31508=b888.#g()
            Void unused31509=b888.#e()
            Void unused31510=b888.#t()
            Void unused31511=b888.#E()
            Void unused31512=b888.#l()
            Void unused31513=b888.#e()
            Void unused31514=b888.#m()
            Void unused31515=b888.#e()
            Void unused31516=b888.#n()
            Void unused31517=b888.#t()
            Void unused31518=b888.#B()
            Void unused31519=b888.#y()
            Void unused31520=b888.#I()
            Void unused31521=b888.#d()
            Void unused31522=b888.#oRound()
            Void unused31523=b888.#newline()
            b888
            ))
          )
        rcv20.#from(seqBuilder:(
          mut This0.Abstract.S.SConcat b889=rcv20.#seqBuilder()
          Void unused31524=b889.#add(that:qid)
          b889
          ))
        )
      rcv19.#from(builder:(
        mut This0.Abstract.S.SBuilder b890=rcv19.#builder()
        Void unused31525=b890.#cRound()
        Void unused31526=b890.#dot()
        Void unused31527=b890.#a()
        Void unused31528=b890.#p()
        Void unused31529=b890.#p()
        Void unused31530=b890.#e()
        Void unused31531=b890.#n()
        Void unused31532=b890.#d()
        Void unused31533=b890.#C()
        Void unused31534=b890.#h()
        Void unused31535=b890.#i()
        Void unused31536=b890.#l()
        Void unused31537=b890.#d()
        Void unused31538=b890.#oRound()
        Void unused31539=b890.#t()
        Void unused31540=b890.#e()
        Void unused31541=b890.#m()
        Void unused31542=b890.#p()
        Void unused31543=b890.#l()
        Void unused31544=b890.#a()
        Void unused31545=b890.#t()
        Void unused31546=b890.#e()
        Void unused31547=b890.#dot()
        Void unused31548=b890.#f()
        Void unused31549=b890.#i()
        Void unused31550=b890.#r()
        Void unused31551=b890.#s()
        Void unused31552=b890.#t()
        Void unused31553=b890.#C()
        Void unused31554=b890.#h()
        Void unused31555=b890.#i()
        Void unused31556=b890.#l()
        Void unused31557=b890.#d()
        Void unused31558=b890.#cRound()
        Void unused31559=b890.#semicolon()
        Void unused31560=b890.#newline()
        b890
        ))
      )
    This0.Abstract.S x=this.executeJs(that:cmd)
    Void unused31420=This0.Abstract.Debug.#apply(that:cmd)
    Void unused31421=(
      This0.Abstract.Bool cond130=(
        This0.Abstract.S read$opPar115=This0.Abstract.S.#from(builder:(
          mut This0.Abstract.S.SBuilder b891=This0.Abstract.S.#builder()
          b891
          ))
        x.#equalequal#0left(right:read$opPar115)
        ).#bang()
      (
        Void unused31561=cond130.#checkTrue()
        
        catch exception Void catched41214 void
        
        (This0.Abstract.Debug.#apply(that:x))
        )
      )
    Void unused31422=return void
    void
    )
  
  catch return Void result162 result162
  
  error  {/*@stringU
CurlyBlock-Should be unreachable code
*/}
  )
mut method 
This0.Abstract.S executeJs(This0.Abstract.S that) This0.Abstract.S.#from(binaryRepr:use This0.GuiPlugin check executeJs(wName:this.id().#binaryRepr(), command:that.#binaryRepr()) error void)
mut method 
mut This0.Iterator events() This0.Iterator.#$(id:this.id(), current:This0.Abstract.S.#from(builder:(
  mut This0.Abstract.S.SBuilder b892=This0.Abstract.S.#builder()
  b892
  )))
class method 
mut This0 #$(fwd This0.Abstract.S id) 
Abstract: {
Alu: {/*@plugin
L42.is/connected/withAlu
*/}
ExitCode: {
class method /*To signal normal program completion
*/Library normal() 
class method /*To signal a failure in program completion
*/Library failure() }
Bool: {implements This1.Concept.Base, This1.Concept.ToS, This1.Concept.Classable, This1.Concept.Equals
read method 
Library _binaryRepr() 
class method 
mut This0 #apply(Library _binaryRepr) 
read method 
This0 clone() 
read method 
Library #binaryRepr() 
class method 
mut This0 #from(Library binaryRepr) 
refine class method 
read This0 cast(read This1.Concept.Classable that) 
refine class method 
mut This0 #cast(mut This1.Concept.Classable that) 
refine class method /*
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  */This0 is(class This1.Concept.Classable subtype) 
refine read method 
class This0 class() 
refine class method /*
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  */This1.S readableName() 
refine read method 
This1.S toS() 
refine read method 
This0 #equalequal#0left(read Any right) 
read method 
Void #checkTrue() exception Void 
class method 
This0 true() 
class method 
This0 false() 
method 
This0 #and#0left(This0 right) 
method 
This0 #or#0left(This0 right) 
method 
This0 #bang() 
read method 
This0 equals(read This0 that) 
class method 
This0 fromS(read This1.Concept.ToS that) 
class method 
Any parseError(This1.S that) 
ParseFail: {implements This2.Guard.ParseFail, This2.Guard, This2.Message, This2.Concept.Base, This2.Concept.ToS, This2.Concept.Classable, This2.Concept.Equals
refine read method 
class This0 class() 
refine class method /*
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  */This2.S readableName() 
refine class method /*
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  */This1 is(class This2.Concept.Classable subtype) 
refine read method 
This1 #equalequal#0left(read Any right) 
refine class method 
read This0 cast(read This2.Concept.Classable that) 
refine class method 
mut This0 #cast(mut This2.Concept.Classable that) 
read method 
This2.S _text() 
read method 
This2.Message.Opt cause() 
class method 
This0 #apply(This2.S _text, This2.Message.Opt cause) 
refine class method 
This2.S kind() 
refine read method 
This2.S text() 
refine read method 
This2.Message.Opt responseOf() 
method 
This0 #apply(This2.Message that) 
refine read method 
This2.S toS() 
read method 
This1 equals(read This0 that) 
class method 
This0 #apply(This2.S text) 
class method 
This0 #apply(This2.S text, This2.Message cause) 
class method 
mut This2.S.SBuilder #builder() 
class method 
This0 #from(This2.S.SBuilder builder) 
method 
This0.Continue #from(This2.S.SConcat seqBuilder) 
method 
mut This2.S.SConcat #seqBuilder() 
Continue: {
read method 
This3.S that() 
class method 
This0 #apply(This3.S that) 
method 
mut This3.S.SBuilder #builder() 
method 
This1 #from(This3.S.SBuilder builder) }}}
Size: {implements This1.Concept.ToS, This1.Concept.Equals, This1.Concept.Classable/*@_private
*/
class method 
mut This0 _private(Library _binaryRepr) 
read method 
Library _binaryRepr() 
refine class method 
read This0 cast(read This1.Concept.Classable that) 
refine class method 
mut This0 #cast(mut This1.Concept.Classable that) 
refine class method /*
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  */This1.Bool is(class This1.Concept.Classable subtype) 
refine read method 
class This0 class() 
refine class method /*
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  */This1.S readableName() 
class method 
This0 fromS(This1.Concept.ToS that) 
class method 
mut This0 #from(Library binaryRepr) 
read method 
Library #binaryRepr() 
class method 
mut This1.S.SBuilder #builder() 
class method 
This0 #from(This1.S.SBuilder builder) 
refine read method 
This1.S toS() 
method 
This0 #plus#0left(This0 right) 
method 
This0 #less#0left(This0 right) 
method 
This0 #times#0left(This0 right) 
method 
This0 #divide#0left(This0 right) 
read method 
This1.Bool equals(read This0 that) 
refine read method 
This1.Bool #equalequal#0left(read Any right) 
method 
This1.Bool #right#0left(This0 right) 
method 
This1.Bool #rightequal#0left(This0 right) 
method 
mut This0.Iterator vals() 
method 
mut This0.Iterator vals(This0 upTo) 
class method 
This0 #0() 
class method 
This0 #1() 
class method 
This0 #2() 
class method 
This0 #3() 
class method 
This0 #4() 
class method 
This0 #5() 
class method 
This0 #6() 
class method 
This0 #7() 
class method 
This0 #8() 
class method 
This0 #9() 
class method 
This0 #10() 
class method 
This0 #11() 
class method 
This0 #12() 
class method 
This0 #13() 
class method 
This0 #14() 
class method 
This0 #15() 
class method 
This0 #16() 
class method 
This0 #17() 
class method 
This0 #18() 
class method 
This0 #19() 
class method 
This0 #20() 
class method 
This0 #21() 
class method 
This0 #22() 
class method 
This0 #23() 
class method 
This0 #24() 
class method 
This0 #25() 
class method 
This0 #26() 
class method 
This0 #27() 
class method 
This0 #28() 
class method 
This0 #29() 
class method 
This0 #30() 
class method 
This0 #31() 
class method 
This0 #32() 
class method 
This0 #33() 
class method 
This0 #34() 
class method 
This0 #35() 
class method 
This0 #36() 
class method 
This0 #37() 
class method 
This0 #38() 
class method 
This0 #39() 
class method 
This0 #40() 
class method 
This0 #41() 
class method 
This0 #42() 
class method 
This0 #43() 
class method 
This0 #44() 
class method 
This0 #45() 
class method 
This0 #46() 
class method 
This0 #47() 
class method 
This0 #48() 
class method 
This0 #49() 
class method 
This0 #50() 
class method 
This0 #51() 
class method 
This0 #52() 
class method 
This0 #53() 
class method 
This0 #54() 
class method 
This0 #55() 
class method 
This0 #56() 
class method 
This0 #57() 
class method 
This0 #58() 
class method 
This0 #59() 
class method 
This0 #60() 
class method 
This0 #61() 
class method 
This0 #62() 
class method 
This0 #63() 
class method 
Any parseError(This1.S that) 
Iterator: {
mut method 
Void start(This1 that) 
read method 
This1 start() 
read method 
This1 end() 
class method 
mut This0 #apply(This1 start, This1 end) 
mut method 
Void #next() exception Void 
read method 
Void #checkEnd() 
read method 
This1 #inner() 
read method 
Void #close() }
ParseFail: {implements This2.Guard.ParseFail, This2.Guard, This2.Message, This2.Concept.Base, This2.Concept.ToS, This2.Concept.Classable, This2.Concept.Equals
refine read method 
class This0 class() 
refine class method /*
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  */This2.S readableName() 
refine class method /*
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  */This2.Bool is(class This2.Concept.Classable subtype) 
refine read method 
This2.Bool #equalequal#0left(read Any right) 
refine class method 
read This0 cast(read This2.Concept.Classable that) 
refine class method 
mut This0 #cast(mut This2.Concept.Classable that) 
read method 
This2.S _text() 
read method 
This2.Message.Opt cause() 
class method 
This0 #apply(This2.S _text, This2.Message.Opt cause) 
refine class method 
This2.S kind() 
refine read method 
This2.S text() 
refine read method 
This2.Message.Opt responseOf() 
method 
This0 #apply(This2.Message that) 
refine read method 
This2.S toS() 
read method 
This2.Bool equals(read This0 that) 
class method 
This0 #apply(This2.S text) 
class method 
This0 #apply(This2.S text, This2.Message cause) 
class method 
mut This2.S.SBuilder #builder() 
class method 
This0 #from(This2.S.SBuilder builder) 
method 
This0.Continue #from(This2.S.SConcat seqBuilder) 
method 
mut This2.S.SConcat #seqBuilder() 
Continue: {
read method 
This3.S that() 
class method 
This0 #apply(This3.S that) 
method 
mut This3.S.SBuilder #builder() 
method 
This1 #from(This3.S.SBuilder builder) }}}
Num: {implements This1.Concept.Base, This1.Concept.ToS, This1.Concept.Classable, This1.Concept.Equals
refine class method /*
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  */This1.S readableName() 
refine class method /*
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  */This1.Bool is(class This1.Concept.Classable subtype) 
refine read method 
This1.Bool #equalequal#0left(read Any right) 
refine read method 
class This0 class() 
refine class method 
read This0 cast(read This1.Concept.Classable that) 
refine class method 
mut This0 #cast(mut This1.Concept.Classable that) 
class method 
mut This0 _private(Library _binaryRepr) 
read method 
Library _binaryRepr() 
class method 
This0 fromS(This1.Concept.ToS that) 
class method 
This0 #from(Library binaryRepr) 
read method 
Library #binaryRepr() 
class method 
mut This1.S.SBuilder #builder() 
class method 
This0 #from(This1.S.SBuilder builder) 
class method 
Any parseError(This1.S that) 
refine read method 
This1.S toS() 
method 
This0 #plus#0left(This0 right) 
method 
This0 #less#0left(This0 right) 
method 
This0 #times#0left(This0 right) 
method 
This0 #divide#0left(This0 right) 
read method 
This1.Bool equals(read This0 that) 
method 
This1.Bool #right#0left(This0 right) 
method 
This1.Bool #rightequal#0left(This0 right) 
Plg: {/*@plugin
L42.is/connected/withNumbers
*/}
ParseFail: {implements This2.Guard.ParseFail, This2.Guard, This2.Message, This2.Concept.Base, This2.Concept.ToS, This2.Concept.Classable, This2.Concept.Equals
refine read method 
class This0 class() 
refine class method /*
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  */This2.S readableName() 
refine class method /*
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  */This2.Bool is(class This2.Concept.Classable subtype) 
refine read method 
This2.Bool #equalequal#0left(read Any right) 
refine class method 
read This0 cast(read This2.Concept.Classable that) 
refine class method 
mut This0 #cast(mut This2.Concept.Classable that) 
read method 
This2.S _text() 
read method 
This2.Message.Opt cause() 
class method 
This0 #apply(This2.S _text, This2.Message.Opt cause) 
refine class method 
This2.S kind() 
refine read method 
This2.S text() 
refine read method 
This2.Message.Opt responseOf() 
method 
This0 #apply(This2.Message that) 
refine read method 
This2.S toS() 
read method 
This2.Bool equals(read This0 that) 
class method 
This0 #apply(This2.S text) 
class method 
This0 #apply(This2.S text, This2.Message cause) 
class method 
mut This2.S.SBuilder #builder() 
class method 
This0 #from(This2.S.SBuilder builder) 
method 
This0.Continue #from(This2.S.SConcat seqBuilder) 
method 
mut This2.S.SConcat #seqBuilder() 
Continue: {
read method 
This3.S that() 
class method 
This0 #apply(This3.S that) 
method 
mut This3.S.SBuilder #builder() 
method 
This1 #from(This3.S.SBuilder builder) }}}
S: {implements This1.Concept.Base/*, Concept.Equals //needed until we do (also refine) normalization
*/, This1.Concept.ToS, This1.Concept.Classable, This1.Concept.Equals, This1.Concept.ToS
class method 
mut This0 _private(Library _binaryRepr) 
read method 
Library _binaryRepr() 
read method 
This0 clone() 
refine class method 
read This0 cast(read This1.Concept.Classable that) 
refine class method 
mut This0 #cast(mut This1.Concept.Classable that) 
refine class method /*
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  */This1.Bool is(class This1.Concept.Classable subtype) 
refine read method 
class This0 class() 
refine class method /*
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  */This0 readableName() 
class method 
mut This0 #from(Library binaryRepr) 
read method 
Library #binaryRepr() 
refine read method 
This1.Bool #equalequal#0left(read Any right) 
method 
This0 #plusplus#0left(This0 right) 
read method 
This1.Bool equals(read This0 that) 
method 
This0 #less#0left(This0 right) 
method 
This1.Bool #rightright#0left(This0 right) 
method 
This1.Bool #rightrightequal#0left(This0 right) 
method 
This1.Bool #right#0left(This0 right) 
method 
This1.Size indexOfLeft(This0 val) 
method 
This1.Size indexOfLeft(This0 val, This1.Size start) 
method 
This1.Size indexOfRight(This0 val) 
method 
This0 withoutLeft(This0 val) 
method 
This0 withoutRight(This0 val) 
method 
This0 withoutAll(This0 val) 
method 
This1.Bool isEmpty() 
method 
This0 val(This1.Size that) 
method 
This1.Size #default#val(Void that) 
method 
This0 left() 
method 
This0 right() 
method 
This0 with(This1.Size that, This0 val) 
method 
This1.Size #default#with(Void that) 
method 
This0 withLeft(This0 that) 
method 
This0 withRight(This0 that) 
method 
This0 withAlso(This1.Size that, This0 val) 
method 
This1.Size #default#withAlso(Void that) 
method 
This0 withAlsoLeft(This0 that) 
method 
This0 withAlsoRight(This0 that) 
method 
This0 without(This1.Size index) 
method 
This1.Size #default#without(Void index) 
method 
This0 without(This1.Size index, This1.Size skipNum) 
method 
This0 withoutLeft() 
method 
This0 withoutRight() 
method 
This1.Bool contains(This0 that) 
method 
This0 #apply(This1.Size start, This1.Size end) 
method 
This0 #apply(This1.Size that) 
method 
This0 #apply(This1.Size start) 
method 
This0 #apply(This1.Size end) 
method 
This1.Size #default##apply(Void that) 
method 
This1.Size #default##apply(Void end) 
method 
This1.Size #default##apply(Void start) 
method 
This1.Size size() 
method 
This1.Bool subStrEq(This0 that, This1.Size start) 
method 
This1.Bool beginsWith(This0 that) 
class method 
This0 aSCIILowerCase() 
class method 
This0 aSCIIUpperCase() 
method 
This1.Bool isASCIILowerCase(This1.Size that) 
method 
This1.Bool isASCIIUpperCase(This1.Size that) 
class method 
This0 doubleQuote() 
class method 
This0 nl() 
method 
This0 replace(This0 that, This0 into) 
method 
This0 as42MultilineString() 
method 
This0.Continue #from(This0.SConcat seqBuilder) 
method 
mut This0.SConcat #seqBuilder() 
class method 
This0 #from(This0.SBuilder builder) 
class method 
mut This0.SBuilder #builder() 
refine read method 
This0 toS() 
method 
This1.Strings splitOn(This0 chars) 
Continue: {
read method 
This1 that() 
class method 
This0 #apply(This1 that) 
method 
mut This1.SBuilder #builder() 
method 
This1 #from(This1.SBuilder builder) }
SConcat: {
read method 
This1 old() 
mut method 
Void accumulator(This1 that) 
read method 
This1 accumulator() 
class method 
mut This0 #apply(This1 old, This1 accumulator) 
mut method 
Void #add(read This2.Concept.ToS that) 
mut method 
Void #add(read This2.Concept.ToS that, This2.Concept.ToS sep) }
SBuilder: {
mut method 
Void _binaryRepr(Library that) 
read method 
Library _binaryRepr() 
class method 
mut This0 _private(Library _binaryRepr) 
read method 
Library #binaryRepr() 
mut method 
Void acc(Library that) 
class method 
mut This0 empty() 
mut method 
Void #0() 
mut method 
Void #1() 
mut method 
Void #2() 
mut method 
Void #3() 
mut method 
Void #4() 
mut method 
Void #5() 
mut method 
Void #6() 
mut method 
Void #7() 
mut method 
Void #8() 
mut method 
Void #9() 
mut method 
Void #q() 
mut method 
Void #w() 
mut method 
Void #e() 
mut method 
Void #r() 
mut method 
Void #t() 
mut method 
Void #y() 
mut method 
Void #u() 
mut method 
Void #i() 
mut method 
Void #o() 
mut method 
Void #p() 
mut method 
Void #a() 
mut method 
Void #s() 
mut method 
Void #d() 
mut method 
Void #f() 
mut method 
Void #g() 
mut method 
Void #h() 
mut method 
Void #j() 
mut method 
Void #k() 
mut method 
Void #l() 
mut method 
Void #z() 
mut method 
Void #x() 
mut method 
Void #c() 
mut method 
Void #v() 
mut method 
Void #b() 
mut method 
Void #n() 
mut method 
Void #m() 
mut method 
Void #Q() 
mut method 
Void #W() 
mut method 
Void #E() 
mut method 
Void #R() 
mut method 
Void #T() 
mut method 
Void #Y() 
mut method 
Void #U() 
mut method 
Void #I() 
mut method 
Void #O() 
mut method 
Void #P() 
mut method 
Void #A() 
mut method 
Void #S() 
mut method 
Void #D() 
mut method 
Void #F() 
mut method 
Void #G() 
mut method 
Void #H() 
mut method 
Void #J() 
mut method 
Void #K() 
mut method 
Void #L() 
mut method 
Void #Z() 
mut method 
Void #X() 
mut method 
Void #C() 
mut method 
Void #V() 
mut method 
Void #B() 
mut method 
Void #N() 
mut method 
Void #M() 
mut method 
Void #%() 
mut method 
Void #left() 
mut method 
Void #right() 
mut method 
Void #bang() 
mut method 
Void #tilde() 
mut method 
Void #plus() 
mut method 
Void #times() 
mut method 
Void #divide() 
mut method 
Void #less() 
mut method 
Void #and() 
mut method 
Void #or() 
mut method 
Void #oRound() 
mut method 
Void #cRound() 
mut method 
Void #oSquare() 
mut method 
Void #cSquare() 
mut method 
Void #oCurly() 
mut method 
Void #cCurly() 
mut method 
Void #dQuote() 
mut method 
Void #sQuote() 
mut method 
Void #hQuote() 
mut method 
Void #equal() 
mut method 
Void #qMark() 
mut method 
Void #hat() 
mut method 
Void #comma() 
mut method 
Void #semicolon() 
mut method 
Void #colon() 
mut method 
Void #dot() 
mut method 
Void #underscore() 
mut method 
Void #hash() 
mut method 
Void #at() 
mut method 
Void #backslash() 
mut method 
Void #dollar() 
mut method 
Void #space() 
mut method 
Void #newline() }
U: {
class method 
mut This1.SBuilder #builder() 
class method 
This1 #from(This1.SBuilder builder) }}
Concept: {
ToS: {interface 
read method 
This2.S toS() }
Classable: {interface 
class method /*
  Cast a (read/imm) object to this type.
  A class implementing this method should refine the return type to This.
  if is(subtype) is true, then cast(that) must produce a result.
  */read This0 cast(read This0 that) 
class method /*
  Cast a (mutable) object to this type.
  A class implementing this method should refine the return type to This.
  if cast(that) produces a result, then #cast(that) also must produce a result.
  */mut This0 #cast(mut This0 that) 
read method /*
  Extracts the class singleton from another instance of this class
  */class This0 class() 
class method /*
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  */This2.S readableName() 
class method /*
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  */This2.Bool is(class This0 subtype) }
Base: {interface implements This1.ToS, This1.Classable, This1.Equals
refine read method 
This2.S toS() 
refine class method /*
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  */This2.S readableName() 
refine class method /*
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  */This2.Bool is(class This1.Classable subtype) 
refine read method 
This2.Bool #equalequal#0left(read Any right) 
refine read method 
class This0 class() 
refine class method 
read This0 cast(read This1.Classable that) 
refine class method 
mut This0 #cast(mut This1.Classable that) }
Wrapper: {interface 
read method 
Any inner() }
ClassWrapper: {interface 
read method 
class Any inner() }
MutWrapper: {interface 
read method 
read Any inner() 
mut method 
mut Any #inner() }
Equals: {interface 
read method 
This2.Bool #equalequal#0left(read Any right) }
Comparable: {interface 
read method 
This2.Bool greater(read Any that) }
Boollable: {interface 
read method 
Void #checkTrue() exception Void }
Decorator: {interface }
Contains: {interface 
read method 
This2.Bool contains(read Any that) }
Parsable: {interface }
RandomAccess: {interface 
read method 
read Any get(This2.Size that) 
mut method 
mut Any #get(This2.Size that) }
Sizable: {interface 
read method 
This2.Size size() 
read method 
This2.Bool isEmpty() }
Iterator: {interface 
mut method 
Void #next() exception Void 
read method 
Void #checkEnd() 
read method 
Void #close() }}
Message: {interface implements This1.Concept.Base, This1.Concept.ToS, This1.Concept.Classable, This1.Concept.Equals
refine read method 
This1.S toS() 
refine class method /*
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  */This1.S readableName() 
refine class method /*
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  */This1.Bool is(class This1.Concept.Classable subtype) 
refine read method 
This1.Bool #equalequal#0left(read Any right) 
refine class method 
read This1.Concept.Base cast(read This1.Concept.Classable that) 
refine class method 
mut This1.Concept.Base #cast(mut This1.Concept.Classable that) 
class method 
This1.S kind() 
read method 
This1.S text() 
read method 
This0.Opt responseOf() 
refine read method 
class This0 class() 
EqualMessages: {
class method 
This2.Bool #apply(read This1 that, read This1 other) }
$: {
class method 
This0 #apply() 
class method 
Library #leftrightleft#0left(Library right) 
class method 
Library messageTrait() }
Opt: {/*will be Fixed in AdamTowel02
*/
method 
This0.TOpt that() 
class method 
This0 #new(This0.TOpt that) 
method 
This1 get() exception This2.Guard.Operation 
method 
This1 #get() 
method 
This2.Bool isPresent() 
class method 
This0 #apply() 
class method 
This0 #apply(This1 that) 
TOpt: {interface 
method 
This2 get() }
TEmpty: {implements This1.TOpt
class method 
This0 #apply() 
refine method 
This2 get() }
TOf: {implements This1.TOpt
method 
This2 that() 
class method 
This0 #apply(This2 that) 
refine method 
This2 get() }}}
Guard: {/* exception as Guard bureocracy, error as Guard detection
-is a check guarenteed to be performed, program logic can rely on this being enforced.
  as exceptions, Guards objects are a way to report/guard complex operations,
 where checking the shape of the input can be unconvenient.
as errors, they represent precondition violations.
Turning an exception Guard into an error Guard
 is equivalent of declaring that such misuse should not happen (blame on the caller),
 still, there is no bug in the program at this stage. Is legit for the caller to try and be blamed
*/interface implements This1.Message, This1.Concept.Base, This1.Concept.ToS, This1.Concept.Classable, This1.Concept.Equals
refine read method 
This1.S toS() 
refine class method /*
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  */This1.S readableName() 
refine class method /*
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  */This1.Bool is(class This1.Concept.Classable subtype) 
refine read method 
This1.Bool #equalequal#0left(read Any right) 
refine class method 
read This1.Concept.Base cast(read This1.Concept.Classable that) 
refine class method 
mut This1.Concept.Base #cast(mut This1.Concept.Classable that) 
refine class method 
This1.S kind() 
refine read method 
This1.S text() 
refine read method 
This1.Message.Opt responseOf() 
refine read method 
class This1.Message class() 
Operation: {implements This1, This2.Message, This2.Concept.Base, This2.Concept.ToS, This2.Concept.Classable, This2.Concept.Equals
refine read method 
class This0 class() 
refine class method /*
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  */This2.S readableName() 
refine class method /*
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  */This2.Bool is(class This2.Concept.Classable subtype) 
refine read method 
This2.Bool #equalequal#0left(read Any right) 
refine class method 
read This0 cast(read This2.Concept.Classable that) 
refine class method 
mut This0 #cast(mut This2.Concept.Classable that) 
read method 
This2.S _text() 
read method 
This2.Message.Opt cause() 
class method 
This0 #apply(This2.S _text, This2.Message.Opt cause) 
refine class method 
This2.S kind() 
refine read method 
This2.S text() 
refine read method 
This2.Message.Opt responseOf() 
method 
This0 #apply(This2.Message that) 
refine read method 
This2.S toS() 
read method 
This2.Bool equals(read This0 that) 
class method 
This0 #apply(This2.S text) 
class method 
This0 #apply(This2.S text, This2.Message cause) 
class method 
mut This2.S.SBuilder #builder() 
class method 
This0 #from(This2.S.SBuilder builder) 
method 
This0.Continue #from(This2.S.SConcat seqBuilder) 
method 
mut This2.S.SConcat #seqBuilder() 
Continue: {
read method 
This3.S that() 
class method 
This0 #apply(This3.S that) 
method 
mut This3.S.SBuilder #builder() 
method 
This1 #from(This3.S.SBuilder builder) }}
Parameter: {implements This1, This2.Message, This2.Concept.Base, This2.Concept.ToS, This2.Concept.Classable, This2.Concept.Equals
refine read method 
class This0 class() 
refine class method /*
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  */This2.S readableName() 
refine class method /*
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  */This2.Bool is(class This2.Concept.Classable subtype) 
refine read method 
This2.Bool #equalequal#0left(read Any right) 
refine class method 
read This0 cast(read This2.Concept.Classable that) 
refine class method 
mut This0 #cast(mut This2.Concept.Classable that) 
read method 
This2.S _text() 
read method 
This2.Message.Opt cause() 
class method 
This0 #apply(This2.S _text, This2.Message.Opt cause) 
refine class method 
This2.S kind() 
refine read method 
This2.S text() 
refine read method 
This2.Message.Opt responseOf() 
method 
This0 #apply(This2.Message that) 
refine read method 
This2.S toS() 
read method 
This2.Bool equals(read This0 that) 
class method 
This0 #apply(This2.S text) 
class method 
This0 #apply(This2.S text, This2.Message cause) 
class method 
mut This2.S.SBuilder #builder() 
class method 
This0 #from(This2.S.SBuilder builder) 
method 
This0.Continue #from(This2.S.SConcat seqBuilder) 
method 
mut This2.S.SConcat #seqBuilder() 
Continue: {
read method 
This3.S that() 
class method 
This0 #apply(This3.S that) 
method 
mut This3.S.SBuilder #builder() 
method 
This1 #from(This3.S.SBuilder builder) }}
Precondition: {implements This1, This2.Message, This2.Concept.Base, This2.Concept.ToS, This2.Concept.Classable, This2.Concept.Equals
refine read method 
class This0 class() 
refine class method /*
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  */This2.S readableName() 
refine class method /*
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  */This2.Bool is(class This2.Concept.Classable subtype) 
refine read method 
This2.Bool #equalequal#0left(read Any right) 
refine class method 
read This0 cast(read This2.Concept.Classable that) 
refine class method 
mut This0 #cast(mut This2.Concept.Classable that) 
read method 
This2.S _text() 
read method 
This2.Message.Opt cause() 
class method 
This0 #apply(This2.S _text, This2.Message.Opt cause) 
refine class method 
This2.S kind() 
refine read method 
This2.S text() 
refine read method 
This2.Message.Opt responseOf() 
method 
This0 #apply(This2.Message that) 
refine read method 
This2.S toS() 
read method 
This2.Bool equals(read This0 that) 
class method 
This0 #apply(This2.S text) 
class method 
This0 #apply(This2.S text, This2.Message cause) 
class method 
mut This2.S.SBuilder #builder() 
class method 
This0 #from(This2.S.SBuilder builder) 
method 
This0.Continue #from(This2.S.SConcat seqBuilder) 
method 
mut This2.S.SConcat #seqBuilder() 
Continue: {
read method 
This3.S that() 
class method 
This0 #apply(This3.S that) 
method 
mut This3.S.SBuilder #builder() 
method 
This1 #from(This3.S.SBuilder builder) }}
ParseFail: {interface implements This1, This2.Message, This2.Concept.Base, This2.Concept.ToS, This2.Concept.Classable, This2.Concept.Equals
refine read method 
This2.S toS() 
refine class method /*
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  */This2.S readableName() 
refine class method /*
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  */This2.Bool is(class This2.Concept.Classable subtype) 
refine read method 
This2.Bool #equalequal#0left(read Any right) 
refine class method 
read This2.Concept.Base cast(read This2.Concept.Classable that) 
refine class method 
mut This2.Concept.Base #cast(mut This2.Concept.Classable that) 
refine class method 
This2.S kind() 
refine read method 
This2.S text() 
refine read method 
This2.Message.Opt responseOf() 
refine read method 
class This2.Message class() }
CastFail: {implements This1, This2.Message, This2.Concept.Base, This2.Concept.ToS, This2.Concept.Classable, This2.Concept.Equals
refine read method 
class This0 class() 
refine class method /*
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  */This2.S readableName() 
refine class method /*
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  */This2.Bool is(class This2.Concept.Classable subtype) 
refine read method 
This2.Bool #equalequal#0left(read Any right) 
refine class method 
read This0 cast(read This2.Concept.Classable that) 
refine class method 
mut This0 #cast(mut This2.Concept.Classable that) 
read method 
This2.S _text() 
read method 
This2.Message.Opt cause() 
class method 
This0 #apply(This2.S _text, This2.Message.Opt cause) 
refine class method 
This2.S kind() 
refine read method 
This2.S text() 
refine read method 
This2.Message.Opt responseOf() 
method 
This0 #apply(This2.Message that) 
refine read method 
This2.S toS() 
read method 
This2.Bool equals(read This0 that) 
class method 
This0 #apply(This2.S text) 
class method 
This0 #apply(This2.S text, This2.Message cause) 
class method 
mut This2.S.SBuilder #builder() 
class method 
This0 #from(This2.S.SBuilder builder) 
method 
This0.Continue #from(This2.S.SConcat seqBuilder) 
method 
mut This2.S.SConcat #seqBuilder() 
Continue: {
read method 
This3.S that() 
class method 
This0 #apply(This3.S that) 
method 
mut This3.S.SBuilder #builder() 
method 
This1 #from(This3.S.SBuilder builder) }}}
System: {
Guard: {/* implements Outer.Guard soon (remove "interface" for a bad translation bug: This1_System_Guard is not abstract and does not override abstract method MtoS()
*/interface implements This2.Guard, This2.Message, This2.Concept.Base, This2.Concept.ToS, This2.Concept.Classable, This2.Concept.Equals
refine read method 
This2.S toS() 
refine class method /*
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  */This2.S readableName() 
refine class method /*
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  */This2.Bool is(class This2.Concept.Classable subtype) 
refine read method 
This2.Bool #equalequal#0left(read Any right) 
refine class method 
read This2.Concept.Base cast(read This2.Concept.Classable that) 
refine class method 
mut This2.Concept.Base #cast(mut This2.Concept.Classable that) 
refine class method 
This2.S kind() 
refine read method 
This2.S text() 
refine read method 
This2.Message.Opt responseOf() 
refine read method 
class This2.Message class() 
PluginFailure: {implements This1, This3.Guard, This3.Message, This3.Concept.Base, This3.Concept.ToS, This3.Concept.Classable, This3.Concept.Equals
refine read method 
class This0 class() 
refine class method /*
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  */This3.S readableName() 
refine class method /*
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  */This3.Bool is(class This3.Concept.Classable subtype) 
refine read method 
This3.Bool #equalequal#0left(read Any right) 
refine class method 
read This0 cast(read This3.Concept.Classable that) 
refine class method 
mut This0 #cast(mut This3.Concept.Classable that) 
read method 
This3.S _text() 
read method 
This3.Message.Opt cause() 
class method 
This0 #apply(This3.S _text, This3.Message.Opt cause) 
refine class method 
This3.S kind() 
refine read method 
This3.S text() 
refine read method 
This3.Message.Opt responseOf() 
method 
This0 #apply(This3.Message that) 
refine read method 
This3.S toS() 
read method 
This3.Bool equals(read This0 that) 
class method 
This0 #apply(This3.S text) 
class method 
This0 #apply(This3.S text, This3.Message cause) 
class method 
mut This3.S.SBuilder #builder() 
class method 
This0 #from(This3.S.SBuilder builder) 
method 
This0.Continue #from(This3.S.SConcat seqBuilder) 
method 
mut This3.S.SConcat #seqBuilder() 
Continue: {
read method 
This4.S that() 
class method 
This0 #apply(This4.S that) 
method 
mut This4.S.SBuilder #builder() 
method 
This1 #from(This4.S.SBuilder builder) }}}}
X: {
class method 
This0.AssertionFail #from(This1.S.SBuilder builder) 
class method 
mut This1.S.SBuilder #builder() 
class method 
mut This0.Tests #seqBuilder() 
class method 
Void #from(This0.Tests seqBuilder) 
NotImplementedYet: {implements This2.Message, This2.Concept.Base, This2.Concept.ToS, This2.Concept.Classable, This2.Concept.Equals
refine read method 
class This0 class() 
refine class method /*
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  */This2.S readableName() 
refine class method /*
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  */This2.Bool is(class This2.Concept.Classable subtype) 
refine read method 
This2.Bool #equalequal#0left(read Any right) 
refine class method 
read This0 cast(read This2.Concept.Classable that) 
refine class method 
mut This0 #cast(mut This2.Concept.Classable that) 
read method 
This2.S _text() 
read method 
This2.Message.Opt cause() 
class method 
This0 #apply(This2.S _text, This2.Message.Opt cause) 
refine class method 
This2.S kind() 
refine read method 
This2.S text() 
refine read method 
This2.Message.Opt responseOf() 
method 
This0 #apply(This2.Message that) 
refine read method 
This2.S toS() 
read method 
This2.Bool equals(read This0 that) 
class method 
This0 #apply(This2.S text) 
class method 
This0 #apply(This2.S text, This2.Message cause) 
class method 
mut This2.S.SBuilder #builder() 
class method 
This0 #from(This2.S.SBuilder builder) 
method 
This0.Continue #from(This2.S.SConcat seqBuilder) 
method 
mut This2.S.SConcat #seqBuilder() 
Continue: {
read method 
This3.S that() 
class method 
This0 #apply(This3.S that) 
method 
mut This3.S.SBuilder #builder() 
method 
This1 #from(This3.S.SBuilder builder) }}
AssertionFail: {implements This2.Message, This2.Concept.Base, This2.Concept.ToS, This2.Concept.Classable, This2.Concept.Equals
refine read method 
class This0 class() 
refine class method /*
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  */This2.S readableName() 
refine class method /*
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  */This2.Bool is(class This2.Concept.Classable subtype) 
refine read method 
This2.Bool #equalequal#0left(read Any right) 
refine class method 
read This0 cast(read This2.Concept.Classable that) 
refine class method 
mut This0 #cast(mut This2.Concept.Classable that) 
read method 
This2.S _text() 
read method 
This2.Message.Opt cause() 
class method 
This0 #apply(This2.S _text, This2.Message.Opt cause) 
refine class method 
This2.S kind() 
refine read method 
This2.S text() 
refine read method 
This2.Message.Opt responseOf() 
method 
This0 #apply(This2.Message that) 
refine read method 
This2.S toS() 
read method 
This2.Bool equals(read This0 that) 
class method 
This0 #apply(This2.S text) 
class method 
This0 #apply(This2.S text, This2.Message cause) 
class method 
mut This2.S.SBuilder #builder() 
class method 
This0 #from(This2.S.SBuilder builder) 
method 
This0.Continue #from(This2.S.SConcat seqBuilder) 
method 
mut This2.S.SConcat #seqBuilder() 
Continue: {
read method 
This3.S that() 
class method 
This0 #apply(This3.S that) 
method 
mut This3.S.SBuilder #builder() 
method 
This1 #from(This3.S.SBuilder builder) }}
Pre: {
class method 
mut This1.Tests #seqBuilder() 
class method 
Void #from(This1.Tests seqBuilder) }
Test: {
read method 
This2.Bool that() 
read method 
This2.S msg() 
class method 
This0 #apply(This2.Bool that, This2.S msg) }
Tests: {implements This2.Concept.ToS, This2.Concept.Classable
refine class method /*
  Cast a (read/imm) object to this type.
  A class implementing this method should refine the return type to This.
  if is(subtype) is true, then cast(that) must produce a result.
  */read This0 cast(read This2.Concept.Classable that) 
refine class method /*
  Cast a (mutable) object to this type.
  A class implementing this method should refine the return type to This.
  if cast(that) produces a result, then #cast(that) also must produce a result.
  */mut This0 #cast(mut This2.Concept.Classable that) 
refine read method /*
  Extracts the class singleton from another instance of this class
  */class This0 class() 
refine class method /*
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  */This2.S readableName() 
refine class method /*
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  */This2.Bool is(class This2.Concept.Classable subtype) 
read method 
read This2.Collections.MutListAny inner() 
mut method 
mut This2.Collections.MutListAny #inner() 
class method 
mut This0 #apply(fwd mut This2.Collections.MutListAny inner) 
class method 
This0 #immK(This2.Collections.MutListAny inner) 
class method 
mut This0 empty() 
class method 
mut This0 #seqBuilder() 
class method 
mut This0 #from(mut This0 seqBuilder) 
read method 
mut This0 reverse() 
read method 
This2.Size size() 
read method 
This2.Bool isEmpty() 
read method 
This1.Test val(This2.Size that) 
read method 
class This2.Size #default#val(Void that) 
read method 
This1.Test left() 
read method 
This1.Test right() 
mut method 
Void #apply(This2.Size that, This1.Test val) 
mut method 
Void left(This1.Test that) 
mut method 
Void right(This1.Test that) 
mut method 
Void add(This2.Size that, This1.Test val) 
mut method 
Void add(This1.Test right) 
mut method 
Void add(This1.Test left) 
mut method 
Void remove(This2.Size that) 
mut method 
Void removeLeft() 
mut method 
Void removeRight() 
method 
This0 #plus#0left(This1.Test right) 
method 
This0 #plusplus#0left(This0 right) 
method 
This0 with(This2.Size that, This1.Test val) 
method 
This0 withLeft(This1.Test that) 
method 
This0 withRight(This1.Test that) 
method 
This0 withAlso(This2.Size that, This1.Test val) 
method 
This0 withAlsoLeft(This1.Test that) 
method 
This0 withAlsoRight(This1.Test that) 
method 
This0 without(This2.Size index) 
method 
This0 withoutLeft() 
method 
This0 withoutRight() 
read method 
lent This0.IteratorVal vals(This2.Size from, This2.Size maxTo, This2.Size minTo) 
read method 
lent This0.IteratorVal vals(This2.Size minTo) 
read method 
lent This0.IteratorVal vals(This2.Size from, This2.Size to) 
read method 
lent This0.IteratorVal vals() 
read method 
lent This0.IteratorValFill vals(This2.Size from, This2.Size maxTo, This2.Size minTo, This1.Test filled) 
read method 
lent This0.IteratorValFill vals(This2.Size minTo, This1.Test filled) 
read method 
lent This0.IteratorValFill vals(This2.Size from, This2.Size to, This1.Test filled) 
read method 
lent This0.IteratorValFill vals(This1.Test filled) 
mut method 
lent This0.IteratorVar #vals(This2.Size from, This2.Size maxTo, This2.Size minTo) 
mut method 
lent This0.IteratorVar #vals(This2.Size minTo) 
mut method 
lent This0.IteratorVar #vals(This2.Size from, This2.Size to) 
mut method 
lent This0.IteratorVar #vals() 
refine read method 
This2.S toS() 
mut method 
Void #add(This2.Bool that, This2.Concept.ToS msg) 
mut method 
Void #add(This2.Bool that) 
read method 
This2.S collapse() 
Cast: {
class method 
This2.Test #apply(Any that) }
IteratorTrait: {
class method 
Library #apply() }
IteratorVal: {
mut method 
Void #next() exception Void 
read method 
Void #checkEnd() 
read method 
This2.Test #inner() 
read method 
Void #close() 
read method 
read This3.Collections.MutListAny _that() 
mut method 
Void from(This3.Size that) 
read method 
This3.Size from() 
read method 
This3.Size maxTo() 
read method 
This3.Size minTo() 
read method 
read This3.Collections.MutListAny that() 
class method 
lent This0 #apply(read This3.Collections.MutListAny _that, This3.Size from, This3.Size maxTo, This3.Size minTo) 
class method 
lent This0 #apply(read This3.Collections.MutListAny that, This3.Size from, This3.Size maxTo, This3.Size minTo) 
read method 
This3.Bool isFill() 
read method 
This2.Test filled() }
IteratorValFill: {
mut method 
Void #next() exception Void 
read method 
Void #checkEnd() 
read method 
This2.Test #inner() 
read method 
Void #close() 
read method 
read This3.Collections.MutListAny _that() 
mut method 
Void from(This3.Size that) 
read method 
This3.Size from() 
read method 
This3.Size maxTo() 
read method 
This3.Size minTo() 
read method 
This2.Test filled() 
read method 
read This3.Collections.MutListAny that() 
class method 
lent This0 #apply(read This3.Collections.MutListAny _that, This3.Size from, This3.Size maxTo, This3.Size minTo, This2.Test filled) 
class method 
lent This0 #apply(read This3.Collections.MutListAny that, This3.Size from, This3.Size maxTo, This3.Size minTo, This2.Test filled) 
read method 
This3.Bool isFill() }
IteratorVar: {
mut method 
Void #next() exception Void 
read method 
Void #checkEnd() 
read method 
This2.Test #inner() 
read method 
Void #close() 
read method 
read This3.Collections.MutListAny that() 
mut method 
mut This3.Collections.MutListAny #that() 
mut method 
Void from(This3.Size that) 
read method 
This3.Size from() 
read method 
This3.Size maxTo() 
read method 
This3.Size minTo() 
class method 
mut This0 #apply(mut This3.Collections.MutListAny that, This3.Size from, This3.Size maxTo, This3.Size minTo) 
mut method 
Void inner(This2.Test that) 
read method 
This3.Bool isFill() 
read method 
This2.Test filled() }}}
Strings: {implements This1.Concept.ToS, This1.Concept.Classable, This1.Concept.Equals
refine class method /*
  Cast a (read/imm) object to this type.
  A class implementing this method should refine the return type to This.
  if is(subtype) is true, then cast(that) must produce a result.
  */read This0 cast(read This1.Concept.Classable that) 
refine class method /*
  Cast a (mutable) object to this type.
  A class implementing this method should refine the return type to This.
  if cast(that) produces a result, then #cast(that) also must produce a result.
  */mut This0 #cast(mut This1.Concept.Classable that) 
refine read method /*
  Extracts the class singleton from another instance of this class
  */class This0 class() 
refine class method /*
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  */This1.S readableName() 
refine class method /*
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  */This1.Bool is(class This1.Concept.Classable subtype) 
read method 
read This1.Collections.MutListAny inner() 
mut method 
mut This1.Collections.MutListAny #inner() 
class method 
mut This0 #apply(fwd mut This1.Collections.MutListAny inner) 
class method 
This0 #immK(This1.Collections.MutListAny inner) 
class method 
mut This0 empty() 
read method 
mut This0 reverse() 
read method 
This1.Bool isEmpty() 
read method 
class This1.Size #default#val(Void that) 
read method 
This1.S left() 
read method 
This1.S right() 
mut method 
Void #apply(This1.Size that, This1.S val) 
mut method 
Void left(This1.S that) 
mut method 
Void right(This1.S that) 
mut method 
Void add(This1.Size that, This1.S val) 
mut method 
Void add(This1.S right) 
mut method 
Void add(This1.S left) 
mut method 
Void removeLeft() 
mut method 
Void removeRight() 
method 
This0 #plus#0left(This1.S right) 
method 
This0 #plusplus#0left(This0 right) 
method 
This0 with(This1.Size that, This1.S val) 
method 
This0 withLeft(This1.S that) 
method 
This0 withRight(This1.S that) 
method 
This0 withAlso(This1.Size that, This1.S val) 
method 
This0 withAlsoLeft(This1.S that) 
method 
This0 withAlsoRight(This1.S that) 
method 
This0 withoutLeft() 
method 
This0 withoutRight() 
read method 
lent This0.IteratorVal vals(This1.Size from, This1.Size maxTo, This1.Size minTo) 
read method 
lent This0.IteratorVal vals(This1.Size minTo) 
read method 
lent This0.IteratorVal vals(This1.Size from, This1.Size to) 
read method 
lent This0.IteratorValFill vals(This1.Size from, This1.Size maxTo, This1.Size minTo, This1.S filled) 
read method 
lent This0.IteratorValFill vals(This1.Size minTo, This1.S filled) 
read method 
lent This0.IteratorValFill vals(This1.Size from, This1.Size to, This1.S filled) 
read method 
lent This0.IteratorValFill vals(This1.S filled) 
mut method 
lent This0.IteratorVar #vals(This1.Size from, This1.Size maxTo, This1.Size minTo) 
mut method 
lent This0.IteratorVar #vals(This1.Size minTo) 
mut method 
lent This0.IteratorVar #vals(This1.Size from, This1.Size to) 
mut method 
lent This0.IteratorVar #vals() 
refine read method 
This1.S toS() 
read method 
This1.Size size() 
read method 
This1.S val(This1.Size that) 
class method 
mut This0 #seqBuilder() 
class method 
mut This0 #from(mut This0 seqBuilder) 
mut method 
Void #add(This1.S that) 
read method 
lent This0.IteratorVal vals() 
read method 
This1.Bool contains(This1.S that) 
method 
This0 #less#0left(This1.S right) 
method 
This0 #lessless#0left(This0 right) 
method 
This0 #and#0left(This0 right) 
method 
This1.Bool #rightright#0left(This0 right) 
method 
This1.Bool #rightrightequal#0left(This0 right) 
method 
This1.Bool #right#0left(This1.S right) 
read method 
This1.Bool equals(read This0 that) 
refine read method 
This1.Bool #equalequal#0left(read Any right) 
read method 
This1.Size indexOfLeft(This1.S val) 
read method 
This1.Size indexOfRight(This1.S val) 
method /*from VectorTrait
*/This0 without(This1.Size index) 
method 
This0 withoutLeft(This1.S val) 
method 
This0 withoutRight(This1.S val) 
method 
This0 withoutAll(This1.S val) 
mut method /*from VectorTrait
*/Void remove(This1.Size that) 
mut method 
Void removeAll(This1.S val) 
mut method 
Void removeLeft(This1.S val) 
mut method 
Void removeRight(This1.S val) 
Cast: {
class method 
This2.S #apply(Any that) }
IteratorTrait: {
class method 
Library #apply() }
IteratorValFill: {
mut method 
Void #next() exception Void 
read method 
Void #checkEnd() 
read method 
This2.S #inner() 
read method 
Void #close() 
read method 
read This2.Collections.MutListAny _that() 
mut method 
Void from(This2.Size that) 
read method 
This2.Size from() 
read method 
This2.Size maxTo() 
read method 
This2.Size minTo() 
read method 
This2.S filled() 
read method 
read This2.Collections.MutListAny that() 
class method 
lent This0 #apply(read This2.Collections.MutListAny _that, This2.Size from, This2.Size maxTo, This2.Size minTo, This2.S filled) 
class method 
lent This0 #apply(read This2.Collections.MutListAny that, This2.Size from, This2.Size maxTo, This2.Size minTo, This2.S filled) 
read method 
This2.Bool isFill() }
IteratorVar: {
mut method 
Void #next() exception Void 
read method 
Void #checkEnd() 
read method 
This2.S #inner() 
read method 
Void #close() 
read method 
read This2.Collections.MutListAny that() 
mut method 
mut This2.Collections.MutListAny #that() 
mut method 
Void from(This2.Size that) 
read method 
This2.Size from() 
read method 
This2.Size maxTo() 
read method 
This2.Size minTo() 
class method 
mut This0 #apply(mut This2.Collections.MutListAny that, This2.Size from, This2.Size maxTo, This2.Size minTo) 
mut method 
Void inner(This2.S that) 
read method 
This2.Bool isFill() 
read method 
This2.S filled() }
IteratorVal: {
read method 
read This2.Collections.MutListAny _that() 
mut method 
Void from(This2.Size that) 
read method 
This2.Size from() 
read method 
This2.Size maxTo() 
read method 
This2.Size minTo() 
read method 
read This2.Collections.MutListAny that() 
class method 
lent This0 #apply(read This2.Collections.MutListAny _that, This2.Size from, This2.Size maxTo, This2.Size minTo) 
class method 
lent This0 #apply(read This2.Collections.MutListAny that, This2.Size from, This2.Size maxTo, This2.Size minTo) 
read method 
This2.Bool isFill() 
read method 
This2.S filled() 
mut method 
Void #next() exception Void 
read method 
Void #checkEnd() 
read method 
This2.S #inner() 
read method 
Void #close() }}
Debug: {
class method 
Void #apply(read This1.Concept.ToS that) 
class method 
Void #apply(Library lib) 
class method 
Void #$(This1.Concept.ToS fileName, This1.Concept.ToS content) 
class method 
This1.S #$readFile(This1.Concept.ToS fileName) 
class method 
This1.S #$localToAbsolute(This1.Concept.ToS fileName) 
class method 
Void test(read This1.Concept.ToS that, read This1.Concept.ToS expected, This1.S message) 
class method 
Void test(read This1.Concept.ToS that, read This1.Concept.ToS expected) 
Test: {/* Builder to look like a list and run a series of debug.test calls.
 Does not actually make an instance or store the list of calls anywhere :-)
*/
class method 
class This0 #seqBuilder() 
class method 
Void #from(class This0 seqBuilder) 
class method 
Void #add(read This2.Concept.ToS that, read This2.Concept.ToS expected) 
class method 
Void #add(read This2.Concept.ToS that, read This2.Concept.ToS expected, This2.S message) }}
ConceptMap: {interface 
method 
This1.Alu _Alu() 
method 
This1.ExitCode _ExitCode() 
method 
This1.Bool _Bool() 
method 
This1.Size _Size() 
method 
This1.Num _Num() 
method 
This1.S _S() 
method 
This1.Concept _Concept() 
method 
This1.Message _Message() 
method 
This1.Guard _Guard() 
method 
This1.System _System() 
method 
This1.X _X() 
method 
This1.Strings _Strings() 
method 
This1.Debug _Debug() 
method 
This0 _ConceptMap() 
method 
This1.Url _Url() 
method 
This1.Path _Path() 
method 
This1.Selector _Selector() 
method 
This1.Location _Location() 
method 
This1.Refactor2 _Refactor2() 
method 
This1.Optimize _Optimize() 
method 
This1.Opt _Opt() 
method 
This1.Use _Use() 
method 
This1.Collections _Collections() 
method 
This1.CollectionsMut _CollectionsMut() 
method 
This1.K _K() 
method 
This1.Alphanumeric _Alphanumeric() 
method 
This1.DeployTowel _DeployTowel() 
method 
This1.Composers _Composers() 
method 
This1.Load _Load() }
Url: {implements This1.Concept.ToS
read method 
This1.S inner() 
class method 
This0 #apply(This1.S inner) 
refine read method 
This1.S toS() 
method 
Library #binaryRepr() 
class method /* if you do not implement it, it is a constructor?
may become an interface Concept.Parsable method?
*/This0 from(This1.Concept.ToS string) 
class method 
This0 #from(This1.S.SBuilder builder) 
class method 
mut This1.S.SBuilder #builder() }
Path: {/*@plugin is.L42.connected.withSafeOperators
@pluginPart java.util.List
*/implements This1.Concept.Base, This1.Concept.ToS, This1.Concept.Classable, This1.Concept.Equals
class method 
mut This0 #from(Library binaryRepr) 
read method 
Library #binaryRepr() 
class method 
Void #exceptionIf(Library binaryRepr) exception This0 
read method 
This1.Bool equals(read This0 that) 
refine class method /*
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  */This1.S readableName() 
refine class method /*
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  */This1.Bool is(class This1.Concept.Classable subtype) 
refine read method 
This1.Bool #equalequal#0left(read Any right) 
refine read method 
class This0 class() 
refine class method 
read This0 cast(read This1.Concept.Classable that) 
refine class method 
mut This0 #cast(mut This1.Concept.Classable that) 
class method 
Library #pluginUnresponsive(Library binaryRepr) 
class method 
This0 from(This1.Concept.ToS string) 
class method 
This0 #from(This1.S.SBuilder builder) 
class method 
mut This1.S.SBuilder #builder() 
method 
This1.Strings names() 
class method 
This0 from(read This1.Strings names) 
class method 
This0 fresh() 
method 
This1.S name(This1.Size that) 
method 
This1.Size nameSize() 
refine read method 
This1.S toS() 
method 
This0 #plusplus#0left(This0 right) 
method 
This1.Bool isUnique() 
class method 
This0 fresh(This0 like) 
method 
This1.Size size() 
class method 
Any parseError(This1.S that) 
class method 
Any parseError(This1.S that, This1.Message cause) 
PlgPath: {/*@plugin is.L42.connected.withSafeOperators
@pluginPart is.L42.connected.withSafeOperators.refactor.PathAdapter
*/
class method 
mut This0 #from(Library binaryRepr) 
read method 
Library #binaryRepr() 
class method 
Void #exceptionIf(Library binaryRepr) exception This0 
class method 
Library #pluginUnresponsive(Library binaryRepr) 
class method 
This2.S name(This1 that, This2.Size index) 
class method 
This1 concat(This1 that, This1 and) 
class method 
This2.Bool isUnique(This1 that) 
class method 
This1 fresh(This1 that) 
class method 
This1 rawFromS(This2.S that) 
class method 
This2.S toS(read This1 that) }
ParseFail: {implements This2.Guard.ParseFail, This2.Guard, This2.Message, This2.Concept.Base, This2.Concept.ToS, This2.Concept.Classable, This2.Concept.Equals, This2.Guard.ParseFail, This2.Guard, This2.Message, This2.Concept.Base, This2.Concept.ToS, This2.Concept.Classable, This2.Concept.Equals
refine read method 
class This0 class() 
refine class method /*
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  */This2.S readableName() 
refine class method /*
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  */This2.Bool is(class This2.Concept.Classable subtype) 
refine read method 
This2.Bool #equalequal#0left(read Any right) 
refine class method 
read This0 cast(read This2.Concept.Classable that) 
refine class method 
mut This0 #cast(mut This2.Concept.Classable that) 
read method 
This2.S _text() 
read method 
This2.Message.Opt cause() 
class method 
This0 #apply(This2.S _text, This2.Message.Opt cause) 
refine class method 
This2.S kind() 
refine read method 
This2.S text() 
refine read method 
This2.Message.Opt responseOf() 
method 
This0 #apply(This2.Message that) 
refine read method 
This2.S toS() 
read method 
This2.Bool equals(read This0 that) 
class method 
This0 #apply(This2.S text) 
class method 
This0 #apply(This2.S text, This2.Message cause) 
class method 
mut This2.S.SBuilder #builder() 
class method 
This0 #from(This2.S.SBuilder builder) 
method 
This0.Continue #from(This2.S.SConcat seqBuilder) 
method 
mut This2.S.SConcat #seqBuilder() 
Continue: {
read method 
This3.S that() 
class method 
This0 #apply(This3.S that) 
method 
mut This3.S.SBuilder #builder() 
method 
This1 #from(This3.S.SBuilder builder) }}}
Selector: {/*@plugin  toFix 
@pluginPart ast.Ast$MethodSelector
*/implements This1.Concept.Base, This1.Concept.ToS, This1.Concept.Classable, This1.Concept.Equals
class method 
mut This0 #from(Library binaryRepr) 
read method 
Library #binaryRepr() 
class method 
Void #exceptionIf(Library binaryRepr) exception This0 
read method 
This1.Bool equals(read This0 that) 
refine read method 
This1.S toS() 
refine class method /*
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  */This1.S readableName() 
refine class method /*
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  */This1.Bool is(class This1.Concept.Classable subtype) 
refine read method 
This1.Bool #equalequal#0left(read Any right) 
refine read method 
class This0 class() 
refine class method 
read This0 cast(read This1.Concept.Classable that) 
refine class method 
mut This0 #cast(mut This1.Concept.Classable that) 
class method 
Library #pluginUnresponsive(Library binaryRepr) 
class method 
This0 parse(This1.S that) 
class method 
This0 from(This1.Concept.ToS string) 
class method 
This0 #from(This1.S.SBuilder builder) 
class method 
mut This1.S.SBuilder #builder() 
class method 
This0 from(This1.S name, This1.Strings names) 
method 
This1.S nameAsField() 
method 
This1.S prefixAsField() 
method 
This1.Bool isOperator() 
method 
This1.Bool isUnique() 
method 
This1.S nameToS() 
method 
This1.S name() 
method 
This1.Size nameSize() 
method 
This1.S name(This1.Size that) 
method 
This1.Strings names() 
class method 
This0 fresh(This0 like) 
class method /*will be private
*/This1.S leftAsASCIIUpperCase(This1.S that) 
method 
This0 with(This1.S prefix) 
method 
This0 with(This1.S name) 
method 
This0 with(This1.Strings names) 
class method 
Any parseError(This1.S that) 
ParseFail: {implements This2.Guard.ParseFail, This2.Guard, This2.Message, This2.Concept.Base, This2.Concept.ToS, This2.Concept.Classable, This2.Concept.Equals, This2.Guard.ParseFail, This2.Guard, This2.Message, This2.Concept.Base, This2.Concept.ToS, This2.Concept.Classable, This2.Concept.Equals
refine read method 
class This0 class() 
refine class method /*
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  */This2.S readableName() 
refine class method /*
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  */This2.Bool is(class This2.Concept.Classable subtype) 
refine read method 
This2.Bool #equalequal#0left(read Any right) 
refine class method 
read This0 cast(read This2.Concept.Classable that) 
refine class method 
mut This0 #cast(mut This2.Concept.Classable that) 
read method 
This2.S _text() 
read method 
This2.Message.Opt cause() 
class method 
This0 #apply(This2.S _text, This2.Message.Opt cause) 
refine class method 
This2.S kind() 
refine read method 
This2.S text() 
refine read method 
This2.Message.Opt responseOf() 
method 
This0 #apply(This2.Message that) 
refine read method 
This2.S toS() 
read method 
This2.Bool equals(read This0 that) 
class method 
This0 #apply(This2.S text) 
class method 
This0 #apply(This2.S text, This2.Message cause) 
class method 
mut This2.S.SBuilder #builder() 
class method 
This0 #from(This2.S.SBuilder builder) 
method 
This0.Continue #from(This2.S.SConcat seqBuilder) 
method 
mut This2.S.SConcat #seqBuilder() 
Continue: {
read method 
This3.S that() 
class method 
This0 #apply(This3.S that) 
method 
mut This3.S.SBuilder #builder() 
method 
This1 #from(This3.S.SBuilder builder) }}}
Location: {interface implements This1.Concept.Base/*that is equals, toS and "know your class"
*/, This1.Concept.ToS, This1.Concept.Classable, This1.Concept.Equals
refine read method 
This1.S toS() 
refine class method /*
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  */This1.S readableName() 
refine class method /*
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  */This1.Bool is(class This1.Concept.Classable subtype) 
refine read method 
This1.Bool #equalequal#0left(read Any right) 
refine read method 
class This1.Concept.Base class() 
refine class method 
read This1.Concept.Base cast(read This1.Concept.Classable that) 
refine class method 
mut This1.Concept.Base #cast(mut This1.Concept.Classable that) 
method 
This1.Size originSize() 
method 
This0.Origin origin(This1.Size that) 
method 
This0 location() 
method 
This0.Doc doc() 
NotAvailable: {implements This2.Guard, This2.Message, This2.Concept.Base, This2.Concept.ToS, This2.Concept.Classable, This2.Concept.Equals
refine read method 
class This0 class() 
refine class method /*
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  */This2.S readableName() 
refine class method /*
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  */This2.Bool is(class This2.Concept.Classable subtype) 
refine read method 
This2.Bool #equalequal#0left(read Any right) 
refine class method 
read This0 cast(read This2.Concept.Classable that) 
refine class method 
mut This0 #cast(mut This2.Concept.Classable that) 
read method 
This2.S _text() 
read method 
This2.Message.Opt cause() 
class method 
This0 #apply(This2.S _text, This2.Message.Opt cause) 
refine class method 
This2.S kind() 
refine read method 
This2.S text() 
refine read method 
This2.Message.Opt responseOf() 
method 
This0 #apply(This2.Message that) 
refine read method 
This2.S toS() 
read method 
This2.Bool equals(read This0 that) 
class method 
This0 #apply(This2.S text) 
class method 
This0 #apply(This2.S text, This2.Message cause) 
class method 
mut This2.S.SBuilder #builder() 
class method 
This0 #from(This2.S.SBuilder builder) 
method 
This0.Continue #from(This2.S.SConcat seqBuilder) 
method 
mut This2.S.SConcat #seqBuilder() 
Continue: {
read method 
This3.S that() 
class method 
This0 #apply(This3.S that) 
method 
mut This3.S.SBuilder #builder() 
method 
This1 #from(This3.S.SBuilder builder) }}
Mdf: {implements This2.Concept.Base, This2.Concept.ToS, This2.Concept.Classable, This2.Concept.Equals
read method 
This2.Size inner() 
class method 
This0 #apply(This2.Size inner) 
read method 
This2.S name() 
read method 
This2.Bool equals(read This0 that) 
class method 
This0 fromS(This2.S that) 
class method 
This2.Strings names() 
class method 
This0 cmpImm() 
method 
This2.Bool isCmpImm() 
class method 
This0 cmpMut() 
method 
This2.Bool isCmpMut() 
class method 
This0 cmpRead() 
method 
This2.Bool isCmpRead() 
class method 
This0 cmpLent() 
method 
This2.Bool isCmpLent() 
class method 
This0 cmpCapsule() 
method 
This2.Bool isCmpCapsule() 
class method 
This0 cmpClass() 
method 
This2.Bool isCmpClass() 
class method 
This0 fwdImm() 
method 
This2.Bool isFwdImm() 
class method 
This0 fwdMut() 
method 
This2.Bool isFwdMut() 
refine read method 
This2.S toS() 
refine class method /*
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  */This2.S readableName() 
refine class method /*
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  */This2.Bool is(class This2.Concept.Classable subtype) 
refine read method 
This2.Bool #equalequal#0left(read Any right) 
refine read method 
class This0 class() 
refine class method 
read This0 cast(read This2.Concept.Classable that) 
refine class method 
mut This0 #cast(mut This2.Concept.Classable that) 
ParseFail: {implements This3.Guard.ParseFail, This3.Guard, This3.Message, This3.Concept.Base, This3.Concept.ToS, This3.Concept.Classable, This3.Concept.Equals
refine read method 
class This0 class() 
refine class method /*
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  */This3.S readableName() 
refine class method /*
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  */This3.Bool is(class This3.Concept.Classable subtype) 
refine read method 
This3.Bool #equalequal#0left(read Any right) 
refine class method 
read This0 cast(read This3.Concept.Classable that) 
refine class method 
mut This0 #cast(mut This3.Concept.Classable that) 
read method 
This3.S _text() 
read method 
This3.Message.Opt cause() 
class method 
This0 #apply(This3.S _text, This3.Message.Opt cause) 
refine class method 
This3.S kind() 
refine read method 
This3.S text() 
refine read method 
This3.Message.Opt responseOf() 
method 
This0 #apply(This3.Message that) 
refine read method 
This3.S toS() 
read method 
This3.Bool equals(read This0 that) 
class method 
This0 #apply(This3.S text) 
class method 
This0 #apply(This3.S text, This3.Message cause) 
class method 
mut This3.S.SBuilder #builder() 
class method 
This0 #from(This3.S.SBuilder builder) 
method 
This0.Continue #from(This3.S.SConcat seqBuilder) 
method 
mut This3.S.SConcat #seqBuilder() 
Continue: {
read method 
This4.S that() 
class method 
This0 #apply(This4.S that) 
method 
mut This4.S.SBuilder #builder() 
method 
This1 #from(This4.S.SBuilder builder) }}
List: {implements This3.Concept.ToS, This3.Concept.Classable, This3.Concept.Equals
refine class method /*
  Cast a (read/imm) object to this type.
  A class implementing this method should refine the return type to This.
  if is(subtype) is true, then cast(that) must produce a result.
  */read This0 cast(read This3.Concept.Classable that) 
refine class method /*
  Cast a (mutable) object to this type.
  A class implementing this method should refine the return type to This.
  if cast(that) produces a result, then #cast(that) also must produce a result.
  */mut This0 #cast(mut This3.Concept.Classable that) 
refine read method /*
  Extracts the class singleton from another instance of this class
  */class This0 class() 
refine class method /*
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  */This3.S readableName() 
refine class method /*
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  */This3.Bool is(class This3.Concept.Classable subtype) 
read method 
read This3.Collections.MutListAny inner() 
mut method 
mut This3.Collections.MutListAny #inner() 
class method 
mut This0 #apply(fwd mut This3.Collections.MutListAny inner) 
class method 
This0 #immK(This3.Collections.MutListAny inner) 
class method 
mut This0 empty() 
read method 
mut This0 reverse() 
read method 
This3.Bool isEmpty() 
read method 
class This3.Size #default#val(Void that) 
read method 
This1 left() 
read method 
This1 right() 
mut method 
Void #apply(This3.Size that, This1 val) 
mut method 
Void left(This1 that) 
mut method 
Void right(This1 that) 
mut method 
Void add(This3.Size that, This1 val) 
mut method 
Void add(This1 right) 
mut method 
Void add(This1 left) 
mut method 
Void removeLeft() 
mut method 
Void removeRight() 
method 
This0 #plus#0left(This1 right) 
method 
This0 #plusplus#0left(This0 right) 
method 
This0 with(This3.Size that, This1 val) 
method 
This0 withLeft(This1 that) 
method 
This0 withRight(This1 that) 
method 
This0 withAlso(This3.Size that, This1 val) 
method 
This0 withAlsoLeft(This1 that) 
method 
This0 withAlsoRight(This1 that) 
method 
This0 withoutLeft() 
method 
This0 withoutRight() 
read method 
lent This0.IteratorVal vals(This3.Size from, This3.Size maxTo, This3.Size minTo) 
read method 
lent This0.IteratorVal vals(This3.Size minTo) 
read method 
lent This0.IteratorVal vals(This3.Size from, This3.Size to) 
read method 
lent This0.IteratorValFill vals(This3.Size from, This3.Size maxTo, This3.Size minTo, This1 filled) 
read method 
lent This0.IteratorValFill vals(This3.Size minTo, This1 filled) 
read method 
lent This0.IteratorValFill vals(This3.Size from, This3.Size to, This1 filled) 
read method 
lent This0.IteratorValFill vals(This1 filled) 
mut method 
lent This0.IteratorVar #vals(This3.Size from, This3.Size maxTo, This3.Size minTo) 
mut method 
lent This0.IteratorVar #vals(This3.Size minTo) 
mut method 
lent This0.IteratorVar #vals(This3.Size from, This3.Size to) 
mut method 
lent This0.IteratorVar #vals() 
refine read method 
This3.S toS() 
read method 
This3.Size size() 
read method 
This1 val(This3.Size that) 
class method 
mut This0 #seqBuilder() 
class method 
mut This0 #from(mut This0 seqBuilder) 
mut method 
Void #add(This1 that) 
read method 
lent This0.IteratorVal vals() 
read method 
This3.Bool contains(This1 that) 
method 
This0 #less#0left(This1 right) 
method 
This0 #lessless#0left(This0 right) 
method 
This0 #and#0left(This0 right) 
method 
This3.Bool #rightright#0left(This0 right) 
method 
This3.Bool #rightrightequal#0left(This0 right) 
method 
This3.Bool #right#0left(This1 right) 
read method 
This3.Bool equals(read This0 that) 
refine read method 
This3.Bool #equalequal#0left(read Any right) 
read method 
This3.Size indexOfLeft(This1 val) 
read method 
This3.Size indexOfRight(This1 val) 
method /*from VectorTrait
*/This0 without(This3.Size index) 
method 
This0 withoutLeft(This1 val) 
method 
This0 withoutRight(This1 val) 
method 
This0 withoutAll(This1 val) 
mut method /*from VectorTrait
*/Void remove(This3.Size that) 
mut method 
Void removeAll(This1 val) 
mut method 
Void removeLeft(This1 val) 
mut method 
Void removeRight(This1 val) 
Cast: {
class method 
This2 #apply(Any that) }
IteratorTrait: {
class method 
Library #apply() }
IteratorValFill: {
mut method 
Void #next() exception Void 
read method 
Void #checkEnd() 
read method 
This2 #inner() 
read method 
Void #close() 
read method 
read This4.Collections.MutListAny _that() 
mut method 
Void from(This4.Size that) 
read method 
This4.Size from() 
read method 
This4.Size maxTo() 
read method 
This4.Size minTo() 
read method 
This2 filled() 
read method 
read This4.Collections.MutListAny that() 
class method 
lent This0 #apply(read This4.Collections.MutListAny _that, This4.Size from, This4.Size maxTo, This4.Size minTo, This2 filled) 
class method 
lent This0 #apply(read This4.Collections.MutListAny that, This4.Size from, This4.Size maxTo, This4.Size minTo, This2 filled) 
read method 
This4.Bool isFill() }
IteratorVar: {
mut method 
Void #next() exception Void 
read method 
Void #checkEnd() 
read method 
This2 #inner() 
read method 
Void #close() 
read method 
read This4.Collections.MutListAny that() 
mut method 
mut This4.Collections.MutListAny #that() 
mut method 
Void from(This4.Size that) 
read method 
This4.Size from() 
read method 
This4.Size maxTo() 
read method 
This4.Size minTo() 
class method 
mut This0 #apply(mut This4.Collections.MutListAny that, This4.Size from, This4.Size maxTo, This4.Size minTo) 
mut method 
Void inner(This2 that) 
read method 
This4.Bool isFill() 
read method 
This2 filled() }
IteratorVal: {
read method 
read This4.Collections.MutListAny _that() 
mut method 
Void from(This4.Size that) 
read method 
This4.Size from() 
read method 
This4.Size maxTo() 
read method 
This4.Size minTo() 
read method 
read This4.Collections.MutListAny that() 
class method 
lent This0 #apply(read This4.Collections.MutListAny _that, This4.Size from, This4.Size maxTo, This4.Size minTo) 
class method 
lent This0 #apply(read This4.Collections.MutListAny that, This4.Size from, This4.Size maxTo, This4.Size minTo) 
read method 
This4.Bool isFill() 
read method 
This2 filled() 
mut method 
Void #next() exception Void 
read method 
Void #checkEnd() 
read method 
This2 #inner() 
read method 
Void #close() }}}
Origin: {/*@plugin  toFix 
@pluginPart is.L42.connected.withSafeOperators.location.Origin
*/implements This2.Concept.Base, This2.Concept.ToS, This2.Concept.Classable, This2.Concept.Equals
class method 
mut This0 #from(Library binaryRepr) 
read method 
Library #binaryRepr() 
class method 
Void #exceptionIf(Library binaryRepr) exception This0 
read method 
This2.Bool equals(read This0 that) 
read method 
This2.S fileName() 
read method 
This2.Size lineStart() 
read method 
This2.Size lineEnd() 
read method 
This2.Size columnStart() 
read method 
This2.Size columnEnd() 
class method 
Library #pluginUnresponsive(Library binaryRepr) 
class method 
This0 #apply(This2.S fileName, This2.Size lineStart, This2.Size lineEnd, This2.Size columnStart, This2.Size columnEnd) 
refine read method 
This2.S toS() 
refine class method /*
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  */This2.S readableName() 
refine class method /*
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  */This2.Bool is(class This2.Concept.Classable subtype) 
refine read method 
This2.Bool #equalequal#0left(read Any right) 
refine class method 
read This0 cast(read This2.Concept.Classable that) 
refine class method 
mut This0 #cast(mut This2.Concept.Classable that) 
refine read method 
class This0 class() 
List: {implements This3.Concept.ToS, This3.Concept.Classable, This3.Concept.Equals
refine class method /*
  Cast a (read/imm) object to this type.
  A class implementing this method should refine the return type to This.
  if is(subtype) is true, then cast(that) must produce a result.
  */read This0 cast(read This3.Concept.Classable that) 
refine class method /*
  Cast a (mutable) object to this type.
  A class implementing this method should refine the return type to This.
  if cast(that) produces a result, then #cast(that) also must produce a result.
  */mut This0 #cast(mut This3.Concept.Classable that) 
refine read method /*
  Extracts the class singleton from another instance of this class
  */class This0 class() 
refine class method /*
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  */This3.S readableName() 
refine class method /*
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  */This3.Bool is(class This3.Concept.Classable subtype) 
read method 
read This3.Collections.MutListAny inner() 
mut method 
mut This3.Collections.MutListAny #inner() 
class method 
mut This0 #apply(fwd mut This3.Collections.MutListAny inner) 
class method 
This0 #immK(This3.Collections.MutListAny inner) 
class method 
mut This0 empty() 
read method 
mut This0 reverse() 
read method 
This3.Bool isEmpty() 
read method 
class This3.Size #default#val(Void that) 
read method 
This1 left() 
read method 
This1 right() 
mut method 
Void #apply(This3.Size that, This1 val) 
mut method 
Void left(This1 that) 
mut method 
Void right(This1 that) 
mut method 
Void add(This3.Size that, This1 val) 
mut method 
Void add(This1 right) 
mut method 
Void add(This1 left) 
mut method 
Void removeLeft() 
mut method 
Void removeRight() 
method 
This0 #plus#0left(This1 right) 
method 
This0 #plusplus#0left(This0 right) 
method 
This0 with(This3.Size that, This1 val) 
method 
This0 withLeft(This1 that) 
method 
This0 withRight(This1 that) 
method 
This0 withAlso(This3.Size that, This1 val) 
method 
This0 withAlsoLeft(This1 that) 
method 
This0 withAlsoRight(This1 that) 
method 
This0 withoutLeft() 
method 
This0 withoutRight() 
read method 
lent This0.IteratorVal vals(This3.Size from, This3.Size maxTo, This3.Size minTo) 
read method 
lent This0.IteratorVal vals(This3.Size minTo) 
read method 
lent This0.IteratorVal vals(This3.Size from, This3.Size to) 
read method 
lent This0.IteratorValFill vals(This3.Size from, This3.Size maxTo, This3.Size minTo, This1 filled) 
read method 
lent This0.IteratorValFill vals(This3.Size minTo, This1 filled) 
read method 
lent This0.IteratorValFill vals(This3.Size from, This3.Size to, This1 filled) 
read method 
lent This0.IteratorValFill vals(This1 filled) 
mut method 
lent This0.IteratorVar #vals(This3.Size from, This3.Size maxTo, This3.Size minTo) 
mut method 
lent This0.IteratorVar #vals(This3.Size minTo) 
mut method 
lent This0.IteratorVar #vals(This3.Size from, This3.Size to) 
mut method 
lent This0.IteratorVar #vals() 
refine read method 
This3.S toS() 
read method 
This3.Size size() 
read method 
This1 val(This3.Size that) 
class method 
mut This0 #seqBuilder() 
class method 
mut This0 #from(mut This0 seqBuilder) 
mut method 
Void #add(This1 that) 
read method 
lent This0.IteratorVal vals() 
read method 
This3.Bool contains(This1 that) 
method 
This0 #less#0left(This1 right) 
method 
This0 #lessless#0left(This0 right) 
method 
This0 #and#0left(This0 right) 
method 
This3.Bool #rightright#0left(This0 right) 
method 
This3.Bool #rightrightequal#0left(This0 right) 
method 
This3.Bool #right#0left(This1 right) 
read method 
This3.Bool equals(read This0 that) 
refine read method 
This3.Bool #equalequal#0left(read Any right) 
read method 
This3.Size indexOfLeft(This1 val) 
read method 
This3.Size indexOfRight(This1 val) 
method /*from VectorTrait
*/This0 without(This3.Size index) 
method 
This0 withoutLeft(This1 val) 
method 
This0 withoutRight(This1 val) 
method 
This0 withoutAll(This1 val) 
mut method /*from VectorTrait
*/Void remove(This3.Size that) 
mut method 
Void removeAll(This1 val) 
mut method 
Void removeLeft(This1 val) 
mut method 
Void removeRight(This1 val) 
Cast: {
class method 
This2 #apply(Any that) }
IteratorTrait: {
class method 
Library #apply() }
IteratorValFill: {
mut method 
Void #next() exception Void 
read method 
Void #checkEnd() 
read method 
This2 #inner() 
read method 
Void #close() 
read method 
read This4.Collections.MutListAny _that() 
mut method 
Void from(This4.Size that) 
read method 
This4.Size from() 
read method 
This4.Size maxTo() 
read method 
This4.Size minTo() 
read method 
This2 filled() 
read method 
read This4.Collections.MutListAny that() 
class method 
lent This0 #apply(read This4.Collections.MutListAny _that, This4.Size from, This4.Size maxTo, This4.Size minTo, This2 filled) 
class method 
lent This0 #apply(read This4.Collections.MutListAny that, This4.Size from, This4.Size maxTo, This4.Size minTo, This2 filled) 
read method 
This4.Bool isFill() }
IteratorVar: {
mut method 
Void #next() exception Void 
read method 
Void #checkEnd() 
read method 
This2 #inner() 
read method 
Void #close() 
read method 
read This4.Collections.MutListAny that() 
mut method 
mut This4.Collections.MutListAny #that() 
mut method 
Void from(This4.Size that) 
read method 
This4.Size from() 
read method 
This4.Size maxTo() 
read method 
This4.Size minTo() 
class method 
mut This0 #apply(mut This4.Collections.MutListAny that, This4.Size from, This4.Size maxTo, This4.Size minTo) 
mut method 
Void inner(This2 that) 
read method 
This4.Bool isFill() 
read method 
This2 filled() }
IteratorVal: {
read method 
read This4.Collections.MutListAny _that() 
mut method 
Void from(This4.Size that) 
read method 
This4.Size from() 
read method 
This4.Size maxTo() 
read method 
This4.Size minTo() 
read method 
read This4.Collections.MutListAny that() 
class method 
lent This0 #apply(read This4.Collections.MutListAny _that, This4.Size from, This4.Size maxTo, This4.Size minTo) 
class method 
lent This0 #apply(read This4.Collections.MutListAny that, This4.Size from, This4.Size maxTo, This4.Size minTo) 
read method 
This4.Bool isFill() 
read method 
This2 filled() 
mut method 
Void #next() exception Void 
read method 
Void #checkEnd() 
read method 
This2 #inner() 
read method 
Void #close() }}}
PUnresponsive: {
class method 
Library #leftrightleft#0left(Library right) 
class method 
Library #apply() }
This$Impl: {
class method 
Library #leftrightleft#0left(Library right) 
class method 
Library #apply() }
PlgClass: {
class method 
Library #leftrightleft#0left(Library right) }
Lib: {/*@plugin  toFix
@pluginPart is.L42.connected.withSafeOperators.location.Lib
*/implements This1, This2.Concept.Base, This2.Concept.ToS, This2.Concept.Classable, This2.Concept.Equals
class method 
mut This0 #from(Library binaryRepr) 
read method 
Library #binaryRepr() 
class method 
Void #exceptionIf(Library binaryRepr) exception This0 
class method 
Library #pluginUnresponsive(Library binaryRepr) 
read method 
This2.Bool equals(read This0 that) 
method 
This1.Origin.List origins() 
refine method 
This2.Size originSize() 
refine method 
This1.Origin origin(This2.Size that) 
refine method 
This1.Doc doc() 
method 
This0.List nesteds() 
method 
This0.List allNesteds() 
method 
class This2.Path #default#nested(Void path) 
method 
This0 nested(This2.Path path) exception This1.NotAvailable 
method 
class This2.Path #default#has(Void path) 
method 
This2.Bool has(This2.Path path) 
method 
This1.Method.List methods() 
method 
class This2.Selector #default#method(Void selector) 
method 
This1.Method method(This2.Selector selector) exception This1.NotAvailable 
method 
class This2.Selector #default#has(Void selector) 
method 
This2.Bool has(This2.Selector selector) 
method 
This1.Type.Implemented.List implements() 
method 
This2.Bool implements(class Any classObj) 
method 
class This2.Path #default#implements(Void path) 
method 
This2.Bool implements(This2.Path path) 
class method 
This0 #apply(class Any classObj) 
class method 
This0 #apply(Library that) 
method 
This0 navigate(This2.Path that) 
class method 
This0 newFromClass(class Any that) 
class method 
This0 newFromLibrary(Library that) 
method 
This1.Type.Implemented implemented(This2.Size that) 
method 
This2.Size implementedSize() 
method 
This2.Bool isBinded() 
method 
This2.Bool isCloseState() 
method /*as in EnsureCoherent<><
*/This2.Bool isEnsuredCoherent() 
method 
This2.Bool isInterface() 
method 
This2.Bool isPotentialInterface() 
method 
This2.Bool isRedirectable() 
method 
This1.Method method(This2.Size that) 
method 
This2.Size methodSize() 
method 
This0 nested(This2.Size that) 
method /*empty doc if it is root
*/This1.Doc nestedDoc() 
method 
This2.Size nestedSize() 
method /*last is its name, empty path for root
*/This2.Path path() 
method 
This0 root() 
refine method /*implemented but refined
*/This0 location() 
refine read method 
This2.S toS() 
refine class method /*
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  */This2.S readableName() 
refine class method /*
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  */This2.Bool is(class This2.Concept.Classable subtype) 
refine read method 
This2.Bool #equalequal#0left(read Any right) 
refine class method 
read This0 cast(read This2.Concept.Classable that) 
refine class method 
mut This0 #cast(mut This2.Concept.Classable that) 
refine read method 
class This0 class() 
List: {implements This3.Concept.ToS, This3.Concept.Classable, This3.Concept.Equals
refine class method /*
  Cast a (read/imm) object to this type.
  A class implementing this method should refine the return type to This.
  if is(subtype) is true, then cast(that) must produce a result.
  */read This0 cast(read This3.Concept.Classable that) 
refine class method /*
  Cast a (mutable) object to this type.
  A class implementing this method should refine the return type to This.
  if cast(that) produces a result, then #cast(that) also must produce a result.
  */mut This0 #cast(mut This3.Concept.Classable that) 
refine read method /*
  Extracts the class singleton from another instance of this class
  */class This0 class() 
refine class method /*
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  */This3.S readableName() 
refine class method /*
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  */This3.Bool is(class This3.Concept.Classable subtype) 
read method 
read This3.Collections.MutListAny inner() 
mut method 
mut This3.Collections.MutListAny #inner() 
class method 
mut This0 #apply(fwd mut This3.Collections.MutListAny inner) 
class method 
This0 #immK(This3.Collections.MutListAny inner) 
class method 
mut This0 empty() 
read method 
mut This0 reverse() 
read method 
This3.Bool isEmpty() 
read method 
class This3.Size #default#val(Void that) 
read method 
This1 left() 
read method 
This1 right() 
mut method 
Void #apply(This3.Size that, This1 val) 
mut method 
Void left(This1 that) 
mut method 
Void right(This1 that) 
mut method 
Void add(This3.Size that, This1 val) 
mut method 
Void add(This1 right) 
mut method 
Void add(This1 left) 
mut method 
Void removeLeft() 
mut method 
Void removeRight() 
method 
This0 #plus#0left(This1 right) 
method 
This0 #plusplus#0left(This0 right) 
method 
This0 with(This3.Size that, This1 val) 
method 
This0 withLeft(This1 that) 
method 
This0 withRight(This1 that) 
method 
This0 withAlso(This3.Size that, This1 val) 
method 
This0 withAlsoLeft(This1 that) 
method 
This0 withAlsoRight(This1 that) 
method 
This0 withoutLeft() 
method 
This0 withoutRight() 
read method 
lent This0.IteratorVal vals(This3.Size from, This3.Size maxTo, This3.Size minTo) 
read method 
lent This0.IteratorVal vals(This3.Size minTo) 
read method 
lent This0.IteratorVal vals(This3.Size from, This3.Size to) 
read method 
lent This0.IteratorValFill vals(This3.Size from, This3.Size maxTo, This3.Size minTo, This1 filled) 
read method 
lent This0.IteratorValFill vals(This3.Size minTo, This1 filled) 
read method 
lent This0.IteratorValFill vals(This3.Size from, This3.Size to, This1 filled) 
read method 
lent This0.IteratorValFill vals(This1 filled) 
mut method 
lent This0.IteratorVar #vals(This3.Size from, This3.Size maxTo, This3.Size minTo) 
mut method 
lent This0.IteratorVar #vals(This3.Size minTo) 
mut method 
lent This0.IteratorVar #vals(This3.Size from, This3.Size to) 
mut method 
lent This0.IteratorVar #vals() 
refine read method 
This3.S toS() 
read method 
This3.Size size() 
read method 
This1 val(This3.Size that) 
class method 
mut This0 #seqBuilder() 
class method 
mut This0 #from(mut This0 seqBuilder) 
mut method 
Void #add(This1 that) 
read method 
lent This0.IteratorVal vals() 
read method 
This3.Bool contains(This1 that) 
method 
This0 #less#0left(This1 right) 
method 
This0 #lessless#0left(This0 right) 
method 
This0 #and#0left(This0 right) 
method 
This3.Bool #rightright#0left(This0 right) 
method 
This3.Bool #rightrightequal#0left(This0 right) 
method 
This3.Bool #right#0left(This1 right) 
read method 
This3.Bool equals(read This0 that) 
refine read method 
This3.Bool #equalequal#0left(read Any right) 
read method 
This3.Size indexOfLeft(This1 val) 
read method 
This3.Size indexOfRight(This1 val) 
method /*from VectorTrait
*/This0 without(This3.Size index) 
method 
This0 withoutLeft(This1 val) 
method 
This0 withoutRight(This1 val) 
method 
This0 withoutAll(This1 val) 
mut method /*from VectorTrait
*/Void remove(This3.Size that) 
mut method 
Void removeAll(This1 val) 
mut method 
Void removeLeft(This1 val) 
mut method 
Void removeRight(This1 val) 
Cast: {
class method 
This2 #apply(Any that) }
IteratorTrait: {
class method 
Library #apply() }
IteratorValFill: {
mut method 
Void #next() exception Void 
read method 
Void #checkEnd() 
read method 
This2 #inner() 
read method 
Void #close() 
read method 
read This4.Collections.MutListAny _that() 
mut method 
Void from(This4.Size that) 
read method 
This4.Size from() 
read method 
This4.Size maxTo() 
read method 
This4.Size minTo() 
read method 
This2 filled() 
read method 
read This4.Collections.MutListAny that() 
class method 
lent This0 #apply(read This4.Collections.MutListAny _that, This4.Size from, This4.Size maxTo, This4.Size minTo, This2 filled) 
class method 
lent This0 #apply(read This4.Collections.MutListAny that, This4.Size from, This4.Size maxTo, This4.Size minTo, This2 filled) 
read method 
This4.Bool isFill() }
IteratorVar: {
mut method 
Void #next() exception Void 
read method 
Void #checkEnd() 
read method 
This2 #inner() 
read method 
Void #close() 
read method 
read This4.Collections.MutListAny that() 
mut method 
mut This4.Collections.MutListAny #that() 
mut method 
Void from(This4.Size that) 
read method 
This4.Size from() 
read method 
This4.Size maxTo() 
read method 
This4.Size minTo() 
class method 
mut This0 #apply(mut This4.Collections.MutListAny that, This4.Size from, This4.Size maxTo, This4.Size minTo) 
mut method 
Void inner(This2 that) 
read method 
This4.Bool isFill() 
read method 
This2 filled() }
IteratorVal: {
read method 
read This4.Collections.MutListAny _that() 
mut method 
Void from(This4.Size that) 
read method 
This4.Size from() 
read method 
This4.Size maxTo() 
read method 
This4.Size minTo() 
read method 
read This4.Collections.MutListAny that() 
class method 
lent This0 #apply(read This4.Collections.MutListAny _that, This4.Size from, This4.Size maxTo, This4.Size minTo) 
class method 
lent This0 #apply(read This4.Collections.MutListAny that, This4.Size from, This4.Size maxTo, This4.Size minTo) 
read method 
This4.Bool isFill() 
read method 
This2 filled() 
mut method 
Void #next() exception Void 
read method 
Void #checkEnd() 
read method 
This2 #inner() 
read method 
Void #close() }}}
Method: {/*@plugin  toFix 
@pluginPart is.L42.connected.withSafeOperators.location.Method
*/implements This1, This2.Concept.Base, This2.Concept.ToS, This2.Concept.Classable, This2.Concept.Equals
class method 
mut This0 #from(Library binaryRepr) 
read method 
Library #binaryRepr() 
class method 
Void #exceptionIf(Library binaryRepr) exception This0 
class method 
Library #pluginUnresponsive(Library binaryRepr) 
read method 
This2.Bool equals(read This0 that) 
method 
This1.Origin.List origins() 
refine method 
This2.Size originSize() 
refine method 
This1.Origin origin(This2.Size that) 
refine method 
This1.Doc doc() 
refine method 
This1.Lib location() 
method 
This2.Bool isAbstract() 
method 
This2.Bool isRefine() 
method 
This2.Selector selector() 
method 
This1.Type.Return returnType() 
method 
This2.Size parameterTypeSize() 
method 
This1.Type.Parameter parameterType(This2.Size that) 
method 
This1.Type.Parameter.List parameterTypes() 
method 
This2.Size exceptionTypeSize() 
method 
This1.Type.Exception exceptionType(This2.Size that) 
method 
This1.Type.Exception.List exceptionTypes() 
refine read method 
This2.S toS() 
refine class method /*
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  */This2.S readableName() 
refine class method /*
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  */This2.Bool is(class This2.Concept.Classable subtype) 
refine read method 
This2.Bool #equalequal#0left(read Any right) 
refine class method 
read This0 cast(read This2.Concept.Classable that) 
refine class method 
mut This0 #cast(mut This2.Concept.Classable that) 
refine read method 
class This0 class() 
List: {implements This3.Concept.ToS, This3.Concept.Classable, This3.Concept.Equals
refine class method /*
  Cast a (read/imm) object to this type.
  A class implementing this method should refine the return type to This.
  if is(subtype) is true, then cast(that) must produce a result.
  */read This0 cast(read This3.Concept.Classable that) 
refine class method /*
  Cast a (mutable) object to this type.
  A class implementing this method should refine the return type to This.
  if cast(that) produces a result, then #cast(that) also must produce a result.
  */mut This0 #cast(mut This3.Concept.Classable that) 
refine read method /*
  Extracts the class singleton from another instance of this class
  */class This0 class() 
refine class method /*
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  */This3.S readableName() 
refine class method /*
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  */This3.Bool is(class This3.Concept.Classable subtype) 
read method 
read This3.Collections.MutListAny inner() 
mut method 
mut This3.Collections.MutListAny #inner() 
class method 
mut This0 #apply(fwd mut This3.Collections.MutListAny inner) 
class method 
This0 #immK(This3.Collections.MutListAny inner) 
class method 
mut This0 empty() 
read method 
mut This0 reverse() 
read method 
This3.Bool isEmpty() 
read method 
class This3.Size #default#val(Void that) 
read method 
This1 left() 
read method 
This1 right() 
mut method 
Void #apply(This3.Size that, This1 val) 
mut method 
Void left(This1 that) 
mut method 
Void right(This1 that) 
mut method 
Void add(This3.Size that, This1 val) 
mut method 
Void add(This1 right) 
mut method 
Void add(This1 left) 
mut method 
Void removeLeft() 
mut method 
Void removeRight() 
method 
This0 #plus#0left(This1 right) 
method 
This0 #plusplus#0left(This0 right) 
method 
This0 with(This3.Size that, This1 val) 
method 
This0 withLeft(This1 that) 
method 
This0 withRight(This1 that) 
method 
This0 withAlso(This3.Size that, This1 val) 
method 
This0 withAlsoLeft(This1 that) 
method 
This0 withAlsoRight(This1 that) 
method 
This0 withoutLeft() 
method 
This0 withoutRight() 
read method 
lent This0.IteratorVal vals(This3.Size from, This3.Size maxTo, This3.Size minTo) 
read method 
lent This0.IteratorVal vals(This3.Size minTo) 
read method 
lent This0.IteratorVal vals(This3.Size from, This3.Size to) 
read method 
lent This0.IteratorValFill vals(This3.Size from, This3.Size maxTo, This3.Size minTo, This1 filled) 
read method 
lent This0.IteratorValFill vals(This3.Size minTo, This1 filled) 
read method 
lent This0.IteratorValFill vals(This3.Size from, This3.Size to, This1 filled) 
read method 
lent This0.IteratorValFill vals(This1 filled) 
mut method 
lent This0.IteratorVar #vals(This3.Size from, This3.Size maxTo, This3.Size minTo) 
mut method 
lent This0.IteratorVar #vals(This3.Size minTo) 
mut method 
lent This0.IteratorVar #vals(This3.Size from, This3.Size to) 
mut method 
lent This0.IteratorVar #vals() 
refine read method 
This3.S toS() 
read method 
This3.Size size() 
read method 
This1 val(This3.Size that) 
class method 
mut This0 #seqBuilder() 
class method 
mut This0 #from(mut This0 seqBuilder) 
mut method 
Void #add(This1 that) 
read method 
lent This0.IteratorVal vals() 
read method 
This3.Bool contains(This1 that) 
method 
This0 #less#0left(This1 right) 
method 
This0 #lessless#0left(This0 right) 
method 
This0 #and#0left(This0 right) 
method 
This3.Bool #rightright#0left(This0 right) 
method 
This3.Bool #rightrightequal#0left(This0 right) 
method 
This3.Bool #right#0left(This1 right) 
read method 
This3.Bool equals(read This0 that) 
refine read method 
This3.Bool #equalequal#0left(read Any right) 
read method 
This3.Size indexOfLeft(This1 val) 
read method 
This3.Size indexOfRight(This1 val) 
method /*from VectorTrait
*/This0 without(This3.Size index) 
method 
This0 withoutLeft(This1 val) 
method 
This0 withoutRight(This1 val) 
method 
This0 withoutAll(This1 val) 
mut method /*from VectorTrait
*/Void remove(This3.Size that) 
mut method 
Void removeAll(This1 val) 
mut method 
Void removeLeft(This1 val) 
mut method 
Void removeRight(This1 val) 
Cast: {
class method 
This2 #apply(Any that) }
IteratorTrait: {
class method 
Library #apply() }
IteratorValFill: {
mut method 
Void #next() exception Void 
read method 
Void #checkEnd() 
read method 
This2 #inner() 
read method 
Void #close() 
read method 
read This4.Collections.MutListAny _that() 
mut method 
Void from(This4.Size that) 
read method 
This4.Size from() 
read method 
This4.Size maxTo() 
read method 
This4.Size minTo() 
read method 
This2 filled() 
read method 
read This4.Collections.MutListAny that() 
class method 
lent This0 #apply(read This4.Collections.MutListAny _that, This4.Size from, This4.Size maxTo, This4.Size minTo, This2 filled) 
class method 
lent This0 #apply(read This4.Collections.MutListAny that, This4.Size from, This4.Size maxTo, This4.Size minTo, This2 filled) 
read method 
This4.Bool isFill() }
IteratorVar: {
mut method 
Void #next() exception Void 
read method 
Void #checkEnd() 
read method 
This2 #inner() 
read method 
Void #close() 
read method 
read This4.Collections.MutListAny that() 
mut method 
mut This4.Collections.MutListAny #that() 
mut method 
Void from(This4.Size that) 
read method 
This4.Size from() 
read method 
This4.Size maxTo() 
read method 
This4.Size minTo() 
class method 
mut This0 #apply(mut This4.Collections.MutListAny that, This4.Size from, This4.Size maxTo, This4.Size minTo) 
mut method 
Void inner(This2 that) 
read method 
This4.Bool isFill() 
read method 
This2 filled() }
IteratorVal: {
read method 
read This4.Collections.MutListAny _that() 
mut method 
Void from(This4.Size that) 
read method 
This4.Size from() 
read method 
This4.Size maxTo() 
read method 
This4.Size minTo() 
read method 
read This4.Collections.MutListAny that() 
class method 
lent This0 #apply(read This4.Collections.MutListAny _that, This4.Size from, This4.Size maxTo, This4.Size minTo) 
class method 
lent This0 #apply(read This4.Collections.MutListAny that, This4.Size from, This4.Size maxTo, This4.Size minTo) 
read method 
This4.Bool isFill() 
read method 
This2 filled() 
mut method 
Void #next() exception Void 
read method 
Void #checkEnd() 
read method 
This2 #inner() 
read method 
Void #close() }}}
Type: {interface implements This1, This2.Concept.Base, This2.Concept.ToS, This2.Concept.Classable, This2.Concept.Equals
refine read method 
This2.S toS() 
refine class method /*
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  */This2.S readableName() 
refine class method /*
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  */This2.Bool is(class This2.Concept.Classable subtype) 
refine read method 
This2.Bool #equalequal#0left(read Any right) 
refine read method 
class This2.Concept.Base class() 
refine class method 
read This2.Concept.Base cast(read This2.Concept.Classable that) 
refine class method 
mut This2.Concept.Base #cast(mut This2.Concept.Classable that) 
refine method 
This2.Size originSize() 
refine method 
This1.Origin origin(This2.Size that) 
refine method 
This1 location() 
refine method 
This1.Doc doc() 
method 
This0.RefTo refTo() 
method 
This2.Size mdfS() 
method 
This1.Mdf mdf() 
DispatchRefTo: {
class method 
This1.RefTo #apply(Library that) }
Return: {/*@plugin  toFix 
@pluginPart is.L42.connected.withSafeOperators.location.Type$Return
*/implements This1, This2, This3.Concept.Base, This3.Concept.ToS, This3.Concept.Classable, This3.Concept.Equals
class method 
mut This0 #from(Library binaryRepr) 
read method 
Library #binaryRepr() 
class method 
Void #exceptionIf(Library binaryRepr) exception This0 
class method 
Library #pluginUnresponsive(Library binaryRepr) 
read method 
This3.Bool equals(read This0 that) 
method 
This2.Origin.List origins() 
refine method 
This3.Size originSize() 
refine method 
This2.Origin origin(This3.Size that) 
refine method 
This2.Doc doc() 
refine method 
This3.Size mdfS() 
refine method 
This2.Method location() 
refine method 
This1.RefTo refTo() 
refine method 
This2.Mdf mdf() 
refine read method 
This3.S toS() 
refine class method /*
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  */This3.S readableName() 
refine class method /*
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  */This3.Bool is(class This3.Concept.Classable subtype) 
refine read method 
This3.Bool #equalequal#0left(read Any right) 
refine class method 
read This0 cast(read This3.Concept.Classable that) 
refine class method 
mut This0 #cast(mut This3.Concept.Classable that) 
refine read method 
class This0 class() }
Parameter: {/*@plugin  toFix 
@pluginPart is.L42.connected.withSafeOperators.location.Type$Parameter     
*/implements This1, This2, This3.Concept.Base, This3.Concept.ToS, This3.Concept.Classable, This3.Concept.Equals
class method 
mut This0 #from(Library binaryRepr) 
read method 
Library #binaryRepr() 
class method 
Void #exceptionIf(Library binaryRepr) exception This0 
class method 
Library #pluginUnresponsive(Library binaryRepr) 
read method 
This3.Bool equals(read This0 that) 
method 
This2.Origin.List origins() 
refine method 
This3.Size originSize() 
refine method 
This2.Origin origin(This3.Size that) 
refine method 
This2.Doc doc() 
refine method 
This3.Size mdfS() 
refine method 
This2.Method location() 
refine method 
This1.RefTo refTo() 
refine method 
This2.Mdf mdf() 
method 
This3.Size pos() 
refine read method 
This3.S toS() 
refine class method /*
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  */This3.S readableName() 
refine class method /*
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  */This3.Bool is(class This3.Concept.Classable subtype) 
refine read method 
This3.Bool #equalequal#0left(read Any right) 
refine class method 
read This0 cast(read This3.Concept.Classable that) 
refine class method 
mut This0 #cast(mut This3.Concept.Classable that) 
refine read method 
class This0 class() 
List: {implements This4.Concept.ToS, This4.Concept.Classable, This4.Concept.Equals
refine class method /*
  Cast a (read/imm) object to this type.
  A class implementing this method should refine the return type to This.
  if is(subtype) is true, then cast(that) must produce a result.
  */read This0 cast(read This4.Concept.Classable that) 
refine class method /*
  Cast a (mutable) object to this type.
  A class implementing this method should refine the return type to This.
  if cast(that) produces a result, then #cast(that) also must produce a result.
  */mut This0 #cast(mut This4.Concept.Classable that) 
refine read method /*
  Extracts the class singleton from another instance of this class
  */class This0 class() 
refine class method /*
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  */This4.S readableName() 
refine class method /*
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  */This4.Bool is(class This4.Concept.Classable subtype) 
read method 
read This4.Collections.MutListAny inner() 
mut method 
mut This4.Collections.MutListAny #inner() 
class method 
mut This0 #apply(fwd mut This4.Collections.MutListAny inner) 
class method 
This0 #immK(This4.Collections.MutListAny inner) 
class method 
mut This0 empty() 
read method 
mut This0 reverse() 
read method 
This4.Bool isEmpty() 
read method 
class This4.Size #default#val(Void that) 
read method 
This1 left() 
read method 
This1 right() 
mut method 
Void #apply(This4.Size that, This1 val) 
mut method 
Void left(This1 that) 
mut method 
Void right(This1 that) 
mut method 
Void add(This4.Size that, This1 val) 
mut method 
Void add(This1 right) 
mut method 
Void add(This1 left) 
mut method 
Void removeLeft() 
mut method 
Void removeRight() 
method 
This0 #plus#0left(This1 right) 
method 
This0 #plusplus#0left(This0 right) 
method 
This0 with(This4.Size that, This1 val) 
method 
This0 withLeft(This1 that) 
method 
This0 withRight(This1 that) 
method 
This0 withAlso(This4.Size that, This1 val) 
method 
This0 withAlsoLeft(This1 that) 
method 
This0 withAlsoRight(This1 that) 
method 
This0 withoutLeft() 
method 
This0 withoutRight() 
read method 
lent This0.IteratorVal vals(This4.Size from, This4.Size maxTo, This4.Size minTo) 
read method 
lent This0.IteratorVal vals(This4.Size minTo) 
read method 
lent This0.IteratorVal vals(This4.Size from, This4.Size to) 
read method 
lent This0.IteratorValFill vals(This4.Size from, This4.Size maxTo, This4.Size minTo, This1 filled) 
read method 
lent This0.IteratorValFill vals(This4.Size minTo, This1 filled) 
read method 
lent This0.IteratorValFill vals(This4.Size from, This4.Size to, This1 filled) 
read method 
lent This0.IteratorValFill vals(This1 filled) 
mut method 
lent This0.IteratorVar #vals(This4.Size from, This4.Size maxTo, This4.Size minTo) 
mut method 
lent This0.IteratorVar #vals(This4.Size minTo) 
mut method 
lent This0.IteratorVar #vals(This4.Size from, This4.Size to) 
mut method 
lent This0.IteratorVar #vals() 
refine read method 
This4.S toS() 
read method 
This4.Size size() 
read method 
This1 val(This4.Size that) 
class method 
mut This0 #seqBuilder() 
class method 
mut This0 #from(mut This0 seqBuilder) 
mut method 
Void #add(This1 that) 
read method 
lent This0.IteratorVal vals() 
read method 
This4.Bool contains(This1 that) 
method 
This0 #less#0left(This1 right) 
method 
This0 #lessless#0left(This0 right) 
method 
This0 #and#0left(This0 right) 
method 
This4.Bool #rightright#0left(This0 right) 
method 
This4.Bool #rightrightequal#0left(This0 right) 
method 
This4.Bool #right#0left(This1 right) 
read method 
This4.Bool equals(read This0 that) 
refine read method 
This4.Bool #equalequal#0left(read Any right) 
read method 
This4.Size indexOfLeft(This1 val) 
read method 
This4.Size indexOfRight(This1 val) 
method /*from VectorTrait
*/This0 without(This4.Size index) 
method 
This0 withoutLeft(This1 val) 
method 
This0 withoutRight(This1 val) 
method 
This0 withoutAll(This1 val) 
mut method /*from VectorTrait
*/Void remove(This4.Size that) 
mut method 
Void removeAll(This1 val) 
mut method 
Void removeLeft(This1 val) 
mut method 
Void removeRight(This1 val) 
Cast: {
class method 
This2 #apply(Any that) }
IteratorTrait: {
class method 
Library #apply() }
IteratorValFill: {
mut method 
Void #next() exception Void 
read method 
Void #checkEnd() 
read method 
This2 #inner() 
read method 
Void #close() 
read method 
read This5.Collections.MutListAny _that() 
mut method 
Void from(This5.Size that) 
read method 
This5.Size from() 
read method 
This5.Size maxTo() 
read method 
This5.Size minTo() 
read method 
This2 filled() 
read method 
read This5.Collections.MutListAny that() 
class method 
lent This0 #apply(read This5.Collections.MutListAny _that, This5.Size from, This5.Size maxTo, This5.Size minTo, This2 filled) 
class method 
lent This0 #apply(read This5.Collections.MutListAny that, This5.Size from, This5.Size maxTo, This5.Size minTo, This2 filled) 
read method 
This5.Bool isFill() }
IteratorVar: {
mut method 
Void #next() exception Void 
read method 
Void #checkEnd() 
read method 
This2 #inner() 
read method 
Void #close() 
read method 
read This5.Collections.MutListAny that() 
mut method 
mut This5.Collections.MutListAny #that() 
mut method 
Void from(This5.Size that) 
read method 
This5.Size from() 
read method 
This5.Size maxTo() 
read method 
This5.Size minTo() 
class method 
mut This0 #apply(mut This5.Collections.MutListAny that, This5.Size from, This5.Size maxTo, This5.Size minTo) 
mut method 
Void inner(This2 that) 
read method 
This5.Bool isFill() 
read method 
This2 filled() }
IteratorVal: {
read method 
read This5.Collections.MutListAny _that() 
mut method 
Void from(This5.Size that) 
read method 
This5.Size from() 
read method 
This5.Size maxTo() 
read method 
This5.Size minTo() 
read method 
read This5.Collections.MutListAny that() 
class method 
lent This0 #apply(read This5.Collections.MutListAny _that, This5.Size from, This5.Size maxTo, This5.Size minTo) 
class method 
lent This0 #apply(read This5.Collections.MutListAny that, This5.Size from, This5.Size maxTo, This5.Size minTo) 
read method 
This5.Bool isFill() 
read method 
This2 filled() 
mut method 
Void #next() exception Void 
read method 
Void #checkEnd() 
read method 
This2 #inner() 
read method 
Void #close() }}}
Exception: {/*@plugin  toFix 
@pluginPart is.L42.connected.withSafeOperators.location.Type$Exception
*/implements This1, This2, This3.Concept.Base, This3.Concept.ToS, This3.Concept.Classable, This3.Concept.Equals
class method 
mut This0 #from(Library binaryRepr) 
read method 
Library #binaryRepr() 
class method 
Void #exceptionIf(Library binaryRepr) exception This0 
class method 
Library #pluginUnresponsive(Library binaryRepr) 
read method 
This3.Bool equals(read This0 that) 
method 
This2.Origin.List origins() 
refine method 
This3.Size originSize() 
refine method 
This2.Origin origin(This3.Size that) 
refine method 
This2.Doc doc() 
refine method 
This3.Size mdfS() 
refine method 
This2.Method location() 
refine method 
This1.RefTo refTo() 
refine method 
This2.Mdf mdf() 
method 
This3.Size pos() 
refine read method 
This3.S toS() 
refine class method /*
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  */This3.S readableName() 
refine class method /*
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  */This3.Bool is(class This3.Concept.Classable subtype) 
refine read method 
This3.Bool #equalequal#0left(read Any right) 
refine class method 
read This0 cast(read This3.Concept.Classable that) 
refine class method 
mut This0 #cast(mut This3.Concept.Classable that) 
refine read method 
class This0 class() 
List: {implements This4.Concept.ToS, This4.Concept.Classable, This4.Concept.Equals
refine class method /*
  Cast a (read/imm) object to this type.
  A class implementing this method should refine the return type to This.
  if is(subtype) is true, then cast(that) must produce a result.
  */read This0 cast(read This4.Concept.Classable that) 
refine class method /*
  Cast a (mutable) object to this type.
  A class implementing this method should refine the return type to This.
  if cast(that) produces a result, then #cast(that) also must produce a result.
  */mut This0 #cast(mut This4.Concept.Classable that) 
refine read method /*
  Extracts the class singleton from another instance of this class
  */class This0 class() 
refine class method /*
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  */This4.S readableName() 
refine class method /*
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  */This4.Bool is(class This4.Concept.Classable subtype) 
read method 
read This4.Collections.MutListAny inner() 
mut method 
mut This4.Collections.MutListAny #inner() 
class method 
mut This0 #apply(fwd mut This4.Collections.MutListAny inner) 
class method 
This0 #immK(This4.Collections.MutListAny inner) 
class method 
mut This0 empty() 
read method 
mut This0 reverse() 
read method 
This4.Bool isEmpty() 
read method 
class This4.Size #default#val(Void that) 
read method 
This1 left() 
read method 
This1 right() 
mut method 
Void #apply(This4.Size that, This1 val) 
mut method 
Void left(This1 that) 
mut method 
Void right(This1 that) 
mut method 
Void add(This4.Size that, This1 val) 
mut method 
Void add(This1 right) 
mut method 
Void add(This1 left) 
mut method 
Void removeLeft() 
mut method 
Void removeRight() 
method 
This0 #plus#0left(This1 right) 
method 
This0 #plusplus#0left(This0 right) 
method 
This0 with(This4.Size that, This1 val) 
method 
This0 withLeft(This1 that) 
method 
This0 withRight(This1 that) 
method 
This0 withAlso(This4.Size that, This1 val) 
method 
This0 withAlsoLeft(This1 that) 
method 
This0 withAlsoRight(This1 that) 
method 
This0 withoutLeft() 
method 
This0 withoutRight() 
read method 
lent This0.IteratorVal vals(This4.Size from, This4.Size maxTo, This4.Size minTo) 
read method 
lent This0.IteratorVal vals(This4.Size minTo) 
read method 
lent This0.IteratorVal vals(This4.Size from, This4.Size to) 
read method 
lent This0.IteratorValFill vals(This4.Size from, This4.Size maxTo, This4.Size minTo, This1 filled) 
read method 
lent This0.IteratorValFill vals(This4.Size minTo, This1 filled) 
read method 
lent This0.IteratorValFill vals(This4.Size from, This4.Size to, This1 filled) 
read method 
lent This0.IteratorValFill vals(This1 filled) 
mut method 
lent This0.IteratorVar #vals(This4.Size from, This4.Size maxTo, This4.Size minTo) 
mut method 
lent This0.IteratorVar #vals(This4.Size minTo) 
mut method 
lent This0.IteratorVar #vals(This4.Size from, This4.Size to) 
mut method 
lent This0.IteratorVar #vals() 
refine read method 
This4.S toS() 
read method 
This4.Size size() 
read method 
This1 val(This4.Size that) 
class method 
mut This0 #seqBuilder() 
class method 
mut This0 #from(mut This0 seqBuilder) 
mut method 
Void #add(This1 that) 
read method 
lent This0.IteratorVal vals() 
read method 
This4.Bool contains(This1 that) 
method 
This0 #less#0left(This1 right) 
method 
This0 #lessless#0left(This0 right) 
method 
This0 #and#0left(This0 right) 
method 
This4.Bool #rightright#0left(This0 right) 
method 
This4.Bool #rightrightequal#0left(This0 right) 
method 
This4.Bool #right#0left(This1 right) 
read method 
This4.Bool equals(read This0 that) 
refine read method 
This4.Bool #equalequal#0left(read Any right) 
read method 
This4.Size indexOfLeft(This1 val) 
read method 
This4.Size indexOfRight(This1 val) 
method /*from VectorTrait
*/This0 without(This4.Size index) 
method 
This0 withoutLeft(This1 val) 
method 
This0 withoutRight(This1 val) 
method 
This0 withoutAll(This1 val) 
mut method /*from VectorTrait
*/Void remove(This4.Size that) 
mut method 
Void removeAll(This1 val) 
mut method 
Void removeLeft(This1 val) 
mut method 
Void removeRight(This1 val) 
Cast: {
class method 
This2 #apply(Any that) }
IteratorTrait: {
class method 
Library #apply() }
IteratorValFill: {
mut method 
Void #next() exception Void 
read method 
Void #checkEnd() 
read method 
This2 #inner() 
read method 
Void #close() 
read method 
read This5.Collections.MutListAny _that() 
mut method 
Void from(This5.Size that) 
read method 
This5.Size from() 
read method 
This5.Size maxTo() 
read method 
This5.Size minTo() 
read method 
This2 filled() 
read method 
read This5.Collections.MutListAny that() 
class method 
lent This0 #apply(read This5.Collections.MutListAny _that, This5.Size from, This5.Size maxTo, This5.Size minTo, This2 filled) 
class method 
lent This0 #apply(read This5.Collections.MutListAny that, This5.Size from, This5.Size maxTo, This5.Size minTo, This2 filled) 
read method 
This5.Bool isFill() }
IteratorVar: {
mut method 
Void #next() exception Void 
read method 
Void #checkEnd() 
read method 
This2 #inner() 
read method 
Void #close() 
read method 
read This5.Collections.MutListAny that() 
mut method 
mut This5.Collections.MutListAny #that() 
mut method 
Void from(This5.Size that) 
read method 
This5.Size from() 
read method 
This5.Size maxTo() 
read method 
This5.Size minTo() 
class method 
mut This0 #apply(mut This5.Collections.MutListAny that, This5.Size from, This5.Size maxTo, This5.Size minTo) 
mut method 
Void inner(This2 that) 
read method 
This5.Bool isFill() 
read method 
This2 filled() }
IteratorVal: {
read method 
read This5.Collections.MutListAny _that() 
mut method 
Void from(This5.Size that) 
read method 
This5.Size from() 
read method 
This5.Size maxTo() 
read method 
This5.Size minTo() 
read method 
read This5.Collections.MutListAny that() 
class method 
lent This0 #apply(read This5.Collections.MutListAny _that, This5.Size from, This5.Size maxTo, This5.Size minTo) 
class method 
lent This0 #apply(read This5.Collections.MutListAny that, This5.Size from, This5.Size maxTo, This5.Size minTo) 
read method 
This5.Bool isFill() 
read method 
This2 filled() 
mut method 
Void #next() exception Void 
read method 
Void #checkEnd() 
read method 
This2 #inner() 
read method 
Void #close() }}}
Implemented: {/*@plugin  toFix 
@pluginPart is.L42.connected.withSafeOperators.location.Type$Implemented
*/implements This1, This2, This3.Concept.Base, This3.Concept.ToS, This3.Concept.Classable, This3.Concept.Equals
class method 
mut This0 #from(Library binaryRepr) 
read method 
Library #binaryRepr() 
class method 
Void #exceptionIf(Library binaryRepr) exception This0 
class method 
Library #pluginUnresponsive(Library binaryRepr) 
read method 
This3.Bool equals(read This0 that) 
method 
This2.Origin.List origins() 
refine method 
This3.Size originSize() 
refine method 
This2.Origin origin(This3.Size that) 
refine method 
This2.Doc doc() 
refine method 
This3.Size mdfS() 
refine method 
This2.Lib location() 
refine method 
This1.RefTo refTo() 
refine method 
This2.Mdf mdf() 
method 
This3.Size pos() 
refine read method 
This3.S toS() 
refine class method /*
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  */This3.S readableName() 
refine class method /*
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  */This3.Bool is(class This3.Concept.Classable subtype) 
refine read method 
This3.Bool #equalequal#0left(read Any right) 
refine class method 
read This0 cast(read This3.Concept.Classable that) 
refine class method 
mut This0 #cast(mut This3.Concept.Classable that) 
refine read method 
class This0 class() 
List: {implements This4.Concept.ToS, This4.Concept.Classable, This4.Concept.Equals
refine class method /*
  Cast a (read/imm) object to this type.
  A class implementing this method should refine the return type to This.
  if is(subtype) is true, then cast(that) must produce a result.
  */read This0 cast(read This4.Concept.Classable that) 
refine class method /*
  Cast a (mutable) object to this type.
  A class implementing this method should refine the return type to This.
  if cast(that) produces a result, then #cast(that) also must produce a result.
  */mut This0 #cast(mut This4.Concept.Classable that) 
refine read method /*
  Extracts the class singleton from another instance of this class
  */class This0 class() 
refine class method /*
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  */This4.S readableName() 
refine class method /*
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  */This4.Bool is(class This4.Concept.Classable subtype) 
read method 
read This4.Collections.MutListAny inner() 
mut method 
mut This4.Collections.MutListAny #inner() 
class method 
mut This0 #apply(fwd mut This4.Collections.MutListAny inner) 
class method 
This0 #immK(This4.Collections.MutListAny inner) 
class method 
mut This0 empty() 
read method 
mut This0 reverse() 
read method 
This4.Bool isEmpty() 
read method 
class This4.Size #default#val(Void that) 
read method 
This1 left() 
read method 
This1 right() 
mut method 
Void #apply(This4.Size that, This1 val) 
mut method 
Void left(This1 that) 
mut method 
Void right(This1 that) 
mut method 
Void add(This4.Size that, This1 val) 
mut method 
Void add(This1 right) 
mut method 
Void add(This1 left) 
mut method 
Void removeLeft() 
mut method 
Void removeRight() 
method 
This0 #plus#0left(This1 right) 
method 
This0 #plusplus#0left(This0 right) 
method 
This0 with(This4.Size that, This1 val) 
method 
This0 withLeft(This1 that) 
method 
This0 withRight(This1 that) 
method 
This0 withAlso(This4.Size that, This1 val) 
method 
This0 withAlsoLeft(This1 that) 
method 
This0 withAlsoRight(This1 that) 
method 
This0 withoutLeft() 
method 
This0 withoutRight() 
read method 
lent This0.IteratorVal vals(This4.Size from, This4.Size maxTo, This4.Size minTo) 
read method 
lent This0.IteratorVal vals(This4.Size minTo) 
read method 
lent This0.IteratorVal vals(This4.Size from, This4.Size to) 
read method 
lent This0.IteratorValFill vals(This4.Size from, This4.Size maxTo, This4.Size minTo, This1 filled) 
read method 
lent This0.IteratorValFill vals(This4.Size minTo, This1 filled) 
read method 
lent This0.IteratorValFill vals(This4.Size from, This4.Size to, This1 filled) 
read method 
lent This0.IteratorValFill vals(This1 filled) 
mut method 
lent This0.IteratorVar #vals(This4.Size from, This4.Size maxTo, This4.Size minTo) 
mut method 
lent This0.IteratorVar #vals(This4.Size minTo) 
mut method 
lent This0.IteratorVar #vals(This4.Size from, This4.Size to) 
mut method 
lent This0.IteratorVar #vals() 
refine read method 
This4.S toS() 
read method 
This4.Size size() 
read method 
This1 val(This4.Size that) 
class method 
mut This0 #seqBuilder() 
class method 
mut This0 #from(mut This0 seqBuilder) 
mut method 
Void #add(This1 that) 
read method 
lent This0.IteratorVal vals() 
read method 
This4.Bool contains(This1 that) 
method 
This0 #less#0left(This1 right) 
method 
This0 #lessless#0left(This0 right) 
method 
This0 #and#0left(This0 right) 
method 
This4.Bool #rightright#0left(This0 right) 
method 
This4.Bool #rightrightequal#0left(This0 right) 
method 
This4.Bool #right#0left(This1 right) 
read method 
This4.Bool equals(read This0 that) 
refine read method 
This4.Bool #equalequal#0left(read Any right) 
read method 
This4.Size indexOfLeft(This1 val) 
read method 
This4.Size indexOfRight(This1 val) 
method /*from VectorTrait
*/This0 without(This4.Size index) 
method 
This0 withoutLeft(This1 val) 
method 
This0 withoutRight(This1 val) 
method 
This0 withoutAll(This1 val) 
mut method /*from VectorTrait
*/Void remove(This4.Size that) 
mut method 
Void removeAll(This1 val) 
mut method 
Void removeLeft(This1 val) 
mut method 
Void removeRight(This1 val) 
Cast: {
class method 
This2 #apply(Any that) }
IteratorTrait: {
class method 
Library #apply() }
IteratorValFill: {
mut method 
Void #next() exception Void 
read method 
Void #checkEnd() 
read method 
This2 #inner() 
read method 
Void #close() 
read method 
read This5.Collections.MutListAny _that() 
mut method 
Void from(This5.Size that) 
read method 
This5.Size from() 
read method 
This5.Size maxTo() 
read method 
This5.Size minTo() 
read method 
This2 filled() 
read method 
read This5.Collections.MutListAny that() 
class method 
lent This0 #apply(read This5.Collections.MutListAny _that, This5.Size from, This5.Size maxTo, This5.Size minTo, This2 filled) 
class method 
lent This0 #apply(read This5.Collections.MutListAny that, This5.Size from, This5.Size maxTo, This5.Size minTo, This2 filled) 
read method 
This5.Bool isFill() }
IteratorVar: {
mut method 
Void #next() exception Void 
read method 
Void #checkEnd() 
read method 
This2 #inner() 
read method 
Void #close() 
read method 
read This5.Collections.MutListAny that() 
mut method 
mut This5.Collections.MutListAny #that() 
mut method 
Void from(This5.Size that) 
read method 
This5.Size from() 
read method 
This5.Size maxTo() 
read method 
This5.Size minTo() 
class method 
mut This0 #apply(mut This5.Collections.MutListAny that, This5.Size from, This5.Size maxTo, This5.Size minTo) 
mut method 
Void inner(This2 that) 
read method 
This5.Bool isFill() 
read method 
This2 filled() }
IteratorVal: {
read method 
read This5.Collections.MutListAny _that() 
mut method 
Void from(This5.Size that) 
read method 
This5.Size from() 
read method 
This5.Size maxTo() 
read method 
This5.Size minTo() 
read method 
read This5.Collections.MutListAny that() 
class method 
lent This0 #apply(read This5.Collections.MutListAny _that, This5.Size from, This5.Size maxTo, This5.Size minTo) 
class method 
lent This0 #apply(read This5.Collections.MutListAny that, This5.Size from, This5.Size maxTo, This5.Size minTo) 
read method 
This5.Bool isFill() 
read method 
This2 filled() 
mut method 
Void #next() exception Void 
read method 
Void #checkEnd() 
read method 
This2 #inner() 
read method 
Void #close() }}}
RefTo: {interface implements This3.Concept.Base, This3.Concept.ToS, This3.Concept.Classable, This3.Concept.Equals
refine read method 
This3.S toS() 
refine class method /*
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  */This3.S readableName() 
refine class method /*
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  */This3.Bool is(class This3.Concept.Classable subtype) 
refine read method 
This3.Bool #equalequal#0left(read Any right) 
refine read method 
class This3.Concept.Base class() 
refine class method 
read This3.Concept.Base cast(read This3.Concept.Classable that) 
refine class method 
mut This3.Concept.Base #cast(mut This3.Concept.Classable that) 
Lib: {/*@plugin  toFix 
@pluginPart is.L42.connected.withSafeOperators.location.TypeRefTo$Lib
*/implements This4.Concept.Base, This4.Concept.ToS, This4.Concept.Classable, This4.Concept.Equals, This1
class method 
mut This0 #from(Library binaryRepr) 
read method 
Library #binaryRepr() 
class method 
Void #exceptionIf(Library binaryRepr) exception This0 
class method 
Library #pluginUnresponsive(Library binaryRepr) 
read method 
This4.Bool equals(read This0 that) 
method 
This3.Lib referredLib() 
refine read method 
This4.S toS() 
refine class method /*
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  */This4.S readableName() 
refine class method /*
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  */This4.Bool is(class This4.Concept.Classable subtype) 
refine read method 
This4.Bool #equalequal#0left(read Any right) 
refine class method 
read This0 cast(read This4.Concept.Classable that) 
refine class method 
mut This0 #cast(mut This4.Concept.Classable that) 
refine read method 
class This0 class() }
Unavailable: {/*@plugin  toFix 
@pluginPart is.L42.connected.withSafeOperators.location.TypeRefTo$Unavailable
*/implements This4.Concept.Base, This4.Concept.ToS, This4.Concept.Classable, This4.Concept.Equals, This1
class method 
mut This0 #from(Library binaryRepr) 
read method 
Library #binaryRepr() 
class method 
Void #exceptionIf(Library binaryRepr) exception This0 
class method 
Library #pluginUnresponsive(Library binaryRepr) 
read method 
This4.Bool equals(read This0 that) 
refine read method 
This4.S toS() 
refine class method /*
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  */This4.S readableName() 
refine class method /*
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  */This4.Bool is(class This4.Concept.Classable subtype) 
refine read method 
This4.Bool #equalequal#0left(read Any right) 
refine class method 
read This0 cast(read This4.Concept.Classable that) 
refine class method 
mut This0 #cast(mut This4.Concept.Classable that) 
refine read method 
class This0 class() }
Binded: {/*@plugin  toFix 
@pluginPart is.L42.connected.withSafeOperators.location.TypeRefTo$Binded
*/implements This4.Concept.Base, This4.Concept.ToS, This4.Concept.Classable, This4.Concept.Equals, This1/*includes primitives
*/
class method 
mut This0 #from(Library binaryRepr) 
read method 
Library #binaryRepr() 
class method 
Void #exceptionIf(Library binaryRepr) exception This0 
class method 
Library #pluginUnresponsive(Library binaryRepr) 
read method 
This4.Bool equals(read This0 that) 
method 
class Any referredClassObj() 
class method 
This0 #apply(class Any classObj) 
class method 
This4.Bool equalsClassObj(class Any that, class Any and) 
refine read method 
This4.S toS() 
refine class method /*
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  */This4.S readableName() 
refine class method /*
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  */This4.Bool is(class This4.Concept.Classable subtype) 
refine read method 
This4.Bool #equalequal#0left(read Any right) 
refine class method 
read This0 cast(read This4.Concept.Classable that) 
refine class method 
mut This0 #cast(mut This4.Concept.Classable that) 
refine read method 
class This0 class() }
Missing: {/*@plugin  toFix 
@pluginPart is.L42.connected.withSafeOperators.location.TypeRefTo$Missing
*/implements This4.Concept.Base, This4.Concept.ToS, This4.Concept.Classable, This4.Concept.Equals, This1
class method 
mut This0 #from(Library binaryRepr) 
read method 
Library #binaryRepr() 
class method 
Void #exceptionIf(Library binaryRepr) exception This0 
class method 
Library #pluginUnresponsive(Library binaryRepr) 
read method 
This4.Bool equals(read This0 that) 
refine read method 
This4.S toS() 
refine class method /*
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  */This4.S readableName() 
refine class method /*
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  */This4.Bool is(class This4.Concept.Classable subtype) 
refine read method 
This4.Bool #equalequal#0left(read Any right) 
refine class method 
read This0 cast(read This4.Concept.Classable that) 
refine class method 
mut This0 #cast(mut This4.Concept.Classable that) 
refine read method 
class This0 class() }}}
Doc: {/*user will need typecase to discover precise type, location() not refined
@plugin  toFix 
@pluginPart is.L42.connected.withSafeOperators.location.Doc
*/implements This1, This2.Concept.Base, This2.Concept.ToS, This2.Concept.Classable, This2.Concept.Equals
class method 
mut This0 #from(Library binaryRepr) 
read method 
Library #binaryRepr() 
class method 
Void #exceptionIf(Library binaryRepr) exception This0 
class method 
Library #pluginUnresponsive(Library binaryRepr) 
read method 
This2.Bool equals(read This0 that) 
method 
This1.Origin.List origins() 
refine method 
This2.Size originSize() 
refine method 
This1.Origin origin(This2.Size that) 
refine method 
This0 doc() 
refine method 
This1 location() 
method 
This2.Size annotationSize() 
method 
This0.Annotation annotation(This2.Size that) 
method 
This0.Annotation.List annotations() 
refine read method 
This2.S toS() 
refine class method /*
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  */This2.S readableName() 
refine class method /*
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  */This2.Bool is(class This2.Concept.Classable subtype) 
refine read method 
This2.Bool #equalequal#0left(read Any right) 
refine class method 
read This0 cast(read This2.Concept.Classable that) 
refine class method 
mut This0 #cast(mut This2.Concept.Classable that) 
refine read method 
class This0 class() 
Annotation: {/*@plugin  toFix 
@pluginPart is.L42.connected.withSafeOperators.location.Doc$Annotation
*/implements This3.Concept.Base, This3.Concept.ToS, This3.Concept.Classable, This3.Concept.Equals
class method 
mut This0 #from(Library binaryRepr) 
read method 
Library #binaryRepr() 
class method 
Void #exceptionIf(Library binaryRepr) exception This0 
read method 
This3.Bool equals(read This0 that) 
method 
This2.Type.RefTo title() 
method 
This3.S text() 
class method 
Library #pluginUnresponsive(Library binaryRepr) 
refine read method 
This3.S toS() 
refine class method /*
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  */This3.S readableName() 
refine class method /*
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  */This3.Bool is(class This3.Concept.Classable subtype) 
refine read method 
This3.Bool #equalequal#0left(read Any right) 
refine class method 
read This0 cast(read This3.Concept.Classable that) 
refine class method 
mut This0 #cast(mut This3.Concept.Classable that) 
refine read method 
class This0 class() 
List: {implements This4.Concept.ToS, This4.Concept.Classable, This4.Concept.Equals
refine class method /*
  Cast a (read/imm) object to this type.
  A class implementing this method should refine the return type to This.
  if is(subtype) is true, then cast(that) must produce a result.
  */read This0 cast(read This4.Concept.Classable that) 
refine class method /*
  Cast a (mutable) object to this type.
  A class implementing this method should refine the return type to This.
  if cast(that) produces a result, then #cast(that) also must produce a result.
  */mut This0 #cast(mut This4.Concept.Classable that) 
refine read method /*
  Extracts the class singleton from another instance of this class
  */class This0 class() 
refine class method /*
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  */This4.S readableName() 
refine class method /*
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  */This4.Bool is(class This4.Concept.Classable subtype) 
read method 
read This4.Collections.MutListAny inner() 
mut method 
mut This4.Collections.MutListAny #inner() 
class method 
mut This0 #apply(fwd mut This4.Collections.MutListAny inner) 
class method 
This0 #immK(This4.Collections.MutListAny inner) 
class method 
mut This0 empty() 
read method 
mut This0 reverse() 
read method 
This4.Bool isEmpty() 
read method 
class This4.Size #default#val(Void that) 
read method 
This1 left() 
read method 
This1 right() 
mut method 
Void #apply(This4.Size that, This1 val) 
mut method 
Void left(This1 that) 
mut method 
Void right(This1 that) 
mut method 
Void add(This4.Size that, This1 val) 
mut method 
Void add(This1 right) 
mut method 
Void add(This1 left) 
mut method 
Void removeLeft() 
mut method 
Void removeRight() 
method 
This0 #plus#0left(This1 right) 
method 
This0 #plusplus#0left(This0 right) 
method 
This0 with(This4.Size that, This1 val) 
method 
This0 withLeft(This1 that) 
method 
This0 withRight(This1 that) 
method 
This0 withAlso(This4.Size that, This1 val) 
method 
This0 withAlsoLeft(This1 that) 
method 
This0 withAlsoRight(This1 that) 
method 
This0 withoutLeft() 
method 
This0 withoutRight() 
read method 
lent This0.IteratorVal vals(This4.Size from, This4.Size maxTo, This4.Size minTo) 
read method 
lent This0.IteratorVal vals(This4.Size minTo) 
read method 
lent This0.IteratorVal vals(This4.Size from, This4.Size to) 
read method 
lent This0.IteratorValFill vals(This4.Size from, This4.Size maxTo, This4.Size minTo, This1 filled) 
read method 
lent This0.IteratorValFill vals(This4.Size minTo, This1 filled) 
read method 
lent This0.IteratorValFill vals(This4.Size from, This4.Size to, This1 filled) 
read method 
lent This0.IteratorValFill vals(This1 filled) 
mut method 
lent This0.IteratorVar #vals(This4.Size from, This4.Size maxTo, This4.Size minTo) 
mut method 
lent This0.IteratorVar #vals(This4.Size minTo) 
mut method 
lent This0.IteratorVar #vals(This4.Size from, This4.Size to) 
mut method 
lent This0.IteratorVar #vals() 
refine read method 
This4.S toS() 
read method 
This4.Size size() 
read method 
This1 val(This4.Size that) 
class method 
mut This0 #seqBuilder() 
class method 
mut This0 #from(mut This0 seqBuilder) 
mut method 
Void #add(This1 that) 
read method 
lent This0.IteratorVal vals() 
read method 
This4.Bool contains(This1 that) 
method 
This0 #less#0left(This1 right) 
method 
This0 #lessless#0left(This0 right) 
method 
This0 #and#0left(This0 right) 
method 
This4.Bool #rightright#0left(This0 right) 
method 
This4.Bool #rightrightequal#0left(This0 right) 
method 
This4.Bool #right#0left(This1 right) 
read method 
This4.Bool equals(read This0 that) 
refine read method 
This4.Bool #equalequal#0left(read Any right) 
read method 
This4.Size indexOfLeft(This1 val) 
read method 
This4.Size indexOfRight(This1 val) 
method /*from VectorTrait
*/This0 without(This4.Size index) 
method 
This0 withoutLeft(This1 val) 
method 
This0 withoutRight(This1 val) 
method 
This0 withoutAll(This1 val) 
mut method /*from VectorTrait
*/Void remove(This4.Size that) 
mut method 
Void removeAll(This1 val) 
mut method 
Void removeLeft(This1 val) 
mut method 
Void removeRight(This1 val) 
Cast: {
class method 
This2 #apply(Any that) }
IteratorTrait: {
class method 
Library #apply() }
IteratorValFill: {
mut method 
Void #next() exception Void 
read method 
Void #checkEnd() 
read method 
This2 #inner() 
read method 
Void #close() 
read method 
read This5.Collections.MutListAny _that() 
mut method 
Void from(This5.Size that) 
read method 
This5.Size from() 
read method 
This5.Size maxTo() 
read method 
This5.Size minTo() 
read method 
This2 filled() 
read method 
read This5.Collections.MutListAny that() 
class method 
lent This0 #apply(read This5.Collections.MutListAny _that, This5.Size from, This5.Size maxTo, This5.Size minTo, This2 filled) 
class method 
lent This0 #apply(read This5.Collections.MutListAny that, This5.Size from, This5.Size maxTo, This5.Size minTo, This2 filled) 
read method 
This5.Bool isFill() }
IteratorVar: {
mut method 
Void #next() exception Void 
read method 
Void #checkEnd() 
read method 
This2 #inner() 
read method 
Void #close() 
read method 
read This5.Collections.MutListAny that() 
mut method 
mut This5.Collections.MutListAny #that() 
mut method 
Void from(This5.Size that) 
read method 
This5.Size from() 
read method 
This5.Size maxTo() 
read method 
This5.Size minTo() 
class method 
mut This0 #apply(mut This5.Collections.MutListAny that, This5.Size from, This5.Size maxTo, This5.Size minTo) 
mut method 
Void inner(This2 that) 
read method 
This5.Bool isFill() 
read method 
This2 filled() }
IteratorVal: {
read method 
read This5.Collections.MutListAny _that() 
mut method 
Void from(This5.Size that) 
read method 
This5.Size from() 
read method 
This5.Size maxTo() 
read method 
This5.Size minTo() 
read method 
read This5.Collections.MutListAny that() 
class method 
lent This0 #apply(read This5.Collections.MutListAny _that, This5.Size from, This5.Size maxTo, This5.Size minTo) 
class method 
lent This0 #apply(read This5.Collections.MutListAny that, This5.Size from, This5.Size maxTo, This5.Size minTo) 
read method 
This5.Bool isFill() 
read method 
This2 filled() 
mut method 
Void #next() exception Void 
read method 
Void #checkEnd() 
read method 
This2 #inner() 
read method 
Void #close() }}}}}
Refactor2: {/*------------------------------
Infrastructure
------------------------------
*/
class method 
Library compose(Library that, Library and) exception This0.MethodClash, This0.ClassClash, This0.SubtleSubtypeViolation 
class method 
class This1.Path #default#rename(Void path) 
class method 
class This1.Path #default#rename(Void into) 
class method 
This0.RenameClass rename(This1.Path path, This1.Path into) 
class method 
class This1.Path #default#hide(Void path) 
class method 
This0.HideClass hide(This1.Path path) 
class method 
class This1.Path #default#toAbstract(Void path) 
class method 
This0.ToAbstractClass toAbstract(This1.Path path) 
class method 
This0.ToAbstract toAbstract(This1.Selector selector) 
class method 
This0.ToAbstractDest toAbstract(This1.Selector selector, This1.Selector into) 
class method 
This0.ToAbstractPath toAbstract(This1.Selector selector, This1.Path of) 
class method 
This0.ToAbstractPathDest toAbstract(This1.Selector selector, This1.Path of, This1.Selector into) 
class method 
class This1.Selector #default#toAbstract(Void selector) 
class method 
class This1.Selector #default#toAbstract(Void into) 
class method 
class This1.Path #default#toAbstract(Void of) 
class method 
class This1.Path #default#redirect(Void path) 
class method 
This0.Redirect redirect(This1.Path path, class Any into) 
class method 
This0.RedirectRefTo redirect(This1.Path path, This1.Location.Type.RefTo intoRefTo) 
class method 
Library makeDoc(This1.S that) 
class method 
This0.SumMethods sumMethods(This1.Selector that, This1.Selector and, This1.Path of, This1.S over, This1.Selector into) 
Fail: {interface implements This2.Guard, This2.Message, This2.Concept.Base, This2.Concept.ToS, This2.Concept.Classable, This2.Concept.Equals
refine read method 
This2.S toS() 
refine class method /*
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  */This2.S readableName() 
refine class method /*
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  */This2.Bool is(class This2.Concept.Classable subtype) 
refine read method 
This2.Bool #equalequal#0left(read Any right) 
refine class method 
read This2.Concept.Base cast(read This2.Concept.Classable that) 
refine class method 
mut This2.Concept.Base #cast(mut This2.Concept.Classable that) 
refine class method 
This2.S kind() 
refine read method 
This2.S text() 
refine read method 
This2.Message.Opt responseOf() 
refine read method 
class This2.Message class() }
ErrorW: {
class method 
Library trait() 
class method 
Library #leftrightleft#0left(Library right) }
ParseFail: {/*@pluginPart is.L42.connected.withSafeOperators.pluginWrapper.RefactorErrors$ParseFail
@plugin is.L42.connected.withSafeOperators
*/implements This1.Fail, This2.Guard, This2.Message, This2.Concept.Base, This2.Concept.ToS, This2.Concept.Classable, This2.Concept.Equals
class method 
mut This0 #from(Library binaryRepr) 
read method 
Library #binaryRepr() 
class method 
Void #exceptionIf(Library binaryRepr) exception This0 
read method 
This2.Bool equals(read This0 that) 
method 
This2.S string() 
method 
This2.S expected() 
refine class method /*
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  */This2.S readableName() 
refine class method /*
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  */This2.Bool is(class This2.Concept.Classable subtype) 
refine read method 
This2.Bool #equalequal#0left(read Any right) 
refine class method 
read This0 cast(read This2.Concept.Classable that) 
refine class method 
mut This0 #cast(mut This2.Concept.Classable that) 
refine read method 
This2.S text() 
refine read method 
class This0 class() 
refine class method 
This2.S kind() 
refine read method 
This2.Message.Opt responseOf() 
refine read method 
This2.S toS() 
class method 
Library #pluginUnresponsive(Library binaryRepr) }
UnresolvedOverloading: {/*@pluginPart is.L42.connected.withSafeOperators.pluginWrapper.RefactorErrors$UnresolvedOverloading
@plugin is.L42.connected.withSafeOperators
*/implements This1.Fail, This2.Guard, This2.Message, This2.Concept.Base, This2.Concept.ToS, This2.Concept.Classable, This2.Concept.Equals
class method 
mut This0 #from(Library binaryRepr) 
read method 
Library #binaryRepr() 
class method 
Void #exceptionIf(Library binaryRepr) exception This0 
read method 
This2.Bool equals(read This0 that) 
refine class method /*
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  */This2.S readableName() 
refine class method /*
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  */This2.Bool is(class This2.Concept.Classable subtype) 
refine read method 
This2.Bool #equalequal#0left(read Any right) 
refine class method 
read This0 cast(read This2.Concept.Classable that) 
refine class method 
mut This0 #cast(mut This2.Concept.Classable that) 
refine read method 
This2.S text() 
refine read method 
class This0 class() 
refine class method 
This2.S kind() 
refine read method 
This2.Message.Opt responseOf() 
refine read method 
This2.S toS() 
class method 
Library #pluginUnresponsive(Library binaryRepr) }
ClassUnfit: {/*@pluginPart is.L42.connected.withSafeOperators.pluginWrapper.RefactorErrors$ClassUnfit
@plugin is.L42.connected.withSafeOperators
*/implements This1.Fail, This2.Guard, This2.Message, This2.Concept.Base, This2.Concept.ToS, This2.Concept.Classable, This2.Concept.Equals
class method 
mut This0 #from(Library binaryRepr) 
read method 
Library #binaryRepr() 
class method 
Void #exceptionIf(Library binaryRepr) exception This0 
read method 
This2.Bool equals(read This0 that) 
refine class method /*
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  */This2.S readableName() 
refine class method /*
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  */This2.Bool is(class This2.Concept.Classable subtype) 
refine read method 
This2.Bool #equalequal#0left(read Any right) 
refine class method 
read This0 cast(read This2.Concept.Classable that) 
refine class method 
mut This0 #cast(mut This2.Concept.Classable that) 
refine read method 
This2.S text() 
refine read method 
class This0 class() 
refine class method 
This2.S kind() 
refine read method 
This2.Message.Opt responseOf() 
refine read method 
This2.S toS() 
class method 
Library #pluginUnresponsive(Library binaryRepr) }
MethodUnfit: {/*@pluginPart is.L42.connected.withSafeOperators.pluginWrapper.RefactorErrors$MethodUnfit
@plugin is.L42.connected.withSafeOperators
*/implements This1.Fail, This2.Guard, This2.Message, This2.Concept.Base, This2.Concept.ToS, This2.Concept.Classable, This2.Concept.Equals
class method 
mut This0 #from(Library binaryRepr) 
read method 
Library #binaryRepr() 
class method 
Void #exceptionIf(Library binaryRepr) exception This0 
read method 
This2.Bool equals(read This0 that) 
refine class method /*
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  */This2.S readableName() 
refine class method /*
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  */This2.Bool is(class This2.Concept.Classable subtype) 
refine read method 
This2.Bool #equalequal#0left(read Any right) 
refine class method 
read This0 cast(read This2.Concept.Classable that) 
refine class method 
mut This0 #cast(mut This2.Concept.Classable that) 
refine read method 
This2.S text() 
refine read method 
class This0 class() 
refine class method 
This2.S kind() 
refine read method 
This2.Message.Opt responseOf() 
refine read method 
This2.S toS() 
class method 
Library #pluginUnresponsive(Library binaryRepr) }
ClassClash: {/*@pluginPart is.L42.connected.withSafeOperators.pluginWrapper.RefactorErrors$ClassClash
@plugin is.L42.connected.withSafeOperators
*/implements This1.Fail, This2.Guard, This2.Message, This2.Concept.Base, This2.Concept.ToS, This2.Concept.Classable, This2.Concept.Equals
class method 
mut This0 #from(Library binaryRepr) 
read method 
Library #binaryRepr() 
class method 
Void #exceptionIf(Library binaryRepr) exception This0 
read method 
This2.Bool equals(read This0 that) 
method 
This2.Location.Lib left() 
method 
This2.Location.Lib right() 
refine class method /*
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  */This2.S readableName() 
refine class method /*
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  */This2.Bool is(class This2.Concept.Classable subtype) 
refine read method 
This2.Bool #equalequal#0left(read Any right) 
refine class method 
read This0 cast(read This2.Concept.Classable that) 
refine class method 
mut This0 #cast(mut This2.Concept.Classable that) 
refine read method 
This2.S text() 
refine read method 
class This0 class() 
refine class method 
This2.S kind() 
refine read method 
This2.Message.Opt responseOf() 
refine read method 
This2.S toS() 
class method 
Library #pluginUnresponsive(Library binaryRepr) }
MethodClash: {/*@pluginPart is.L42.connected.withSafeOperators.pluginWrapper.RefactorErrors$MethodClash
@plugin is.L42.connected.withSafeOperators
*/implements This1.Fail, This2.Guard, This2.Message, This2.Concept.Base, This2.Concept.ToS, This2.Concept.Classable, This2.Concept.Equals
class method 
mut This0 #from(Library binaryRepr) 
read method 
Library #binaryRepr() 
class method 
Void #exceptionIf(Library binaryRepr) exception This0 
read method 
This2.Bool equals(read This0 that) 
method 
This2.Location.Method left() 
method 
This2.Location.Method right() 
refine class method /*
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  */This2.S readableName() 
refine class method /*
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  */This2.Bool is(class This2.Concept.Classable subtype) 
refine read method 
This2.Bool #equalequal#0left(read Any right) 
refine class method 
read This0 cast(read This2.Concept.Classable that) 
refine class method 
mut This0 #cast(mut This2.Concept.Classable that) 
refine read method 
This2.S text() 
refine read method 
class This0 class() 
refine class method 
This2.S kind() 
refine read method 
This2.Message.Opt responseOf() 
refine read method 
This2.S toS() 
class method 
Library #pluginUnresponsive(Library binaryRepr) }
PathUnfit: {/*@pluginPart is.L42.connected.withSafeOperators.pluginWrapper.RefactorErrors$PathUnfit
@plugin is.L42.connected.withSafeOperators
*/implements This1.Fail, This2.Guard, This2.Message, This2.Concept.Base, This2.Concept.ToS, This2.Concept.Classable, This2.Concept.Equals
class method 
mut This0 #from(Library binaryRepr) 
read method 
Library #binaryRepr() 
class method 
Void #exceptionIf(Library binaryRepr) exception This0 
read method 
This2.Bool equals(read This0 that) 
method 
This2.Path path() 
refine class method /*
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  */This2.S readableName() 
refine class method /*
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  */This2.Bool is(class This2.Concept.Classable subtype) 
refine read method 
This2.Bool #equalequal#0left(read Any right) 
refine class method 
read This0 cast(read This2.Concept.Classable that) 
refine class method 
mut This0 #cast(mut This2.Concept.Classable that) 
refine read method 
This2.S text() 
refine read method 
class This0 class() 
refine class method 
This2.S kind() 
refine read method 
This2.Message.Opt responseOf() 
refine read method 
This2.S toS() 
class method 
Library #pluginUnresponsive(Library binaryRepr) }
SelectorUnfit: {/*@pluginPart is.L42.connected.withSafeOperators.pluginWrapper.RefactorErrors$SelectorUnfit
@plugin is.L42.connected.withSafeOperators
*/implements This1.Fail, This2.Guard, This2.Message, This2.Concept.Base, This2.Concept.ToS, This2.Concept.Classable, This2.Concept.Equals
class method 
mut This0 #from(Library binaryRepr) 
read method 
Library #binaryRepr() 
class method 
Void #exceptionIf(Library binaryRepr) exception This0 
read method 
This2.Bool equals(read This0 that) 
method 
This2.Path path() 
method 
This2.Selector selector() 
refine class method /*
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  */This2.S readableName() 
refine class method /*
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  */This2.Bool is(class This2.Concept.Classable subtype) 
refine read method 
This2.Bool #equalequal#0left(read Any right) 
refine class method 
read This0 cast(read This2.Concept.Classable that) 
refine class method 
mut This0 #cast(mut This2.Concept.Classable that) 
refine read method 
This2.S text() 
refine read method 
class This0 class() 
refine class method 
This2.S kind() 
refine read method 
This2.Message.Opt responseOf() 
refine read method 
This2.S toS() 
class method 
Library #pluginUnresponsive(Library binaryRepr) }
IncoherentMapping: {/*@pluginPart is.L42.connected.withSafeOperators.pluginWrapper.RefactorErrors$SelectorUnfit
@plugin is.L42.connected.withSafeOperators
*/implements This1.Fail, This2.Guard, This2.Message, This2.Concept.Base, This2.Concept.ToS, This2.Concept.Classable, This2.Concept.Equals
class method 
mut This0 #from(Library binaryRepr) 
read method 
Library #binaryRepr() 
class method 
Void #exceptionIf(Library binaryRepr) exception This0 
read method 
This2.Bool equals(read This0 that) 
refine class method /*
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  */This2.S readableName() 
refine class method /*
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  */This2.Bool is(class This2.Concept.Classable subtype) 
refine read method 
This2.Bool #equalequal#0left(read Any right) 
refine class method 
read This0 cast(read This2.Concept.Classable that) 
refine class method 
mut This0 #cast(mut This2.Concept.Classable that) 
refine read method 
This2.S text() 
refine read method 
class This0 class() 
refine class method 
This2.S kind() 
refine read method 
This2.Message.Opt responseOf() 
refine read method 
This2.S toS() 
class method 
Library #pluginUnresponsive(Library binaryRepr) }
PrivacyCoupuled: {/*@pluginPart is.L42.connected.withSafeOperators.pluginWrapper.RefactorErrors$PrivacyCoupuled
@plugin is.L42.connected.withSafeOperators
*/implements This1.Fail, This2.Guard, This2.Message, This2.Concept.Base, This2.Concept.ToS, This2.Concept.Classable, This2.Concept.Equals
class method 
mut This0 #from(Library binaryRepr) 
read method 
Library #binaryRepr() 
class method 
Void #exceptionIf(Library binaryRepr) exception This0 
read method 
This2.Bool equals(read This0 that) 
refine class method /*
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  */This2.S readableName() 
refine class method /*
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  */This2.Bool is(class This2.Concept.Classable subtype) 
refine read method 
This2.Bool #equalequal#0left(read Any right) 
refine class method 
read This0 cast(read This2.Concept.Classable that) 
refine class method 
mut This0 #cast(mut This2.Concept.Classable that) 
refine read method 
This2.S text() 
refine read method 
class This0 class() 
refine class method 
This2.S kind() 
refine read method 
This2.Message.Opt responseOf() 
refine read method 
This2.S toS() 
class method 
Library #pluginUnresponsive(Library binaryRepr) }
SubtleSubtypeViolation: {/*@pluginPart is.L42.connected.withSafeOperators.pluginWrapper.RefactorErrors$SubtleSubtypeViolation
@plugin is.L42.connected.withSafeOperators
*/implements This1.Fail, This2.Guard, This2.Message, This2.Concept.Base, This2.Concept.ToS, This2.Concept.Classable, This2.Concept.Equals
class method 
mut This0 #from(Library binaryRepr) 
read method 
Library #binaryRepr() 
class method 
Void #exceptionIf(Library binaryRepr) exception This0 
read method 
This2.Bool equals(read This0 that) 
refine class method /*
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  */This2.S readableName() 
refine class method /*
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  */This2.Bool is(class This2.Concept.Classable subtype) 
refine read method 
This2.Bool #equalequal#0left(read Any right) 
refine class method 
read This0 cast(read This2.Concept.Classable that) 
refine class method 
mut This0 #cast(mut This2.Concept.Classable that) 
refine read method 
This2.S text() 
refine read method 
class This0 class() 
refine class method 
This2.S kind() 
refine read method 
This2.Message.Opt responseOf() 
refine read method 
This2.S toS() 
class method 
Library #pluginUnresponsive(Library binaryRepr) }
JavaImport: {/*@plugin is.L42.connected.withSafeOperators
@pluginPart is.L42.connected.withSafeOperators.pluginWrapper.PlgWrapperGenerator
*/
class method 
mut This0 #from(Library binaryRepr) 
read method 
Library #binaryRepr() 
class method 
Void #exceptionIf(Library binaryRepr) exception This0 
class method 
Library #pluginUnresponsive(Library binaryRepr) 
class method 
Library #leftrightleft#0left(Library right) exception This1.UnresolvedOverloading, This1.ClassUnfit, This1.MethodUnfit 
class method 
Library main(Library that) exception This1.UnresolvedOverloading, This1.ClassUnfit, This1.MethodUnfit }
Compose: {/*@plugin  toFix
@pluginPart is.L42.connected.withSafeOperators.refactor.Compose
*/
class method 
mut This0 #from(Library binaryRepr) 
read method 
Library #binaryRepr() 
class method 
Void #exceptionIf(Library binaryRepr) exception This0 
class method 
Void #pluginUnresponsive(Library binaryRepr) 
class method 
Library compose(Library left, Library right) exception This1.MethodClash, This1.ClassClash, This1.SubtleSubtypeViolation }
PlgRenameClass: {/*@plugin  toFix
@pluginPart is.L42.connected.withSafeOperators.refactor.Rename
*/
class method 
mut This0 #from(Library binaryRepr) 
read method 
Library #binaryRepr() 
class method 
Void #exceptionIf(Library binaryRepr) exception This0 
class method 
Void #pluginUnresponsive(Library binaryRepr) 
class method 
Library renameClassJ(Library that, This2.Path src, This2.Path dest) exception This1.PathUnfit, This1.MethodClash, This1.ClassClash, This1.SubtleSubtypeViolation 
class method 
Library hideClassJ(Library that, This2.Path src) exception This1.PathUnfit, This1.ClassUnfit }
RenameClass: {
method 
This2.Path src() 
method 
This2.Path dest() 
class method 
This0 #apply(This2.Path src, This2.Path dest) 
method 
Library #leftrightleft#0left(Library right) exception This1.PathUnfit, This1.MethodClash, This1.ClassClash, This1.SubtleSubtypeViolation }
HideClass: {
method 
This2.Path src() 
class method 
This0 #apply(This2.Path src) 
method 
Library #leftrightleft#0left(Library right) exception This1.PathUnfit, This1.ClassUnfit }
PlgAbstractClass: {/*@plugin  toFix
@pluginPart is.L42.connected.withSafeOperators.refactor.AbstractClass
*/
class method 
mut This0 #from(Library binaryRepr) 
read method 
Library #binaryRepr() 
class method 
Void #exceptionIf(Library binaryRepr) exception This0 
class method 
Void #pluginUnresponsive(Library binaryRepr) 
class method 
Library toAbstractJ(Library that, This2.Path src) exception This1.PathUnfit, This1.PrivacyCoupuled }
ToAbstractClass: {
read method 
This2.Path src() 
class method 
This0 #apply(This2.Path src) 
method 
Library #leftrightleft#0left(Library right) exception This1.PathUnfit, This1.PrivacyCoupuled }
PlgToAbstract: {/*@plugin  toFix
@pluginPart is.L42.connected.withSafeOperators.refactor.ToAbstract
*/
class method 
mut This0 #from(Library binaryRepr) 
read method 
Library #binaryRepr() 
class method 
Void #exceptionIf(Library binaryRepr) exception This0 
class method 
Void #pluginUnresponsive(Library binaryRepr) 
class method 
Library toAbstractPathDestJ(Library that, This2.Path path, This2.Selector src, This2.Selector dest) exception This1.SelectorUnfit, This1.PathUnfit, This1.MethodClash 
class method 
Library toAbstractPathJ(Library that, This2.Path path, This2.Selector src) exception This1.SelectorUnfit, This1.PathUnfit 
class method 
Library toAbstractDestJ(Library that, This2.Selector src, This2.Selector dest) exception This1.SelectorUnfit, This1.MethodClash 
class method 
Library toAbstractJ(Library that, This2.Selector src) exception This1.SelectorUnfit }
ToAbstract: {
method 
This2.Selector src() 
class method 
This0 #apply(This2.Selector src) 
method 
Library #leftrightleft#0left(Library right) exception This1.SelectorUnfit }
ToAbstractDest: {
method 
This2.Selector src() 
method 
This2.Selector dest() 
class method 
This0 #apply(This2.Selector src, This2.Selector dest) 
method 
Library #leftrightleft#0left(Library right) exception This1.SelectorUnfit, This1.MethodClash }
ToAbstractPath: {
method 
This2.Path path() 
method 
This2.Selector src() 
class method 
This0 #apply(This2.Path path, This2.Selector src) 
method 
Library #leftrightleft#0left(Library right) exception This1.SelectorUnfit, This1.PathUnfit }
ToAbstractPathDest: {
method 
This2.Path path() 
method 
This2.Selector src() 
method 
This2.Selector dest() 
class method 
This0 #apply(This2.Path path, This2.Selector src, This2.Selector dest) 
method 
Library #leftrightleft#0left(Library right) exception This1.SelectorUnfit, This1.PathUnfit, This1.MethodClash }
PlgRedirect: {/*@plugin  toFix
@pluginPart is.L42.connected.withSafeOperators.refactor.Redirect
*/
class method 
mut This0 #from(Library binaryRepr) 
read method 
Library #binaryRepr() 
class method 
Void #exceptionIf(Library binaryRepr) exception This0 
class method 
Void #pluginUnresponsive(Library binaryRepr) 
class method 
Library redirectJ(Library that, This2.Path src, class Any dest) exception This1.ClassUnfit, This1.IncoherentMapping, This1.MethodClash, This1.PathUnfit }
Redirect: {
method 
This2.Path src() 
method 
class Any dest() 
class method 
This0 #apply(This2.Path src, class Any dest) 
method 
Library #leftrightleft#0left(Library right) exception This1.ClassUnfit, This1.IncoherentMapping, This1.MethodClash, This1.PathUnfit }
RefToUnfit: {implements This1.Fail, This2.Guard, This2.Message, This2.Concept.Base, This2.Concept.ToS, This2.Concept.Classable, This2.Concept.Equals
refine read method 
class This0 class() 
refine class method /*
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  */This2.S readableName() 
refine class method /*
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  */This2.Bool is(class This2.Concept.Classable subtype) 
refine read method 
This2.Bool #equalequal#0left(read Any right) 
refine class method 
read This0 cast(read This2.Concept.Classable that) 
refine class method 
mut This0 #cast(mut This2.Concept.Classable that) 
read method 
This2.S _text() 
read method 
This2.Message.Opt cause() 
class method 
This0 #apply(This2.S _text, This2.Message.Opt cause) 
refine class method 
This2.S kind() 
refine read method 
This2.S text() 
refine read method 
This2.Message.Opt responseOf() 
method 
This0 #apply(This2.Message that) 
refine read method 
This2.S toS() 
read method 
This2.Bool equals(read This0 that) 
class method 
This0 #apply(This2.S text) 
class method 
This0 #apply(This2.S text, This2.Message cause) 
class method 
mut This2.S.SBuilder #builder() 
class method 
This0 #from(This2.S.SBuilder builder) 
method 
This0.Continue #from(This2.S.SConcat seqBuilder) 
method 
mut This2.S.SConcat #seqBuilder() 
Continue: {
read method 
This3.S that() 
class method 
This0 #apply(This3.S that) 
method 
mut This3.S.SBuilder #builder() 
method 
This1 #from(This3.S.SBuilder builder) }}
RedirectRefTo: {
read method 
This2.Path src() 
read method 
This2.Location.Type.RefTo into() 
class method 
This0 #apply(This2.Path src, This2.Location.Type.RefTo into) 
method 
Library #leftrightleft#0left(Library right) exception This1.ClassUnfit, This1.IncoherentMapping, This1.MethodClash, This1.ClassClash, This1.PathUnfit, This1.RefToUnfit, This1.SubtleSubtypeViolation }
PlgMethod: {/*@plugin  toFix
@pluginPart is.L42.connected.withSafeOperators.refactor.RenameMethods
*/
class method 
mut This0 #from(Library binaryRepr) 
read method 
Library #binaryRepr() 
class method 
Void #exceptionIf(Library binaryRepr) exception This0 
class method 
Void #pluginUnresponsive(Library binaryRepr) 
class method 
This0 #apply() 
method 
Library act(Library that) exception This1.PathUnfit, This1.SelectorUnfit, This1.MethodClash, This1.ClassUnfit 
method 
This0 addRenameJ(This2.Path path, This2.Selector src, This2.Selector dest) 
method 
This0 addHideJ(This2.Path path, This2.Selector src) 
method 
This0 addCloseJ(This2.Path path) 
method 
This0 addAbstractJ(This2.Path path, This2.Selector src) 
method 
This0 addAbstractAliasJ(This2.Path path, This2.Selector src, This2.Selector dest) }
Method: {
mut method 
Void inner(This1.PlgMethod that) 
read method 
This1.PlgMethod inner() 
class method 
mut This0 #apply(This1.PlgMethod inner) 
read method 
Library #leftrightleft#0left(Library right) exception This1.PathUnfit, This1.SelectorUnfit, This1.MethodClash, This1.ClassUnfit 
class method 
mut This0 #seqBuilder() 
class method 
mut This0 #from(mut This0 seqBuilder) 
class method 
class This2.Path #default##square(Void of) 
class method 
class This2.Selector #default##square(Void hide) 
class method 
class This2.Selector #default##square(Void rename) 
class method 
class This2.Selector #default##square(Void into) 
class method 
class This2.Selector #default##square(Void abstract) 
class method 
class This2.Selector #default##square(Void alias) 
mut method 
Void #add(This2.Selector hide, This2.Path of) 
mut method 
Void #add(This2.Selector hide) 
mut method 
Void #add(This2.Selector rename, This2.Path of, This2.Selector into) 
mut method 
Void #add(This2.Selector rename, This2.Selector into) 
mut method 
Void #add(This2.Path closeState) 
mut method 
Void #add(This2.Selector abstract, This2.Path of) 
mut method 
Void #add(This2.Selector abstract, This2.Path of, This2.Selector alias) 
mut method 
Void #add(This2.Selector abstract) 
mut method 
Void #add(This2.Selector abstract, This2.Selector alias) }
MakeDoc: {/*@plugin  toFix
@pluginPart is.L42.connected.withSafeOperators.refactor.MakeDoc
*/
class method 
mut This0 #from(Library binaryRepr) 
read method 
Library #binaryRepr() 
class method 
Void #exceptionIf(Library binaryRepr) exception This0 
class method 
Void #pluginUnresponsive(Library binaryRepr) 
class method 
Library makeDoc(This2.S that) }
PlgSumMethods: {/*@plugin  toFix
@pluginPart is.L42.connected.withSafeOperators.refactor.SumMethods
*/
class method 
mut This0 #from(Library binaryRepr) 
read method 
Library #binaryRepr() 
class method 
Void #exceptionIf(Library binaryRepr) exception This0 
class method 
Void #pluginUnresponsive(Library binaryRepr) 
class method 
Library sumMethodsJ(Library lib, This2.Path path, This2.Selector src1, This2.Selector src2, This2.Selector dest, This2.S name) exception This1.MethodClash, This1.PathUnfit, This1.SelectorUnfit }
SumMethods: {
read method 
This2.Selector that() 
read method 
This2.Selector and() 
read method 
This2.Path of() 
read method 
This2.S over() 
read method 
This2.Selector into() 
class method 
This0 #apply(This2.Selector that, This2.Selector and, This2.Path of, This2.S over, This2.Selector into) 
method 
Library #leftrightleft#0left(Library right) exception This1.MethodClash, This1.PathUnfit, This1.SelectorUnfit }}
Optimize: {
RemoveUnreachableCode: {
class method 
Library #leftrightleft#0left(Library right) }}
Opt: {
class method 
Library #apply(class Any that) 
class method 
Library optTrait() }
Use: {
mut method 
Void fillMaps() 
mut method 
Void fillMaps(This1.Location.Lib li, This1.Size i) 
mut method 
Void fillMaps(This1.Location.Lib lij, This1.Composers.Selectors ssj, This1.Path pj, This1.Size i) 
mut method 
This1.Selector superName(This1.Selector selector, This1.Size i) 
class method 
mut This1.Composers.Libs #seqBuilder() 
class method 
mut This0.Decorator #from(mut This1.Composers.Libs seqBuilder) 
mut method 
mut This1.Composers.RenameMethods openMaps() 
mut method 
mut This1.Refactor2.Method close() 
read method 
read This1.Composers.Libs inputs() 
mut method 
mut This1.Composers.Libs #inputs() 
read method 
Library input() 
read method 
This1.Location.Lib.List ls() 
read method 
This1.Location.Lib l0() 
read method 
This1.Location.Lib.List l0ns() 
read method 
This1.Composers.Selectorss sels() 
class method 
mut This0 #apply(mut This1.Composers.Libs libs, Library lib0) 
mut method 
mut This1.Refactor2.Method open(This1.Size that) 
mut method 
Void fillMapsPatch(This1.Location.Lib top, This1.Path fix) 
class method 
mut This0 #apply(Library top, This1.Path fix) exception This1.Location.NotAvailable 
class method 
class This1.Path #default##apply(Void patch) 
class method 
mut This0.Patcher #apply(This1.Path patch) 
class method 
mut This0 #apply(fwd mut This1.Composers.RenameMethods openMaps, fwd mut This1.Refactor2.Method close, fwd mut This1.Composers.Libs inputs, fwd Library input, fwd This1.Location.Lib.List ls, fwd This1.Location.Lib l0, fwd This1.Location.Lib.List l0ns, fwd This1.Composers.Selectorss sels) 
mut method 
Void op(This1.Path p, This1.Location.Method m, This1.Size i) 
Over: {
mut method 
Void fillMaps() 
mut method 
Void fillMaps(This2.Location.Lib li, This2.Size i) 
mut method 
Void fillMaps(This2.Location.Lib lij, This2.Composers.Selectors ssj, This2.Path pj, This2.Size i) 
mut method 
This2.Selector superName(This2.Selector selector, This2.Size i) 
class method 
mut This2.Composers.Libs #seqBuilder() 
class method 
mut This0.Decorator #from(mut This2.Composers.Libs seqBuilder) 
mut method 
mut This2.Composers.RenameMethods openMaps() 
mut method 
mut This2.Refactor2.Method close() 
read method 
read This2.Composers.Libs inputs() 
mut method 
mut This2.Composers.Libs #inputs() 
read method 
Library input() 
read method 
This2.Location.Lib.List ls() 
read method 
This2.Location.Lib l0() 
read method 
This2.Location.Lib.List l0ns() 
read method 
This2.Composers.Selectorss sels() 
class method 
mut This0 #apply(mut This2.Composers.Libs libs, Library lib0) 
mut method 
mut This2.Refactor2.Method open(This2.Size that) 
mut method 
Void fillMapsPatch(This2.Location.Lib top, This2.Path fix) 
class method 
mut This0 #apply(Library top, This2.Path fix) exception This2.Location.NotAvailable 
class method 
class This2.Path #default##apply(Void patch) 
class method 
mut This0.Patcher #apply(This2.Path patch) 
class method 
mut This0 #apply(fwd mut This2.Composers.RenameMethods openMaps, fwd mut This2.Refactor2.Method close, fwd mut This2.Composers.Libs inputs, fwd Library input, fwd This2.Location.Lib.List ls, fwd This2.Location.Lib l0, fwd This2.Location.Lib.List l0ns, fwd This2.Composers.Selectorss sels) 
mut method 
Void op(This2.Path p, This2.Location.Method m, This2.Size i) 
Decorator: {
read method 
read This3.Composers.Libs inner() 
mut method 
mut This3.Composers.Libs #inner() 
class method 
mut This0 #apply(mut This3.Composers.Libs inner) 
mut method 
Library #leftrightleft#0left(Library right) exception This3.Refactor2.MethodClash, This3.Refactor2.ClassClash, This3.Refactor2.SubtleSubtypeViolation 
method 
Library foldLeft(Library resolver) exception This3.Refactor2.MethodClash, This3.Refactor2.ClassClash, This3.Refactor2.SubtleSubtypeViolation }
Patcher: {
read method 
This3.Path patch() 
class method 
mut This0 #apply(This3.Path patch) 
mut method 
Library #leftrightleft#0left(Library right) exception This3.Refactor2.MethodClash, This3.Refactor2.ClassClash, This3.Refactor2.SubtleSubtypeViolation, This3.Refactor2.PathUnfit, This3.Refactor2.SelectorUnfit, This3.Refactor2.ClassUnfit, This3.Location.NotAvailable }}
Override: {
mut method 
Void fillMaps() 
mut method 
Void fillMaps(This2.Location.Lib li, This2.Size i) 
mut method 
Void fillMaps(This2.Location.Lib lij, This2.Composers.Selectors ssj, This2.Path pj, This2.Size i) 
mut method 
This2.Selector superName(This2.Selector selector, This2.Size i) 
class method 
mut This2.Composers.Libs #seqBuilder() 
class method 
mut This0.Decorator #from(mut This2.Composers.Libs seqBuilder) 
mut method 
mut This2.Composers.RenameMethods openMaps() 
mut method 
mut This2.Refactor2.Method close() 
read method 
read This2.Composers.Libs inputs() 
mut method 
mut This2.Composers.Libs #inputs() 
read method 
Library input() 
read method 
This2.Location.Lib.List ls() 
read method 
This2.Location.Lib l0() 
read method 
This2.Location.Lib.List l0ns() 
read method 
This2.Composers.Selectorss sels() 
class method 
mut This0 #apply(mut This2.Composers.Libs libs, Library lib0) 
mut method 
mut This2.Refactor2.Method open(This2.Size that) 
mut method 
Void fillMapsPatch(This2.Location.Lib top, This2.Path fix) 
class method 
mut This0 #apply(Library top, This2.Path fix) exception This2.Location.NotAvailable 
class method 
class This2.Path #default##apply(Void patch) 
class method 
mut This0.Patcher #apply(This2.Path patch) 
class method 
mut This0 #apply(fwd mut This2.Composers.RenameMethods openMaps, fwd mut This2.Refactor2.Method close, fwd mut This2.Composers.Libs inputs, fwd Library input, fwd This2.Location.Lib.List ls, fwd This2.Location.Lib l0, fwd This2.Location.Lib.List l0ns, fwd This2.Composers.Selectorss sels) 
mut method 
Void op(This2.Path p, This2.Location.Method m, This2.Size i) 
Decorator: {
read method 
read This3.Composers.Libs inner() 
mut method 
mut This3.Composers.Libs #inner() 
class method 
mut This0 #apply(mut This3.Composers.Libs inner) 
mut method 
Library #leftrightleft#0left(Library right) exception This3.Refactor2.MethodClash, This3.Refactor2.ClassClash, This3.Refactor2.SubtleSubtypeViolation 
method 
Library foldLeft(Library resolver) exception This3.Refactor2.MethodClash, This3.Refactor2.ClassClash, This3.Refactor2.SubtleSubtypeViolation }
Patcher: {
read method 
This3.Path patch() 
class method 
mut This0 #apply(This3.Path patch) 
mut method 
Library #leftrightleft#0left(Library right) exception This3.Refactor2.MethodClash, This3.Refactor2.ClassClash, This3.Refactor2.SubtleSubtypeViolation, This3.Refactor2.PathUnfit, This3.Refactor2.SelectorUnfit, This3.Refactor2.ClassUnfit, This3.Location.NotAvailable }}
Decorator: {
read method 
read This2.Composers.Libs inner() 
mut method 
mut This2.Composers.Libs #inner() 
class method 
mut This0 #apply(mut This2.Composers.Libs inner) 
mut method 
Library #leftrightleft#0left(Library right) exception This2.Refactor2.MethodClash, This2.Refactor2.ClassClash, This2.Refactor2.SubtleSubtypeViolation 
method 
Library foldLeft(Library resolver) exception This2.Refactor2.MethodClash, This2.Refactor2.ClassClash, This2.Refactor2.SubtleSubtypeViolation }
Patcher: {
read method 
This2.Path patch() 
class method 
mut This0 #apply(This2.Path patch) 
mut method 
Library #leftrightleft#0left(Library right) exception This2.Refactor2.MethodClash, This2.Refactor2.ClassClash, This2.Refactor2.SubtleSubtypeViolation, This2.Refactor2.PathUnfit, This2.Refactor2.SelectorUnfit, This2.Refactor2.ClassUnfit, This2.Location.NotAvailable }}
Collections: {
class method 
Library vector(class Any ofMut) 
class method 
Library vector(class Any of) 
class method 
Library minimal(class Any that) 
class method 
Library eq(class Any that) 
IterationFailure: {implements This2.Guard, This2.Message, This2.Concept.Base, This2.Concept.ToS, This2.Concept.Classable, This2.Concept.Equals
refine read method 
class This0 class() 
refine class method /*
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  */This2.S readableName() 
refine class method /*
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  */This2.Bool is(class This2.Concept.Classable subtype) 
refine read method 
This2.Bool #equalequal#0left(read Any right) 
refine class method 
read This0 cast(read This2.Concept.Classable that) 
refine class method 
mut This0 #cast(mut This2.Concept.Classable that) 
read method 
This2.S _text() 
read method 
This2.Message.Opt cause() 
class method 
This0 #apply(This2.S _text, This2.Message.Opt cause) 
refine class method 
This2.S kind() 
refine read method 
This2.S text() 
refine read method 
This2.Message.Opt responseOf() 
method 
This0 #apply(This2.Message that) 
refine read method 
This2.S toS() 
read method 
This2.Bool equals(read This0 that) 
class method 
This0 #apply(This2.S text) 
class method 
This0 #apply(This2.S text, This2.Message cause) 
class method 
mut This2.S.SBuilder #builder() 
class method 
This0 #from(This2.S.SBuilder builder) 
method 
This0.Continue #from(This2.S.SConcat seqBuilder) 
method 
mut This2.S.SConcat #seqBuilder() 
Continue: {
read method 
This3.S that() 
class method 
This0 #apply(This3.S that) 
method 
mut This3.S.SBuilder #builder() 
method 
This1 #from(This3.S.SBuilder builder) }}
CollectionErrors: {
class method 
Any negBound(This2.Size that, This2.Size listSize) 
class method 
Any outBound(This2.Size that, This2.Size listSize) 
class method 
Any cast() 
class method 
Any iterationTermination(This2.Size from, This2.Size minTo, This2.Size size) 
class method 
Void checkBound(This2.Size that, This2.Size listSize) 
class method 
Void checkBoundAdd(This2.Size that, This2.Size listSize) }
MutListAny: {implements This2.Concept.ToS
mut method 
Void head(This0.Cell that) 
read method 
This0.Cell head() 
mut method 
Void size(This2.Size that) 
read method 
This2.Size size() 
class method 
mut This0 #apply(This0.Cell head, This2.Size size) 
class method 
mut This0 empty() 
read method 
Any val(This2.Size that) 
mut method 
Void #apply(This2.Size that, Any val) 
mut method 
Void add(This2.Size that, Any val) 
mut method 
Void remove(This2.Size that) 
method 
This0 without(This2.Size that) 
method 
This0 withAlso(This2.Size that, Any val) 
method 
This0 with(This2.Size that, Any val) 
refine read method 
This2.S toS() 
Cell: {interface 
method 
Any get(This3.Size that) 
method 
This0 set(This3.Size that, Any val, This3.Bool add) 
method 
This0 remove(This3.Size that) }
CellNext: {implements This1.Cell
read method 
Any val() 
read method 
This1.Cell next() 
class method 
mut This0 #apply(Any val, This1.Cell next) 
refine method 
Any get(This3.Size that) 
refine method 
This1.Cell set(This3.Size that, Any val, This3.Bool add) 
refine method 
This1.Cell remove(This3.Size that) }
CellEnd: {implements This1.Cell
class method 
mut This0 #apply() 
refine method 
Any get(This3.Size that) 
refine method 
This1.Cell set(This3.Size that, Any val, This3.Bool add) 
refine method 
This1.Cell remove(This3.Size that) }}
VectorTrait: {
class method 
Library #apply() }
CodeEq: {
class method 
Library #apply() }}
CollectionsMut: {
class method 
Library vector(class Any of) 
class method 
Library minimal(class Any that) 
class method 
Library eq(class Any that) 
IterationFailure: {implements This2.Guard, This2.Message, This2.Concept.Base, This2.Concept.ToS, This2.Concept.Classable, This2.Concept.Equals
refine read method 
class This0 class() 
refine class method /*
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  */This2.S readableName() 
refine class method /*
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  */This2.Bool is(class This2.Concept.Classable subtype) 
refine read method 
This2.Bool #equalequal#0left(read Any right) 
refine class method 
read This0 cast(read This2.Concept.Classable that) 
refine class method 
mut This0 #cast(mut This2.Concept.Classable that) 
read method 
This2.S _text() 
read method 
This2.Message.Opt cause() 
class method 
This0 #apply(This2.S _text, This2.Message.Opt cause) 
refine class method 
This2.S kind() 
refine read method 
This2.S text() 
refine read method 
This2.Message.Opt responseOf() 
method 
This0 #apply(This2.Message that) 
refine read method 
This2.S toS() 
read method 
This2.Bool equals(read This0 that) 
class method 
This0 #apply(This2.S text) 
class method 
This0 #apply(This2.S text, This2.Message cause) 
class method 
mut This2.S.SBuilder #builder() 
class method 
This0 #from(This2.S.SBuilder builder) 
method 
This0.Continue #from(This2.S.SConcat seqBuilder) 
method 
mut This2.S.SConcat #seqBuilder() 
Continue: {
read method 
This3.S that() 
class method 
This0 #apply(This3.S that) 
method 
mut This3.S.SBuilder #builder() 
method 
This1 #from(This3.S.SBuilder builder) }}
CollectionErrors: {
class method 
Any negBound(This2.Size that, This2.Size listSize) 
class method 
Any outBound(This2.Size that, This2.Size listSize) 
class method 
Any cast() 
class method 
Any iterationTermination(This2.Size from, This2.Size minTo, This2.Size size) 
class method 
Void checkBound(This2.Size that, This2.Size listSize) 
class method 
Void checkBoundAdd(This2.Size that, This2.Size listSize) }
MutListAny: {implements This2.Concept.ToS
mut method 
Void head(mut This0.Cell that) 
read method 
read This0.Cell head() 
mut method 
mut This0.Cell #head() 
mut method 
Void size(This2.Size that) 
read method 
This2.Size size() 
class method 
mut This0 #apply(fwd mut This0.Cell head, This2.Size size) 
class method 
mut This0 empty() 
read method 
read Any val(This2.Size that) 
mut method 
mut Any #val(This2.Size that) 
mut method 
Void #apply(This2.Size that, mut Any val) 
mut method 
Void add(This2.Size that, mut Any val) 
mut method 
Void remove(This2.Size that) 
method 
This0 without(This2.Size that) 
method 
This0 withAlso(This2.Size that, Any val) 
method 
This0 with(This2.Size that, Any val) 
refine read method 
This2.S toS() 
Cell: {interface 
read method 
read Any get(This3.Size that) 
mut method 
mut Any #get(This3.Size that) 
read method 
read This0 set(This3.Size that, read Any val, This3.Bool add) 
mut method 
mut This0 #set(This3.Size that, mut Any val, This3.Bool add) 
read method 
read This0 remove(This3.Size that) 
mut method 
mut This0 #remove(This3.Size that) }
CellNext: {implements This1.Cell
read method 
read Any val() 
mut method 
mut Any #val() 
read method 
read This1.Cell next() 
mut method 
mut This1.Cell #next() 
class method 
mut This0 #apply(fwd mut Any val, fwd mut This1.Cell next) 
refine read method 
read Any get(This3.Size that) 
refine mut method 
mut Any #get(This3.Size that) 
refine read method 
read This1.Cell set(This3.Size that, read Any val, This3.Bool add) 
refine mut method 
mut This1.Cell #set(This3.Size that, mut Any val, This3.Bool add) 
refine read method 
read This1.Cell remove(This3.Size that) 
refine mut method 
mut This1.Cell #remove(This3.Size that) }
CellEnd: {implements This1.Cell
class method 
mut This0 #apply() 
refine read method 
read Any get(This3.Size that) 
refine mut method 
mut Any #get(This3.Size that) 
refine read method 
read This1.Cell set(This3.Size that, read Any val, This3.Bool add) 
refine mut method 
mut This1.Cell #set(This3.Size that, mut Any val, This3.Bool add) 
refine read method 
read This1.Cell remove(This3.Size that) 
refine mut method 
mut This1.Cell #remove(This3.Size that) }}
VectorTrait: {
class method 
Library #apply() }
CodeEq: {
class method 
Library #apply() }}
K: {
class method 
Library #leftrightleft#0left(Library right) exception This1.Refactor2.ClassUnfit 
class method 
This0.Decorator #apply(This1.S name, This1.Path path, This1.S excluded, This1.Bool immK, This1.Bool isFwd) 
PlgK: {/*@plugin is.L42.connected.withSafeOperators
@pluginPart is.L42.connected.withSafeOperators.refactor.MakeK
*/
class method 
mut This0 #from(Library binaryRepr) 
read method 
Library #binaryRepr() 
class method 
Void #exceptionIf(Library binaryRepr) exception This0 
class method 
Library makeKJ(Library that, This2.S name, This2.Path path, This2.S excluded, This2.Bool immK, This2.Bool isFwd) 
class method 
Library #pluginUnresponsive(Library binaryRepr) }
Imm: {
class method 
Library #leftrightleft#0left(Library right) exception This2.Refactor2.ClassUnfit }
$: {
class method 
Library #leftrightleft#0left(Library right) exception This2.Refactor2.ClassUnfit }
Decorator: {
read method 
This2.S name() 
read method 
This2.Path path() 
read method 
This2.S excluded() 
read method 
This2.Bool immK() 
read method 
This2.Bool isFwd() 
class method 
This0 #apply(This2.S name, This2.Path path, This2.S excluded, This2.Bool immK, This2.Bool isFwd) 
method 
Library #leftrightleft#0left(Library right) exception This2.Refactor2.ClassUnfit }}
Alphanumeric: {
class method 
Library #leftrightleft#0left(Library right) exception This0.Fail 
ParseFail: {implements This2.Guard.ParseFail, This2.Guard, This2.Message, This2.Concept.Base, This2.Concept.ToS, This2.Concept.Classable, This2.Concept.Equals
refine read method 
class This0 class() 
refine class method /*
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  */This2.S readableName() 
refine class method /*
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  */This2.Bool is(class This2.Concept.Classable subtype) 
refine read method 
This2.Bool #equalequal#0left(read Any right) 
refine class method 
read This0 cast(read This2.Concept.Classable that) 
refine class method 
mut This0 #cast(mut This2.Concept.Classable that) 
read method 
This2.S _text() 
read method 
This2.Message.Opt cause() 
class method 
This0 #apply(This2.S _text, This2.Message.Opt cause) 
refine class method 
This2.S kind() 
refine read method 
This2.S text() 
refine read method 
This2.Message.Opt responseOf() 
method 
This0 #apply(This2.Message that) 
refine read method 
This2.S toS() 
read method 
This2.Bool equals(read This0 that) 
class method 
This0 #apply(This2.S text) 
class method 
This0 #apply(This2.S text, This2.Message cause) 
class method 
mut This2.S.SBuilder #builder() 
class method 
This0 #from(This2.S.SBuilder builder) 
method 
This0.Continue #from(This2.S.SConcat seqBuilder) 
method 
mut This2.S.SConcat #seqBuilder() 
Continue: {
read method 
This3.S that() 
class method 
This0 #apply(This3.S that) 
method 
mut This3.S.SBuilder #builder() 
method 
This1 #from(This3.S.SBuilder builder) }}
Fail: {implements This2.Guard, This2.Message, This2.Concept.Base, This2.Concept.ToS, This2.Concept.Classable, This2.Concept.Equals
refine read method 
class This0 class() 
refine class method /*
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  */This2.S readableName() 
refine class method /*
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  */This2.Bool is(class This2.Concept.Classable subtype) 
refine read method 
This2.Bool #equalequal#0left(read Any right) 
refine class method 
read This0 cast(read This2.Concept.Classable that) 
refine class method 
mut This0 #cast(mut This2.Concept.Classable that) 
read method 
This2.S _text() 
read method 
This2.Message.Opt cause() 
class method 
This0 #apply(This2.S _text, This2.Message.Opt cause) 
refine class method 
This2.S kind() 
refine read method 
This2.S text() 
refine read method 
This2.Message.Opt responseOf() 
method 
This0 #apply(This2.Message that) 
refine read method 
This2.S toS() 
read method 
This2.Bool equals(read This0 that) 
class method 
This0 #apply(This2.S text) 
class method 
This0 #apply(This2.S text, This2.Message cause) 
class method 
mut This2.S.SBuilder #builder() 
class method 
This0 #from(This2.S.SBuilder builder) 
method 
This0.Continue #from(This2.S.SConcat seqBuilder) 
method 
mut This2.S.SConcat #seqBuilder() 
Continue: {
read method 
This3.S that() 
class method 
This0 #apply(This3.S that) 
method 
mut This3.S.SBuilder #builder() 
method 
This1 #from(This3.S.SBuilder builder) }}
Trait: {
class method 
Any val() 
class method 
Library #apply() }}
DeployTowel: {/*@untrusted
*/
read method 
This1.Url fileName() 
class method 
mut This0 #$(This1.Url fileName) 
mut method 
Library #leftrightleft#0left(Library right) 
FileSystemAccess:/*@_private
*/ {/*@plugin
L42.is/connected/withFileSystem
*/}}
Composers: {/*
Main feature of Composers:
you implement an
  mut method Void op(Path p, Location.Method m, Size i)
       op(p,meth,i) for example can be
         s=meth.selector()
         s2=this.superName(s,i)
         this.open(i).op(p,s,s2)//#add(rename:s of:p into:s2)
         this.close().op(p,s2)//hide selector of
*/
class method 
Library composerTrait() 
class method 
read Library #leftrightleft#0left(Library right) exception This1.Refactor2.MethodClash, This1.Refactor2.ClassClash, This1.Refactor2.SubtleSubtypeViolation 
class method 
This1.Location.Lib.List filterClash(This1.Location.Lib.List ls) 
class method 
This0.Selectors filterClash(This1.Location.Method.List ms) 
class method 
This1.Bool noClash(This1.Location.Method m) 
class method 
This1.Bool noClash(This1.Location.Lib l) 
class method 
This1.Path removePrefix(This1.Path path, This1.Path prefix) 
Selectors: {implements This2.Concept.ToS, This2.Concept.Classable, This2.Concept.Equals
refine class method /*
  Cast a (read/imm) object to this type.
  A class implementing this method should refine the return type to This.
  if is(subtype) is true, then cast(that) must produce a result.
  */read This0 cast(read This2.Concept.Classable that) 
refine class method /*
  Cast a (mutable) object to this type.
  A class implementing this method should refine the return type to This.
  if cast(that) produces a result, then #cast(that) also must produce a result.
  */mut This0 #cast(mut This2.Concept.Classable that) 
refine read method /*
  Extracts the class singleton from another instance of this class
  */class This0 class() 
refine class method /*
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  */This2.S readableName() 
refine class method /*
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  */This2.Bool is(class This2.Concept.Classable subtype) 
read method 
read This2.Collections.MutListAny inner() 
mut method 
mut This2.Collections.MutListAny #inner() 
class method 
mut This0 #apply(fwd mut This2.Collections.MutListAny inner) 
class method 
This0 #immK(This2.Collections.MutListAny inner) 
class method 
mut This0 empty() 
read method 
mut This0 reverse() 
read method 
This2.Bool isEmpty() 
read method 
class This2.Size #default#val(Void that) 
read method 
This2.Selector left() 
read method 
This2.Selector right() 
mut method 
Void #apply(This2.Size that, This2.Selector val) 
mut method 
Void left(This2.Selector that) 
mut method 
Void right(This2.Selector that) 
mut method 
Void add(This2.Size that, This2.Selector val) 
mut method 
Void add(This2.Selector right) 
mut method 
Void add(This2.Selector left) 
mut method 
Void removeLeft() 
mut method 
Void removeRight() 
method 
This0 #plus#0left(This2.Selector right) 
method 
This0 #plusplus#0left(This0 right) 
method 
This0 with(This2.Size that, This2.Selector val) 
method 
This0 withLeft(This2.Selector that) 
method 
This0 withRight(This2.Selector that) 
method 
This0 withAlso(This2.Size that, This2.Selector val) 
method 
This0 withAlsoLeft(This2.Selector that) 
method 
This0 withAlsoRight(This2.Selector that) 
method 
This0 withoutLeft() 
method 
This0 withoutRight() 
read method 
lent This0.IteratorVal vals(This2.Size from, This2.Size maxTo, This2.Size minTo) 
read method 
lent This0.IteratorVal vals(This2.Size minTo) 
read method 
lent This0.IteratorVal vals(This2.Size from, This2.Size to) 
read method 
lent This0.IteratorValFill vals(This2.Size from, This2.Size maxTo, This2.Size minTo, This2.Selector filled) 
read method 
lent This0.IteratorValFill vals(This2.Size minTo, This2.Selector filled) 
read method 
lent This0.IteratorValFill vals(This2.Size from, This2.Size to, This2.Selector filled) 
read method 
lent This0.IteratorValFill vals(This2.Selector filled) 
mut method 
lent This0.IteratorVar #vals(This2.Size from, This2.Size maxTo, This2.Size minTo) 
mut method 
lent This0.IteratorVar #vals(This2.Size minTo) 
mut method 
lent This0.IteratorVar #vals(This2.Size from, This2.Size to) 
mut method 
lent This0.IteratorVar #vals() 
refine read method 
This2.S toS() 
read method 
This2.Size size() 
read method 
This2.Selector val(This2.Size that) 
class method 
mut This0 #seqBuilder() 
class method 
mut This0 #from(mut This0 seqBuilder) 
mut method 
Void #add(This2.Selector that) 
read method 
lent This0.IteratorVal vals() 
read method 
This2.Bool contains(This2.Selector that) 
method 
This0 #less#0left(This2.Selector right) 
method 
This0 #lessless#0left(This0 right) 
method 
This0 #and#0left(This0 right) 
method 
This2.Bool #rightright#0left(This0 right) 
method 
This2.Bool #rightrightequal#0left(This0 right) 
method 
This2.Bool #right#0left(This2.Selector right) 
read method 
This2.Bool equals(read This0 that) 
refine read method 
This2.Bool #equalequal#0left(read Any right) 
read method 
This2.Size indexOfLeft(This2.Selector val) 
read method 
This2.Size indexOfRight(This2.Selector val) 
method /*from VectorTrait
*/This0 without(This2.Size index) 
method 
This0 withoutLeft(This2.Selector val) 
method 
This0 withoutRight(This2.Selector val) 
method 
This0 withoutAll(This2.Selector val) 
mut method /*from VectorTrait
*/Void remove(This2.Size that) 
mut method 
Void removeAll(This2.Selector val) 
mut method 
Void removeLeft(This2.Selector val) 
mut method 
Void removeRight(This2.Selector val) 
Cast: {
class method 
This3.Selector #apply(Any that) }
IteratorTrait: {
class method 
Library #apply() }
IteratorValFill: {
mut method 
Void #next() exception Void 
read method 
Void #checkEnd() 
read method 
This3.Selector #inner() 
read method 
Void #close() 
read method 
read This3.Collections.MutListAny _that() 
mut method 
Void from(This3.Size that) 
read method 
This3.Size from() 
read method 
This3.Size maxTo() 
read method 
This3.Size minTo() 
read method 
This3.Selector filled() 
read method 
read This3.Collections.MutListAny that() 
class method 
lent This0 #apply(read This3.Collections.MutListAny _that, This3.Size from, This3.Size maxTo, This3.Size minTo, This3.Selector filled) 
class method 
lent This0 #apply(read This3.Collections.MutListAny that, This3.Size from, This3.Size maxTo, This3.Size minTo, This3.Selector filled) 
read method 
This3.Bool isFill() }
IteratorVar: {
mut method 
Void #next() exception Void 
read method 
Void #checkEnd() 
read method 
This3.Selector #inner() 
read method 
Void #close() 
read method 
read This3.Collections.MutListAny that() 
mut method 
mut This3.Collections.MutListAny #that() 
mut method 
Void from(This3.Size that) 
read method 
This3.Size from() 
read method 
This3.Size maxTo() 
read method 
This3.Size minTo() 
class method 
mut This0 #apply(mut This3.Collections.MutListAny that, This3.Size from, This3.Size maxTo, This3.Size minTo) 
mut method 
Void inner(This3.Selector that) 
read method 
This3.Bool isFill() 
read method 
This3.Selector filled() }
IteratorVal: {
read method 
read This3.Collections.MutListAny _that() 
mut method 
Void from(This3.Size that) 
read method 
This3.Size from() 
read method 
This3.Size maxTo() 
read method 
This3.Size minTo() 
read method 
read This3.Collections.MutListAny that() 
class method 
lent This0 #apply(read This3.Collections.MutListAny _that, This3.Size from, This3.Size maxTo, This3.Size minTo) 
class method 
lent This0 #apply(read This3.Collections.MutListAny that, This3.Size from, This3.Size maxTo, This3.Size minTo) 
read method 
This3.Bool isFill() 
read method 
This3.Selector filled() 
mut method 
Void #next() exception Void 
read method 
Void #checkEnd() 
read method 
This3.Selector #inner() 
read method 
Void #close() }}
Selectorss: {implements This2.Concept.ToS, This2.Concept.Classable, This2.Concept.Equals
refine class method /*
  Cast a (read/imm) object to this type.
  A class implementing this method should refine the return type to This.
  if is(subtype) is true, then cast(that) must produce a result.
  */read This0 cast(read This2.Concept.Classable that) 
refine class method /*
  Cast a (mutable) object to this type.
  A class implementing this method should refine the return type to This.
  if cast(that) produces a result, then #cast(that) also must produce a result.
  */mut This0 #cast(mut This2.Concept.Classable that) 
refine read method /*
  Extracts the class singleton from another instance of this class
  */class This0 class() 
refine class method /*
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  */This2.S readableName() 
refine class method /*
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  */This2.Bool is(class This2.Concept.Classable subtype) 
read method 
read This2.Collections.MutListAny inner() 
mut method 
mut This2.Collections.MutListAny #inner() 
class method 
mut This0 #apply(fwd mut This2.Collections.MutListAny inner) 
class method 
This0 #immK(This2.Collections.MutListAny inner) 
class method 
mut This0 empty() 
read method 
mut This0 reverse() 
read method 
This2.Bool isEmpty() 
read method 
class This2.Size #default#val(Void that) 
read method 
This1.Selectors left() 
read method 
This1.Selectors right() 
mut method 
Void #apply(This2.Size that, This1.Selectors val) 
mut method 
Void left(This1.Selectors that) 
mut method 
Void right(This1.Selectors that) 
mut method 
Void add(This2.Size that, This1.Selectors val) 
mut method 
Void add(This1.Selectors right) 
mut method 
Void add(This1.Selectors left) 
mut method 
Void removeLeft() 
mut method 
Void removeRight() 
method 
This0 #plus#0left(This1.Selectors right) 
method 
This0 #plusplus#0left(This0 right) 
method 
This0 with(This2.Size that, This1.Selectors val) 
method 
This0 withLeft(This1.Selectors that) 
method 
This0 withRight(This1.Selectors that) 
method 
This0 withAlso(This2.Size that, This1.Selectors val) 
method 
This0 withAlsoLeft(This1.Selectors that) 
method 
This0 withAlsoRight(This1.Selectors that) 
method 
This0 withoutLeft() 
method 
This0 withoutRight() 
read method 
lent This0.IteratorVal vals(This2.Size from, This2.Size maxTo, This2.Size minTo) 
read method 
lent This0.IteratorVal vals(This2.Size minTo) 
read method 
lent This0.IteratorVal vals(This2.Size from, This2.Size to) 
read method 
lent This0.IteratorValFill vals(This2.Size from, This2.Size maxTo, This2.Size minTo, This1.Selectors filled) 
read method 
lent This0.IteratorValFill vals(This2.Size minTo, This1.Selectors filled) 
read method 
lent This0.IteratorValFill vals(This2.Size from, This2.Size to, This1.Selectors filled) 
read method 
lent This0.IteratorValFill vals(This1.Selectors filled) 
mut method 
lent This0.IteratorVar #vals(This2.Size from, This2.Size maxTo, This2.Size minTo) 
mut method 
lent This0.IteratorVar #vals(This2.Size minTo) 
mut method 
lent This0.IteratorVar #vals(This2.Size from, This2.Size to) 
mut method 
lent This0.IteratorVar #vals() 
refine read method 
This2.S toS() 
read method 
This2.Size size() 
read method 
This1.Selectors val(This2.Size that) 
class method 
mut This0 #seqBuilder() 
class method 
mut This0 #from(mut This0 seqBuilder) 
mut method 
Void #add(This1.Selectors that) 
read method 
lent This0.IteratorVal vals() 
read method 
This2.Bool contains(This1.Selectors that) 
method 
This0 #less#0left(This1.Selectors right) 
method 
This0 #lessless#0left(This0 right) 
method 
This0 #and#0left(This0 right) 
method 
This2.Bool #rightright#0left(This0 right) 
method 
This2.Bool #rightrightequal#0left(This0 right) 
method 
This2.Bool #right#0left(This1.Selectors right) 
read method 
This2.Bool equals(read This0 that) 
refine read method 
This2.Bool #equalequal#0left(read Any right) 
read method 
This2.Size indexOfLeft(This1.Selectors val) 
read method 
This2.Size indexOfRight(This1.Selectors val) 
method /*from VectorTrait
*/This0 without(This2.Size index) 
method 
This0 withoutLeft(This1.Selectors val) 
method 
This0 withoutRight(This1.Selectors val) 
method 
This0 withoutAll(This1.Selectors val) 
mut method /*from VectorTrait
*/Void remove(This2.Size that) 
mut method 
Void removeAll(This1.Selectors val) 
mut method 
Void removeLeft(This1.Selectors val) 
mut method 
Void removeRight(This1.Selectors val) 
Cast: {
class method 
This2.Selectors #apply(Any that) }
IteratorTrait: {
class method 
Library #apply() }
IteratorValFill: {
mut method 
Void #next() exception Void 
read method 
Void #checkEnd() 
read method 
This2.Selectors #inner() 
read method 
Void #close() 
read method 
read This3.Collections.MutListAny _that() 
mut method 
Void from(This3.Size that) 
read method 
This3.Size from() 
read method 
This3.Size maxTo() 
read method 
This3.Size minTo() 
read method 
This2.Selectors filled() 
read method 
read This3.Collections.MutListAny that() 
class method 
lent This0 #apply(read This3.Collections.MutListAny _that, This3.Size from, This3.Size maxTo, This3.Size minTo, This2.Selectors filled) 
class method 
lent This0 #apply(read This3.Collections.MutListAny that, This3.Size from, This3.Size maxTo, This3.Size minTo, This2.Selectors filled) 
read method 
This3.Bool isFill() }
IteratorVar: {
mut method 
Void #next() exception Void 
read method 
Void #checkEnd() 
read method 
This2.Selectors #inner() 
read method 
Void #close() 
read method 
read This3.Collections.MutListAny that() 
mut method 
mut This3.Collections.MutListAny #that() 
mut method 
Void from(This3.Size that) 
read method 
This3.Size from() 
read method 
This3.Size maxTo() 
read method 
This3.Size minTo() 
class method 
mut This0 #apply(mut This3.Collections.MutListAny that, This3.Size from, This3.Size maxTo, This3.Size minTo) 
mut method 
Void inner(This2.Selectors that) 
read method 
This3.Bool isFill() 
read method 
This2.Selectors filled() }
IteratorVal: {
read method 
read This3.Collections.MutListAny _that() 
mut method 
Void from(This3.Size that) 
read method 
This3.Size from() 
read method 
This3.Size maxTo() 
read method 
This3.Size minTo() 
read method 
read This3.Collections.MutListAny that() 
class method 
lent This0 #apply(read This3.Collections.MutListAny _that, This3.Size from, This3.Size maxTo, This3.Size minTo) 
class method 
lent This0 #apply(read This3.Collections.MutListAny that, This3.Size from, This3.Size maxTo, This3.Size minTo) 
read method 
This3.Bool isFill() 
read method 
This2.Selectors filled() 
mut method 
Void #next() exception Void 
read method 
Void #checkEnd() 
read method 
This2.Selectors #inner() 
read method 
Void #close() }}
RenameMethods: {implements This2.Concept.ToS, This2.Concept.Classable
refine class method /*
  Cast a (read/imm) object to this type.
  A class implementing this method should refine the return type to This.
  if is(subtype) is true, then cast(that) must produce a result.
  */read This0 cast(read This2.Concept.Classable that) 
refine class method /*
  Cast a (mutable) object to this type.
  A class implementing this method should refine the return type to This.
  if cast(that) produces a result, then #cast(that) also must produce a result.
  */mut This0 #cast(mut This2.Concept.Classable that) 
refine read method /*
  Extracts the class singleton from another instance of this class
  */class This0 class() 
refine class method /*
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  */This2.S readableName() 
refine class method /*
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  */This2.Bool is(class This2.Concept.Classable subtype) 
read method 
read This2.CollectionsMut.MutListAny inner() 
mut method 
mut This2.CollectionsMut.MutListAny #inner() 
class method 
mut This0 #apply(fwd mut This2.CollectionsMut.MutListAny inner) 
class method 
This0 #immK(This2.CollectionsMut.MutListAny inner) 
class method 
mut This0 empty() 
class method 
mut This0 #seqBuilder() 
class method 
mut This0 #from(mut This0 seqBuilder) 
mut method 
Void #add(mut This2.Refactor2.Method that) 
mut method 
mut This0 #reverse() 
read method 
This2.Size size() 
read method 
This2.Bool isEmpty() 
read method 
read This2.Refactor2.Method val(This2.Size that) 
mut method 
mut This2.Refactor2.Method #val(This2.Size that) 
read method 
class This2.Size #default#val(Void that) 
read method 
read This2.Refactor2.Method left() 
read method 
read This2.Refactor2.Method right() 
mut method 
mut This2.Refactor2.Method #left() 
mut method 
mut This2.Refactor2.Method #right() 
mut method 
Void #apply(This2.Size that, mut This2.Refactor2.Method val) 
mut method 
Void left(mut This2.Refactor2.Method that) 
mut method 
Void right(mut This2.Refactor2.Method that) 
mut method 
Void add(This2.Size that, mut This2.Refactor2.Method val) 
mut method 
Void add(mut This2.Refactor2.Method right) 
mut method 
Void add(mut This2.Refactor2.Method left) 
mut method 
Void remove(This2.Size that) 
mut method 
Void removeLeft() 
mut method 
Void removeRight() 
method 
This0 #plus#0left(This2.Refactor2.Method right) 
method 
This0 #plusplus#0left(This0 right) 
method 
This0 with(This2.Size that, This2.Refactor2.Method val) 
method 
This0 withLeft(This2.Refactor2.Method that) 
method 
This0 withRight(This2.Refactor2.Method that) 
method 
This0 withAlso(This2.Size that, This2.Refactor2.Method val) 
method 
This0 withAlsoLeft(This2.Refactor2.Method that) 
method 
This0 withAlsoRight(This2.Refactor2.Method that) 
method 
This0 without(This2.Size index) 
method 
This0 withoutLeft() 
method 
This0 withoutRight() 
read method 
lent This0.IteratorVal vals(This2.Size from, This2.Size maxTo, This2.Size minTo) 
read method 
lent This0.IteratorVal vals(This2.Size minTo) 
read method 
lent This0.IteratorVal vals(This2.Size from, This2.Size to) 
read method 
lent This0.IteratorVal vals() 
read method 
lent This0.IteratorValFill vals(This2.Size from, This2.Size maxTo, This2.Size minTo, read This2.Refactor2.Method filled) 
read method 
lent This0.IteratorValFill vals(This2.Size minTo, read This2.Refactor2.Method filled) 
read method 
lent This0.IteratorValFill vals(This2.Size from, This2.Size to, read This2.Refactor2.Method filled) 
read method 
lent This0.IteratorValFill vals(read This2.Refactor2.Method filled) 
mut method 
mut This0.IteratorVar #vals(This2.Size from, This2.Size maxTo, This2.Size minTo) 
mut method 
mut This0.IteratorVar #vals(This2.Size minTo) 
mut method 
mut This0.IteratorVar #vals(This2.Size from, This2.Size to) 
mut method 
mut This0.IteratorVar #vals() 
refine read method 
This2.S toS() 
Cast: {
class method 
read This3.Refactor2.Method #apply(read Any that) 
class method 
mut This3.Refactor2.Method mut(mut Any that) }
IteratorTrait: {
class method 
Library #apply() }
IteratorVal: {
mut method 
Void #next() exception Void 
read method 
Void #checkEnd() 
read method 
read This3.Refactor2.Method readInner() 
mut method 
mut This3.Refactor2.Method mutInner() 
read method 
Void #close() 
mut method 
Void from(This3.Size that) 
read method 
This3.Size from() 
read method 
This3.Size maxTo() 
read method 
This3.Size minTo() 
read method 
read This3.CollectionsMut.MutListAny that() 
mut method 
mut This3.CollectionsMut.MutListAny #that() 
class method 
lent This0 #apply(read This3.CollectionsMut.MutListAny that, This3.Size from, This3.Size maxTo, This3.Size minTo) 
read method 
read This3.Refactor2.Method #inner() 
read method 
This3.Bool isFill() 
read method 
read This3.Refactor2.Method filled() 
mut method 
mut This3.Refactor2.Method #filled() }
IteratorValFill: {
mut method 
Void #next() exception Void 
read method 
Void #checkEnd() 
read method 
read This3.Refactor2.Method readInner() 
mut method 
mut This3.Refactor2.Method mutInner() 
read method 
Void #close() 
mut method 
Void from(This3.Size that) 
read method 
This3.Size from() 
read method 
This3.Size maxTo() 
read method 
This3.Size minTo() 
read method 
read This3.Refactor2.Method filled() 
mut method 
mut This3.Refactor2.Method #filled() 
read method 
read This3.CollectionsMut.MutListAny that() 
mut method 
mut This3.CollectionsMut.MutListAny #that() 
class method 
lent This0 #apply(read This3.CollectionsMut.MutListAny that, This3.Size from, This3.Size maxTo, This3.Size minTo, read This3.Refactor2.Method filled) 
read method 
read This3.Refactor2.Method #inner() 
read method 
This3.Bool isFill() }
IteratorVar: {
mut method 
Void #next() exception Void 
read method 
Void #checkEnd() 
read method 
read This3.Refactor2.Method readInner() 
mut method 
mut This3.Refactor2.Method mutInner() 
read method 
Void #close() 
read method 
read This3.CollectionsMut.MutListAny that() 
mut method 
mut This3.CollectionsMut.MutListAny #that() 
mut method 
Void from(This3.Size that) 
read method 
This3.Size from() 
read method 
This3.Size maxTo() 
read method 
This3.Size minTo() 
class method 
mut This0 #apply(mut This3.CollectionsMut.MutListAny that, This3.Size from, This3.Size maxTo, This3.Size minTo) 
mut method 
Void inner(mut This3.Refactor2.Method that) 
mut method 
mut This3.Refactor2.Method #inner() 
read method 
This3.Bool isFill() 
read method 
read This3.Refactor2.Method filled() 
mut method 
mut This3.Refactor2.Method #filled() }}
Libs: {implements This2.Concept.ToS, This2.Concept.Classable
refine class method /*
  Cast a (read/imm) object to this type.
  A class implementing this method should refine the return type to This.
  if is(subtype) is true, then cast(that) must produce a result.
  */read This0 cast(read This2.Concept.Classable that) 
refine class method /*
  Cast a (mutable) object to this type.
  A class implementing this method should refine the return type to This.
  if cast(that) produces a result, then #cast(that) also must produce a result.
  */mut This0 #cast(mut This2.Concept.Classable that) 
refine read method /*
  Extracts the class singleton from another instance of this class
  */class This0 class() 
refine class method /*
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  */This2.S readableName() 
refine class method /*
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  */This2.Bool is(class This2.Concept.Classable subtype) 
read method 
read This2.Collections.MutListAny inner() 
mut method 
mut This2.Collections.MutListAny #inner() 
class method 
mut This0 #apply(fwd mut This2.Collections.MutListAny inner) 
class method 
This0 #immK(This2.Collections.MutListAny inner) 
class method 
mut This0 empty() 
class method 
mut This0 #seqBuilder() 
class method 
mut This0 #from(mut This0 seqBuilder) 
mut method 
Void #add(Library that) 
read method 
mut This0 reverse() 
read method 
This2.Size size() 
read method 
This2.Bool isEmpty() 
read method 
Library val(This2.Size that) 
read method 
class This2.Size #default#val(Void that) 
read method 
Library left() 
read method 
Library right() 
mut method 
Void #apply(This2.Size that, Library val) 
mut method 
Void left(Library that) 
mut method 
Void right(Library that) 
mut method 
Void add(This2.Size that, Library val) 
mut method 
Void add(Library right) 
mut method 
Void add(Library left) 
mut method 
Void remove(This2.Size that) 
mut method 
Void removeLeft() 
mut method 
Void removeRight() 
method 
This0 #plus#0left(Library right) 
method 
This0 #plusplus#0left(This0 right) 
method 
This0 with(This2.Size that, Library val) 
method 
This0 withLeft(Library that) 
method 
This0 withRight(Library that) 
method 
This0 withAlso(This2.Size that, Library val) 
method 
This0 withAlsoLeft(Library that) 
method 
This0 withAlsoRight(Library that) 
method 
This0 without(This2.Size index) 
method 
This0 withoutLeft() 
method 
This0 withoutRight() 
read method 
lent This0.IteratorVal vals(This2.Size from, This2.Size maxTo, This2.Size minTo) 
read method 
lent This0.IteratorVal vals(This2.Size minTo) 
read method 
lent This0.IteratorVal vals(This2.Size from, This2.Size to) 
read method 
lent This0.IteratorVal vals() 
read method 
lent This0.IteratorValFill vals(This2.Size from, This2.Size maxTo, This2.Size minTo, Library filled) 
read method 
lent This0.IteratorValFill vals(This2.Size minTo, Library filled) 
read method 
lent This0.IteratorValFill vals(This2.Size from, This2.Size to, Library filled) 
read method 
lent This0.IteratorValFill vals(Library filled) 
mut method 
lent This0.IteratorVar #vals(This2.Size from, This2.Size maxTo, This2.Size minTo) 
mut method 
lent This0.IteratorVar #vals(This2.Size minTo) 
mut method 
lent This0.IteratorVar #vals(This2.Size from, This2.Size to) 
mut method 
lent This0.IteratorVar #vals() 
refine read method 
This2.S toS() 
Cast: {
class method 
Library #apply(Any that) }
IteratorTrait: {
class method 
Library #apply() }
IteratorVal: {
mut method 
Void #next() exception Void 
read method 
Void #checkEnd() 
read method 
Library #inner() 
read method 
Void #close() 
read method 
read This3.Collections.MutListAny _that() 
mut method 
Void from(This3.Size that) 
read method 
This3.Size from() 
read method 
This3.Size maxTo() 
read method 
This3.Size minTo() 
read method 
read This3.Collections.MutListAny that() 
class method 
lent This0 #apply(read This3.Collections.MutListAny _that, This3.Size from, This3.Size maxTo, This3.Size minTo) 
class method 
lent This0 #apply(read This3.Collections.MutListAny that, This3.Size from, This3.Size maxTo, This3.Size minTo) 
read method 
This3.Bool isFill() 
read method 
Library filled() }
IteratorValFill: {
mut method 
Void #next() exception Void 
read method 
Void #checkEnd() 
read method 
Library #inner() 
read method 
Void #close() 
read method 
read This3.Collections.MutListAny _that() 
mut method 
Void from(This3.Size that) 
read method 
This3.Size from() 
read method 
This3.Size maxTo() 
read method 
This3.Size minTo() 
read method 
Library filled() 
read method 
read This3.Collections.MutListAny that() 
class method 
lent This0 #apply(read This3.Collections.MutListAny _that, This3.Size from, This3.Size maxTo, This3.Size minTo, Library filled) 
class method 
lent This0 #apply(read This3.Collections.MutListAny that, This3.Size from, This3.Size maxTo, This3.Size minTo, Library filled) 
read method 
This3.Bool isFill() }
IteratorVar: {
mut method 
Void #next() exception Void 
read method 
Void #checkEnd() 
read method 
Library #inner() 
read method 
Void #close() 
read method 
read This3.Collections.MutListAny that() 
mut method 
mut This3.Collections.MutListAny #that() 
mut method 
Void from(This3.Size that) 
read method 
This3.Size from() 
read method 
This3.Size maxTo() 
read method 
This3.Size minTo() 
class method 
mut This0 #apply(mut This3.Collections.MutListAny that, This3.Size from, This3.Size maxTo, This3.Size minTo) 
mut method 
Void inner(Library that) 
read method 
This3.Bool isFill() 
read method 
Library filled() }}}
Load: {/*shape of a loadable library:
 This contains actual library, but
 Abstract:{} contains abstract classes, and
 Abstract.ConceptMap maps concepts names to abstract classes
*/
class method 
Library cacheTowel() 
class method 
Library #leftrightleft#0left(Library right) exception This0.ConceptMapMismatch, This0.ConceptMapUnavailable 
ConceptMapMismatch: {implements This2.Guard, This2.Message, This2.Concept.Base, This2.Concept.ToS, This2.Concept.Classable, This2.Concept.Equals
refine read method 
class This0 class() 
refine class method /*
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  */This2.S readableName() 
refine class method /*
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  */This2.Bool is(class This2.Concept.Classable subtype) 
refine read method 
This2.Bool #equalequal#0left(read Any right) 
refine class method 
read This0 cast(read This2.Concept.Classable that) 
refine class method 
mut This0 #cast(mut This2.Concept.Classable that) 
read method 
This2.S _text() 
read method 
This2.Message.Opt cause() 
class method 
This0 #apply(This2.S _text, This2.Message.Opt cause) 
refine class method 
This2.S kind() 
refine read method 
This2.S text() 
refine read method 
This2.Message.Opt responseOf() 
method 
This0 #apply(This2.Message that) 
refine read method 
This2.S toS() 
read method 
This2.Bool equals(read This0 that) 
class method 
This0 #apply(This2.S text) 
class method 
This0 #apply(This2.S text, This2.Message cause) 
class method 
mut This2.S.SBuilder #builder() 
class method 
This0 #from(This2.S.SBuilder builder) 
method 
This0.Continue #from(This2.S.SConcat seqBuilder) 
method 
mut This2.S.SConcat #seqBuilder() 
Continue: {
read method 
This3.S that() 
class method 
This0 #apply(This3.S that) 
method 
mut This3.S.SBuilder #builder() 
method 
This1 #from(This3.S.SBuilder builder) }}
ConceptMapUnavailable: {implements This2.Guard, This2.Message, This2.Concept.Base, This2.Concept.ToS, This2.Concept.Classable, This2.Concept.Equals
refine read method 
class This0 class() 
refine class method /*
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  
  A readable name for this class. Do not need to follow the rule of paths,
  and once defined will not be automatically influenced by
  base metaprogramming operations.
  */This2.S readableName() 
refine class method /*
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  
  subtype test; similar to java 'instanceof'.
  if is(subtype) is true, then cast(that) must produce a result.
  */This2.Bool is(class This2.Concept.Classable subtype) 
refine read method 
This2.Bool #equalequal#0left(read Any right) 
refine class method 
read This0 cast(read This2.Concept.Classable that) 
refine class method 
mut This0 #cast(mut This2.Concept.Classable that) 
read method 
This2.S _text() 
read method 
This2.Message.Opt cause() 
class method 
This0 #apply(This2.S _text, This2.Message.Opt cause) 
refine class method 
This2.S kind() 
refine read method 
This2.S text() 
refine read method 
This2.Message.Opt responseOf() 
method 
This0 #apply(This2.Message that) 
refine read method 
This2.S toS() 
read method 
This2.Bool equals(read This0 that) 
class method 
This0 #apply(This2.S text) 
class method 
This0 #apply(This2.S text, This2.Message cause) 
class method 
mut This2.S.SBuilder #builder() 
class method 
This0 #from(This2.S.SBuilder builder) 
method 
This0.Continue #from(This2.S.SConcat seqBuilder) 
method 
mut This2.S.SConcat #seqBuilder() 
Continue: {
read method 
This3.S that() 
class method 
This0 #apply(This3.S that) 
method 
mut This3.S.SBuilder #builder() 
method 
This1 #from(This3.S.SBuilder builder) }}
DeployLibrary: {/*@untrusted
*/
read method 
This2.Path path() 
read method 
This2.Url url() 
class method 
mut This0 #$(This2.Path path, This2.Url url) 
class method 
Library moveToAbstract(This2.Path that, Library of) 
class method 
This2.X.AssertionFail msg(This2.Path that, Library of) 
class method 
Library exposeAsLibrary(Library that, This2.Path path) exception This2.Refactor2.PathUnfit, This2.Refactor2.PrivacyCoupuled, This2.Location.NotAvailable 
class method 
Void checkTargetExists(Library that, This2.Path path) exception This2.Refactor2.PathUnfit 
mut method 
Library #leftrightleft#0left(Library right) exception This2.Refactor2.PathUnfit, This2.Refactor2.PrivacyCoupuled, This2.Location.NotAvailable }}}
GuiPlugin: {/*@plugin
L42.is/connected/withHtml
*/}
Iterator: {/*@untrusted
*/
read method 
This1.Abstract.S id() 
mut method 
Void current(This1.Abstract.S that) 
read method 
This1.Abstract.S current() 
class method 
This1.Abstract.S #$auxFetchEvent(This1.Abstract.S id) exception Void (
  Void unused31562=(
    Library s=use This1.GuiPlugin check eventPending(wName:id.#binaryRepr()) exception void
    
    catch error Library x exception void
    
    (
      Void unused31563=return This1.Abstract.S.#from(binaryRepr:s)
      void
      )
    )
  
  catch return capsule This1.Abstract.S result163 result163
  
  error  {/*@stringU
CurlyBlock-Should be unreachable code
*/}
  )
mut method 
Void #next() exception Void (
  Void unused31564=(
    This1.Abstract.S s=This0.#$auxFetchEvent(id:this.id())
    Void unused31565=return this.current(that:s)
    void
    )
  
  catch return Void result164 result164
  
  error  {/*@stringU
CurlyBlock-Should be unreachable code
*/}
  )
read method 
Void #checkEnd() void
read method 
This1.Abstract.S #inner() (this.current())
read method 
Void #close() void
class method 
mut This0 #$(fwd This1.Abstract.S id, fwd This1.Abstract.S current) }}