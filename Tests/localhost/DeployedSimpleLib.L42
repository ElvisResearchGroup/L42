{'could be in another file

Abstract:{
Load:{'shape of a loadable library:
' This contains actual library, but
' Abstract:{} contains abstract classes, and 
' Abstract.ConceptMap mapps concepts names to abstract classes

class method 
This0 #begin() 
method 
This0 #end() 
ConceptMapMismatch:{<:This2.MetaGuard, This2.Message
class method 
This0 #apply(This2.S _text, This2.Message.Opt cause) 
mut method 
This2.S #_text() 
read method 
This2.S _text() 
mut method 
This2.Message.Opt #cause() 
read method 
This2.Message.Opt cause() 
method 
This0 #apply(This2.Message that) 
method 
This2.Bool #bangequal(This0 that) 
method 
This2.Bool #equalequal(This0 that) 
class method 
This0 #apply(This2.S text) 
class method 
This0 #apply(This2.S text, This2.Message cause) 
class method 
mut This2.S.SBuilder #builder() 
class method 
This0 #from(This2.S.SBuilder builder) 
method 
This0.SConcat #begin() 
SConcat:{
class method 
This0 #apply(This3.Concept.ToS old, This3.S accumulator) 
mut method 
This3.Concept.ToS #old() 
read method 
This3.Concept.ToS old() 
mut method 
This3.S #accumulator() 
read method 
This3.S accumulator() 
method 
This0 #add(This3.Concept.ToS that) 
method 
This0 #add(This3.Concept.ToS that, This3.Concept.ToS separedBy) 
method 
This0 #end() 
method 
mut This3.S.SBuilder #builder() 
method 
This1 #from(This3.S.SBuilder builder) }}
ConceptMapUnavailable:{<:This2.MetaGuard, This2.Message
class method 
This0 #apply(This2.S _text, This2.Message.Opt cause) 
mut method 
This2.S #_text() 
read method 
This2.S _text() 
mut method 
This2.Message.Opt #cause() 
read method 
This2.Message.Opt cause() 
method 
This0 #apply(This2.Message that) 
method 
This2.Bool #bangequal(This0 that) 
method 
This2.Bool #equalequal(This0 that) 
class method 
This0 #apply(This2.S text) 
class method 
This0 #apply(This2.S text, This2.Message cause) 
class method 
mut This2.S.SBuilder #builder() 
class method 
This0 #from(This2.S.SBuilder builder) 
method 
This0.SConcat #begin() 
SConcat:{
class method 
This0 #apply(This3.Concept.ToS old, This3.S accumulator) 
mut method 
This3.Concept.ToS #old() 
read method 
This3.Concept.ToS old() 
mut method 
This3.S #accumulator() 
read method 
This3.S accumulator() 
method 
This0 #add(This3.Concept.ToS that) 
method 
This0 #add(This3.Concept.ToS that, This3.Concept.ToS separedBy) 
method 
This0 #end() 
method 
mut This3.S.SBuilder #builder() 
method 
This1 #from(This3.S.SBuilder builder) }}
method 
Library #leftleft(Library that) exception This0.ConceptMapMismatch, This0.ConceptMapUnavailable 
DeployLibrary:{
class method 
This0 #apply(This2.Path path, This2.Url url) 
mut method 
This2.Path #path() 
read method 
This2.Path path() 
mut method 
This2.Url #url() 
read method 
This2.Url url() 
class method 
Library moveToAbstract(This2.Path that, Library of) 
class method 
Library exposeAsLibrary(Library that, This2.Path path) exception This2.MetaGuard.NestedClassUnavailable, This2.MetaGuard.PrivacyCoupuled 
class method 
Void checkTargetExists(Library that, This2.Path path) exception This2.MetaGuard.NestedClassUnavailable 
class method 
class This0 #begin() 
method 
This0 #end() 
class method 
This0 #add(This2.Path that, This2.Url url) 
method 
Library #leftleft(Library that) exception This2.MetaGuard.NestedClassUnavailable, This2.MetaGuard.PrivacyCoupuled }}
PreferentialComposition:{'members of PreferentialComposition

$:{interface 
method 
Library solveConflict(Library that, This1.SrcDest location) }
SrcDest:{
class method 
This0 #apply(This2.Path path, This2.Selector src, This2.Selector dest) 
mut method 
This2.Path #path() 
read method 
This2.Path path() 
mut method 
This2.Selector #src() 
read method 
This2.Selector src() 
mut method 
This2.Selector #dest() 
read method 
This2.Selector dest() }
SrcDests:{' generic linked list class, elements of class Elem
<:This2.Concept.Named
class method 
This0 _new(This0.Cell head) 
mut method 
This0.Cell #head() 
read method 
This0.Cell head() 
class method 
This0 #apply() 
method 
This2.Bool isEmpty() 
method 
This1.SrcDest top() 
method 
mut This0.Iterator vals() 
method 
mut This0.Iterator valsCut() 
method 
This0 pop() 
method 
This0 #plusplus(This0 that) 
class method 
This0 #begin() 
method 
This0 #add(This1.SrcDest that) 
method 
This0 #end() 
Cell:{interface 
method 
mut This1.Iterator vals(This3.Bool terminate) 
method 
This0 #next() exception Void 
method 
This2.SrcDest #inner() 
method 
Void #checkEnd() }
CellEnd:{<:This1.Cell
class method 
This0 #apply() }
CellNext:{<:This1.Cell
class method 
This0 #apply(This2.SrcDest elem, This1.Cell nextCell) 
mut method 
This2.SrcDest #elem() 
read method 
This2.SrcDest elem() 
mut method 
This1.Cell #nextCell() 
read method 
This1.Cell nextCell() }
Iterator:{
class method 
mut This0 #apply(This1.Cell that, This3.Bool terminate) 
mut method 
Void that(This1.Cell that) 
mut method 
This1.Cell #that() 
read method 
This1.Cell that() 
mut method 
This3.Bool #terminate() 
read method 
This3.Bool terminate() 
mut method 
Void #next() exception Void 
read method 
Void #checkEnd() 
read method 
This2.SrcDest #inner() 
read method 
Void #close() }}
class method 
This0.SrcDests renameMap(Library that, This1.S prefix, This1.Path path, This1.Introspection.Methods ms) 
class method 
This1.Bool needRename(This1.Introspection.NestedClass that, This1.Introspection.Method meth) 
class method 
Library #leftleft(Library that) exception This1.MetaGuard.ClassClash, This1.MetaGuard.MethodClash }
DeployTowel:{
class method '(Any fileName)
This0 #apply(This1.Url fileName) 
mut method '(Any fileName)
This1.Url #fileName() 
read method '(Any fileName)
This1.Url fileName() 
class method 
Library binaryReprFrom(Library lib) 
method 
Library #leftleft(Library that) }
LinkedList:{
ListCode:{
class method 
Library #apply() }
class method 
Library list(class Any that) 
class method 
Library eqList(class Any that) 
ListCodeEq:{
class method 
Library #apply() }}
Default:{
DecorationUnfeasable:{<:This2.MetaGuard, This2.Message
class method 
This0 #apply(This2.S _text, This2.Message.Opt cause) 
mut method 
This2.S #_text() 
read method 
This2.S _text() 
mut method 
This2.Message.Opt #cause() 
read method 
This2.Message.Opt cause() 
method 
This0 #apply(This2.Message that) 
method 
This2.Bool #bangequal(This0 that) 
method 
This2.Bool #equalequal(This0 that) 
class method 
This0 #apply(This2.S text) 
class method 
This0 #apply(This2.S text, This2.Message cause) 
class method 
mut This2.S.SBuilder #builder() 
class method 
This0 #from(This2.S.SBuilder builder) 
method 
This0.SConcat #begin() 
SConcat:{
class method 
This0 #apply(This3.Concept.ToS old, This3.S accumulator) 
mut method 
This3.Concept.ToS #old() 
read method 
This3.Concept.ToS old() 
mut method 
This3.S #accumulator() 
read method 
This3.S accumulator() 
method 
This0 #add(This3.Concept.ToS that) 
method 
This0 #add(This3.Concept.ToS that, This3.Concept.ToS separedBy) 
method 
This0 #end() 
method 
mut This3.S.SBuilder #builder() 
method 
This1 #from(This3.S.SBuilder builder) }}
Parsable:{
class method 
Library #leftleft(Library that) exception This1.DecorationUnfeasable }
SealState:{' how to specify which factory to keep out? what getters

class method 
Library #leftleft(Library that) }
DataFromToS:{' in the future we can add also hashCode and > =>

class method 
Library #leftleft(Library that) exception This1.DecorationUnfeasable }
Equals:{
class method 
Library #leftleft(Library that) exception This1.DecorationUnfeasable }
Named:{
class method 
Library #leftleft(Library that) exception This1.DecorationUnfeasable }}
Use:{'members of each produced class
<:This1.PreferentialComposition.$, This1.PreferentialComposition.$
method 
This0 #add(Library that) 
class method 
This0 #begin() 
method 
This0 #end() 
method 
Library #leftleft(Library that) exception This1.MetaGuard.ClassClash, This1.MetaGuard.MethodClash 
method 
This0 #plusplus(This0 that) }
Extends:{'members of each produced class
<:This1.PreferentialComposition.$, This1.PreferentialComposition.$
method 
This0 #add(Library that) 
class method 
This0 #begin() 
method 
This0 #end() 
method 
Library #leftleft(Library that) exception This1.MetaGuard.ClassClash, This1.MetaGuard.MethodClash 
method 
This0 #plusplus(This0 that) }
Opt:{
class method 
Library #apply(class Any that) }
Optimize:{
RemoveUnreachableCode:{
class method 
This0 #apply() 
class method 
This0 #begin() 
method 
This0 #end() 
method 
Library #leftleft(Library that) }}
Refactor:{
class method 
Library compose(Library left, Library right) exception This1.MetaGuard.ClassClash, This1.MetaGuard.MethodClash 
class method 
Void checkTargetExists(Library that, This1.Path path) exception This1.MetaGuard.NestedClassUnavailable 
Redirect:{
class method 
This0 #apply(This2.Path that, class Any to) 
mut method 
This2.Path #that() 
read method 
This2.Path that() 
mut method 
class Any #to() 
read method 
class Any to() 
method 
Library #leftleft(Library that) exception This2.MetaGuard.NestedClassUnavailable, This2.MetaGuard.InvalidOnTopLevel, This2.MetaGuard.SourceUnfit, This2.MetaGuard.MethodClash, This2.MetaGuard.IncoherentRedirectMapping }
RenameSelector:{
class method 
This0 #apply(This2.Selector that, This2.Path of, This2.Selector to) 
mut method 
This2.Selector #that() 
read method 
This2.Selector that() 
mut method 
This2.Path #of() 
read method 
This2.Path of() 
mut method 
This2.Selector #to() 
read method 
This2.Selector to() 
method 
Library #leftleft(Library that) exception This2.MetaGuard.MemberUnavailable, This2.MetaGuard.MethodClash }
RenamePath:{
class method 
This0 #apply(This2.Path that, This2.Path to) 
mut method 
This2.Path #that() 
read method 
This2.Path that() 
mut method 
This2.Path #to() 
read method 
This2.Path to() 
method 
Library #leftleft(Library that) exception This2.MetaGuard.NestedClassUnavailable, This2.MetaGuard.MethodClash, This2.MetaGuard.ClassClash }
RemoveImplementationSelector:{
class method 
This0 #apply(This2.Selector that, This2.Path of) 
mut method 
This2.Selector #that() 
read method 
This2.Selector that() 
mut method 
This2.Path #of() 
read method 
This2.Path of() 
method 
Library #leftleft(Library that) exception This2.MetaGuard.MemberUnavailable }
MoveImplementationSelector:{
class method 
This0 #apply(This2.Selector that, This2.Path of, This2.Selector to) 
mut method 
This2.Selector #that() 
read method 
This2.Selector that() 
mut method 
This2.Path #of() 
read method 
This2.Path of() 
mut method 
This2.Selector #to() 
read method 
This2.Selector to() 
method 
Library #leftleft(Library that) exception This2.MetaGuard.MemberUnavailable, This2.MetaGuard.MethodClash }
RemoveImplementationPath:{
class method 
This0 #apply(This2.Path that) 
mut method 
This2.Path #that() 
read method 
This2.Path that() 
method 
Library #leftleft(Library that) exception This2.MetaGuard.NestedClassUnavailable, This2.MetaGuard.PrivacyCoupuled }
AddDocumentationSelector:{
class method 
This0 #apply(This2.Selector that, This2.Path of, This2.Introspection.Doc doc) 
mut method 
This2.Selector #that() 
read method 
This2.Selector that() 
mut method 
This2.Path #of() 
read method 
This2.Path of() 
mut method 
This2.Introspection.Doc #doc() 
read method 
This2.Introspection.Doc doc() 
method 
Library #leftleft(Library that) exception This2.MetaGuard.MemberUnavailable }
AddDocumentationPath:{
class method 
This0 #apply(This2.Path that, This2.Introspection.Doc doc) 
mut method 
This2.Path #that() 
read method 
This2.Path that() 
mut method 
This2.Introspection.Doc #doc() 
read method 
This2.Introspection.Doc doc() 
method 
Library #leftleft(Library that) exception This2.MetaGuard.NestedClassUnavailable, This2.MetaGuard.InvalidOnTopLevel }
MakePrivatePath:{
class method 
This0 #apply(This2.Path that) 
mut method 
This2.Path #that() 
read method 
This2.Path that() 
method 
Library #leftleft(Library that) exception This2.MetaGuard.MemberUnavailable, This2.MetaGuard.InvalidOnTopLevel }
MakePrivateSelector:{
class method 
This0 #apply(This2.Selector that, This2.Path of) 
mut method 
This2.Selector #that() 
read method 
This2.Selector that() 
mut method 
This2.Path #of() 
read method 
This2.Path of() 
method 
Library #leftleft(Library that) exception This2.MetaGuard.MemberUnavailable }
SumMethods:{
class method 
This0 #apply(This2.Selector that, This2.Selector and, This2.Path of, This2.S over, This2.Selector to) 
mut method 
This2.Selector #that() 
read method 
This2.Selector that() 
mut method 
This2.Selector #and() 
read method 
This2.Selector and() 
mut method 
This2.Path #of() 
read method 
This2.Path of() 
mut method 
This2.S #over() 
read method 
This2.S over() 
mut method 
This2.Selector #to() 
read method 
This2.Selector to() 
method 
Library #leftleft(Library that) exception This2.MetaGuard.MemberUnavailable, This2.MetaGuard.MethodClash, This2.MetaGuard.ParameterMismatch }
Tools:{
class method 
This2.S getToSOrName(read Any that) }}
Introspection:{'findMeIntrospection

class method 
This0.NestedClass #apply(Library lib) 
class method 
This0.NestedClass #apply(Library lib, This1.Path path) exception This1.MetaGuard.NestedClassUnavailable 
class method 
This0.NestedClass #apply(class Any clazz) 
class method 
This0.NestedClass #apply(class Any clazz, This1.Path path) 
MirrorPr:{interface <:This2.Concept.ToS
method 
This1.NestedClass introspectReport(fwd This1.NestedClass root, This2.Path path) exception This2.MetaGuard.NestedClassUnavailable 
method 
This1.Member introspectReportMember(fwd This1.NestedClass root, This2.Path path, This2.N memberN) exception This2.MetaGuard.MemberUnavailable, Void 
method 
This1.Type introspectReportType(fwd This1.NestedClass root, This2.Path path, This2.N memberN, This2.N typeN) exception This2.MetaGuard.MemberUnavailable, Void 
method 
This2.S introspectDocAsString(This2.Path path) exception This2.MetaGuard.NestedClassUnavailable 
method 
This2.S introspectDocAsString(This2.Path path, This2.N annotationN) exception This2.MetaGuard.NestedClassUnavailable, Void 
method 
class Any introspectDocPath(This2.Path path, This2.N annotationN) exception This2.MetaGuard.NestedClassUnavailable, Void 
Lib:{<:This1
class method 
This0 #apply(Library lib) 
mut method 
Library #lib() 
read method 
Library lib() }
Class:{<:This1
class method 
This0 #apply(class Any lib) 
mut method 
class Any #lib() 
read method 
class Any lib() }}
Doc:{<:This2.Concept.ToS, This2.Concept.Named
Annotation:{<:This3.Concept.ToS, This3.Concept.Named
class method 
This0 #apply(Library _binaryRepr, This3.S text, This3.N index) 
mut method 
Library #_binaryRepr() 
read method 
Library _binaryRepr() 
mut method 
This3.S #text() 
read method 
This3.S text() 
mut method 
This3.N #index() 
read method 
This3.N index() 
method 
class Any referredClass() 
method 
This3.Bool hasReferredClass() }
Annotations:{' generic linked list class, elements of class Elem
<:This3.Concept.Named
class method 
This0 _new(This0.Cell head) 
mut method 
This0.Cell #head() 
read method 
This0.Cell head() 
class method 
This0 #apply() 
method 
This3.Bool isEmpty() 
method 
This1.Annotation top() 
method 
mut This0.Iterator vals() 
method 
mut This0.Iterator valsCut() 
method 
This0 pop() 
method 
This0 #plusplus(This0 that) 
class method 
This0 #begin() 
method 
This0 #add(This1.Annotation that) 
method 
This0 #end() 
Cell:{interface 
method 
mut This1.Iterator vals(This4.Bool terminate) 
method 
This0 #next() exception Void 
method 
This2.Annotation #inner() 
method 
Void #checkEnd() }
CellEnd:{<:This1.Cell
class method 
This0 #apply() }
CellNext:{<:This1.Cell
class method 
This0 #apply(This2.Annotation elem, This1.Cell nextCell) 
mut method 
This2.Annotation #elem() 
read method 
This2.Annotation elem() 
mut method 
This1.Cell #nextCell() 
read method 
This1.Cell nextCell() }
Iterator:{
class method 
mut This0 #apply(This1.Cell that, This4.Bool terminate) 
mut method 
Void that(This1.Cell that) 
mut method 
This1.Cell #that() 
read method 
This1.Cell that() 
mut method 
This4.Bool #terminate() 
read method 
This4.Bool terminate() 
mut method 
Void #next() exception Void 
read method 
Void #checkEnd() 
read method 
This2.Annotation #inner() 
read method 
Void #close() }}
class method 
This0 #apply(Library that) 
class method 
mut This2.S.SBuilder #builder() 
class method 
This0 #from(This2.S.SBuilder builder) 
method 
Library binaryRepr() 
method 
This0.Annotations annotations() }
Record:{
class method 
This0 #apply(This1.MirrorPr that) 
mut method 
This1.MirrorPr #that() 
read method 
This1.MirrorPr that() 
class method 
This0 #apply(class Any clazz) 
class method 
This0 #apply(Library lib) 
method 
Void dbg() 
method 
mut This2.S.SBuilder #builder() 
method 
This2.S #from(This2.S.SBuilder builder) 
method 
This1.Doc docOf(This2.Path path) 
RootForMember:' toPutAs private
{interface 
method 
This2.Member #apply(fwd This2.NestedClass root) }
RootForNested:' toPutAs private
{<:This1.RootForMember
class method 
This0 #apply(This3.Path path, This2.MirrorPr mirror, This1 _report) 
mut method 
This3.Path #path() 
read method 
This3.Path path() 
mut method 
This2.MirrorPr #mirror() 
read method 
This2.MirrorPr mirror() 
mut method 
This1 #_report() 
read method 
This1 _report() }
RootForMethod:' toPutAs private
{<:This1.RootForMember
class method 
This0 #apply(This3.Path path, This3.N memberN, This1 _report) 
mut method 
This3.Path #path() 
read method 
This3.Path path() 
mut method 
This3.N #memberN() 
read method 
This3.N memberN() 
mut method 
This1 #_report() 
read method 
This1 _report() }
class method 
This1.Member dispatch(fwd This1.NestedClass root, This2.Path path, This1.MirrorPr mirror, This2.N memberN, Library record) }
Member:{interface <:This2.Concept.ToS, This2.Concept.Named, This2.Concept.Equals}
Members:{' generic linked list class, elements of class Elem
<:This2.Concept.Named
class method 
This0 _new(This0.Cell head) 
mut method 
This0.Cell #head() 
read method 
This0.Cell head() 
class method 
This0 #apply() 
method 
This2.Bool isEmpty() 
method 
This1.Member top() 
method 
mut This0.Iterator vals() 
method 
mut This0.Iterator valsCut() 
method 
This0 pop() 
method 
This0 #plusplus(This0 that) 
class method 
This0 #begin() 
method 
This0 #add(This1.Member that) 
method 
This0 #end() 
Cell:{interface 
method 
mut This1.Iterator vals(This3.Bool terminate) 
method 
This0 #next() exception Void 
method 
This2.Member #inner() 
method 
Void #checkEnd() }
CellEnd:{<:This1.Cell
class method 
This0 #apply() }
CellNext:{<:This1.Cell
class method 
This0 #apply(This2.Member elem, This1.Cell nextCell) 
mut method 
This2.Member #elem() 
read method 
This2.Member elem() 
mut method 
This1.Cell #nextCell() 
read method 
This1.Cell nextCell() }
Iterator:{
class method 
mut This0 #apply(This1.Cell that, This3.Bool terminate) 
mut method 
Void that(This1.Cell that) 
mut method 
This1.Cell #that() 
read method 
This1.Cell that() 
mut method 
This3.Bool #terminate() 
read method 
This3.Bool terminate() 
mut method 
Void #next() exception Void 
read method 
Void #checkEnd() 
read method 
This2.Member #inner() 
read method 
Void #close() }
method 
This2.Bool contains(This1.Member that) 
method 
This0 remove(This1.Member that) 
method 
This2.Bool #equalequal(This0 that) 
method 
This2.Bool equals(Any that) }
Method:{<:This1.Member, This2.Concept.Equals
method 
This2.Bool #equalequal(This0 that) 
method 
This2.Bool #bangequal(This0 that) 
method 
This1.Doc doc() 
method 
This2.S thisMdf() 
method ' invariant NestedClass(...).nestedClassFromRoot(path).pathFromRoot()==path
This2.Path pathFromRoot() 
method 
This2.Selector selector() 
method 
This2.S methodKind() 
method 
This2.S allAsString() 
method 
This1.Type returnType() 
method 
This1.Types exceptions() 
method 
This1.Types parameterTypes() 
method 
This2.Bool isPrivate() 
method 
This1.NestedClass root() }
Methods:{' generic linked list class, elements of class Elem
<:This2.Concept.Named
class method 
This0 _new(This0.Cell head) 
mut method 
This0.Cell #head() 
read method 
This0.Cell head() 
class method 
This0 #apply() 
method 
This2.Bool isEmpty() 
method 
This1.Method top() 
method 
mut This0.Iterator vals() 
method 
mut This0.Iterator valsCut() 
method 
This0 pop() 
method 
This0 #plusplus(This0 that) 
class method 
This0 #begin() 
method 
This0 #add(This1.Method that) 
method 
This0 #end() 
Cell:{interface 
method 
mut This1.Iterator vals(This3.Bool terminate) 
method 
This0 #next() exception Void 
method 
This2.Method #inner() 
method 
Void #checkEnd() }
CellEnd:{<:This1.Cell
class method 
This0 #apply() }
CellNext:{<:This1.Cell
class method 
This0 #apply(This2.Method elem, This1.Cell nextCell) 
mut method 
This2.Method #elem() 
read method 
This2.Method elem() 
mut method 
This1.Cell #nextCell() 
read method 
This1.Cell nextCell() }
Iterator:{
class method 
mut This0 #apply(This1.Cell that, This3.Bool terminate) 
mut method 
Void that(This1.Cell that) 
mut method 
This1.Cell #that() 
read method 
This1.Cell that() 
mut method 
This3.Bool #terminate() 
read method 
This3.Bool terminate() 
mut method 
Void #next() exception Void 
read method 
Void #checkEnd() 
read method 
This2.Method #inner() 
read method 
Void #close() }
method 
This2.Bool contains(This1.Method that) 
method 
This0 remove(This1.Method that) 
method 
This2.Bool #equalequal(This0 that) 
method 
This2.Bool equals(Any that) }
NestedClass:{'findMeNestedClass
<:This1.Member, This2.Concept.Equals
method 
This2.Bool #equalequal(This0 that) 
method 
This2.Bool #bangequal(This0 that) 
method 
This0 root() 
method 'error for This
This1.Doc nestedDoc() 
method 'of the library literal
This1.Doc doc() 
method 
This2.Path pathFromRoot() 
method 
This2.Bool hasExternalType() 
method 
class Any externalType() 
method 
This2.S externalTypeToS() 
method 
This2.S classKind() 
method 
This2.S allAsString() 
method 
This1.Members members() 
method 
This1.Methods methods() 
method 
This1.NestedClasses nestedClasses() 
method 
This1.NestedClasses transitivelyNestedClasses() 
method 
This1.Types implementedInterfaces() 
method 
This1.Types transitivelyImplementedInterfaces() 
method 
This1.Methods stateCandidate() 
method 
This1.Methods state() 
method 
This1.Method methodFromSelector(This2.Selector that) exception This2.MetaGuard.MethodUnavailable 
method 
This2.Bool has(This2.Selector selector) 
method 
This0 nestedClassFromRoot(This2.Path that) exception This2.MetaGuard.NestedClassUnavailable 
method 
This2.Bool has(This2.Path fromRoot) 
method 
This2.Bool isPrivate() }
NestedClasses:{' generic linked list class, elements of class Elem
<:This2.Concept.Named
class method 
This0 _new(This0.Cell head) 
mut method 
This0.Cell #head() 
read method 
This0.Cell head() 
class method 
This0 #apply() 
method 
This2.Bool isEmpty() 
method 
This1.NestedClass top() 
method 
mut This0.Iterator vals() 
method 
mut This0.Iterator valsCut() 
method 
This0 pop() 
method 
This0 #plusplus(This0 that) 
class method 
This0 #begin() 
method 
This0 #add(This1.NestedClass that) 
method 
This0 #end() 
Cell:{interface 
method 
mut This1.Iterator vals(This3.Bool terminate) 
method 
This0 #next() exception Void 
method 
This2.NestedClass #inner() 
method 
Void #checkEnd() }
CellEnd:{<:This1.Cell
class method 
This0 #apply() }
CellNext:{<:This1.Cell
class method 
This0 #apply(This2.NestedClass elem, This1.Cell nextCell) 
mut method 
This2.NestedClass #elem() 
read method 
This2.NestedClass elem() 
mut method 
This1.Cell #nextCell() 
read method 
This1.Cell nextCell() }
Iterator:{
class method 
mut This0 #apply(This1.Cell that, This3.Bool terminate) 
mut method 
Void that(This1.Cell that) 
mut method 
This1.Cell #that() 
read method 
This1.Cell that() 
mut method 
This3.Bool #terminate() 
read method 
This3.Bool terminate() 
mut method 
Void #next() exception Void 
read method 
Void #checkEnd() 
read method 
This2.NestedClass #inner() 
read method 
Void #close() }
method 
This2.Bool contains(This1.NestedClass that) 
method 
This0 remove(This1.NestedClass that) 
method 
This2.Bool #equalequal(This0 that) 
method 
This2.Bool equals(Any that) }
Type:{<:This2.Concept.ToS, This2.Concept.Named
method 
This2.S allAsString() 
method 
This2.S strRepr() 
method 
This2.S typeKind() 
method 
This2.S mdf() 
method 
This1.NestedClass referencedPath() 
method 
This1.NestedClass resolvedReferencedPath() 
method 
This2.Bool partial() 
method 
This2.Bool resolvedPartial() 
method 
This2.S suffix() 
method 
This1.Doc doc() }
Types:{' generic linked list class, elements of class Elem
<:This2.Concept.Named
class method 
This0 _new(This0.Cell head) 
mut method 
This0.Cell #head() 
read method 
This0.Cell head() 
class method 
This0 #apply() 
method 
This2.Bool isEmpty() 
method 
This1.Type top() 
method 
mut This0.Iterator vals() 
method 
mut This0.Iterator valsCut() 
method 
This0 pop() 
method 
This0 #plusplus(This0 that) 
class method 
This0 #begin() 
method 
This0 #add(This1.Type that) 
method 
This0 #end() 
Cell:{interface 
method 
mut This1.Iterator vals(This3.Bool terminate) 
method 
This0 #next() exception Void 
method 
This2.Type #inner() 
method 
Void #checkEnd() }
CellEnd:{<:This1.Cell
class method 
This0 #apply() }
CellNext:{<:This1.Cell
class method 
This0 #apply(This2.Type elem, This1.Cell nextCell) 
mut method 
This2.Type #elem() 
read method 
This2.Type elem() 
mut method 
This1.Cell #nextCell() 
read method 
This1.Cell nextCell() }
Iterator:{
class method 
mut This0 #apply(This1.Cell that, This3.Bool terminate) 
mut method 
Void that(This1.Cell that) 
mut method 
This1.Cell #that() 
read method 
This1.Cell that() 
mut method 
This3.Bool #terminate() 
read method 
This3.Bool terminate() 
mut method 
Void #next() exception Void 
read method 
Void #checkEnd() 
read method 
This2.Type #inner() 
read method 
Void #close() }}}
MetaGuard:{interface <:This1.Guard
RecordWrapper:' can not be private, I need to Patch it.
{
class method 
This2.S libToS(Library that) 
class method 
Library recordWrapperToSTrait() 
class method 
Library recordWrapperTrait() 
class method 
Library #leftleft(Library that) }
SourceUnfit:{<:This1, This1
class method 
This2.S libName() 
class method 
This0 #apply(This2.Introspection.Record record, Library lib) 
method 
This2.Bool #bangequal(This0 that) 
method 
This2.Bool #equalequal(This0 that) 
class method 
Void #apply(Library lift) exception This0 
method 
Library lib() }
IncoherentRedirectMapping:{<:This1, This1
class method 
This2.S libName() 
class method 
This0 #apply(This2.Introspection.Record record, Library lib) 
method 
This2.Bool #bangequal(This0 that) 
method 
This2.Bool #equalequal(This0 that) 
class method 
Void #apply(Library lift) exception This0 
method 
Library lib() }
ClassClash:{<:This1, This1
class method 
This2.S libName() 
class method 
This0 #apply(This2.Introspection.Record record, Library lib) 
method 
This2.Bool #bangequal(This0 that) 
method 
This2.Bool #equalequal(This0 that) 
class method 
Void #apply(Library lift) exception This0 
method 
Library lib() }
MethodClash:{<:This1, This1
class method 
This2.S libName() 
class method 
This0 #apply(This2.Introspection.Record record, Library lib) 
method 
This2.Bool #bangequal(This0 that) 
method 
This2.Bool #equalequal(This0 that) 
class method 
Void #apply(Library lift) exception This0 
method 
Library lib() }
InvalidOnTopLevel:{<:This1, This1
class method 
This2.S libName() 
class method 
This0 #apply(This2.Introspection.Record record, Library lib) 
method 
This2.Bool #bangequal(This0 that) 
method 
This2.Bool #equalequal(This0 that) 
class method 
Void #apply(Library lift) exception This0 
method 
Library lib() }
PrivacyCoupuled:{<:This1, This1
class method 
This2.S libName() 
class method 
This0 #apply(This2.Introspection.Record record, Library lib) 
method 
This2.Bool #bangequal(This0 that) 
method 
This2.Bool #equalequal(This0 that) 
class method 
Void #apply(Library lift) exception This0 
method 
Library lib() }
ParameterMismatch:{<:This1, This1
class method 
This2.S libName() 
class method 
This0 #apply(This2.Introspection.Record record, Library lib) 
method 
This2.Bool #bangequal(This0 that) 
method 
This2.Bool #equalequal(This0 that) 
class method 
Void #apply(Library lift) exception This0 
method 
Library lib() }
MemberUnavailable:{interface <:This1}
DispatchMemberUnavailable:{
class method 
Void #apply(Library that) exception This1.MemberUnavailable }
NestedClassUnavailable:{<:This1.MemberUnavailable, This1
class method 
This0 #apply(This2.Path path, This2.Bool isPrivate) 
mut method 
This2.Path #path() 
read method 
This2.Path path() 
mut method 
This2.Bool #isPrivate() 
read method 
This2.Bool isPrivate() 
class method 
This0 #apply(This2.Introspection.Record record, Library lib) 
class method 
This2.S libName() 
method 
This2.Bool #bangequal(This0 that) 
method 
This2.Bool #equalequal(This0 that) 
class method 
Void #apply(Library lift) exception This0 }
MethodUnavailable:{<:This1.MemberUnavailable, This1
class method 
This0 #apply(This2.Path path, This2.Selector selector, This2.Bool isPrivate) 
mut method 
This2.Path #path() 
read method 
This2.Path path() 
mut method 
This2.Selector #selector() 
read method 
This2.Selector selector() 
mut method 
This2.Bool #isPrivate() 
read method 
This2.Bool isPrivate() 
class method 
This0 #apply(This2.Introspection.Record record, Library lib) 
class method 
This2.S libName() 
method 
This2.Bool #bangequal(This0 that) 
method 
This2.Bool #equalequal(This0 that) 
class method 
Void #apply(Library lift) exception This0 }}
Selector:{<:This1.Concept.ToS, This1.Concept.Equals, This1.Concept.Named
class method 
This0 fromS(This1.Concept.ToS that) 
class method 
This0 #from(This1.S.SBuilder builder) 
class method 
mut This1.S.SBuilder #builder() 
class method 
This0 #from(Library binaryRepr) 
class method 
Any parseError(This1.S that) 
class method 
This0 from(This1.S name, This1.Strings names) 
method 
This1.S nameAsField() 
method 
This1.S prefixAsField() 
method 
Library binaryRepr() 
method 
This1.Bool #bangequal(This0 that) 
method 
This1.Bool #equalequal(This0 that) 
method 
This1.Bool isOperator() 
method 
This1.S name() 
method 
This1.Strings names() 
class method 
This0 fresh(This0 that) 
ParseFail:{<:This2.Guard.ParseFail, This2.Message
class method 
This0 #apply(This2.S _text, This2.Message.Opt cause) 
mut method 
This2.S #_text() 
read method 
This2.S _text() 
mut method 
This2.Message.Opt #cause() 
read method 
This2.Message.Opt cause() 
method 
This0 #apply(This2.Message that) 
method 
This2.Bool #bangequal(This0 that) 
method 
This2.Bool #equalequal(This0 that) 
class method 
This0 #apply(This2.S text) 
class method 
This0 #apply(This2.S text, This2.Message cause) 
class method 
mut This2.S.SBuilder #builder() 
class method 
This0 #from(This2.S.SBuilder builder) 
method 
This0.SConcat #begin() 
SConcat:{
class method 
This0 #apply(This3.Concept.ToS old, This3.S accumulator) 
mut method 
This3.Concept.ToS #old() 
read method 
This3.Concept.ToS old() 
mut method 
This3.S #accumulator() 
read method 
This3.S accumulator() 
method 
This0 #add(This3.Concept.ToS that) 
method 
This0 #add(This3.Concept.ToS that, This3.Concept.ToS separedBy) 
method 
This0 #end() 
method 
mut This3.S.SBuilder #builder() 
method 
This1 #from(This3.S.SBuilder builder) }}}
Path:{<:This1.Concept.ToS, This1.Concept.Equals, This1.Concept.Named
class method 
This0 fromDocInternalizedS(This1.S that) 
class method 
This0 fromS(This1.Concept.ToS that) 
class method 
This0 #from(This1.S.SBuilder builder) 
class method 
mut This1.S.SBuilder #builder() 
class method 
This0 #from(Library binaryRepr) 
class method 
Any parseError(This1.S that) 
class method 
Any parseError(This1.S that, This1.Message cause) 
method 
Library binaryRepr() 
method 
This1.Bool #bangequal(This0 that) 
method 
This1.Bool #equalequal(This0 that) 
method 
This0 #plusplus(This0 that) 
method 
This1.Strings names() 
class method 
This0 from(This1.Strings names) 
class method 
This0 fresh(This1.S name) 
class method 
This0 fresh() 
class method 
This0 fresh(This0 path) 
ParseFail:{<:This2.Guard.ParseFail, This2.Message
class method 
This0 #apply(This2.S _text, This2.Message.Opt cause) 
mut method 
This2.S #_text() 
read method 
This2.S _text() 
mut method 
This2.Message.Opt #cause() 
read method 
This2.Message.Opt cause() 
method 
This0 #apply(This2.Message that) 
method 
This2.Bool #bangequal(This0 that) 
method 
This2.Bool #equalequal(This0 that) 
class method 
This0 #apply(This2.S text) 
class method 
This0 #apply(This2.S text, This2.Message cause) 
class method 
mut This2.S.SBuilder #builder() 
class method 
This0 #from(This2.S.SBuilder builder) 
method 
This0.SConcat #begin() 
SConcat:{
class method 
This0 #apply(This3.Concept.ToS old, This3.S accumulator) 
mut method 
This3.Concept.ToS #old() 
read method 
This3.Concept.ToS old() 
mut method 
This3.S #accumulator() 
read method 
This3.S accumulator() 
method 
This0 #add(This3.Concept.ToS that) 
method 
This0 #add(This3.Concept.ToS that, This3.Concept.ToS separedBy) 
method 
This0 #end() 
method 
mut This3.S.SBuilder #builder() 
method 
This1 #from(This3.S.SBuilder builder) }}}
Url:{'ParseFailure:Message:S[]<<{<:Guard} no need, related to invariant?
<:This1.Concept.ToS
class method ' if you do not implement it, it is a constructor?
This0 fromS(read This1.Concept.ToS that) 
class method 
This0 #from(This1.S.SBuilder builder) 
class method 
mut This1.S.SBuilder #builder() 
class method 
This0 #apply(This1.S inner) 
mut method 
This1.S #inner() 
read method 
This1.S inner() 
method 
Library binaryRepr() }
ConceptMap:{interface 
method 
This1.Alu _Alu() 
method 
This1.ExitCode _ExitCode() 
method 
This1.Bool _Bool() 
method 
This1.N _N() 
method 
This1.S _S() 
method 
This1.Concept _Concept() 
method 
This1.Message _Message() 
method 
This1.Guard _Guard() 
method 
This1.System _System() 
method 
This1.Assert _Assert() 
method 
This1.Strings _Strings() 
method 
This1.Debug _Debug() 
method 
This0 _ConceptMap() 
method 
This1.Url _Url() 
method 
This1.Path _Path() 
method 
This1.Selector _Selector() 
method 
This1.MetaGuard _MetaGuard() 
method 
This1.Introspection _Introspection() 
method 
This1.Refactor _Refactor() 
method 
This1.Optimize _Optimize() 
method 
This1.Opt _Opt() 
method 
This1.Extends _Extends() 
method 
This1.Use _Use() 
method 
This1.Default _Default() 
method 
This1.LinkedList _LinkedList() 
method 
This1.DeployTowel _DeployTowel() 
method 
This1.PreferentialComposition _PreferentialComposition() 
method 
This1.Load _Load() }
Debug:{
class method 
Void #apply(This1.Concept.ToS that) 
class method 
Void #apply(Library lib) 
class method 
Void #apply(This1.Concept.ToS fileName, This1.Concept.ToS content) }
Strings:{' generic linked list class, elements of class Elem
<:This1.Concept.Named
class method 
This0 _new(This0.Cell head) 
mut method 
This0.Cell #head() 
read method 
This0.Cell head() 
class method 
This0 #apply() 
method 
This1.Bool isEmpty() 
method 
This1.S top() 
method 
mut This0.Iterator vals() 
method 
mut This0.Iterator valsCut() 
method 
This0 pop() 
method 
This0 #plusplus(This0 that) 
class method 
This0 #begin() 
method 
This0 #add(This1.S that) 
method 
This0 #end() 
Cell:{interface 
method 
mut This1.Iterator vals(This2.Bool terminate) 
method 
This0 #next() exception Void 
method 
This2.S #inner() 
method 
Void #checkEnd() }
CellEnd:{<:This1.Cell
class method 
This0 #apply() }
CellNext:{<:This1.Cell
class method 
This0 #apply(This2.S elem, This1.Cell nextCell) 
mut method 
This2.S #elem() 
read method 
This2.S elem() 
mut method 
This1.Cell #nextCell() 
read method 
This1.Cell nextCell() }
Iterator:{
class method 
mut This0 #apply(This1.Cell that, This2.Bool terminate) 
mut method 
Void that(This1.Cell that) 
mut method 
This1.Cell #that() 
read method 
This1.Cell that() 
mut method 
This2.Bool #terminate() 
read method 
This2.Bool terminate() 
mut method 
Void #next() exception Void 
read method 
Void #checkEnd() 
read method 
This2.S #inner() 
read method 
Void #close() }
method 
This1.Bool contains(This1.S that) 
method 
This0 remove(This1.S that) 
method 
This1.Bool #equalequal(This0 that) 
method 
This1.Bool equals(Any that) }
Assert:{interface <:This1.Message
NotImplementedYet:{<:This1, This2.Message
class method 
This0 #apply(This2.S _text, This2.Message.Opt cause) 
mut method 
This2.S #_text() 
read method 
This2.S _text() 
mut method 
This2.Message.Opt #cause() 
read method 
This2.Message.Opt cause() 
method 
This0 #apply(This2.Message that) 
method 
This2.Bool #bangequal(This0 that) 
method 
This2.Bool #equalequal(This0 that) 
class method 
This0 #apply(This2.S text) 
class method 
This0 #apply(This2.S text, This2.Message cause) 
class method 
mut This2.S.SBuilder #builder() 
class method 
This0 #from(This2.S.SBuilder builder) 
method 
This0.SConcat #begin() 
SConcat:{
class method 
This0 #apply(This3.Concept.ToS old, This3.S accumulator) 
mut method 
This3.Concept.ToS #old() 
read method 
This3.Concept.ToS old() 
mut method 
This3.S #accumulator() 
read method 
This3.S accumulator() 
method 
This0 #add(This3.Concept.ToS that) 
method 
This0 #add(This3.Concept.ToS that, This3.Concept.ToS separedBy) 
method 
This0 #end() 
method 
mut This3.S.SBuilder #builder() 
method 
This1 #from(This3.S.SBuilder builder) }}
ObservedBug:{<:This1, This2.Message
class method 
This0 #apply(This2.S _text, This2.Message.Opt cause) 
mut method 
This2.S #_text() 
read method 
This2.S _text() 
mut method 
This2.Message.Opt #cause() 
read method 
This2.Message.Opt cause() 
method 
This0 #apply(This2.Message that) 
method 
This2.Bool #bangequal(This0 that) 
method 
This2.Bool #equalequal(This0 that) 
class method 
This0 #apply(This2.S text) 
class method 
This0 #apply(This2.S text, This2.Message cause) 
class method 
mut This2.S.SBuilder #builder() 
class method 
This0 #from(This2.S.SBuilder builder) 
method 
This0.SConcat #begin() 
SConcat:{
class method 
This0 #apply(This3.Concept.ToS old, This3.S accumulator) 
mut method 
This3.Concept.ToS #old() 
read method 
This3.Concept.ToS old() 
mut method 
This3.S #accumulator() 
read method 
This3.S accumulator() 
method 
This0 #add(This3.Concept.ToS that) 
method 
This0 #add(This3.Concept.ToS that, This3.Concept.ToS separedBy) 
method 
This0 #end() 
method 
mut This3.S.SBuilder #builder() 
method 
This1 #from(This3.S.SBuilder builder) }}
CodeNotReachable:{<:This1, This2.Message
class method 
This0 #apply(This2.S _text, This2.Message.Opt cause) 
mut method 
This2.S #_text() 
read method 
This2.S _text() 
mut method 
This2.Message.Opt #cause() 
read method 
This2.Message.Opt cause() 
method 
This0 #apply(This2.Message that) 
method 
This2.Bool #bangequal(This0 that) 
method 
This2.Bool #equalequal(This0 that) 
class method 
This0 #apply(This2.S text) 
class method 
This0 #apply(This2.S text, This2.Message cause) 
class method 
mut This2.S.SBuilder #builder() 
class method 
This0 #from(This2.S.SBuilder builder) 
method 
This0.SConcat #begin() 
SConcat:{
class method 
This0 #apply(This3.Concept.ToS old, This3.S accumulator) 
mut method 
This3.Concept.ToS #old() 
read method 
This3.Concept.ToS old() 
mut method 
This3.S #accumulator() 
read method 
This3.S accumulator() 
method 
This0 #add(This3.Concept.ToS that) 
method 
This0 #add(This3.Concept.ToS that, This3.Concept.ToS separedBy) 
method 
This0 #end() 
method 
mut This3.S.SBuilder #builder() 
method 
This1 #from(This3.S.SBuilder builder) }}
$:{
class method 
This0 #apply(This2.N that) 
mut method 
This2.N #that() 
read method 
This2.N that() 
class method 
This0 #begin() 
method 
Void #end() 
method 
This0 #add(This2.Bool that) 
method 
This0 #add(This2.Bool that, This2.Concept.ToS msg) }
AssertMessage:{<:This1, This2.Message
class method 
This0 #apply(This2.S _text, This2.Message.Opt cause) 
mut method 
This2.S #_text() 
read method 
This2.S _text() 
mut method 
This2.Message.Opt #cause() 
read method 
This2.Message.Opt cause() 
method 
This0 #apply(This2.Message that) 
method 
This2.Bool #bangequal(This0 that) 
method 
This2.Bool #equalequal(This0 that) 
class method 
This0 #apply(This2.S text) 
class method 
This0 #apply(This2.S text, This2.Message cause) 
class method 
mut This2.S.SBuilder #builder() 
class method 
This0 #from(This2.S.SBuilder builder) 
method 
This0.SConcat #begin() 
SConcat:{
class method 
This0 #apply(This3.Concept.ToS old, This3.S accumulator) 
mut method 
This3.Concept.ToS #old() 
read method 
This3.Concept.ToS old() 
mut method 
This3.S #accumulator() 
read method 
This3.S accumulator() 
method 
This0 #add(This3.Concept.ToS that) 
method 
This0 #add(This3.Concept.ToS that, This3.Concept.ToS separedBy) 
method 
This0 #end() 
method 
mut This3.S.SBuilder #builder() 
method 
This1 #from(This3.S.SBuilder builder) }}}
System:{
Guard:{'<:Outer.Guard soon (remove "interface" for a bad translation bug: This1_System_Guard is not abstract and does not override abstract method MtoS()
interface <:This2.Guard
PluginFailure:{<:This1, This3.Message
class method 
This0 #apply(This3.S _text, This3.Message.Opt cause) 
mut method 
This3.S #_text() 
read method 
This3.S _text() 
mut method 
This3.Message.Opt #cause() 
read method 
This3.Message.Opt cause() 
method 
This0 #apply(This3.Message that) 
method 
This3.Bool #bangequal(This0 that) 
method 
This3.Bool #equalequal(This0 that) 
class method 
This0 #apply(This3.S text) 
class method 
This0 #apply(This3.S text, This3.Message cause) 
class method 
mut This3.S.SBuilder #builder() 
class method 
This0 #from(This3.S.SBuilder builder) 
method 
This0.SConcat #begin() 
SConcat:{
class method 
This0 #apply(This4.Concept.ToS old, This4.S accumulator) 
mut method 
This4.Concept.ToS #old() 
read method 
This4.Concept.ToS old() 
mut method 
This4.S #accumulator() 
read method 
This4.S accumulator() 
method 
This0 #add(This4.Concept.ToS that) 
method 
This0 #add(This4.Concept.ToS that, This4.Concept.ToS separedBy) 
method 
This0 #end() 
method 
mut This4.S.SBuilder #builder() 
method 
This1 #from(This4.S.SBuilder builder) }}}}
Guard:{' exception as Guard bureocracy, error as Guard detection
'-is a check guarenteed to be performed, program logic can rely on this being enforced.
'  as exceptions, Guards objects are a way to report/guard complex operations,
' where checking the shape of the input can be unconvenient.
'as errors, they represent precondition violations. 
'Turning an exception Guard into an error Guard
' is equivalent of declaring that such misuse should not happen (blame on the caller),
' still, there is no bug in the program at this stage. Is legit for the caller to try and be blamed
interface <:This1.Message'all other guards should implement this one

Operation:{<:This1, This2.Message
class method 
This0 #apply(This2.S _text, This2.Message.Opt cause) 
mut method 
This2.S #_text() 
read method 
This2.S _text() 
mut method 
This2.Message.Opt #cause() 
read method 
This2.Message.Opt cause() 
method 
This0 #apply(This2.Message that) 
method 
This2.Bool #bangequal(This0 that) 
method 
This2.Bool #equalequal(This0 that) 
class method 
This0 #apply(This2.S text) 
class method 
This0 #apply(This2.S text, This2.Message cause) 
class method 
mut This2.S.SBuilder #builder() 
class method 
This0 #from(This2.S.SBuilder builder) 
method 
This0.SConcat #begin() 
SConcat:{
class method 
This0 #apply(This3.Concept.ToS old, This3.S accumulator) 
mut method 
This3.Concept.ToS #old() 
read method 
This3.Concept.ToS old() 
mut method 
This3.S #accumulator() 
read method 
This3.S accumulator() 
method 
This0 #add(This3.Concept.ToS that) 
method 
This0 #add(This3.Concept.ToS that, This3.Concept.ToS separedBy) 
method 
This0 #end() 
method 
mut This3.S.SBuilder #builder() 
method 
This1 #from(This3.S.SBuilder builder) }}
Parameter:{<:This1, This2.Message
class method 
This0 #apply(This2.S _text, This2.Message.Opt cause) 
mut method 
This2.S #_text() 
read method 
This2.S _text() 
mut method 
This2.Message.Opt #cause() 
read method 
This2.Message.Opt cause() 
method 
This0 #apply(This2.Message that) 
method 
This2.Bool #bangequal(This0 that) 
method 
This2.Bool #equalequal(This0 that) 
class method 
This0 #apply(This2.S text) 
class method 
This0 #apply(This2.S text, This2.Message cause) 
class method 
mut This2.S.SBuilder #builder() 
class method 
This0 #from(This2.S.SBuilder builder) 
method 
This0.SConcat #begin() 
SConcat:{
class method 
This0 #apply(This3.Concept.ToS old, This3.S accumulator) 
mut method 
This3.Concept.ToS #old() 
read method 
This3.Concept.ToS old() 
mut method 
This3.S #accumulator() 
read method 
This3.S accumulator() 
method 
This0 #add(This3.Concept.ToS that) 
method 
This0 #add(This3.Concept.ToS that, This3.Concept.ToS separedBy) 
method 
This0 #end() 
method 
mut This3.S.SBuilder #builder() 
method 
This1 #from(This3.S.SBuilder builder) }}
Precondition:{<:This1, This2.Message
class method 
This0 #apply(This2.S _text, This2.Message.Opt cause) 
mut method 
This2.S #_text() 
read method 
This2.S _text() 
mut method 
This2.Message.Opt #cause() 
read method 
This2.Message.Opt cause() 
method 
This0 #apply(This2.Message that) 
method 
This2.Bool #bangequal(This0 that) 
method 
This2.Bool #equalequal(This0 that) 
class method 
This0 #apply(This2.S text) 
class method 
This0 #apply(This2.S text, This2.Message cause) 
class method 
mut This2.S.SBuilder #builder() 
class method 
This0 #from(This2.S.SBuilder builder) 
method 
This0.SConcat #begin() 
SConcat:{
class method 
This0 #apply(This3.Concept.ToS old, This3.S accumulator) 
mut method 
This3.Concept.ToS #old() 
read method 
This3.Concept.ToS old() 
mut method 
This3.S #accumulator() 
read method 
This3.S accumulator() 
method 
This0 #add(This3.Concept.ToS that) 
method 
This0 #add(This3.Concept.ToS that, This3.Concept.ToS separedBy) 
method 
This0 #end() 
method 
mut This3.S.SBuilder #builder() 
method 
This1 #from(This3.S.SBuilder builder) }}
ParseFail:{interface <:This1}}
Message:{interface <:This1.Concept.ToS, This1.Concept.Equals, This1.Concept.Classable, This1.Concept.Named
class method 
This1.S kind() 
method 
This1.S text() 
method 
This0.Opt responseOf() 
read method 
class This0 clazz() 
Opt:{
class method 
This0 #new(This0.TOpt that) 
mut method 
This0.TOpt #that() 
read method 
This0.TOpt that() 
TOpt:{interface 
method 
This2 get() }
TEmpty:{<:This1.TOpt, This1.TOpt
class method 
This0 #apply() }
TOf:{<:This1.TOpt
class method 
This0 #apply(This2 that) 
mut method 
This2 #that() 
read method 
This2 that() }
method 
This1 #tilde() 
method 
This2.Bool isPresent() 
class method 
This0 #apply() 
class method 
This0 #apply(This1 that) }
EqualMessages:{
class method 
This2.Bool #apply(This1 that, This1 other) }
$:{
class method 
This0 #apply() 
class method 
Library #leftleft(Library that) 
class method 
Library messageTrait() }}
Concept:{
ToS:{interface 
read method 
This2.S toS() }
Classable:{interface 
read method 
class Any classAny() }
Named:{interface 
class method 
This2.S myName() }
Wrapper:{interface 
read method 
Any inner() }
TypeWrapper:{interface 
read method 
class Any inner() }
ReadWrapper:{interface 
read method 
read Any inner() }
MutWrapper:{interface <:This1.ReadWrapper
mut method 
mut Any #inner() }
LentWrapper:{interface <:This1.ReadWrapper
mut method 
lent Any #inner() }
Equals:{interface 
read method 
This2.Bool equals(read Any that) }
Comparable:{interface 
read method 
This2.Bool greater(read Any that) }
Boollable:{interface 
read method 
Void #checkTrue() exception Void }
Decorator:{interface 'method Library>>(Library that) exception MetaGuard(specific)
'method Library decorate(Library that) exception MetaGuard I can link metaguard for circularity
}
Contains:{interface 'read method Bool >>(read Elem that)

read method 
This2.Bool contains(read Any that) }
Parsable:{interface 'class method capsule This fromS(S that) exception Guard.Parameter(specific) invalid string
'''class method capsule This #fromS(S that) exception Guard.Parameter
}
Invariant:{interface 
read method ' can throw error or return false, as more opportune
This2.Bool invariant() }
RandomAccess:{interface 'read method read Elem (N that)
'mut method mut Elem #(N that)

read method 
read Any get(This2.N that) 
mut method 
mut Any #get(This2.N that) }
Sizable:{interface 
read method 
This2.N size() 
read method 
This2.Bool isEmpty() }
Iterator:{interface 
mut method 
Void #next() exception Void 
read method 
Void #checkEnd() 
read method 
Void #close() }}
S:{<:This1.Concept.ToS, This1.Concept.Equals, This1.Concept.Named
class method 
This0 #from(Library binaryRepr) 
method 
Library binaryRepr() 
method 
This0 #plusplus(This0 that) 
method 
This1.Bool #bangequal(This0 that) 
method 
This1.Bool #equalequal(This0 that) 
method 
This0 #apply(This1.N start, This1.N end) 
method 
This0 #apply(This1.N that) 
method 
This0 #apply(This1.N start) 
method 
This0 #apply(This1.N end) 
method 
This1.Bool beginsWith(This0 that) 
method 
This1.N firstIndexOf(This0 that) 
class method 
Void subStringNotPresent(This0 string, This0 subString) 
method 
This1.Bool contains(This0 that) 
method 
This1.Bool isASCIILowerCase(This1.N that) 
method 
This1.Bool isASCIIUpperCase(This1.N that) 
method 
This1.N size() 
class method 
This0 doubleQuote() 
class method 
This0 nl() 
method 
This0 replace(This0 that, This0 into) 
method 
This0.SConcat #begin() 
SConcat:{
class method 
This0 #apply(This1 old, This1 accumulator) 
mut method 
This1 #old() 
read method 
This1 old() 
mut method 
This1 #accumulator() 
read method 
This1 accumulator() 
method 
This0 #add(This2.Concept.ToS that) 
method 
This0 #add(This2.Concept.ToS that, This2.Concept.ToS separedBy) 
method 
This0 #end() 
method 
mut This1.SBuilder #builder() 
method 
This1 #from(This1.SBuilder builder) }
SBuilder:{
read method 
Library binaryRepr() 
mut method 
Void acc(Library that) 
class method 
mut This0 empty() 
mut method 
Void #0() 
mut method 
Void #1() 
mut method 
Void #2() 
mut method 
Void #3() 
mut method 
Void #4() 
mut method 
Void #5() 
mut method 
Void #6() 
mut method 
Void #7() 
mut method 
Void #8() 
mut method 
Void #9() 
mut method 
Void #q() 
mut method 
Void #w() 
mut method 
Void #e() 
mut method 
Void #r() 
mut method 
Void #t() 
mut method 
Void #y() 
mut method 
Void #u() 
mut method 
Void #i() 
mut method 
Void #o() 
mut method 
Void #p() 
mut method 
Void #a() 
mut method 
Void #s() 
mut method 
Void #d() 
mut method 
Void #f() 
mut method 
Void #g() 
mut method 
Void #h() 
mut method 
Void #j() 
mut method 
Void #k() 
mut method 
Void #l() 
mut method 
Void #z() 
mut method 
Void #x() 
mut method 
Void #c() 
mut method 
Void #v() 
mut method 
Void #b() 
mut method 
Void #n() 
mut method 
Void #m() 
mut method 
Void #Q() 
mut method 
Void #W() 
mut method 
Void #E() 
mut method 
Void #R() 
mut method 
Void #T() 
mut method 
Void #Y() 
mut method 
Void #U() 
mut method 
Void #I() 
mut method 
Void #O() 
mut method 
Void #P() 
mut method 
Void #A() 
mut method 
Void #S() 
mut method 
Void #D() 
mut method 
Void #F() 
mut method 
Void #G() 
mut method 
Void #H() 
mut method 
Void #J() 
mut method 
Void #K() 
mut method 
Void #L() 
mut method 
Void #Z() 
mut method 
Void #X() 
mut method 
Void #C() 
mut method 
Void #V() 
mut method 
Void #B() 
mut method 
Void #N() 
mut method 
Void #M() 
mut method 
Void #%() 
mut method 
Void #$() 
mut method 
Void #left() 
mut method 
Void #right() 
mut method 
Void #bang() 
mut method 
Void #tilde() 
mut method 
Void #plus() 
mut method 
Void #times() 
mut method 
Void #divide() 
mut method 
Void #less() 
mut method 
Void #and() 
mut method 
Void #or() 
mut method 
Void #oRound() 
mut method 
Void #cRound() 
mut method 
Void #oSquare() 
mut method 
Void #cSquare() 
mut method 
Void #oCurly() 
mut method 
Void #cCurly() 
mut method 
Void #dQuote() 
mut method 
Void #sQuote() 
mut method 
Void #hQuote() 
mut method 
Void #equal() 
mut method 
Void #qMark() 
mut method 
Void #hat() 
mut method 
Void #comma() 
mut method 
Void #semicolon() 
mut method 
Void #colon() 
mut method 
Void #dot() 
mut method 
Void #underscore() 
mut method 
Void #hash() 
mut method 
Void #at() 
mut method 
Void #backslash() 
mut method 
Void #space() 
mut method 
Void #newline() }
class method 
This0 #from(This0.SBuilder builder) 
class method 
mut This0.SBuilder #builder() 
SubStringNotPresent:{<:This2.Guard, This2.Message
class method 
This0 #apply(This1 _text, This2.Message.Opt cause) 
mut method 
This1 #_text() 
read method 
This1 _text() 
mut method 
This2.Message.Opt #cause() 
read method 
This2.Message.Opt cause() 
method 
This0 #apply(This2.Message that) 
method 
This2.Bool #bangequal(This0 that) 
method 
This2.Bool #equalequal(This0 that) 
class method 
This0 #apply(This1 text) 
class method 
This0 #apply(This1 text, This2.Message cause) 
class method 
mut This1.SBuilder #builder() 
class method 
This0 #from(This1.SBuilder builder) 
method 
This0.SConcat #begin() 
SConcat:{
class method 
This0 #apply(This3.Concept.ToS old, This2 accumulator) 
mut method 
This3.Concept.ToS #old() 
read method 
This3.Concept.ToS old() 
mut method 
This2 #accumulator() 
read method 
This2 accumulator() 
method 
This0 #add(This3.Concept.ToS that) 
method 
This0 #add(This3.Concept.ToS that, This3.Concept.ToS separedBy) 
method 
This0 #end() 
method 
mut This2.SBuilder #builder() 
method 
This1 #from(This2.SBuilder builder) }}}
N:{<:This1.Concept.ToS, This1.Concept.Equals, This1.Concept.Named
class method 
This0 fromS(This1.Concept.ToS that) 
class method 
This0 #from(Library binaryRepr) 
method 
Library binaryRepr() 
class method 
mut This1.S.SBuilder #builder() 
class method 
This0 #from(This1.S.SBuilder builder) 
class method 
Any parseError(This1.S that) 
method 
This0 #plus(This0 that) 
method 
This0 #less(This0 that) 
method 
This0 #times(This0 that) 
method 
This0 #divide(This0 that) 
method 
This1.Bool #equalequal(This0 that) 
method 
This1.Bool #left(This0 that) 
method 
This1.Bool #leftequal(This0 that) 
method 
This1.Bool #bangequal(This0 that) 
method 
This1.Bool #right(This0 that) 
method 
This1.Bool #rightequal(This0 that) 
method 
mut This0.Iterator vals() 
method 
mut This0.Iterator vals(This0 upTo) 
Iterator:{
class method 
mut This0 #apply(This1 start, This1 end) 
mut method 
Void start(This1 that) 
mut method 
This1 #start() 
read method 
This1 start() 
mut method 
This1 #end() 
read method 
This1 end() 
mut method 
Void #next() exception Void 
read method 
Void #checkEnd() 
read method 
This1 #inner() 
read method 
Void #close() }
ParseFail:{<:This2.Guard.ParseFail, This2.Message
class method 
This0 #apply(This2.S _text, This2.Message.Opt cause) 
mut method 
This2.S #_text() 
read method 
This2.S _text() 
mut method 
This2.Message.Opt #cause() 
read method 
This2.Message.Opt cause() 
method 
This0 #apply(This2.Message that) 
method 
This2.Bool #bangequal(This0 that) 
method 
This2.Bool #equalequal(This0 that) 
class method 
This0 #apply(This2.S text) 
class method 
This0 #apply(This2.S text, This2.Message cause) 
class method 
mut This2.S.SBuilder #builder() 
class method 
This0 #from(This2.S.SBuilder builder) 
method 
This0.SConcat #begin() 
SConcat:{
class method 
This0 #apply(This3.Concept.ToS old, This3.S accumulator) 
mut method 
This3.Concept.ToS #old() 
read method 
This3.Concept.ToS old() 
mut method 
This3.S #accumulator() 
read method 
This3.S accumulator() 
method 
This0 #add(This3.Concept.ToS that) 
method 
This0 #add(This3.Concept.ToS that, This3.Concept.ToS separedBy) 
method 
This0 #end() 
method 
mut This3.S.SBuilder #builder() 
method 
This1 #from(This3.S.SBuilder builder) }}}
Bool:{<:This1.Concept.ToS, This1.Concept.Equals, This1.Concept.Named
method 
Void #checkTrue() exception Void 
class method 
This0 true() 
class method 
This0 false() 
method 
This0 #and(This0 that) 
method 
This0 #or(This0 that) 
method 
This0 #bang() 
class method 
This0 fromS(read This1.Concept.ToS that) 
method 
This0 #equalequal(This0 that) 
method 
This0 #bangequal(This0 that) 
class method 
Any parseError(This1.S that) 
ParseFail:{<:This2.Guard.ParseFail, This2.Message
class method 
This0 #apply(This2.S _text, This2.Message.Opt cause) 
mut method 
This2.S #_text() 
read method 
This2.S _text() 
mut method 
This2.Message.Opt #cause() 
read method 
This2.Message.Opt cause() 
method 
This0 #apply(This2.Message that) 
method 
This1 #bangequal(This0 that) 
method 
This1 #equalequal(This0 that) 
class method 
This0 #apply(This2.S text) 
class method 
This0 #apply(This2.S text, This2.Message cause) 
class method 
mut This2.S.SBuilder #builder() 
class method 
This0 #from(This2.S.SBuilder builder) 
method 
This0.SConcat #begin() 
SConcat:{
class method 
This0 #apply(This3.Concept.ToS old, This3.S accumulator) 
mut method 
This3.Concept.ToS #old() 
read method 
This3.Concept.ToS old() 
mut method 
This3.S #accumulator() 
read method 
This3.S accumulator() 
method 
This0 #add(This3.Concept.ToS that) 
method 
This0 #add(This3.Concept.ToS that, This3.Concept.ToS separedBy) 
method 
This0 #end() 
method 
mut This3.S.SBuilder #builder() 
method 
This1 #from(This3.S.SBuilder builder) }}}
ExitCode:{
class method 
Library normal() 
class method 
Library failure() }
Alu:{'@plugin
'L42.is/connected/withAlu
}}
class method 
Void printHelloWorld() This0.Abstract.Debug.#apply(that:This0.Abstract.S.#from(builder:(
  This0.Abstract.S::#builder() b=This0.Abstract.S.#builder()
  Void unused=b.#H()
  Void unused0=b.#e()
  Void unused1=b.#l()
  Void unused2=b.#l()
  Void unused3=b.#o()
  Void unused4=b.#space()
  Void unused5=b.#W()
  Void unused6=b.#o()
  Void unused7=b.#r()
  Void unused8=b.#l()
  Void unused9=b.#d()
  Void unused10=b.#space()
  Void unused11=b.#D()
  Void unused12=b.#e()
  Void unused13=b.#p()
  Void unused14=b.#l()
  Void unused15=b.#o()
  Void unused16=b.#y()
  Void unused17=b.#e()
  Void unused18=b.#d()
  b
  )))}