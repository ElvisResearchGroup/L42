{'could be in another file

Abstract:{
Load:{'shape of a loadable library:
' Outer0 contains actual library, but
' Abstract:{} contains abstract classes, and 
' Abstract::ConceptMap mapps concepts names to abstract classes

type method 
Outer0 #begin() 
method 
Outer0 #end() 
ConceptMapMismatch:{<:Outer2::MetaGuard, Outer2::Message
type method 
Outer0 #apply(Outer2::S _text, Outer2::Message::Opt cause) 
mut method 
Outer2::S #_text() 
read method 
Outer2::S _text() 
mut method 
Outer2::Message::Opt #cause() 
read method 
Outer2::Message::Opt cause() 
type method 
Outer0 #stringParser(Library that) 
method 
Outer0 #apply(Outer2::Message that) 
method 
Outer2::Bool #bangequal(Outer0 that) 
method 
Outer2::Bool #equalequal(Outer0 that) 
type method 
Outer0 #apply(Outer2::S text) 
type method 
Outer0 #apply(Outer2::S text, Outer2::Message cause) 
method 
Outer0::SConcat #begin() 
SConcat:{
type method 
Outer0 #apply(Outer3::S accumulator) 
mut method 
Outer3::S #accumulator() 
read method 
Outer3::S accumulator() 
method 
Outer0 #add(Outer3::Concept::ToS that) 
method 
Outer0 #end() 
method 
Outer1 #stringParser(Library that) }}
ConceptMapUnavailable:{<:Outer2::MetaGuard, Outer2::Message
type method 
Outer0 #apply(Outer2::S _text, Outer2::Message::Opt cause) 
mut method 
Outer2::S #_text() 
read method 
Outer2::S _text() 
mut method 
Outer2::Message::Opt #cause() 
read method 
Outer2::Message::Opt cause() 
type method 
Outer0 #stringParser(Library that) 
method 
Outer0 #apply(Outer2::Message that) 
method 
Outer2::Bool #bangequal(Outer0 that) 
method 
Outer2::Bool #equalequal(Outer0 that) 
type method 
Outer0 #apply(Outer2::S text) 
type method 
Outer0 #apply(Outer2::S text, Outer2::Message cause) 
method 
Outer0::SConcat #begin() 
SConcat:{
type method 
Outer0 #apply(Outer3::S accumulator) 
mut method 
Outer3::S #accumulator() 
read method 
Outer3::S accumulator() 
method 
Outer0 #add(Outer3::Concept::ToS that) 
method 
Outer0 #end() 
method 
Outer1 #stringParser(Library that) }}
method 
Library #leftleft(Library that) exception Outer0::ConceptMapMismatch, Outer0::ConceptMapUnavailable 
DeployLibrary:{
type method 
Outer0 #apply(Outer2::Path path, Outer2::Url url) 
mut method 
Outer2::Path #path() 
read method 
Outer2::Path path() 
mut method 
Outer2::Url #url() 
read method 
Outer2::Url url() 
type method 
Library moveToAbstract(Outer2::Path that, Library of) 
type method 
Library exposeAsLibrary(Library that, Outer2::Path path) exception Outer2::MetaGuard::NestedClassUnavailable, Outer2::MetaGuard::PrivacyCoupuled 
type method 
Void checkTargetExists(Library that, Outer2::Path path) exception Outer2::MetaGuard::NestedClassUnavailable 
type method 
type Outer0 #begin() 
method 
Outer0 #end() 
type method 
Outer0 #add(Outer2::Path that, Outer2::Url url) 
method 
Library #leftleft(Library that) exception Outer2::MetaGuard::NestedClassUnavailable, Outer2::MetaGuard::PrivacyCoupuled }}
PreferentialComposition:{'members of PreferentialComposition

$:{interface 
method 
Library solveConflict(Library that, Outer1::SrcDest location) }
SrcDest:{
type method 
Outer0 #apply(Outer2::Path path, Outer2::Selector src, Outer2::Selector dest) 
mut method 
Outer2::Path #path() 
read method 
Outer2::Path path() 
mut method 
Outer2::Selector #src() 
read method 
Outer2::Selector src() 
mut method 
Outer2::Selector #dest() 
read method 
Outer2::Selector dest() }
SrcDests:{' generic linked list class, elements of type Elem
<:Outer2::Concept::Named
type method 
Outer0 _new(Outer0::Cell head) 
mut method 
Outer0::Cell #head() 
read method 
Outer0::Cell head() 
type method 
Outer0 #apply() 
method 
Outer2::Bool isEmpty() 
method 
Outer1::SrcDest top() 
method 
mut Outer0::Iterator vals() 
method 
mut Outer0::Iterator valsCut() 
method 
Outer0 pop() 
method 
Outer0 #plusplus(Outer0 that) 
type method 
Outer0 #begin() 
method 
Outer0 #add(Outer1::SrcDest that) 
method 
Outer0 #end() 
Cell:{interface 
method 
mut Outer1::Iterator vals(Outer3::Bool terminate) 
method 
Outer0 #next() exception Void 
method 
Outer2::SrcDest #inner() 
method 
Void #checkEnd() }
CellEnd:{<:Outer1::Cell
type method 
Outer0 #apply() }
CellNext:{<:Outer1::Cell
type method 
Outer0 #apply(Outer2::SrcDest elem, Outer1::Cell nextCell) 
mut method 
Outer2::SrcDest #elem() 
read method 
Outer2::SrcDest elem() 
mut method 
Outer1::Cell #nextCell() 
read method 
Outer1::Cell nextCell() }
Iterator:{
type method 
mut Outer0 #apply(Outer1::Cell that, Outer3::Bool terminate) 
mut method 
Void that(Outer1::Cell that) 
mut method 
Outer1::Cell #that() 
read method 
Outer1::Cell that() 
mut method 
Outer3::Bool #terminate() 
read method 
Outer3::Bool terminate() 
mut method 
Void #next() exception Void 
read method 
Void #checkEnd() 
read method 
Outer2::SrcDest #inner() 
read method 
Void #close() }}
type method 
Outer0::SrcDests renameMap(Library that, Outer1::S prefix, Outer1::Path path, Outer1::Introspection::Methods ms) 
type method 
Outer1::Bool needRename(Outer1::Introspection::NestedClass that, Outer1::Introspection::Method meth) 
type method 
Library #leftleft(Library that) exception Outer1::MetaGuard::ClassClash, Outer1::MetaGuard::MethodClash }
DeployTowel:{
type method 
Outer0 #apply(Library fileName) 
mut method 
Library #fileName() 
read method 
Library fileName() 
type method 
type Outer0 #begin() 
type method 
Outer0 #add(Library fileName) 
method 
Outer0 #end() 
type method 
Library binaryReprFrom(Library lib) 
method 
Library #leftleft(Library that) 
Alu:'  toPutAs private
{'@plugin
'L42.is/connected/withAlu
}
type method 
Library #stringParser(Library that) 
type method 
Library #numberParser(Library that) }
LinkedList:{
ListCode:{
type method 
Library #apply() }
type method 
Library list(type Any that) 
type method 
Library eqList(type Any that) 
ListCodeEq:{
type method 
Library #apply() }}
Default:{
DecorationUnfeasable:{<:Outer2::MetaGuard, Outer2::Message
type method 
Outer0 #apply(Outer2::S _text, Outer2::Message::Opt cause) 
mut method 
Outer2::S #_text() 
read method 
Outer2::S _text() 
mut method 
Outer2::Message::Opt #cause() 
read method 
Outer2::Message::Opt cause() 
type method 
Outer0 #stringParser(Library that) 
method 
Outer0 #apply(Outer2::Message that) 
method 
Outer2::Bool #bangequal(Outer0 that) 
method 
Outer2::Bool #equalequal(Outer0 that) 
type method 
Outer0 #apply(Outer2::S text) 
type method 
Outer0 #apply(Outer2::S text, Outer2::Message cause) 
method 
Outer0::SConcat #begin() 
SConcat:{
type method 
Outer0 #apply(Outer3::S accumulator) 
mut method 
Outer3::S #accumulator() 
read method 
Outer3::S accumulator() 
method 
Outer0 #add(Outer3::Concept::ToS that) 
method 
Outer0 #end() 
method 
Outer1 #stringParser(Library that) }}
Parsable:{
type method 
Library #leftleft(Library that) exception Outer1::DecorationUnfeasable }
SealState:{' how to specify which factory to keep out? what getters

type method 
Library #leftleft(Library that) }
DataFromToS:{' in the future we can add also hashCode and > =>

type method 
Library #leftleft(Library that) exception Outer1::DecorationUnfeasable }
Equals:{
type method 
Library #leftleft(Library that) exception Outer1::DecorationUnfeasable }
Named:{
type method 
Library #leftleft(Library that) exception Outer1::DecorationUnfeasable }}
Use:{'members of each produced class
<:Outer1::PreferentialComposition::$, Outer1::PreferentialComposition::$
method 
Outer0 #add(Library that) 
type method 
Outer0 #begin() 
method 
Outer0 #end() 
method 
Library #leftleft(Library that) exception Outer1::MetaGuard::ClassClash, Outer1::MetaGuard::MethodClash 
method 
Outer0 #plusplus(Outer0 that) }
Extends:{'members of each produced class
<:Outer1::PreferentialComposition::$, Outer1::PreferentialComposition::$
method 
Outer0 #add(Library that) 
type method 
Outer0 #begin() 
method 
Outer0 #end() 
method 
Library #leftleft(Library that) exception Outer1::MetaGuard::ClassClash, Outer1::MetaGuard::MethodClash 
method 
Outer0 #plusplus(Outer0 that) }
Opt:{
type method 
Library #apply(type Any that) }
Optimize:{
RemoveUnreachableCode:{
type method 
Outer0 #apply() 
type method 
Outer0 #begin() 
method 
Outer0 #end() 
method 
Library #leftleft(Library that) }}
Refactor:{
type method 
Library compose(Library left, Library right) exception Outer1::MetaGuard::ClassClash, Outer1::MetaGuard::MethodClash 
type method 
Void checkTargetExists(Library that, Outer1::Path path) exception Outer1::MetaGuard::NestedClassUnavailable 
Redirect:{
type method 
Outer0 #apply(Outer2::Path that, type Any to) 
mut method 
Outer2::Path #that() 
read method 
Outer2::Path that() 
mut method 
type Any #to() 
read method 
type Any to() 
method 
Library #leftleft(Library that) exception Outer2::MetaGuard::NestedClassUnavailable, Outer2::MetaGuard::InvalidOnTopLevel, Outer2::MetaGuard::SourceUnfit, Outer2::MetaGuard::MethodClash, Outer2::MetaGuard::IncoherentRedirectMapping }
RenameSelector:{
type method 
Outer0 #apply(Outer2::Selector that, Outer2::Path of, Outer2::Selector to) 
mut method 
Outer2::Selector #that() 
read method 
Outer2::Selector that() 
mut method 
Outer2::Path #of() 
read method 
Outer2::Path of() 
mut method 
Outer2::Selector #to() 
read method 
Outer2::Selector to() 
method 
Library #leftleft(Library that) exception Outer2::MetaGuard::MemberUnavailable, Outer2::MetaGuard::MethodClash }
RenamePath:{
type method 
Outer0 #apply(Outer2::Path that, Outer2::Path to) 
mut method 
Outer2::Path #that() 
read method 
Outer2::Path that() 
mut method 
Outer2::Path #to() 
read method 
Outer2::Path to() 
method 
Library #leftleft(Library that) exception Outer2::MetaGuard::NestedClassUnavailable, Outer2::MetaGuard::MethodClash, Outer2::MetaGuard::ClassClash }
RemoveImplementationSelector:{
type method 
Outer0 #apply(Outer2::Selector that, Outer2::Path of) 
mut method 
Outer2::Selector #that() 
read method 
Outer2::Selector that() 
mut method 
Outer2::Path #of() 
read method 
Outer2::Path of() 
method 
Library #leftleft(Library that) exception Outer2::MetaGuard::MemberUnavailable }
MoveImplementationSelector:{
type method 
Outer0 #apply(Outer2::Selector that, Outer2::Path of, Outer2::Selector to) 
mut method 
Outer2::Selector #that() 
read method 
Outer2::Selector that() 
mut method 
Outer2::Path #of() 
read method 
Outer2::Path of() 
mut method 
Outer2::Selector #to() 
read method 
Outer2::Selector to() 
method 
Library #leftleft(Library that) exception Outer2::MetaGuard::MemberUnavailable, Outer2::MetaGuard::MethodClash }
RemoveImplementationPath:{
type method 
Outer0 #apply(Outer2::Path that) 
mut method 
Outer2::Path #that() 
read method 
Outer2::Path that() 
method 
Library #leftleft(Library that) exception Outer2::MetaGuard::NestedClassUnavailable, Outer2::MetaGuard::PrivacyCoupuled }
AddDocumentationSelector:{
type method 
Outer0 #apply(Outer2::Selector that, Outer2::Path of, Outer2::Introspection::Doc doc) 
mut method 
Outer2::Selector #that() 
read method 
Outer2::Selector that() 
mut method 
Outer2::Path #of() 
read method 
Outer2::Path of() 
mut method 
Outer2::Introspection::Doc #doc() 
read method 
Outer2::Introspection::Doc doc() 
method 
Library #leftleft(Library that) exception Outer2::MetaGuard::MemberUnavailable }
AddDocumentationPath:{
type method 
Outer0 #apply(Outer2::Path that, Outer2::Introspection::Doc doc) 
mut method 
Outer2::Path #that() 
read method 
Outer2::Path that() 
mut method 
Outer2::Introspection::Doc #doc() 
read method 
Outer2::Introspection::Doc doc() 
method 
Library #leftleft(Library that) exception Outer2::MetaGuard::NestedClassUnavailable, Outer2::MetaGuard::InvalidOnTopLevel }
MakePrivatePath:{
type method 
Outer0 #apply(Outer2::Path that) 
mut method 
Outer2::Path #that() 
read method 
Outer2::Path that() 
method 
Library #leftleft(Library that) exception Outer2::MetaGuard::MemberUnavailable, Outer2::MetaGuard::InvalidOnTopLevel }
MakePrivateSelector:{
type method 
Outer0 #apply(Outer2::Selector that, Outer2::Path of) 
mut method 
Outer2::Selector #that() 
read method 
Outer2::Selector that() 
mut method 
Outer2::Path #of() 
read method 
Outer2::Path of() 
method 
Library #leftleft(Library that) exception Outer2::MetaGuard::MemberUnavailable }
SumMethods:{
type method 
Outer0 #apply(Outer2::Selector that, Outer2::Selector and, Outer2::Path of, Outer2::S over, Outer2::Selector to) 
mut method 
Outer2::Selector #that() 
read method 
Outer2::Selector that() 
mut method 
Outer2::Selector #and() 
read method 
Outer2::Selector and() 
mut method 
Outer2::Path #of() 
read method 
Outer2::Path of() 
mut method 
Outer2::S #over() 
read method 
Outer2::S over() 
mut method 
Outer2::Selector #to() 
read method 
Outer2::Selector to() 
method 
Library #leftleft(Library that) exception Outer2::MetaGuard::MemberUnavailable, Outer2::MetaGuard::MethodClash, Outer2::MetaGuard::ParameterMismatch }
Tools:{
type method 
Outer2::S getToSOrName(read Any that) }}
Introspection:{'findMeIntrospection

type method 
Outer0::NestedClass #apply(Library lib) 
type method 
Outer0::NestedClass #apply(Library lib, Outer1::Path path) exception Outer1::MetaGuard::NestedClassUnavailable 
type method 
Outer0::NestedClass #apply(type Any clazz) 
type method 
Outer0::NestedClass #apply(type Any clazz, Outer1::Path path) 
MirrorPr:{interface 
method 
Outer1::NestedClass introspectReport(fwd Outer1::NestedClass root, Outer2::Path path) exception Outer2::MetaGuard::NestedClassUnavailable 
method 
Outer1::Member introspectReportMember(fwd Outer1::NestedClass root, Outer2::Path path, Outer2::N memberN) exception Outer2::MetaGuard::MemberUnavailable, Void 
method 
Outer1::Type introspectReportType(fwd Outer1::NestedClass root, Outer2::Path path, Outer2::N memberN, Outer2::N typeN) exception Outer2::MetaGuard::MemberUnavailable, Void 
method 
Outer2::S introspectDocAsString(Outer2::Path path) exception Outer2::MetaGuard::NestedClassUnavailable 
method 
Outer2::S introspectDocAsString(Outer2::Path path, Outer2::N annotationN) exception Outer2::MetaGuard::NestedClassUnavailable, Void 
method 
type Any introspectDocPath(Outer2::Path path, Outer2::N annotationN) exception Outer2::MetaGuard::NestedClassUnavailable, Void 
Lib:{<:Outer1
type method 
Outer0 #apply(Library lib) 
mut method 
Library #lib() 
read method 
Library lib() }
Class:{<:Outer1
type method 
Outer0 #apply(type Any lib) 
mut method 
type Any #lib() 
read method 
type Any lib() }}
Doc:{<:Outer2::Concept::ToS, Outer2::Concept::Named
Annotation:{<:Outer3::Concept::ToS, Outer3::Concept::Named
type method 
Outer0 #apply(Library _binaryRepr, Outer3::S text, Outer3::N index) 
mut method 
Library #_binaryRepr() 
read method 
Library _binaryRepr() 
mut method 
Outer3::S #text() 
read method 
Outer3::S text() 
mut method 
Outer3::N #index() 
read method 
Outer3::N index() 
method 
type Any referredClass() 
method 
Outer3::Bool hasReferredClass() }
Annotations:{' generic linked list class, elements of type Elem
<:Outer3::Concept::Named
type method 
Outer0 _new(Outer0::Cell head) 
mut method 
Outer0::Cell #head() 
read method 
Outer0::Cell head() 
type method 
Outer0 #apply() 
method 
Outer3::Bool isEmpty() 
method 
Outer1::Annotation top() 
method 
mut Outer0::Iterator vals() 
method 
mut Outer0::Iterator valsCut() 
method 
Outer0 pop() 
method 
Outer0 #plusplus(Outer0 that) 
type method 
Outer0 #begin() 
method 
Outer0 #add(Outer1::Annotation that) 
method 
Outer0 #end() 
Cell:{interface 
method 
mut Outer1::Iterator vals(Outer4::Bool terminate) 
method 
Outer0 #next() exception Void 
method 
Outer2::Annotation #inner() 
method 
Void #checkEnd() }
CellEnd:{<:Outer1::Cell
type method 
Outer0 #apply() }
CellNext:{<:Outer1::Cell
type method 
Outer0 #apply(Outer2::Annotation elem, Outer1::Cell nextCell) 
mut method 
Outer2::Annotation #elem() 
read method 
Outer2::Annotation elem() 
mut method 
Outer1::Cell #nextCell() 
read method 
Outer1::Cell nextCell() }
Iterator:{
type method 
mut Outer0 #apply(Outer1::Cell that, Outer4::Bool terminate) 
mut method 
Void that(Outer1::Cell that) 
mut method 
Outer1::Cell #that() 
read method 
Outer1::Cell that() 
mut method 
Outer4::Bool #terminate() 
read method 
Outer4::Bool terminate() 
mut method 
Void #next() exception Void 
read method 
Void #checkEnd() 
read method 
Outer2::Annotation #inner() 
read method 
Void #close() }}
type method 
Outer0 #apply(Library that) 
type method 
Outer0 #stringParser(Library that) 
method 
Library binaryRepr() 
method 
Outer0::Annotations annotations() }
Record:{
type method 
Outer0 #apply(Outer1::MirrorPr that) 
mut method 
Outer1::MirrorPr #that() 
read method 
Outer1::MirrorPr that() 
type method 
Outer0 #apply(type Any clazz) 
type method 
Outer0 #apply(Library lib) 
method 
Void dbg() 
method 
Outer2::S #stringParser(Library that) 
method 
Outer1::Doc docOf(Outer2::Path path) 
RootForMember:' toPutAs private
{interface 
method 
Outer2::Member #apply(fwd Outer2::NestedClass root) }
RootForNested:' toPutAs private
{<:Outer1::RootForMember
type method 
Outer0 #apply(Outer3::Path path, Outer2::MirrorPr mirror, Outer1 _report) 
mut method 
Outer3::Path #path() 
read method 
Outer3::Path path() 
mut method 
Outer2::MirrorPr #mirror() 
read method 
Outer2::MirrorPr mirror() 
mut method 
Outer1 #_report() 
read method 
Outer1 _report() }
RootForMethod:' toPutAs private
{<:Outer1::RootForMember
type method 
Outer0 #apply(Outer3::Path path, Outer3::N memberN, Outer1 _report) 
mut method 
Outer3::Path #path() 
read method 
Outer3::Path path() 
mut method 
Outer3::N #memberN() 
read method 
Outer3::N memberN() 
mut method 
Outer1 #_report() 
read method 
Outer1 _report() }
type method 
Outer1::Member dispatch(fwd Outer1::NestedClass root, Outer2::Path path, Outer1::MirrorPr mirror, Outer2::N memberN, Library record) }
Member:{interface <:Outer2::Concept::ToS, Outer2::Concept::Named, Outer2::Concept::Equals}
Members:{' generic linked list class, elements of type Elem
<:Outer2::Concept::Named
type method 
Outer0 _new(Outer0::Cell head) 
mut method 
Outer0::Cell #head() 
read method 
Outer0::Cell head() 
type method 
Outer0 #apply() 
method 
Outer2::Bool isEmpty() 
method 
Outer1::Member top() 
method 
mut Outer0::Iterator vals() 
method 
mut Outer0::Iterator valsCut() 
method 
Outer0 pop() 
method 
Outer0 #plusplus(Outer0 that) 
type method 
Outer0 #begin() 
method 
Outer0 #add(Outer1::Member that) 
method 
Outer0 #end() 
Cell:{interface 
method 
mut Outer1::Iterator vals(Outer3::Bool terminate) 
method 
Outer0 #next() exception Void 
method 
Outer2::Member #inner() 
method 
Void #checkEnd() }
CellEnd:{<:Outer1::Cell
type method 
Outer0 #apply() }
CellNext:{<:Outer1::Cell
type method 
Outer0 #apply(Outer2::Member elem, Outer1::Cell nextCell) 
mut method 
Outer2::Member #elem() 
read method 
Outer2::Member elem() 
mut method 
Outer1::Cell #nextCell() 
read method 
Outer1::Cell nextCell() }
Iterator:{
type method 
mut Outer0 #apply(Outer1::Cell that, Outer3::Bool terminate) 
mut method 
Void that(Outer1::Cell that) 
mut method 
Outer1::Cell #that() 
read method 
Outer1::Cell that() 
mut method 
Outer3::Bool #terminate() 
read method 
Outer3::Bool terminate() 
mut method 
Void #next() exception Void 
read method 
Void #checkEnd() 
read method 
Outer2::Member #inner() 
read method 
Void #close() }
method 
Outer2::Bool contains(Outer1::Member that) 
method 
Outer0 remove(Outer1::Member that) 
method 
Outer2::Bool #equalequal(Outer0 that) 
method 
Outer2::Bool equals(Any that) }
Method:{<:Outer1::Member, Outer2::Concept::Equals
method 
Outer2::Bool #equalequal(Outer0 that) 
method 
Outer2::Bool #bangequal(Outer0 that) 
method 
Outer1::Doc doc() 
method 
Outer2::S thisMdf() 
method ' invariant NestedClass(...).nestedClassFromRoot(path).pathFromRoot()==path
Outer2::Path pathFromRoot() 
method 
Outer2::Selector selector() 
method 
Outer2::S methodKind() 
method 
Outer2::S allAsString() 
method 
Outer1::Type returnType() 
method 
Outer1::Types exceptions() 
method 
Outer1::Types parameterTypes() 
method 
Outer2::Bool isPrivate() 
method 
Outer1::NestedClass root() }
Methods:{' generic linked list class, elements of type Elem
<:Outer2::Concept::Named
type method 
Outer0 _new(Outer0::Cell head) 
mut method 
Outer0::Cell #head() 
read method 
Outer0::Cell head() 
type method 
Outer0 #apply() 
method 
Outer2::Bool isEmpty() 
method 
Outer1::Method top() 
method 
mut Outer0::Iterator vals() 
method 
mut Outer0::Iterator valsCut() 
method 
Outer0 pop() 
method 
Outer0 #plusplus(Outer0 that) 
type method 
Outer0 #begin() 
method 
Outer0 #add(Outer1::Method that) 
method 
Outer0 #end() 
Cell:{interface 
method 
mut Outer1::Iterator vals(Outer3::Bool terminate) 
method 
Outer0 #next() exception Void 
method 
Outer2::Method #inner() 
method 
Void #checkEnd() }
CellEnd:{<:Outer1::Cell
type method 
Outer0 #apply() }
CellNext:{<:Outer1::Cell
type method 
Outer0 #apply(Outer2::Method elem, Outer1::Cell nextCell) 
mut method 
Outer2::Method #elem() 
read method 
Outer2::Method elem() 
mut method 
Outer1::Cell #nextCell() 
read method 
Outer1::Cell nextCell() }
Iterator:{
type method 
mut Outer0 #apply(Outer1::Cell that, Outer3::Bool terminate) 
mut method 
Void that(Outer1::Cell that) 
mut method 
Outer1::Cell #that() 
read method 
Outer1::Cell that() 
mut method 
Outer3::Bool #terminate() 
read method 
Outer3::Bool terminate() 
mut method 
Void #next() exception Void 
read method 
Void #checkEnd() 
read method 
Outer2::Method #inner() 
read method 
Void #close() }
method 
Outer2::Bool contains(Outer1::Method that) 
method 
Outer0 remove(Outer1::Method that) 
method 
Outer2::Bool #equalequal(Outer0 that) 
method 
Outer2::Bool equals(Any that) }
NestedClass:{'findMeNestedClass
<:Outer1::Member, Outer2::Concept::Equals
method 
Outer2::Bool #equalequal(Outer0 that) 
method 
Outer2::Bool #bangequal(Outer0 that) 
method 
Outer0 root() 
method 'error for Outer0
Outer1::Doc nestedDoc() 
method 'of the library literal
Outer1::Doc doc() 
method 
Outer2::Path pathFromRoot() 
method 
Outer2::Bool hasExternalType() 
method 
type Any externalType() 
method 
Outer2::S externalTypeToS() 
method 
Outer2::S classKind() 
method 
Outer2::S allAsString() 
method 
Outer1::Members members() 
method 
Outer1::Methods methods() 
method 
Outer1::NestedClasses nestedClasses() 
method 
Outer1::NestedClasses transitivelyNestedClasses() 
method 
Outer1::Types implementedInterfaces() 
method 
Outer1::Types transitivelyImplementedInterfaces() 
method 
Outer1::Methods stateCandidate() 
method 
Outer1::Methods state() 
method 
Outer1::Method methodFromSelector(Outer2::Selector that) exception Outer2::MetaGuard::MethodUnavailable 
method 
Outer2::Bool has(Outer2::Selector selector) 
method 
Outer0 nestedClassFromRoot(Outer2::Path that) exception Outer2::MetaGuard::NestedClassUnavailable 
method 
Outer2::Bool has(Outer2::Path fromRoot) 
method 
Outer2::Bool isPrivate() }
NestedClasses:{' generic linked list class, elements of type Elem
<:Outer2::Concept::Named
type method 
Outer0 _new(Outer0::Cell head) 
mut method 
Outer0::Cell #head() 
read method 
Outer0::Cell head() 
type method 
Outer0 #apply() 
method 
Outer2::Bool isEmpty() 
method 
Outer1::NestedClass top() 
method 
mut Outer0::Iterator vals() 
method 
mut Outer0::Iterator valsCut() 
method 
Outer0 pop() 
method 
Outer0 #plusplus(Outer0 that) 
type method 
Outer0 #begin() 
method 
Outer0 #add(Outer1::NestedClass that) 
method 
Outer0 #end() 
Cell:{interface 
method 
mut Outer1::Iterator vals(Outer3::Bool terminate) 
method 
Outer0 #next() exception Void 
method 
Outer2::NestedClass #inner() 
method 
Void #checkEnd() }
CellEnd:{<:Outer1::Cell
type method 
Outer0 #apply() }
CellNext:{<:Outer1::Cell
type method 
Outer0 #apply(Outer2::NestedClass elem, Outer1::Cell nextCell) 
mut method 
Outer2::NestedClass #elem() 
read method 
Outer2::NestedClass elem() 
mut method 
Outer1::Cell #nextCell() 
read method 
Outer1::Cell nextCell() }
Iterator:{
type method 
mut Outer0 #apply(Outer1::Cell that, Outer3::Bool terminate) 
mut method 
Void that(Outer1::Cell that) 
mut method 
Outer1::Cell #that() 
read method 
Outer1::Cell that() 
mut method 
Outer3::Bool #terminate() 
read method 
Outer3::Bool terminate() 
mut method 
Void #next() exception Void 
read method 
Void #checkEnd() 
read method 
Outer2::NestedClass #inner() 
read method 
Void #close() }
method 
Outer2::Bool contains(Outer1::NestedClass that) 
method 
Outer0 remove(Outer1::NestedClass that) 
method 
Outer2::Bool #equalequal(Outer0 that) 
method 
Outer2::Bool equals(Any that) }
Type:{<:Outer2::Concept::ToS, Outer2::Concept::Named
method 
Outer2::S allAsString() 
method 
Outer2::S typeKind() 
method 
Outer2::S mdf() 
method 
Outer1::NestedClass referencedPath() 
method 
Outer1::NestedClass resolvedReferencedPath() 
method 
Outer2::Bool partial() 
method 
Outer2::Bool resolvedPartial() 
method 
Outer2::S suffix() 
method 
Outer1::Doc doc() }
Types:{' generic linked list class, elements of type Elem
<:Outer2::Concept::Named
type method 
Outer0 _new(Outer0::Cell head) 
mut method 
Outer0::Cell #head() 
read method 
Outer0::Cell head() 
type method 
Outer0 #apply() 
method 
Outer2::Bool isEmpty() 
method 
Outer1::Type top() 
method 
mut Outer0::Iterator vals() 
method 
mut Outer0::Iterator valsCut() 
method 
Outer0 pop() 
method 
Outer0 #plusplus(Outer0 that) 
type method 
Outer0 #begin() 
method 
Outer0 #add(Outer1::Type that) 
method 
Outer0 #end() 
Cell:{interface 
method 
mut Outer1::Iterator vals(Outer3::Bool terminate) 
method 
Outer0 #next() exception Void 
method 
Outer2::Type #inner() 
method 
Void #checkEnd() }
CellEnd:{<:Outer1::Cell
type method 
Outer0 #apply() }
CellNext:{<:Outer1::Cell
type method 
Outer0 #apply(Outer2::Type elem, Outer1::Cell nextCell) 
mut method 
Outer2::Type #elem() 
read method 
Outer2::Type elem() 
mut method 
Outer1::Cell #nextCell() 
read method 
Outer1::Cell nextCell() }
Iterator:{
type method 
mut Outer0 #apply(Outer1::Cell that, Outer3::Bool terminate) 
mut method 
Void that(Outer1::Cell that) 
mut method 
Outer1::Cell #that() 
read method 
Outer1::Cell that() 
mut method 
Outer3::Bool #terminate() 
read method 
Outer3::Bool terminate() 
mut method 
Void #next() exception Void 
read method 
Void #checkEnd() 
read method 
Outer2::Type #inner() 
read method 
Void #close() }}}
MetaGuard:{interface <:Outer1::Guard
RecordWrapper:' can not be private, I need to Patch it.
{
type method 
Outer2::S libToS(Library that) 
type method 
Library recordWrapperToSTrait() 
type method 
Library recordWrapperTrait() 
type method 
Library #leftleft(Library that) }
SourceUnfit:{<:Outer1, Outer1
type method 
Outer2::S libName() 
type method 
Outer0 #apply(Outer2::Introspection::Record record, Library lib) 
method 
Outer2::Bool #bangequal(Outer0 that) 
method 
Outer2::Bool #equalequal(Outer0 that) 
type method 
Void #apply(Library lift) exception Outer0 
method 
Library lib() }
IncoherentRedirectMapping:{<:Outer1, Outer1
type method 
Outer2::S libName() 
type method 
Outer0 #apply(Outer2::Introspection::Record record, Library lib) 
method 
Outer2::Bool #bangequal(Outer0 that) 
method 
Outer2::Bool #equalequal(Outer0 that) 
type method 
Void #apply(Library lift) exception Outer0 
method 
Library lib() }
ClassClash:{<:Outer1, Outer1
type method 
Outer2::S libName() 
type method 
Outer0 #apply(Outer2::Introspection::Record record, Library lib) 
method 
Outer2::Bool #bangequal(Outer0 that) 
method 
Outer2::Bool #equalequal(Outer0 that) 
type method 
Void #apply(Library lift) exception Outer0 
method 
Library lib() }
MethodClash:{<:Outer1, Outer1
type method 
Outer2::S libName() 
type method 
Outer0 #apply(Outer2::Introspection::Record record, Library lib) 
method 
Outer2::Bool #bangequal(Outer0 that) 
method 
Outer2::Bool #equalequal(Outer0 that) 
type method 
Void #apply(Library lift) exception Outer0 
method 
Library lib() }
InvalidOnTopLevel:{<:Outer1, Outer1
type method 
Outer2::S libName() 
type method 
Outer0 #apply(Outer2::Introspection::Record record, Library lib) 
method 
Outer2::Bool #bangequal(Outer0 that) 
method 
Outer2::Bool #equalequal(Outer0 that) 
type method 
Void #apply(Library lift) exception Outer0 
method 
Library lib() }
PrivacyCoupuled:{<:Outer1, Outer1
type method 
Outer2::S libName() 
type method 
Outer0 #apply(Outer2::Introspection::Record record, Library lib) 
method 
Outer2::Bool #bangequal(Outer0 that) 
method 
Outer2::Bool #equalequal(Outer0 that) 
type method 
Void #apply(Library lift) exception Outer0 
method 
Library lib() }
ParameterMismatch:{<:Outer1, Outer1
type method 
Outer2::S libName() 
type method 
Outer0 #apply(Outer2::Introspection::Record record, Library lib) 
method 
Outer2::Bool #bangequal(Outer0 that) 
method 
Outer2::Bool #equalequal(Outer0 that) 
type method 
Void #apply(Library lift) exception Outer0 
method 
Library lib() }
MemberUnavailable:{interface <:Outer1}
DispatchMemberUnavailable:{
type method 
Void #apply(Library that) exception Outer1::MemberUnavailable }
NestedClassUnavailable:{<:Outer1::MemberUnavailable, Outer1
type method 
Outer0 #apply(Outer2::Path path, Outer2::Bool isPrivate) 
mut method 
Outer2::Path #path() 
read method 
Outer2::Path path() 
mut method 
Outer2::Bool #isPrivate() 
read method 
Outer2::Bool isPrivate() 
type method 
Outer0 #apply(Outer2::Introspection::Record record, Library lib) 
type method 
Outer2::S libName() 
method 
Outer2::Bool #bangequal(Outer0 that) 
method 
Outer2::Bool #equalequal(Outer0 that) 
type method 
Void #apply(Library lift) exception Outer0 }
MethodUnavailable:{<:Outer1::MemberUnavailable, Outer1
type method 
Outer0 #apply(Outer2::Path path, Outer2::Selector selector, Outer2::Bool isPrivate) 
mut method 
Outer2::Path #path() 
read method 
Outer2::Path path() 
mut method 
Outer2::Selector #selector() 
read method 
Outer2::Selector selector() 
mut method 
Outer2::Bool #isPrivate() 
read method 
Outer2::Bool isPrivate() 
type method 
Outer0 #apply(Outer2::Introspection::Record record, Library lib) 
type method 
Outer2::S libName() 
method 
Outer2::Bool #bangequal(Outer0 that) 
method 
Outer2::Bool #equalequal(Outer0 that) 
type method 
Void #apply(Library lift) exception Outer0 }}
Selector:{<:Outer1::Concept::ToS, Outer1::Concept::Equals, Outer1::Concept::Named
type method 
Outer0 fromS(Outer1::Concept::ToS that) 
type method 
Outer0 #stringParser(Library that) 
type method 
Any parseError(Outer1::S that) 
type method 
Outer0 from(Outer1::S name, Outer1::Strings names) 
method 
Outer1::S nameAsField() 
method 
Outer1::S prefixAsField() 
method 
Library binaryRepr() 
method 
Outer1::Bool #bangequal(Outer0 that) 
method 
Outer1::Bool #equalequal(Outer0 that) 
method 
Outer1::Bool isOperator() 
method 
Outer1::S name() 
method 
Outer1::Strings names() 
type method 
Outer0 fresh(Outer0 that) 
ParseFail:{<:Outer2::Guard::ParseFail, Outer2::Message
type method 
Outer0 #apply(Outer2::S _text, Outer2::Message::Opt cause) 
mut method 
Outer2::S #_text() 
read method 
Outer2::S _text() 
mut method 
Outer2::Message::Opt #cause() 
read method 
Outer2::Message::Opt cause() 
type method 
Outer0 #stringParser(Library that) 
method 
Outer0 #apply(Outer2::Message that) 
method 
Outer2::Bool #bangequal(Outer0 that) 
method 
Outer2::Bool #equalequal(Outer0 that) 
type method 
Outer0 #apply(Outer2::S text) 
type method 
Outer0 #apply(Outer2::S text, Outer2::Message cause) 
method 
Outer0::SConcat #begin() 
SConcat:{
type method 
Outer0 #apply(Outer3::S accumulator) 
mut method 
Outer3::S #accumulator() 
read method 
Outer3::S accumulator() 
method 
Outer0 #add(Outer3::Concept::ToS that) 
method 
Outer0 #end() 
method 
Outer1 #stringParser(Library that) }}}
Path:{<:Outer1::Concept::ToS, Outer1::Concept::Equals, Outer1::Concept::Named
type method 
Outer0 fromDocInternalizedS(Outer1::S that) 
type method 
Outer0 fromS(Outer1::Concept::ToS that) 
type method 
Outer0 #stringParser(Library that) 
type method 
Any parseError(Outer1::S that) 
type method 
Any parseError(Outer1::S that, Outer1::Message cause) 
method 
Library binaryRepr() 
method 
Outer1::Bool #bangequal(Outer0 that) 
method 
Outer1::Bool #equalequal(Outer0 that) 
method 
Outer0 #plusplus(Outer0 that) 
method 
Outer1::Strings names() 
type method 
Outer0 from(Outer1::Strings names) 
type method 
Outer0 fresh(Outer1::S name) 
type method 
Outer0 fresh() 
type method 
Outer0 fresh(Outer0 path) 
ParseFail:{<:Outer2::Guard::ParseFail, Outer2::Message
type method 
Outer0 #apply(Outer2::S _text, Outer2::Message::Opt cause) 
mut method 
Outer2::S #_text() 
read method 
Outer2::S _text() 
mut method 
Outer2::Message::Opt #cause() 
read method 
Outer2::Message::Opt cause() 
type method 
Outer0 #stringParser(Library that) 
method 
Outer0 #apply(Outer2::Message that) 
method 
Outer2::Bool #bangequal(Outer0 that) 
method 
Outer2::Bool #equalequal(Outer0 that) 
type method 
Outer0 #apply(Outer2::S text) 
type method 
Outer0 #apply(Outer2::S text, Outer2::Message cause) 
method 
Outer0::SConcat #begin() 
SConcat:{
type method 
Outer0 #apply(Outer3::S accumulator) 
mut method 
Outer3::S #accumulator() 
read method 
Outer3::S accumulator() 
method 
Outer0 #add(Outer3::Concept::ToS that) 
method 
Outer0 #end() 
method 
Outer1 #stringParser(Library that) }}}
Url:{'ParseFailure:Message:S[]<<{<:Guard} no need, related to invariant?
<:Outer1::Concept::ToS
type method ' if you do not implement it, it is a constructor?
Outer0 fromS(read Outer1::Concept::ToS that) 
type method 
Outer0 #stringParser(Library that) 
type method 
Outer0 #apply(Outer1::S inner) 
mut method 
Outer1::S #inner() 
read method 
Outer1::S inner() 
method 
Library binaryRepr() }
ConceptMap:{interface 
method 
Outer1::Alu _Alu() 
method 
Outer1::ExitCode _ExitCode() 
method 
Outer1::Bool _Bool() 
method 
Outer1::N _N() 
method 
Outer1::S _S() 
method 
Outer1::Concept _Concept() 
method 
Outer1::Message _Message() 
method 
Outer1::Guard _Guard() 
method 
Outer1::System _System() 
method 
Outer1::Assert _Assert() 
method 
Outer1::Strings _Strings() 
method 
Outer1::Debug _Debug() 
method 
Outer0 _ConceptMap() 
method 
Outer1::Url _Url() 
method 
Outer1::Path _Path() 
method 
Outer1::Selector _Selector() 
method 
Outer1::MetaGuard _MetaGuard() 
method 
Outer1::Introspection _Introspection() 
method 
Outer1::Refactor _Refactor() 
method 
Outer1::Optimize _Optimize() 
method 
Outer1::Opt _Opt() 
method 
Outer1::Extends _Extends() 
method 
Outer1::Use _Use() 
method 
Outer1::Default _Default() 
method 
Outer1::LinkedList _LinkedList() 
method 
Outer1::DeployTowel _DeployTowel() 
method 
Outer1::PreferentialComposition _PreferentialComposition() 
method 
Outer1::Load _Load() }
Debug:{
type method 
Void #apply(Outer1::Concept::ToS that) 
type method 
Void #apply(Library lib) 
type method 
Void #apply(Outer1::Concept::ToS fileName, Outer1::Concept::ToS content) }
Strings:{' generic linked list class, elements of type Elem
<:Outer1::Concept::Named
type method 
Outer0 _new(Outer0::Cell head) 
mut method 
Outer0::Cell #head() 
read method 
Outer0::Cell head() 
type method 
Outer0 #apply() 
method 
Outer1::Bool isEmpty() 
method 
Outer1::S top() 
method 
mut Outer0::Iterator vals() 
method 
mut Outer0::Iterator valsCut() 
method 
Outer0 pop() 
method 
Outer0 #plusplus(Outer0 that) 
type method 
Outer0 #begin() 
method 
Outer0 #add(Outer1::S that) 
method 
Outer0 #end() 
Cell:{interface 
method 
mut Outer1::Iterator vals(Outer2::Bool terminate) 
method 
Outer0 #next() exception Void 
method 
Outer2::S #inner() 
method 
Void #checkEnd() }
CellEnd:{<:Outer1::Cell
type method 
Outer0 #apply() }
CellNext:{<:Outer1::Cell
type method 
Outer0 #apply(Outer2::S elem, Outer1::Cell nextCell) 
mut method 
Outer2::S #elem() 
read method 
Outer2::S elem() 
mut method 
Outer1::Cell #nextCell() 
read method 
Outer1::Cell nextCell() }
Iterator:{
type method 
mut Outer0 #apply(Outer1::Cell that, Outer2::Bool terminate) 
mut method 
Void that(Outer1::Cell that) 
mut method 
Outer1::Cell #that() 
read method 
Outer1::Cell that() 
mut method 
Outer2::Bool #terminate() 
read method 
Outer2::Bool terminate() 
mut method 
Void #next() exception Void 
read method 
Void #checkEnd() 
read method 
Outer2::S #inner() 
read method 
Void #close() }
method 
Outer1::Bool contains(Outer1::S that) 
method 
Outer0 remove(Outer1::S that) 
method 
Outer1::Bool #equalequal(Outer0 that) 
method 
Outer1::Bool equals(Any that) }
Assert:{interface <:Outer1::Message
NotImplementedYet:{<:Outer1, Outer2::Message
type method 
Outer0 #apply(Outer2::S _text, Outer2::Message::Opt cause) 
mut method 
Outer2::S #_text() 
read method 
Outer2::S _text() 
mut method 
Outer2::Message::Opt #cause() 
read method 
Outer2::Message::Opt cause() 
type method 
Outer0 #stringParser(Library that) 
method 
Outer0 #apply(Outer2::Message that) 
method 
Outer2::Bool #bangequal(Outer0 that) 
method 
Outer2::Bool #equalequal(Outer0 that) 
type method 
Outer0 #apply(Outer2::S text) 
type method 
Outer0 #apply(Outer2::S text, Outer2::Message cause) 
method 
Outer0::SConcat #begin() 
SConcat:{
type method 
Outer0 #apply(Outer3::S accumulator) 
mut method 
Outer3::S #accumulator() 
read method 
Outer3::S accumulator() 
method 
Outer0 #add(Outer3::Concept::ToS that) 
method 
Outer0 #end() 
method 
Outer1 #stringParser(Library that) }}
ObservedBug:{<:Outer1, Outer2::Message
type method 
Outer0 #apply(Outer2::S _text, Outer2::Message::Opt cause) 
mut method 
Outer2::S #_text() 
read method 
Outer2::S _text() 
mut method 
Outer2::Message::Opt #cause() 
read method 
Outer2::Message::Opt cause() 
type method 
Outer0 #stringParser(Library that) 
method 
Outer0 #apply(Outer2::Message that) 
method 
Outer2::Bool #bangequal(Outer0 that) 
method 
Outer2::Bool #equalequal(Outer0 that) 
type method 
Outer0 #apply(Outer2::S text) 
type method 
Outer0 #apply(Outer2::S text, Outer2::Message cause) 
method 
Outer0::SConcat #begin() 
SConcat:{
type method 
Outer0 #apply(Outer3::S accumulator) 
mut method 
Outer3::S #accumulator() 
read method 
Outer3::S accumulator() 
method 
Outer0 #add(Outer3::Concept::ToS that) 
method 
Outer0 #end() 
method 
Outer1 #stringParser(Library that) }}
CodeNotReachable:{<:Outer1, Outer2::Message
type method 
Outer0 #apply(Outer2::S _text, Outer2::Message::Opt cause) 
mut method 
Outer2::S #_text() 
read method 
Outer2::S _text() 
mut method 
Outer2::Message::Opt #cause() 
read method 
Outer2::Message::Opt cause() 
type method 
Outer0 #stringParser(Library that) 
method 
Outer0 #apply(Outer2::Message that) 
method 
Outer2::Bool #bangequal(Outer0 that) 
method 
Outer2::Bool #equalequal(Outer0 that) 
type method 
Outer0 #apply(Outer2::S text) 
type method 
Outer0 #apply(Outer2::S text, Outer2::Message cause) 
method 
Outer0::SConcat #begin() 
SConcat:{
type method 
Outer0 #apply(Outer3::S accumulator) 
mut method 
Outer3::S #accumulator() 
read method 
Outer3::S accumulator() 
method 
Outer0 #add(Outer3::Concept::ToS that) 
method 
Outer0 #end() 
method 
Outer1 #stringParser(Library that) }}
$:{
type method 
Outer0 #apply(Outer2::N that) 
mut method 
Outer2::N #that() 
read method 
Outer2::N that() 
type method 
Outer0 #begin() 
method 
Void #end() 
method 
Outer0 #add(Outer2::Bool that) 
method 
Outer0 #add(Outer2::Bool that, Outer2::Concept::ToS msg) }
AssertMessage:{<:Outer1, Outer2::Message
type method 
Outer0 #apply(Outer2::S _text, Outer2::Message::Opt cause) 
mut method 
Outer2::S #_text() 
read method 
Outer2::S _text() 
mut method 
Outer2::Message::Opt #cause() 
read method 
Outer2::Message::Opt cause() 
type method 
Outer0 #stringParser(Library that) 
method 
Outer0 #apply(Outer2::Message that) 
method 
Outer2::Bool #bangequal(Outer0 that) 
method 
Outer2::Bool #equalequal(Outer0 that) 
type method 
Outer0 #apply(Outer2::S text) 
type method 
Outer0 #apply(Outer2::S text, Outer2::Message cause) 
method 
Outer0::SConcat #begin() 
SConcat:{
type method 
Outer0 #apply(Outer3::S accumulator) 
mut method 
Outer3::S #accumulator() 
read method 
Outer3::S accumulator() 
method 
Outer0 #add(Outer3::Concept::ToS that) 
method 
Outer0 #end() 
method 
Outer1 #stringParser(Library that) }}}
System:{
Guard:{'<:Outer::Guard soon (remove "interface" for a bad translation bug: Outer1_System_Guard is not abstract and does not override abstract method MtoS()
interface <:Outer2::Guard
PluginFailure:{<:Outer1, Outer3::Message
type method 
Outer0 #apply(Outer3::S _text, Outer3::Message::Opt cause) 
mut method 
Outer3::S #_text() 
read method 
Outer3::S _text() 
mut method 
Outer3::Message::Opt #cause() 
read method 
Outer3::Message::Opt cause() 
type method 
Outer0 #stringParser(Library that) 
method 
Outer0 #apply(Outer3::Message that) 
method 
Outer3::Bool #bangequal(Outer0 that) 
method 
Outer3::Bool #equalequal(Outer0 that) 
type method 
Outer0 #apply(Outer3::S text) 
type method 
Outer0 #apply(Outer3::S text, Outer3::Message cause) 
method 
Outer0::SConcat #begin() 
SConcat:{
type method 
Outer0 #apply(Outer4::S accumulator) 
mut method 
Outer4::S #accumulator() 
read method 
Outer4::S accumulator() 
method 
Outer0 #add(Outer4::Concept::ToS that) 
method 
Outer0 #end() 
method 
Outer1 #stringParser(Library that) }}}}
Guard:{' exception as Guard bureocracy, error as Guard detection
'-is a check guarenteed to be performed, program logic can rely on this being enforced.
'  as exceptions, Guards objects are a way to report/guard complex operations,
' where checking the shape of the input can be unconvenient.
'as errors, they represent precondition violations. 
'Turning an exception Guard into an error Guard
' is equivalent of declaring that such misuse should not happen (blame on the caller),
' still, there is no bug in the program at this stage. Is legit for the caller to try and be blamed
interface <:Outer1::Message'all other guards should implement this one

Operation:{<:Outer1, Outer2::Message
type method 
Outer0 #apply(Outer2::S _text, Outer2::Message::Opt cause) 
mut method 
Outer2::S #_text() 
read method 
Outer2::S _text() 
mut method 
Outer2::Message::Opt #cause() 
read method 
Outer2::Message::Opt cause() 
type method 
Outer0 #stringParser(Library that) 
method 
Outer0 #apply(Outer2::Message that) 
method 
Outer2::Bool #bangequal(Outer0 that) 
method 
Outer2::Bool #equalequal(Outer0 that) 
type method 
Outer0 #apply(Outer2::S text) 
type method 
Outer0 #apply(Outer2::S text, Outer2::Message cause) 
method 
Outer0::SConcat #begin() 
SConcat:{
type method 
Outer0 #apply(Outer3::S accumulator) 
mut method 
Outer3::S #accumulator() 
read method 
Outer3::S accumulator() 
method 
Outer0 #add(Outer3::Concept::ToS that) 
method 
Outer0 #end() 
method 
Outer1 #stringParser(Library that) }}
Parameter:{<:Outer1, Outer2::Message
type method 
Outer0 #apply(Outer2::S _text, Outer2::Message::Opt cause) 
mut method 
Outer2::S #_text() 
read method 
Outer2::S _text() 
mut method 
Outer2::Message::Opt #cause() 
read method 
Outer2::Message::Opt cause() 
type method 
Outer0 #stringParser(Library that) 
method 
Outer0 #apply(Outer2::Message that) 
method 
Outer2::Bool #bangequal(Outer0 that) 
method 
Outer2::Bool #equalequal(Outer0 that) 
type method 
Outer0 #apply(Outer2::S text) 
type method 
Outer0 #apply(Outer2::S text, Outer2::Message cause) 
method 
Outer0::SConcat #begin() 
SConcat:{
type method 
Outer0 #apply(Outer3::S accumulator) 
mut method 
Outer3::S #accumulator() 
read method 
Outer3::S accumulator() 
method 
Outer0 #add(Outer3::Concept::ToS that) 
method 
Outer0 #end() 
method 
Outer1 #stringParser(Library that) }}
Precondition:{<:Outer1, Outer2::Message
type method 
Outer0 #apply(Outer2::S _text, Outer2::Message::Opt cause) 
mut method 
Outer2::S #_text() 
read method 
Outer2::S _text() 
mut method 
Outer2::Message::Opt #cause() 
read method 
Outer2::Message::Opt cause() 
type method 
Outer0 #stringParser(Library that) 
method 
Outer0 #apply(Outer2::Message that) 
method 
Outer2::Bool #bangequal(Outer0 that) 
method 
Outer2::Bool #equalequal(Outer0 that) 
type method 
Outer0 #apply(Outer2::S text) 
type method 
Outer0 #apply(Outer2::S text, Outer2::Message cause) 
method 
Outer0::SConcat #begin() 
SConcat:{
type method 
Outer0 #apply(Outer3::S accumulator) 
mut method 
Outer3::S #accumulator() 
read method 
Outer3::S accumulator() 
method 
Outer0 #add(Outer3::Concept::ToS that) 
method 
Outer0 #end() 
method 
Outer1 #stringParser(Library that) }}
ParseFail:{interface <:Outer1}}
Message:{interface <:Outer1::Concept::ToS, Outer1::Concept::Equals, Outer1::Concept::Classable, Outer1::Concept::Named
type method 
Outer1::S kind() 
method 
Outer1::S text() 
method 
Outer0::Opt responseOf() 
read method 
type Outer0 clazz() 
Opt:{
type method 
Outer0 #new(Outer0::TOpt that) 
mut method 
Outer0::TOpt #that() 
read method 
Outer0::TOpt that() 
TOpt:{interface 
method 
Outer2 get() }
TEmpty:{<:Outer1::TOpt, Outer1::TOpt
type method 
Outer0 #apply() }
TOf:{<:Outer1::TOpt
type method 
Outer0 #apply(Outer2 that) 
mut method 
Outer2 #that() 
read method 
Outer2 that() }
method 
Outer1 #tilde() 
method 
Outer2::Bool isPresent() 
type method 
Outer0 #apply() 
type method 
Outer0 #apply(Outer1 that) }
EqualMessages:{
type method 
Outer2::Bool #apply(Outer1 that, Outer1 other) }
$:{
type method 
Outer0 #apply() 
type method 
Outer0 #begin() 
method 
Outer0 #end() 
method 
Library #leftleft(Library that) 
type method 
Library messageTrait() }}
Concept:{
ToS:{interface 
read method 
Outer2::S toS() }
Classable:{interface 
read method 
type Any classAny() }
Named:{interface 
type method 
Outer2::S myName() }
Wrapper:{interface 
read method 
Any inner() }
TypeWrapper:{interface 
read method 
type Any inner() }
ReadWrapper:{interface 
read method 
read Any inner() }
MutWrapper:{interface <:Outer1::ReadWrapper
mut method 
mut Any #inner() }
LentWrapper:{interface <:Outer1::ReadWrapper
mut method 
lent Any #inner() }
Equals:{interface 
read method 
Outer2::Bool equals(read Any that) }
Comparable:{interface 
read method 
Outer2::Bool greater(read Any that) }
Boollable:{interface 
read method 
Void #checkTrue() exception Void }
Decorator:{interface 'method Library>>(Library that) exception MetaGuard(specific)
'method Library decorate(Library that) exception MetaGuard I can link metaguard for circularity
}
Contains:{interface 'read method Bool >>(read Elem that)

read method 
Outer2::Bool contains(read Any that) }
Parsable:{interface 'type method capsule Outer0 fromS(S that) exception Guard::Parameter(specific) invalid string
'''type method capsule Outer0 #fromS(S that) exception Guard::Parameter
}
Invariant:{interface 
read method ' can throw error or return false, as more opportune
Outer2::Bool invariant() }
RandomAccess:{interface 'read method read Elem (N that)
'mut method mut Elem #(N that)

read method 
read Any get(Outer2::N that) 
mut method 
mut Any #get(Outer2::N that) }
Sizable:{interface 
read method 
Outer2::N size() 
read method 
Outer2::Bool isEmpty() }
Iterator:{interface 
mut method 
Void #next() exception Void 
read method 
Void #checkEnd() 
read method 
Void #close() }}
S:{<:Outer1::Concept::ToS, Outer1::Concept::Equals, Outer1::Concept::Named
type method 
Outer0 #stringParser(Library that) 
method 
Library binaryRepr() 
method 
Outer0 #plusplus(Outer0 that) 
method 
Outer1::Bool #bangequal(Outer0 that) 
method 
Outer1::Bool #equalequal(Outer0 that) 
method 
Outer0 #apply(Outer1::N start, Outer1::N end) 
method 
Outer0 #apply(Outer1::N that) 
method 
Outer0 #apply(Outer1::N start) 
method 
Outer0 #apply(Outer1::N end) 
method 
Outer1::Bool beginsWith(Outer0 that) 
method 
Outer1::N firstIndexOf(Outer0 that) 
type method 
Void subStringNotPresent(Outer0 string, Outer0 subString) 
method 
Outer1::Bool contains(Outer0 that) 
method 
Outer1::Bool isASCIILowerCase(Outer1::N that) 
method 
Outer1::Bool isASCIIUpperCase(Outer1::N that) 
method 
Outer1::N size() 
type method 
Outer0 doubleQuote() 
type method 
Outer0 nl() 
method 
Outer0 replace(Outer0 that, Outer0 into) 
method 
Outer0::SConcat #begin() 
SConcat:{
type method 
Outer0 #apply(Outer1 old, Outer1 accumulator) 
mut method 
Outer1 #old() 
read method 
Outer1 old() 
mut method 
Outer1 #accumulator() 
read method 
Outer1 accumulator() 
method 
Outer0 #add(Outer2::Concept::ToS that) 
method 
Outer0 #add(Outer2::Concept::ToS that, Outer2::Concept::ToS separedBy) 
method 
Outer0 #end() 
method 
Outer1 #stringParser(Library that) }
SubStringNotPresent:{<:Outer2::Guard, Outer2::Message
type method 
Outer0 #apply(Outer1 _text, Outer2::Message::Opt cause) 
mut method 
Outer1 #_text() 
read method 
Outer1 _text() 
mut method 
Outer2::Message::Opt #cause() 
read method 
Outer2::Message::Opt cause() 
type method 
Outer0 #stringParser(Library that) 
method 
Outer0 #apply(Outer2::Message that) 
method 
Outer2::Bool #bangequal(Outer0 that) 
method 
Outer2::Bool #equalequal(Outer0 that) 
type method 
Outer0 #apply(Outer1 text) 
type method 
Outer0 #apply(Outer1 text, Outer2::Message cause) 
method 
Outer0::SConcat #begin() 
SConcat:{
type method 
Outer0 #apply(Outer2 accumulator) 
mut method 
Outer2 #accumulator() 
read method 
Outer2 accumulator() 
method 
Outer0 #add(Outer3::Concept::ToS that) 
method 
Outer0 #end() 
method 
Outer1 #stringParser(Library that) }}}
N:{<:Outer1::Concept::ToS, Outer1::Concept::Equals, Outer1::Concept::Named
type method 
Outer0 fromS(Outer1::Concept::ToS that) 
method 
Library binaryRepr() 
type method 
Outer0 #numberParser(Library that) 
type method 
Any parseError(Outer1::S that) 
method 
Outer0 #plus(Outer0 that) 
method 
Outer0 #less(Outer0 that) 
method 
Outer0 #times(Outer0 that) 
method 
Outer0 #divide(Outer0 that) 
method 
Outer1::Bool #equalequal(Outer0 that) 
method 
Outer1::Bool #left(Outer0 that) 
method 
Outer1::Bool #leftequal(Outer0 that) 
method 
Outer1::Bool #bangequal(Outer0 that) 
method 
Outer1::Bool #right(Outer0 that) 
method 
Outer1::Bool #rightequal(Outer0 that) 
method 
mut Outer0::Iterator vals() 
method 
mut Outer0::Iterator vals(Outer0 upTo) 
Iterator:{
type method 
mut Outer0 #apply(Outer1 start, Outer1 end) 
mut method 
Void start(Outer1 that) 
mut method 
Outer1 #start() 
read method 
Outer1 start() 
mut method 
Outer1 #end() 
read method 
Outer1 end() 
mut method 
Void #next() exception Void 
read method 
Void #checkEnd() 
read method 
Outer1 #inner() 
read method 
Void #close() }
ParseFail:{<:Outer2::Guard::ParseFail, Outer2::Message
type method 
Outer0 #apply(Outer2::S _text, Outer2::Message::Opt cause) 
mut method 
Outer2::S #_text() 
read method 
Outer2::S _text() 
mut method 
Outer2::Message::Opt #cause() 
read method 
Outer2::Message::Opt cause() 
type method 
Outer0 #stringParser(Library that) 
method 
Outer0 #apply(Outer2::Message that) 
method 
Outer2::Bool #bangequal(Outer0 that) 
method 
Outer2::Bool #equalequal(Outer0 that) 
type method 
Outer0 #apply(Outer2::S text) 
type method 
Outer0 #apply(Outer2::S text, Outer2::Message cause) 
method 
Outer0::SConcat #begin() 
SConcat:{
type method 
Outer0 #apply(Outer3::S accumulator) 
mut method 
Outer3::S #accumulator() 
read method 
Outer3::S accumulator() 
method 
Outer0 #add(Outer3::Concept::ToS that) 
method 
Outer0 #end() 
method 
Outer1 #stringParser(Library that) }}}
Bool:{<:Outer1::Concept::ToS, Outer1::Concept::Equals, Outer1::Concept::Named
method 
Void #checkTrue() exception Void 
type method 
Outer0 true() 
type method 
Outer0 false() 
method 
Outer0 #and(Outer0 that) 
method 
Outer0 #or(Outer0 that) 
method 
Outer0 #bang() 
type method 
Outer0 fromS(read Outer1::Concept::ToS that) 
method 
Outer0 #equalequal(Outer0 that) 
method 
Outer0 #bangequal(Outer0 that) 
type method 
Any parseError(Outer1::S that) 
ParseFail:{<:Outer2::Guard::ParseFail, Outer2::Message
type method 
Outer0 #apply(Outer2::S _text, Outer2::Message::Opt cause) 
mut method 
Outer2::S #_text() 
read method 
Outer2::S _text() 
mut method 
Outer2::Message::Opt #cause() 
read method 
Outer2::Message::Opt cause() 
type method 
Outer0 #stringParser(Library that) 
method 
Outer0 #apply(Outer2::Message that) 
method 
Outer1 #bangequal(Outer0 that) 
method 
Outer1 #equalequal(Outer0 that) 
type method 
Outer0 #apply(Outer2::S text) 
type method 
Outer0 #apply(Outer2::S text, Outer2::Message cause) 
method 
Outer0::SConcat #begin() 
SConcat:{
type method 
Outer0 #apply(Outer3::S accumulator) 
mut method 
Outer3::S #accumulator() 
read method 
Outer3::S accumulator() 
method 
Outer0 #add(Outer3::Concept::ToS that) 
method 
Outer0 #end() 
method 
Outer1 #stringParser(Library that) }}}
ExitCode:{
type method 
Library normal() 
type method 
Library failure() }
Alu:{'@plugin
'L42.is/connected/withAlu
}}
type method 
Void printHelloWorld() Outer0::Abstract::Debug.#apply(that:Outer0::Abstract::S.#stringParser(that:{'@stringU
'Hello World Deployed
}))}