{'could be in another file

Abstract:{
Load:{'shape of a loadable library:
' This contains actual library, but
' Abstract:{} contains abstract classes, and 
' Abstract.ConceptMap mapps concepts names to abstract classes

type method 
This #begin() 
method 
This #end() 
ConceptMapMismatch:{<:Outer2.MetaGuard, Outer2.Message
type method 
This #apply(Outer2.S _text, Outer2.Message.Opt cause) 
mut method 
Outer2.S #_text() 
read method 
Outer2.S _text() 
mut method 
Outer2.Message.Opt #cause() 
read method 
Outer2.Message.Opt cause() 
method 
This #apply(Outer2.Message that) 
method 
Outer2.Bool #bangequal(This that) 
method 
Outer2.Bool #equalequal(This that) 
type method 
This #apply(Outer2.S text) 
type method 
This #apply(Outer2.S text, Outer2.Message cause) 
type method 
mut Outer2.S.SBuilder #builder() 
type method 
This #from(Outer2.S.SBuilder builder) 
method 
This.SConcat #begin() 
SConcat:{
type method 
This #apply(Outer3.Concept.ToS old, Outer3.S accumulator) 
mut method 
Outer3.Concept.ToS #old() 
read method 
Outer3.Concept.ToS old() 
mut method 
Outer3.S #accumulator() 
read method 
Outer3.S accumulator() 
method 
This #add(Outer3.Concept.ToS that) 
method 
This #add(Outer3.Concept.ToS that, Outer3.Concept.ToS separedBy) 
method 
This #end() 
method 
mut Outer3.S.SBuilder #builder() 
method 
Outer1 #from(Outer3.S.SBuilder builder) }}
ConceptMapUnavailable:{<:Outer2.MetaGuard, Outer2.Message
type method 
This #apply(Outer2.S _text, Outer2.Message.Opt cause) 
mut method 
Outer2.S #_text() 
read method 
Outer2.S _text() 
mut method 
Outer2.Message.Opt #cause() 
read method 
Outer2.Message.Opt cause() 
method 
This #apply(Outer2.Message that) 
method 
Outer2.Bool #bangequal(This that) 
method 
Outer2.Bool #equalequal(This that) 
type method 
This #apply(Outer2.S text) 
type method 
This #apply(Outer2.S text, Outer2.Message cause) 
type method 
mut Outer2.S.SBuilder #builder() 
type method 
This #from(Outer2.S.SBuilder builder) 
method 
This.SConcat #begin() 
SConcat:{
type method 
This #apply(Outer3.Concept.ToS old, Outer3.S accumulator) 
mut method 
Outer3.Concept.ToS #old() 
read method 
Outer3.Concept.ToS old() 
mut method 
Outer3.S #accumulator() 
read method 
Outer3.S accumulator() 
method 
This #add(Outer3.Concept.ToS that) 
method 
This #add(Outer3.Concept.ToS that, Outer3.Concept.ToS separedBy) 
method 
This #end() 
method 
mut Outer3.S.SBuilder #builder() 
method 
Outer1 #from(Outer3.S.SBuilder builder) }}
method 
Library #leftleft(Library that) exception This.ConceptMapMismatch, This.ConceptMapUnavailable 
DeployLibrary:{
type method 
This #apply(Outer2.Path path, Outer2.Url url) 
mut method 
Outer2.Path #path() 
read method 
Outer2.Path path() 
mut method 
Outer2.Url #url() 
read method 
Outer2.Url url() 
type method 
Library moveToAbstract(Outer2.Path that, Library of) 
type method 
Library exposeAsLibrary(Library that, Outer2.Path path) exception Outer2.MetaGuard.NestedClassUnavailable, Outer2.MetaGuard.PrivacyCoupuled 
type method 
Void checkTargetExists(Library that, Outer2.Path path) exception Outer2.MetaGuard.NestedClassUnavailable 
type method 
type This #begin() 
method 
This #end() 
type method 
This #add(Outer2.Path that, Outer2.Url url) 
method 
Library #leftleft(Library that) exception Outer2.MetaGuard.NestedClassUnavailable, Outer2.MetaGuard.PrivacyCoupuled }}
PreferentialComposition:{'members of PreferentialComposition

$:{interface 
method 
Library solveConflict(Library that, Outer1.SrcDest location) }
SrcDest:{
type method 
This #apply(Outer2.Path path, Outer2.Selector src, Outer2.Selector dest) 
mut method 
Outer2.Path #path() 
read method 
Outer2.Path path() 
mut method 
Outer2.Selector #src() 
read method 
Outer2.Selector src() 
mut method 
Outer2.Selector #dest() 
read method 
Outer2.Selector dest() }
SrcDests:{' generic linked list class, elements of type Elem
<:Outer2.Concept.Named
type method 
This _new(This.Cell head) 
mut method 
This.Cell #head() 
read method 
This.Cell head() 
type method 
This #apply() 
method 
Outer2.Bool isEmpty() 
method 
Outer1.SrcDest top() 
method 
mut This.Iterator vals() 
method 
mut This.Iterator valsCut() 
method 
This pop() 
method 
This #plusplus(This that) 
type method 
This #begin() 
method 
This #add(Outer1.SrcDest that) 
method 
This #end() 
Cell:{interface 
method 
mut Outer1.Iterator vals(Outer3.Bool terminate) 
method 
This #next() exception Void 
method 
Outer2.SrcDest #inner() 
method 
Void #checkEnd() }
CellEnd:{<:Outer1.Cell
type method 
This #apply() }
CellNext:{<:Outer1.Cell
type method 
This #apply(Outer2.SrcDest elem, Outer1.Cell nextCell) 
mut method 
Outer2.SrcDest #elem() 
read method 
Outer2.SrcDest elem() 
mut method 
Outer1.Cell #nextCell() 
read method 
Outer1.Cell nextCell() }
Iterator:{
type method 
mut This #apply(Outer1.Cell that, Outer3.Bool terminate) 
mut method 
Void that(Outer1.Cell that) 
mut method 
Outer1.Cell #that() 
read method 
Outer1.Cell that() 
mut method 
Outer3.Bool #terminate() 
read method 
Outer3.Bool terminate() 
mut method 
Void #next() exception Void 
read method 
Void #checkEnd() 
read method 
Outer2.SrcDest #inner() 
read method 
Void #close() }}
type method 
This.SrcDests renameMap(Library that, Outer1.S prefix, Outer1.Path path, Outer1.Introspection.Methods ms) 
type method 
Outer1.Bool needRename(Outer1.Introspection.NestedClass that, Outer1.Introspection.Method meth) 
type method 
Library #leftleft(Library that) exception Outer1.MetaGuard.ClassClash, Outer1.MetaGuard.MethodClash }
DeployTowel:{
type method '(Any fileName)
This #apply(Outer1.Url fileName) 
mut method '(Any fileName)
Outer1.Url #fileName() 
read method '(Any fileName)
Outer1.Url fileName() 
type method 
Library binaryReprFrom(Library lib) 
method 
Library #leftleft(Library that) }
LinkedList:{
ListCode:{
type method 
Library #apply() }
type method 
Library list(type Any that) 
type method 
Library eqList(type Any that) 
ListCodeEq:{
type method 
Library #apply() }}
Default:{
DecorationUnfeasable:{<:Outer2.MetaGuard, Outer2.Message
type method 
This #apply(Outer2.S _text, Outer2.Message.Opt cause) 
mut method 
Outer2.S #_text() 
read method 
Outer2.S _text() 
mut method 
Outer2.Message.Opt #cause() 
read method 
Outer2.Message.Opt cause() 
method 
This #apply(Outer2.Message that) 
method 
Outer2.Bool #bangequal(This that) 
method 
Outer2.Bool #equalequal(This that) 
type method 
This #apply(Outer2.S text) 
type method 
This #apply(Outer2.S text, Outer2.Message cause) 
type method 
mut Outer2.S.SBuilder #builder() 
type method 
This #from(Outer2.S.SBuilder builder) 
method 
This.SConcat #begin() 
SConcat:{
type method 
This #apply(Outer3.Concept.ToS old, Outer3.S accumulator) 
mut method 
Outer3.Concept.ToS #old() 
read method 
Outer3.Concept.ToS old() 
mut method 
Outer3.S #accumulator() 
read method 
Outer3.S accumulator() 
method 
This #add(Outer3.Concept.ToS that) 
method 
This #add(Outer3.Concept.ToS that, Outer3.Concept.ToS separedBy) 
method 
This #end() 
method 
mut Outer3.S.SBuilder #builder() 
method 
Outer1 #from(Outer3.S.SBuilder builder) }}
Parsable:{
type method 
Library #leftleft(Library that) exception Outer1.DecorationUnfeasable }
SealState:{' how to specify which factory to keep out? what getters

type method 
Library #leftleft(Library that) }
DataFromToS:{' in the future we can add also hashCode and > =>

type method 
Library #leftleft(Library that) exception Outer1.DecorationUnfeasable }
Equals:{
type method 
Library #leftleft(Library that) exception Outer1.DecorationUnfeasable }
Named:{
type method 
Library #leftleft(Library that) exception Outer1.DecorationUnfeasable }}
Use:{'members of each produced class
<:Outer1.PreferentialComposition.$, Outer1.PreferentialComposition.$
method 
This #add(Library that) 
type method 
This #begin() 
method 
This #end() 
method 
Library #leftleft(Library that) exception Outer1.MetaGuard.ClassClash, Outer1.MetaGuard.MethodClash 
method 
This #plusplus(This that) }
Extends:{'members of each produced class
<:Outer1.PreferentialComposition.$, Outer1.PreferentialComposition.$
method 
This #add(Library that) 
type method 
This #begin() 
method 
This #end() 
method 
Library #leftleft(Library that) exception Outer1.MetaGuard.ClassClash, Outer1.MetaGuard.MethodClash 
method 
This #plusplus(This that) }
Opt:{
type method 
Library #apply(type Any that) }
Optimize:{
RemoveUnreachableCode:{
type method 
This #apply() 
type method 
This #begin() 
method 
This #end() 
method 
Library #leftleft(Library that) }}
Refactor:{
type method 
Library compose(Library left, Library right) exception Outer1.MetaGuard.ClassClash, Outer1.MetaGuard.MethodClash 
type method 
Void checkTargetExists(Library that, Outer1.Path path) exception Outer1.MetaGuard.NestedClassUnavailable 
Redirect:{
type method 
This #apply(Outer2.Path that, type Any to) 
mut method 
Outer2.Path #that() 
read method 
Outer2.Path that() 
mut method 
type Any #to() 
read method 
type Any to() 
method 
Library #leftleft(Library that) exception Outer2.MetaGuard.NestedClassUnavailable, Outer2.MetaGuard.InvalidOnTopLevel, Outer2.MetaGuard.SourceUnfit, Outer2.MetaGuard.MethodClash, Outer2.MetaGuard.IncoherentRedirectMapping }
RenameSelector:{
type method 
This #apply(Outer2.Selector that, Outer2.Path of, Outer2.Selector to) 
mut method 
Outer2.Selector #that() 
read method 
Outer2.Selector that() 
mut method 
Outer2.Path #of() 
read method 
Outer2.Path of() 
mut method 
Outer2.Selector #to() 
read method 
Outer2.Selector to() 
method 
Library #leftleft(Library that) exception Outer2.MetaGuard.MemberUnavailable, Outer2.MetaGuard.MethodClash }
RenamePath:{
type method 
This #apply(Outer2.Path that, Outer2.Path to) 
mut method 
Outer2.Path #that() 
read method 
Outer2.Path that() 
mut method 
Outer2.Path #to() 
read method 
Outer2.Path to() 
method 
Library #leftleft(Library that) exception Outer2.MetaGuard.NestedClassUnavailable, Outer2.MetaGuard.MethodClash, Outer2.MetaGuard.ClassClash }
RemoveImplementationSelector:{
type method 
This #apply(Outer2.Selector that, Outer2.Path of) 
mut method 
Outer2.Selector #that() 
read method 
Outer2.Selector that() 
mut method 
Outer2.Path #of() 
read method 
Outer2.Path of() 
method 
Library #leftleft(Library that) exception Outer2.MetaGuard.MemberUnavailable }
MoveImplementationSelector:{
type method 
This #apply(Outer2.Selector that, Outer2.Path of, Outer2.Selector to) 
mut method 
Outer2.Selector #that() 
read method 
Outer2.Selector that() 
mut method 
Outer2.Path #of() 
read method 
Outer2.Path of() 
mut method 
Outer2.Selector #to() 
read method 
Outer2.Selector to() 
method 
Library #leftleft(Library that) exception Outer2.MetaGuard.MemberUnavailable, Outer2.MetaGuard.MethodClash }
RemoveImplementationPath:{
type method 
This #apply(Outer2.Path that) 
mut method 
Outer2.Path #that() 
read method 
Outer2.Path that() 
method 
Library #leftleft(Library that) exception Outer2.MetaGuard.NestedClassUnavailable, Outer2.MetaGuard.PrivacyCoupuled }
AddDocumentationSelector:{
type method 
This #apply(Outer2.Selector that, Outer2.Path of, Outer2.Introspection.Doc doc) 
mut method 
Outer2.Selector #that() 
read method 
Outer2.Selector that() 
mut method 
Outer2.Path #of() 
read method 
Outer2.Path of() 
mut method 
Outer2.Introspection.Doc #doc() 
read method 
Outer2.Introspection.Doc doc() 
method 
Library #leftleft(Library that) exception Outer2.MetaGuard.MemberUnavailable }
AddDocumentationPath:{
type method 
This #apply(Outer2.Path that, Outer2.Introspection.Doc doc) 
mut method 
Outer2.Path #that() 
read method 
Outer2.Path that() 
mut method 
Outer2.Introspection.Doc #doc() 
read method 
Outer2.Introspection.Doc doc() 
method 
Library #leftleft(Library that) exception Outer2.MetaGuard.NestedClassUnavailable, Outer2.MetaGuard.InvalidOnTopLevel }
MakePrivatePath:{
type method 
This #apply(Outer2.Path that) 
mut method 
Outer2.Path #that() 
read method 
Outer2.Path that() 
method 
Library #leftleft(Library that) exception Outer2.MetaGuard.MemberUnavailable, Outer2.MetaGuard.InvalidOnTopLevel }
MakePrivateSelector:{
type method 
This #apply(Outer2.Selector that, Outer2.Path of) 
mut method 
Outer2.Selector #that() 
read method 
Outer2.Selector that() 
mut method 
Outer2.Path #of() 
read method 
Outer2.Path of() 
method 
Library #leftleft(Library that) exception Outer2.MetaGuard.MemberUnavailable }
SumMethods:{
type method 
This #apply(Outer2.Selector that, Outer2.Selector and, Outer2.Path of, Outer2.S over, Outer2.Selector to) 
mut method 
Outer2.Selector #that() 
read method 
Outer2.Selector that() 
mut method 
Outer2.Selector #and() 
read method 
Outer2.Selector and() 
mut method 
Outer2.Path #of() 
read method 
Outer2.Path of() 
mut method 
Outer2.S #over() 
read method 
Outer2.S over() 
mut method 
Outer2.Selector #to() 
read method 
Outer2.Selector to() 
method 
Library #leftleft(Library that) exception Outer2.MetaGuard.MemberUnavailable, Outer2.MetaGuard.MethodClash, Outer2.MetaGuard.ParameterMismatch }
Tools:{
type method 
Outer2.S getToSOrName(read Any that) }}
Introspection:{'findMeIntrospection

type method 
This.NestedClass #apply(Library lib) 
type method 
This.NestedClass #apply(Library lib, Outer1.Path path) exception Outer1.MetaGuard.NestedClassUnavailable 
type method 
This.NestedClass #apply(type Any clazz) 
type method 
This.NestedClass #apply(type Any clazz, Outer1.Path path) 
MirrorPr:{interface <:Outer2.Concept.ToS
method 
Outer1.NestedClass introspectReport(fwd Outer1.NestedClass root, Outer2.Path path) exception Outer2.MetaGuard.NestedClassUnavailable 
method 
Outer1.Member introspectReportMember(fwd Outer1.NestedClass root, Outer2.Path path, Outer2.N memberN) exception Outer2.MetaGuard.MemberUnavailable, Void 
method 
Outer1.Type introspectReportType(fwd Outer1.NestedClass root, Outer2.Path path, Outer2.N memberN, Outer2.N typeN) exception Outer2.MetaGuard.MemberUnavailable, Void 
method 
Outer2.S introspectDocAsString(Outer2.Path path) exception Outer2.MetaGuard.NestedClassUnavailable 
method 
Outer2.S introspectDocAsString(Outer2.Path path, Outer2.N annotationN) exception Outer2.MetaGuard.NestedClassUnavailable, Void 
method 
type Any introspectDocPath(Outer2.Path path, Outer2.N annotationN) exception Outer2.MetaGuard.NestedClassUnavailable, Void 
Lib:{<:Outer1
type method 
This #apply(Library lib) 
mut method 
Library #lib() 
read method 
Library lib() }
Class:{<:Outer1
type method 
This #apply(type Any lib) 
mut method 
type Any #lib() 
read method 
type Any lib() }}
Doc:{<:Outer2.Concept.ToS, Outer2.Concept.Named
Annotation:{<:Outer3.Concept.ToS, Outer3.Concept.Named
type method 
This #apply(Library _binaryRepr, Outer3.S text, Outer3.N index) 
mut method 
Library #_binaryRepr() 
read method 
Library _binaryRepr() 
mut method 
Outer3.S #text() 
read method 
Outer3.S text() 
mut method 
Outer3.N #index() 
read method 
Outer3.N index() 
method 
type Any referredClass() 
method 
Outer3.Bool hasReferredClass() }
Annotations:{' generic linked list class, elements of type Elem
<:Outer3.Concept.Named
type method 
This _new(This.Cell head) 
mut method 
This.Cell #head() 
read method 
This.Cell head() 
type method 
This #apply() 
method 
Outer3.Bool isEmpty() 
method 
Outer1.Annotation top() 
method 
mut This.Iterator vals() 
method 
mut This.Iterator valsCut() 
method 
This pop() 
method 
This #plusplus(This that) 
type method 
This #begin() 
method 
This #add(Outer1.Annotation that) 
method 
This #end() 
Cell:{interface 
method 
mut Outer1.Iterator vals(This4.Bool terminate) 
method 
This #next() exception Void 
method 
Outer2.Annotation #inner() 
method 
Void #checkEnd() }
CellEnd:{<:Outer1.Cell
type method 
This #apply() }
CellNext:{<:Outer1.Cell
type method 
This #apply(Outer2.Annotation elem, Outer1.Cell nextCell) 
mut method 
Outer2.Annotation #elem() 
read method 
Outer2.Annotation elem() 
mut method 
Outer1.Cell #nextCell() 
read method 
Outer1.Cell nextCell() }
Iterator:{
type method 
mut This #apply(Outer1.Cell that, This4.Bool terminate) 
mut method 
Void that(Outer1.Cell that) 
mut method 
Outer1.Cell #that() 
read method 
Outer1.Cell that() 
mut method 
This4.Bool #terminate() 
read method 
This4.Bool terminate() 
mut method 
Void #next() exception Void 
read method 
Void #checkEnd() 
read method 
Outer2.Annotation #inner() 
read method 
Void #close() }}
type method 
This #apply(Library that) 
type method 
mut Outer2.S.SBuilder #builder() 
type method 
This #from(Outer2.S.SBuilder builder) 
method 
Library binaryRepr() 
method 
This.Annotations annotations() }
Record:{
type method 
This #apply(Outer1.MirrorPr that) 
mut method 
Outer1.MirrorPr #that() 
read method 
Outer1.MirrorPr that() 
type method 
This #apply(type Any clazz) 
type method 
This #apply(Library lib) 
method 
Void dbg() 
method 
mut Outer2.S.SBuilder #builder() 
method 
Outer2.S #from(Outer2.S.SBuilder builder) 
method 
Outer1.Doc docOf(Outer2.Path path) 
RootForMember:' toPutAs private
{interface 
method 
Outer2.Member #apply(fwd Outer2.NestedClass root) }
RootForNested:' toPutAs private
{<:Outer1.RootForMember
type method 
This #apply(Outer3.Path path, Outer2.MirrorPr mirror, Outer1 _report) 
mut method 
Outer3.Path #path() 
read method 
Outer3.Path path() 
mut method 
Outer2.MirrorPr #mirror() 
read method 
Outer2.MirrorPr mirror() 
mut method 
Outer1 #_report() 
read method 
Outer1 _report() }
RootForMethod:' toPutAs private
{<:Outer1.RootForMember
type method 
This #apply(Outer3.Path path, Outer3.N memberN, Outer1 _report) 
mut method 
Outer3.Path #path() 
read method 
Outer3.Path path() 
mut method 
Outer3.N #memberN() 
read method 
Outer3.N memberN() 
mut method 
Outer1 #_report() 
read method 
Outer1 _report() }
type method 
Outer1.Member dispatch(fwd Outer1.NestedClass root, Outer2.Path path, Outer1.MirrorPr mirror, Outer2.N memberN, Library record) }
Member:{interface <:Outer2.Concept.ToS, Outer2.Concept.Named, Outer2.Concept.Equals}
Members:{' generic linked list class, elements of type Elem
<:Outer2.Concept.Named
type method 
This _new(This.Cell head) 
mut method 
This.Cell #head() 
read method 
This.Cell head() 
type method 
This #apply() 
method 
Outer2.Bool isEmpty() 
method 
Outer1.Member top() 
method 
mut This.Iterator vals() 
method 
mut This.Iterator valsCut() 
method 
This pop() 
method 
This #plusplus(This that) 
type method 
This #begin() 
method 
This #add(Outer1.Member that) 
method 
This #end() 
Cell:{interface 
method 
mut Outer1.Iterator vals(Outer3.Bool terminate) 
method 
This #next() exception Void 
method 
Outer2.Member #inner() 
method 
Void #checkEnd() }
CellEnd:{<:Outer1.Cell
type method 
This #apply() }
CellNext:{<:Outer1.Cell
type method 
This #apply(Outer2.Member elem, Outer1.Cell nextCell) 
mut method 
Outer2.Member #elem() 
read method 
Outer2.Member elem() 
mut method 
Outer1.Cell #nextCell() 
read method 
Outer1.Cell nextCell() }
Iterator:{
type method 
mut This #apply(Outer1.Cell that, Outer3.Bool terminate) 
mut method 
Void that(Outer1.Cell that) 
mut method 
Outer1.Cell #that() 
read method 
Outer1.Cell that() 
mut method 
Outer3.Bool #terminate() 
read method 
Outer3.Bool terminate() 
mut method 
Void #next() exception Void 
read method 
Void #checkEnd() 
read method 
Outer2.Member #inner() 
read method 
Void #close() }
method 
Outer2.Bool contains(Outer1.Member that) 
method 
This remove(Outer1.Member that) 
method 
Outer2.Bool #equalequal(This that) 
method 
Outer2.Bool equals(Any that) }
Method:{<:Outer1.Member, Outer2.Concept.Equals
method 
Outer2.Bool #equalequal(This that) 
method 
Outer2.Bool #bangequal(This that) 
method 
Outer1.Doc doc() 
method 
Outer2.S thisMdf() 
method ' invariant NestedClass(...).nestedClassFromRoot(path).pathFromRoot()==path
Outer2.Path pathFromRoot() 
method 
Outer2.Selector selector() 
method 
Outer2.S methodKind() 
method 
Outer2.S allAsString() 
method 
Outer1.Type returnType() 
method 
Outer1.Types exceptions() 
method 
Outer1.Types parameterTypes() 
method 
Outer2.Bool isPrivate() 
method 
Outer1.NestedClass root() }
Methods:{' generic linked list class, elements of type Elem
<:Outer2.Concept.Named
type method 
This _new(This.Cell head) 
mut method 
This.Cell #head() 
read method 
This.Cell head() 
type method 
This #apply() 
method 
Outer2.Bool isEmpty() 
method 
Outer1.Method top() 
method 
mut This.Iterator vals() 
method 
mut This.Iterator valsCut() 
method 
This pop() 
method 
This #plusplus(This that) 
type method 
This #begin() 
method 
This #add(Outer1.Method that) 
method 
This #end() 
Cell:{interface 
method 
mut Outer1.Iterator vals(Outer3.Bool terminate) 
method 
This #next() exception Void 
method 
Outer2.Method #inner() 
method 
Void #checkEnd() }
CellEnd:{<:Outer1.Cell
type method 
This #apply() }
CellNext:{<:Outer1.Cell
type method 
This #apply(Outer2.Method elem, Outer1.Cell nextCell) 
mut method 
Outer2.Method #elem() 
read method 
Outer2.Method elem() 
mut method 
Outer1.Cell #nextCell() 
read method 
Outer1.Cell nextCell() }
Iterator:{
type method 
mut This #apply(Outer1.Cell that, Outer3.Bool terminate) 
mut method 
Void that(Outer1.Cell that) 
mut method 
Outer1.Cell #that() 
read method 
Outer1.Cell that() 
mut method 
Outer3.Bool #terminate() 
read method 
Outer3.Bool terminate() 
mut method 
Void #next() exception Void 
read method 
Void #checkEnd() 
read method 
Outer2.Method #inner() 
read method 
Void #close() }
method 
Outer2.Bool contains(Outer1.Method that) 
method 
This remove(Outer1.Method that) 
method 
Outer2.Bool #equalequal(This that) 
method 
Outer2.Bool equals(Any that) }
NestedClass:{'findMeNestedClass
<:Outer1.Member, Outer2.Concept.Equals
method 
Outer2.Bool #equalequal(This that) 
method 
Outer2.Bool #bangequal(This that) 
method 
This root() 
method 'error for This
Outer1.Doc nestedDoc() 
method 'of the library literal
Outer1.Doc doc() 
method 
Outer2.Path pathFromRoot() 
method 
Outer2.Bool hasExternalType() 
method 
type Any externalType() 
method 
Outer2.S externalTypeToS() 
method 
Outer2.S classKind() 
method 
Outer2.S allAsString() 
method 
Outer1.Members members() 
method 
Outer1.Methods methods() 
method 
Outer1.NestedClasses nestedClasses() 
method 
Outer1.NestedClasses transitivelyNestedClasses() 
method 
Outer1.Types implementedInterfaces() 
method 
Outer1.Types transitivelyImplementedInterfaces() 
method 
Outer1.Methods stateCandidate() 
method 
Outer1.Methods state() 
method 
Outer1.Method methodFromSelector(Outer2.Selector that) exception Outer2.MetaGuard.MethodUnavailable 
method 
Outer2.Bool has(Outer2.Selector selector) 
method 
This nestedClassFromRoot(Outer2.Path that) exception Outer2.MetaGuard.NestedClassUnavailable 
method 
Outer2.Bool has(Outer2.Path fromRoot) 
method 
Outer2.Bool isPrivate() }
NestedClasses:{' generic linked list class, elements of type Elem
<:Outer2.Concept.Named
type method 
This _new(This.Cell head) 
mut method 
This.Cell #head() 
read method 
This.Cell head() 
type method 
This #apply() 
method 
Outer2.Bool isEmpty() 
method 
Outer1.NestedClass top() 
method 
mut This.Iterator vals() 
method 
mut This.Iterator valsCut() 
method 
This pop() 
method 
This #plusplus(This that) 
type method 
This #begin() 
method 
This #add(Outer1.NestedClass that) 
method 
This #end() 
Cell:{interface 
method 
mut Outer1.Iterator vals(Outer3.Bool terminate) 
method 
This #next() exception Void 
method 
Outer2.NestedClass #inner() 
method 
Void #checkEnd() }
CellEnd:{<:Outer1.Cell
type method 
This #apply() }
CellNext:{<:Outer1.Cell
type method 
This #apply(Outer2.NestedClass elem, Outer1.Cell nextCell) 
mut method 
Outer2.NestedClass #elem() 
read method 
Outer2.NestedClass elem() 
mut method 
Outer1.Cell #nextCell() 
read method 
Outer1.Cell nextCell() }
Iterator:{
type method 
mut This #apply(Outer1.Cell that, Outer3.Bool terminate) 
mut method 
Void that(Outer1.Cell that) 
mut method 
Outer1.Cell #that() 
read method 
Outer1.Cell that() 
mut method 
Outer3.Bool #terminate() 
read method 
Outer3.Bool terminate() 
mut method 
Void #next() exception Void 
read method 
Void #checkEnd() 
read method 
Outer2.NestedClass #inner() 
read method 
Void #close() }
method 
Outer2.Bool contains(Outer1.NestedClass that) 
method 
This remove(Outer1.NestedClass that) 
method 
Outer2.Bool #equalequal(This that) 
method 
Outer2.Bool equals(Any that) }
Type:{<:Outer2.Concept.ToS, Outer2.Concept.Named
method 
Outer2.S allAsString() 
method 
Outer2.S strRepr() 
method 
Outer2.S typeKind() 
method 
Outer2.S mdf() 
method 
Outer1.NestedClass referencedPath() 
method 
Outer1.NestedClass resolvedReferencedPath() 
method 
Outer2.Bool partial() 
method 
Outer2.Bool resolvedPartial() 
method 
Outer2.S suffix() 
method 
Outer1.Doc doc() }
Types:{' generic linked list class, elements of type Elem
<:Outer2.Concept.Named
type method 
This _new(This.Cell head) 
mut method 
This.Cell #head() 
read method 
This.Cell head() 
type method 
This #apply() 
method 
Outer2.Bool isEmpty() 
method 
Outer1.Type top() 
method 
mut This.Iterator vals() 
method 
mut This.Iterator valsCut() 
method 
This pop() 
method 
This #plusplus(This that) 
type method 
This #begin() 
method 
This #add(Outer1.Type that) 
method 
This #end() 
Cell:{interface 
method 
mut Outer1.Iterator vals(Outer3.Bool terminate) 
method 
This #next() exception Void 
method 
Outer2.Type #inner() 
method 
Void #checkEnd() }
CellEnd:{<:Outer1.Cell
type method 
This #apply() }
CellNext:{<:Outer1.Cell
type method 
This #apply(Outer2.Type elem, Outer1.Cell nextCell) 
mut method 
Outer2.Type #elem() 
read method 
Outer2.Type elem() 
mut method 
Outer1.Cell #nextCell() 
read method 
Outer1.Cell nextCell() }
Iterator:{
type method 
mut This #apply(Outer1.Cell that, Outer3.Bool terminate) 
mut method 
Void that(Outer1.Cell that) 
mut method 
Outer1.Cell #that() 
read method 
Outer1.Cell that() 
mut method 
Outer3.Bool #terminate() 
read method 
Outer3.Bool terminate() 
mut method 
Void #next() exception Void 
read method 
Void #checkEnd() 
read method 
Outer2.Type #inner() 
read method 
Void #close() }}}
MetaGuard:{interface <:Outer1.Guard
RecordWrapper:' can not be private, I need to Patch it.
{
type method 
Outer2.S libToS(Library that) 
type method 
Library recordWrapperToSTrait() 
type method 
Library recordWrapperTrait() 
type method 
Library #leftleft(Library that) }
SourceUnfit:{<:Outer1, Outer1
type method 
Outer2.S libName() 
type method 
This #apply(Outer2.Introspection.Record record, Library lib) 
method 
Outer2.Bool #bangequal(This that) 
method 
Outer2.Bool #equalequal(This that) 
type method 
Void #apply(Library lift) exception This 
method 
Library lib() }
IncoherentRedirectMapping:{<:Outer1, Outer1
type method 
Outer2.S libName() 
type method 
This #apply(Outer2.Introspection.Record record, Library lib) 
method 
Outer2.Bool #bangequal(This that) 
method 
Outer2.Bool #equalequal(This that) 
type method 
Void #apply(Library lift) exception This 
method 
Library lib() }
ClassClash:{<:Outer1, Outer1
type method 
Outer2.S libName() 
type method 
This #apply(Outer2.Introspection.Record record, Library lib) 
method 
Outer2.Bool #bangequal(This that) 
method 
Outer2.Bool #equalequal(This that) 
type method 
Void #apply(Library lift) exception This 
method 
Library lib() }
MethodClash:{<:Outer1, Outer1
type method 
Outer2.S libName() 
type method 
This #apply(Outer2.Introspection.Record record, Library lib) 
method 
Outer2.Bool #bangequal(This that) 
method 
Outer2.Bool #equalequal(This that) 
type method 
Void #apply(Library lift) exception This 
method 
Library lib() }
InvalidOnTopLevel:{<:Outer1, Outer1
type method 
Outer2.S libName() 
type method 
This #apply(Outer2.Introspection.Record record, Library lib) 
method 
Outer2.Bool #bangequal(This that) 
method 
Outer2.Bool #equalequal(This that) 
type method 
Void #apply(Library lift) exception This 
method 
Library lib() }
PrivacyCoupuled:{<:Outer1, Outer1
type method 
Outer2.S libName() 
type method 
This #apply(Outer2.Introspection.Record record, Library lib) 
method 
Outer2.Bool #bangequal(This that) 
method 
Outer2.Bool #equalequal(This that) 
type method 
Void #apply(Library lift) exception This 
method 
Library lib() }
ParameterMismatch:{<:Outer1, Outer1
type method 
Outer2.S libName() 
type method 
This #apply(Outer2.Introspection.Record record, Library lib) 
method 
Outer2.Bool #bangequal(This that) 
method 
Outer2.Bool #equalequal(This that) 
type method 
Void #apply(Library lift) exception This 
method 
Library lib() }
MemberUnavailable:{interface <:Outer1}
DispatchMemberUnavailable:{
type method 
Void #apply(Library that) exception Outer1.MemberUnavailable }
NestedClassUnavailable:{<:Outer1.MemberUnavailable, Outer1
type method 
This #apply(Outer2.Path path, Outer2.Bool isPrivate) 
mut method 
Outer2.Path #path() 
read method 
Outer2.Path path() 
mut method 
Outer2.Bool #isPrivate() 
read method 
Outer2.Bool isPrivate() 
type method 
This #apply(Outer2.Introspection.Record record, Library lib) 
type method 
Outer2.S libName() 
method 
Outer2.Bool #bangequal(This that) 
method 
Outer2.Bool #equalequal(This that) 
type method 
Void #apply(Library lift) exception This }
MethodUnavailable:{<:Outer1.MemberUnavailable, Outer1
type method 
This #apply(Outer2.Path path, Outer2.Selector selector, Outer2.Bool isPrivate) 
mut method 
Outer2.Path #path() 
read method 
Outer2.Path path() 
mut method 
Outer2.Selector #selector() 
read method 
Outer2.Selector selector() 
mut method 
Outer2.Bool #isPrivate() 
read method 
Outer2.Bool isPrivate() 
type method 
This #apply(Outer2.Introspection.Record record, Library lib) 
type method 
Outer2.S libName() 
method 
Outer2.Bool #bangequal(This that) 
method 
Outer2.Bool #equalequal(This that) 
type method 
Void #apply(Library lift) exception This }}
Selector:{<:Outer1.Concept.ToS, Outer1.Concept.Equals, Outer1.Concept.Named
type method 
This fromS(Outer1.Concept.ToS that) 
type method 
This #from(Outer1.S.SBuilder builder) 
type method 
mut Outer1.S.SBuilder #builder() 
type method 
This #from(Library binaryRepr) 
type method 
Any parseError(Outer1.S that) 
type method 
This from(Outer1.S name, Outer1.Strings names) 
method 
Outer1.S nameAsField() 
method 
Outer1.S prefixAsField() 
method 
Library binaryRepr() 
method 
Outer1.Bool #bangequal(This that) 
method 
Outer1.Bool #equalequal(This that) 
method 
Outer1.Bool isOperator() 
method 
Outer1.S name() 
method 
Outer1.Strings names() 
type method 
This fresh(This that) 
ParseFail:{<:Outer2.Guard.ParseFail, Outer2.Message
type method 
This #apply(Outer2.S _text, Outer2.Message.Opt cause) 
mut method 
Outer2.S #_text() 
read method 
Outer2.S _text() 
mut method 
Outer2.Message.Opt #cause() 
read method 
Outer2.Message.Opt cause() 
method 
This #apply(Outer2.Message that) 
method 
Outer2.Bool #bangequal(This that) 
method 
Outer2.Bool #equalequal(This that) 
type method 
This #apply(Outer2.S text) 
type method 
This #apply(Outer2.S text, Outer2.Message cause) 
type method 
mut Outer2.S.SBuilder #builder() 
type method 
This #from(Outer2.S.SBuilder builder) 
method 
This.SConcat #begin() 
SConcat:{
type method 
This #apply(Outer3.Concept.ToS old, Outer3.S accumulator) 
mut method 
Outer3.Concept.ToS #old() 
read method 
Outer3.Concept.ToS old() 
mut method 
Outer3.S #accumulator() 
read method 
Outer3.S accumulator() 
method 
This #add(Outer3.Concept.ToS that) 
method 
This #add(Outer3.Concept.ToS that, Outer3.Concept.ToS separedBy) 
method 
This #end() 
method 
mut Outer3.S.SBuilder #builder() 
method 
Outer1 #from(Outer3.S.SBuilder builder) }}}
Path:{<:Outer1.Concept.ToS, Outer1.Concept.Equals, Outer1.Concept.Named
type method 
This fromDocInternalizedS(Outer1.S that) 
type method 
This fromS(Outer1.Concept.ToS that) 
type method 
This #from(Outer1.S.SBuilder builder) 
type method 
mut Outer1.S.SBuilder #builder() 
type method 
This #from(Library binaryRepr) 
type method 
Any parseError(Outer1.S that) 
type method 
Any parseError(Outer1.S that, Outer1.Message cause) 
method 
Library binaryRepr() 
method 
Outer1.Bool #bangequal(This that) 
method 
Outer1.Bool #equalequal(This that) 
method 
This #plusplus(This that) 
method 
Outer1.Strings names() 
type method 
This from(Outer1.Strings names) 
type method 
This fresh(Outer1.S name) 
type method 
This fresh() 
type method 
This fresh(This path) 
ParseFail:{<:Outer2.Guard.ParseFail, Outer2.Message
type method 
This #apply(Outer2.S _text, Outer2.Message.Opt cause) 
mut method 
Outer2.S #_text() 
read method 
Outer2.S _text() 
mut method 
Outer2.Message.Opt #cause() 
read method 
Outer2.Message.Opt cause() 
method 
This #apply(Outer2.Message that) 
method 
Outer2.Bool #bangequal(This that) 
method 
Outer2.Bool #equalequal(This that) 
type method 
This #apply(Outer2.S text) 
type method 
This #apply(Outer2.S text, Outer2.Message cause) 
type method 
mut Outer2.S.SBuilder #builder() 
type method 
This #from(Outer2.S.SBuilder builder) 
method 
This.SConcat #begin() 
SConcat:{
type method 
This #apply(Outer3.Concept.ToS old, Outer3.S accumulator) 
mut method 
Outer3.Concept.ToS #old() 
read method 
Outer3.Concept.ToS old() 
mut method 
Outer3.S #accumulator() 
read method 
Outer3.S accumulator() 
method 
This #add(Outer3.Concept.ToS that) 
method 
This #add(Outer3.Concept.ToS that, Outer3.Concept.ToS separedBy) 
method 
This #end() 
method 
mut Outer3.S.SBuilder #builder() 
method 
Outer1 #from(Outer3.S.SBuilder builder) }}}
Url:{'ParseFailure:Message:S[]<<{<:Guard} no need, related to invariant?
<:Outer1.Concept.ToS
type method ' if you do not implement it, it is a constructor?
This fromS(read Outer1.Concept.ToS that) 
type method 
This #from(Outer1.S.SBuilder builder) 
type method 
mut Outer1.S.SBuilder #builder() 
type method 
This #apply(Outer1.S inner) 
mut method 
Outer1.S #inner() 
read method 
Outer1.S inner() 
method 
Library binaryRepr() }
ConceptMap:{interface 
method 
Outer1.Alu _Alu() 
method 
Outer1.ExitCode _ExitCode() 
method 
Outer1.Bool _Bool() 
method 
Outer1.N _N() 
method 
Outer1.S _S() 
method 
Outer1.Concept _Concept() 
method 
Outer1.Message _Message() 
method 
Outer1.Guard _Guard() 
method 
Outer1.System _System() 
method 
Outer1.Assert _Assert() 
method 
Outer1.Strings _Strings() 
method 
Outer1.Debug _Debug() 
method 
This _ConceptMap() 
method 
Outer1.Url _Url() 
method 
Outer1.Path _Path() 
method 
Outer1.Selector _Selector() 
method 
Outer1.MetaGuard _MetaGuard() 
method 
Outer1.Introspection _Introspection() 
method 
Outer1.Refactor _Refactor() 
method 
Outer1.Optimize _Optimize() 
method 
Outer1.Opt _Opt() 
method 
Outer1.Extends _Extends() 
method 
Outer1.Use _Use() 
method 
Outer1.Default _Default() 
method 
Outer1.LinkedList _LinkedList() 
method 
Outer1.DeployTowel _DeployTowel() 
method 
Outer1.PreferentialComposition _PreferentialComposition() 
method 
Outer1.Load _Load() }
Debug:{
type method 
Void #apply(Outer1.Concept.ToS that) 
type method 
Void #apply(Library lib) 
type method 
Void #apply(Outer1.Concept.ToS fileName, Outer1.Concept.ToS content) }
Strings:{' generic linked list class, elements of type Elem
<:Outer1.Concept.Named
type method 
This _new(This.Cell head) 
mut method 
This.Cell #head() 
read method 
This.Cell head() 
type method 
This #apply() 
method 
Outer1.Bool isEmpty() 
method 
Outer1.S top() 
method 
mut This.Iterator vals() 
method 
mut This.Iterator valsCut() 
method 
This pop() 
method 
This #plusplus(This that) 
type method 
This #begin() 
method 
This #add(Outer1.S that) 
method 
This #end() 
Cell:{interface 
method 
mut Outer1.Iterator vals(Outer2.Bool terminate) 
method 
This #next() exception Void 
method 
Outer2.S #inner() 
method 
Void #checkEnd() }
CellEnd:{<:Outer1.Cell
type method 
This #apply() }
CellNext:{<:Outer1.Cell
type method 
This #apply(Outer2.S elem, Outer1.Cell nextCell) 
mut method 
Outer2.S #elem() 
read method 
Outer2.S elem() 
mut method 
Outer1.Cell #nextCell() 
read method 
Outer1.Cell nextCell() }
Iterator:{
type method 
mut This #apply(Outer1.Cell that, Outer2.Bool terminate) 
mut method 
Void that(Outer1.Cell that) 
mut method 
Outer1.Cell #that() 
read method 
Outer1.Cell that() 
mut method 
Outer2.Bool #terminate() 
read method 
Outer2.Bool terminate() 
mut method 
Void #next() exception Void 
read method 
Void #checkEnd() 
read method 
Outer2.S #inner() 
read method 
Void #close() }
method 
Outer1.Bool contains(Outer1.S that) 
method 
This remove(Outer1.S that) 
method 
Outer1.Bool #equalequal(This that) 
method 
Outer1.Bool equals(Any that) }
Assert:{interface <:Outer1.Message
NotImplementedYet:{<:Outer1, Outer2.Message
type method 
This #apply(Outer2.S _text, Outer2.Message.Opt cause) 
mut method 
Outer2.S #_text() 
read method 
Outer2.S _text() 
mut method 
Outer2.Message.Opt #cause() 
read method 
Outer2.Message.Opt cause() 
method 
This #apply(Outer2.Message that) 
method 
Outer2.Bool #bangequal(This that) 
method 
Outer2.Bool #equalequal(This that) 
type method 
This #apply(Outer2.S text) 
type method 
This #apply(Outer2.S text, Outer2.Message cause) 
type method 
mut Outer2.S.SBuilder #builder() 
type method 
This #from(Outer2.S.SBuilder builder) 
method 
This.SConcat #begin() 
SConcat:{
type method 
This #apply(Outer3.Concept.ToS old, Outer3.S accumulator) 
mut method 
Outer3.Concept.ToS #old() 
read method 
Outer3.Concept.ToS old() 
mut method 
Outer3.S #accumulator() 
read method 
Outer3.S accumulator() 
method 
This #add(Outer3.Concept.ToS that) 
method 
This #add(Outer3.Concept.ToS that, Outer3.Concept.ToS separedBy) 
method 
This #end() 
method 
mut Outer3.S.SBuilder #builder() 
method 
Outer1 #from(Outer3.S.SBuilder builder) }}
ObservedBug:{<:Outer1, Outer2.Message
type method 
This #apply(Outer2.S _text, Outer2.Message.Opt cause) 
mut method 
Outer2.S #_text() 
read method 
Outer2.S _text() 
mut method 
Outer2.Message.Opt #cause() 
read method 
Outer2.Message.Opt cause() 
method 
This #apply(Outer2.Message that) 
method 
Outer2.Bool #bangequal(This that) 
method 
Outer2.Bool #equalequal(This that) 
type method 
This #apply(Outer2.S text) 
type method 
This #apply(Outer2.S text, Outer2.Message cause) 
type method 
mut Outer2.S.SBuilder #builder() 
type method 
This #from(Outer2.S.SBuilder builder) 
method 
This.SConcat #begin() 
SConcat:{
type method 
This #apply(Outer3.Concept.ToS old, Outer3.S accumulator) 
mut method 
Outer3.Concept.ToS #old() 
read method 
Outer3.Concept.ToS old() 
mut method 
Outer3.S #accumulator() 
read method 
Outer3.S accumulator() 
method 
This #add(Outer3.Concept.ToS that) 
method 
This #add(Outer3.Concept.ToS that, Outer3.Concept.ToS separedBy) 
method 
This #end() 
method 
mut Outer3.S.SBuilder #builder() 
method 
Outer1 #from(Outer3.S.SBuilder builder) }}
CodeNotReachable:{<:Outer1, Outer2.Message
type method 
This #apply(Outer2.S _text, Outer2.Message.Opt cause) 
mut method 
Outer2.S #_text() 
read method 
Outer2.S _text() 
mut method 
Outer2.Message.Opt #cause() 
read method 
Outer2.Message.Opt cause() 
method 
This #apply(Outer2.Message that) 
method 
Outer2.Bool #bangequal(This that) 
method 
Outer2.Bool #equalequal(This that) 
type method 
This #apply(Outer2.S text) 
type method 
This #apply(Outer2.S text, Outer2.Message cause) 
type method 
mut Outer2.S.SBuilder #builder() 
type method 
This #from(Outer2.S.SBuilder builder) 
method 
This.SConcat #begin() 
SConcat:{
type method 
This #apply(Outer3.Concept.ToS old, Outer3.S accumulator) 
mut method 
Outer3.Concept.ToS #old() 
read method 
Outer3.Concept.ToS old() 
mut method 
Outer3.S #accumulator() 
read method 
Outer3.S accumulator() 
method 
This #add(Outer3.Concept.ToS that) 
method 
This #add(Outer3.Concept.ToS that, Outer3.Concept.ToS separedBy) 
method 
This #end() 
method 
mut Outer3.S.SBuilder #builder() 
method 
Outer1 #from(Outer3.S.SBuilder builder) }}
$:{
type method 
This #apply(Outer2.N that) 
mut method 
Outer2.N #that() 
read method 
Outer2.N that() 
type method 
This #begin() 
method 
Void #end() 
method 
This #add(Outer2.Bool that) 
method 
This #add(Outer2.Bool that, Outer2.Concept.ToS msg) }
AssertMessage:{<:Outer1, Outer2.Message
type method 
This #apply(Outer2.S _text, Outer2.Message.Opt cause) 
mut method 
Outer2.S #_text() 
read method 
Outer2.S _text() 
mut method 
Outer2.Message.Opt #cause() 
read method 
Outer2.Message.Opt cause() 
method 
This #apply(Outer2.Message that) 
method 
Outer2.Bool #bangequal(This that) 
method 
Outer2.Bool #equalequal(This that) 
type method 
This #apply(Outer2.S text) 
type method 
This #apply(Outer2.S text, Outer2.Message cause) 
type method 
mut Outer2.S.SBuilder #builder() 
type method 
This #from(Outer2.S.SBuilder builder) 
method 
This.SConcat #begin() 
SConcat:{
type method 
This #apply(Outer3.Concept.ToS old, Outer3.S accumulator) 
mut method 
Outer3.Concept.ToS #old() 
read method 
Outer3.Concept.ToS old() 
mut method 
Outer3.S #accumulator() 
read method 
Outer3.S accumulator() 
method 
This #add(Outer3.Concept.ToS that) 
method 
This #add(Outer3.Concept.ToS that, Outer3.Concept.ToS separedBy) 
method 
This #end() 
method 
mut Outer3.S.SBuilder #builder() 
method 
Outer1 #from(Outer3.S.SBuilder builder) }}}
System:{
Guard:{'<:Outer.Guard soon (remove "interface" for a bad translation bug: Outer1_System_Guard is not abstract and does not override abstract method MtoS()
interface <:Outer2.Guard
PluginFailure:{<:Outer1, Outer3.Message
type method 
This #apply(Outer3.S _text, Outer3.Message.Opt cause) 
mut method 
Outer3.S #_text() 
read method 
Outer3.S _text() 
mut method 
Outer3.Message.Opt #cause() 
read method 
Outer3.Message.Opt cause() 
method 
This #apply(Outer3.Message that) 
method 
Outer3.Bool #bangequal(This that) 
method 
Outer3.Bool #equalequal(This that) 
type method 
This #apply(Outer3.S text) 
type method 
This #apply(Outer3.S text, Outer3.Message cause) 
type method 
mut Outer3.S.SBuilder #builder() 
type method 
This #from(Outer3.S.SBuilder builder) 
method 
This.SConcat #begin() 
SConcat:{
type method 
This #apply(This4.Concept.ToS old, This4.S accumulator) 
mut method 
This4.Concept.ToS #old() 
read method 
This4.Concept.ToS old() 
mut method 
This4.S #accumulator() 
read method 
This4.S accumulator() 
method 
This #add(This4.Concept.ToS that) 
method 
This #add(This4.Concept.ToS that, This4.Concept.ToS separedBy) 
method 
This #end() 
method 
mut This4.S.SBuilder #builder() 
method 
Outer1 #from(This4.S.SBuilder builder) }}}}
Guard:{' exception as Guard bureocracy, error as Guard detection
'-is a check guarenteed to be performed, program logic can rely on this being enforced.
'  as exceptions, Guards objects are a way to report/guard complex operations,
' where checking the shape of the input can be unconvenient.
'as errors, they represent precondition violations. 
'Turning an exception Guard into an error Guard
' is equivalent of declaring that such misuse should not happen (blame on the caller),
' still, there is no bug in the program at this stage. Is legit for the caller to try and be blamed
interface <:Outer1.Message'all other guards should implement this one

Operation:{<:Outer1, Outer2.Message
type method 
This #apply(Outer2.S _text, Outer2.Message.Opt cause) 
mut method 
Outer2.S #_text() 
read method 
Outer2.S _text() 
mut method 
Outer2.Message.Opt #cause() 
read method 
Outer2.Message.Opt cause() 
method 
This #apply(Outer2.Message that) 
method 
Outer2.Bool #bangequal(This that) 
method 
Outer2.Bool #equalequal(This that) 
type method 
This #apply(Outer2.S text) 
type method 
This #apply(Outer2.S text, Outer2.Message cause) 
type method 
mut Outer2.S.SBuilder #builder() 
type method 
This #from(Outer2.S.SBuilder builder) 
method 
This.SConcat #begin() 
SConcat:{
type method 
This #apply(Outer3.Concept.ToS old, Outer3.S accumulator) 
mut method 
Outer3.Concept.ToS #old() 
read method 
Outer3.Concept.ToS old() 
mut method 
Outer3.S #accumulator() 
read method 
Outer3.S accumulator() 
method 
This #add(Outer3.Concept.ToS that) 
method 
This #add(Outer3.Concept.ToS that, Outer3.Concept.ToS separedBy) 
method 
This #end() 
method 
mut Outer3.S.SBuilder #builder() 
method 
Outer1 #from(Outer3.S.SBuilder builder) }}
Parameter:{<:Outer1, Outer2.Message
type method 
This #apply(Outer2.S _text, Outer2.Message.Opt cause) 
mut method 
Outer2.S #_text() 
read method 
Outer2.S _text() 
mut method 
Outer2.Message.Opt #cause() 
read method 
Outer2.Message.Opt cause() 
method 
This #apply(Outer2.Message that) 
method 
Outer2.Bool #bangequal(This that) 
method 
Outer2.Bool #equalequal(This that) 
type method 
This #apply(Outer2.S text) 
type method 
This #apply(Outer2.S text, Outer2.Message cause) 
type method 
mut Outer2.S.SBuilder #builder() 
type method 
This #from(Outer2.S.SBuilder builder) 
method 
This.SConcat #begin() 
SConcat:{
type method 
This #apply(Outer3.Concept.ToS old, Outer3.S accumulator) 
mut method 
Outer3.Concept.ToS #old() 
read method 
Outer3.Concept.ToS old() 
mut method 
Outer3.S #accumulator() 
read method 
Outer3.S accumulator() 
method 
This #add(Outer3.Concept.ToS that) 
method 
This #add(Outer3.Concept.ToS that, Outer3.Concept.ToS separedBy) 
method 
This #end() 
method 
mut Outer3.S.SBuilder #builder() 
method 
Outer1 #from(Outer3.S.SBuilder builder) }}
Precondition:{<:Outer1, Outer2.Message
type method 
This #apply(Outer2.S _text, Outer2.Message.Opt cause) 
mut method 
Outer2.S #_text() 
read method 
Outer2.S _text() 
mut method 
Outer2.Message.Opt #cause() 
read method 
Outer2.Message.Opt cause() 
method 
This #apply(Outer2.Message that) 
method 
Outer2.Bool #bangequal(This that) 
method 
Outer2.Bool #equalequal(This that) 
type method 
This #apply(Outer2.S text) 
type method 
This #apply(Outer2.S text, Outer2.Message cause) 
type method 
mut Outer2.S.SBuilder #builder() 
type method 
This #from(Outer2.S.SBuilder builder) 
method 
This.SConcat #begin() 
SConcat:{
type method 
This #apply(Outer3.Concept.ToS old, Outer3.S accumulator) 
mut method 
Outer3.Concept.ToS #old() 
read method 
Outer3.Concept.ToS old() 
mut method 
Outer3.S #accumulator() 
read method 
Outer3.S accumulator() 
method 
This #add(Outer3.Concept.ToS that) 
method 
This #add(Outer3.Concept.ToS that, Outer3.Concept.ToS separedBy) 
method 
This #end() 
method 
mut Outer3.S.SBuilder #builder() 
method 
Outer1 #from(Outer3.S.SBuilder builder) }}
ParseFail:{interface <:Outer1}}
Message:{interface <:Outer1.Concept.ToS, Outer1.Concept.Equals, Outer1.Concept.Classable, Outer1.Concept.Named
type method 
Outer1.S kind() 
method 
Outer1.S text() 
method 
This.Opt responseOf() 
read method 
type This clazz() 
Opt:{
type method 
This #new(This.TOpt that) 
mut method 
This.TOpt #that() 
read method 
This.TOpt that() 
TOpt:{interface 
method 
Outer2 get() }
TEmpty:{<:Outer1.TOpt, Outer1.TOpt
type method 
This #apply() }
TOf:{<:Outer1.TOpt
type method 
This #apply(Outer2 that) 
mut method 
Outer2 #that() 
read method 
Outer2 that() }
method 
Outer1 #tilde() 
method 
Outer2.Bool isPresent() 
type method 
This #apply() 
type method 
This #apply(Outer1 that) }
EqualMessages:{
type method 
Outer2.Bool #apply(Outer1 that, Outer1 other) }
$:{
type method 
This #apply() 
type method 
Library #leftleft(Library that) 
type method 
Library messageTrait() }}
Concept:{
ToS:{interface 
read method 
Outer2.S toS() }
Classable:{interface 
read method 
type Any classAny() }
Named:{interface 
type method 
Outer2.S myName() }
Wrapper:{interface 
read method 
Any inner() }
TypeWrapper:{interface 
read method 
type Any inner() }
ReadWrapper:{interface 
read method 
read Any inner() }
MutWrapper:{interface <:Outer1.ReadWrapper
mut method 
mut Any #inner() }
LentWrapper:{interface <:Outer1.ReadWrapper
mut method 
lent Any #inner() }
Equals:{interface 
read method 
Outer2.Bool equals(read Any that) }
Comparable:{interface 
read method 
Outer2.Bool greater(read Any that) }
Boollable:{interface 
read method 
Void #checkTrue() exception Void }
Decorator:{interface 'method Library>>(Library that) exception MetaGuard(specific)
'method Library decorate(Library that) exception MetaGuard I can link metaguard for circularity
}
Contains:{interface 'read method Bool >>(read Elem that)

read method 
Outer2.Bool contains(read Any that) }
Parsable:{interface 'type method capsule This fromS(S that) exception Guard.Parameter(specific) invalid string
'''type method capsule This #fromS(S that) exception Guard.Parameter
}
Invariant:{interface 
read method ' can throw error or return false, as more opportune
Outer2.Bool invariant() }
RandomAccess:{interface 'read method read Elem (N that)
'mut method mut Elem #(N that)

read method 
read Any get(Outer2.N that) 
mut method 
mut Any #get(Outer2.N that) }
Sizable:{interface 
read method 
Outer2.N size() 
read method 
Outer2.Bool isEmpty() }
Iterator:{interface 
mut method 
Void #next() exception Void 
read method 
Void #checkEnd() 
read method 
Void #close() }}
S:{<:Outer1.Concept.ToS, Outer1.Concept.Equals, Outer1.Concept.Named
type method 
This #from(Library binaryRepr) 
method 
Library binaryRepr() 
method 
This #plusplus(This that) 
method 
Outer1.Bool #bangequal(This that) 
method 
Outer1.Bool #equalequal(This that) 
method 
This #apply(Outer1.N start, Outer1.N end) 
method 
This #apply(Outer1.N that) 
method 
This #apply(Outer1.N start) 
method 
This #apply(Outer1.N end) 
method 
Outer1.Bool beginsWith(This that) 
method 
Outer1.N firstIndexOf(This that) 
type method 
Void subStringNotPresent(This string, This subString) 
method 
Outer1.Bool contains(This that) 
method 
Outer1.Bool isASCIILowerCase(Outer1.N that) 
method 
Outer1.Bool isASCIIUpperCase(Outer1.N that) 
method 
Outer1.N size() 
type method 
This doubleQuote() 
type method 
This nl() 
method 
This replace(This that, This into) 
method 
This.SConcat #begin() 
SConcat:{
type method 
This #apply(Outer1 old, Outer1 accumulator) 
mut method 
Outer1 #old() 
read method 
Outer1 old() 
mut method 
Outer1 #accumulator() 
read method 
Outer1 accumulator() 
method 
This #add(Outer2.Concept.ToS that) 
method 
This #add(Outer2.Concept.ToS that, Outer2.Concept.ToS separedBy) 
method 
This #end() 
method 
mut Outer1.SBuilder #builder() 
method 
Outer1 #from(Outer1.SBuilder builder) }
SBuilder:{
read method 
Library binaryRepr() 
mut method 
Void acc(Library that) 
type method 
mut This empty() 
mut method 
Void #0() 
mut method 
Void #1() 
mut method 
Void #2() 
mut method 
Void #3() 
mut method 
Void #4() 
mut method 
Void #5() 
mut method 
Void #6() 
mut method 
Void #7() 
mut method 
Void #8() 
mut method 
Void #9() 
mut method 
Void #q() 
mut method 
Void #w() 
mut method 
Void #e() 
mut method 
Void #r() 
mut method 
Void #t() 
mut method 
Void #y() 
mut method 
Void #u() 
mut method 
Void #i() 
mut method 
Void #o() 
mut method 
Void #p() 
mut method 
Void #a() 
mut method 
Void #s() 
mut method 
Void #d() 
mut method 
Void #f() 
mut method 
Void #g() 
mut method 
Void #h() 
mut method 
Void #j() 
mut method 
Void #k() 
mut method 
Void #l() 
mut method 
Void #z() 
mut method 
Void #x() 
mut method 
Void #c() 
mut method 
Void #v() 
mut method 
Void #b() 
mut method 
Void #n() 
mut method 
Void #m() 
mut method 
Void #Q() 
mut method 
Void #W() 
mut method 
Void #E() 
mut method 
Void #R() 
mut method 
Void #T() 
mut method 
Void #Y() 
mut method 
Void #U() 
mut method 
Void #I() 
mut method 
Void #O() 
mut method 
Void #P() 
mut method 
Void #A() 
mut method 
Void #S() 
mut method 
Void #D() 
mut method 
Void #F() 
mut method 
Void #G() 
mut method 
Void #H() 
mut method 
Void #J() 
mut method 
Void #K() 
mut method 
Void #L() 
mut method 
Void #Z() 
mut method 
Void #X() 
mut method 
Void #C() 
mut method 
Void #V() 
mut method 
Void #B() 
mut method 
Void #N() 
mut method 
Void #M() 
mut method 
Void #%() 
mut method 
Void #$() 
mut method 
Void #left() 
mut method 
Void #right() 
mut method 
Void #bang() 
mut method 
Void #tilde() 
mut method 
Void #plus() 
mut method 
Void #times() 
mut method 
Void #divide() 
mut method 
Void #less() 
mut method 
Void #and() 
mut method 
Void #or() 
mut method 
Void #oRound() 
mut method 
Void #cRound() 
mut method 
Void #oSquare() 
mut method 
Void #cSquare() 
mut method 
Void #oCurly() 
mut method 
Void #cCurly() 
mut method 
Void #dQuote() 
mut method 
Void #sQuote() 
mut method 
Void #hQuote() 
mut method 
Void #equal() 
mut method 
Void #qMark() 
mut method 
Void #hat() 
mut method 
Void #comma() 
mut method 
Void #semicolon() 
mut method 
Void #colon() 
mut method 
Void #dot() 
mut method 
Void #underscore() 
mut method 
Void #hash() 
mut method 
Void #at() 
mut method 
Void #backslash() 
mut method 
Void #space() 
mut method 
Void #newline() }
type method 
This #from(This.SBuilder builder) 
type method 
mut This.SBuilder #builder() 
SubStringNotPresent:{<:Outer2.Guard, Outer2.Message
type method 
This #apply(Outer1 _text, Outer2.Message.Opt cause) 
mut method 
Outer1 #_text() 
read method 
Outer1 _text() 
mut method 
Outer2.Message.Opt #cause() 
read method 
Outer2.Message.Opt cause() 
method 
This #apply(Outer2.Message that) 
method 
Outer2.Bool #bangequal(This that) 
method 
Outer2.Bool #equalequal(This that) 
type method 
This #apply(Outer1 text) 
type method 
This #apply(Outer1 text, Outer2.Message cause) 
type method 
mut Outer1.SBuilder #builder() 
type method 
This #from(Outer1.SBuilder builder) 
method 
This.SConcat #begin() 
SConcat:{
type method 
This #apply(Outer3.Concept.ToS old, Outer2 accumulator) 
mut method 
Outer3.Concept.ToS #old() 
read method 
Outer3.Concept.ToS old() 
mut method 
Outer2 #accumulator() 
read method 
Outer2 accumulator() 
method 
This #add(Outer3.Concept.ToS that) 
method 
This #add(Outer3.Concept.ToS that, Outer3.Concept.ToS separedBy) 
method 
This #end() 
method 
mut Outer2.SBuilder #builder() 
method 
Outer1 #from(Outer2.SBuilder builder) }}}
N:{<:Outer1.Concept.ToS, Outer1.Concept.Equals, Outer1.Concept.Named
type method 
This fromS(Outer1.Concept.ToS that) 
type method 
This #from(Library binaryRepr) 
method 
Library binaryRepr() 
type method 
mut Outer1.S.SBuilder #builder() 
type method 
This #from(Outer1.S.SBuilder builder) 
type method 
Any parseError(Outer1.S that) 
method 
This #plus(This that) 
method 
This #less(This that) 
method 
This #times(This that) 
method 
This #divide(This that) 
method 
Outer1.Bool #equalequal(This that) 
method 
Outer1.Bool #left(This that) 
method 
Outer1.Bool #leftequal(This that) 
method 
Outer1.Bool #bangequal(This that) 
method 
Outer1.Bool #right(This that) 
method 
Outer1.Bool #rightequal(This that) 
method 
mut This.Iterator vals() 
method 
mut This.Iterator vals(This upTo) 
Iterator:{
type method 
mut This #apply(Outer1 start, Outer1 end) 
mut method 
Void start(Outer1 that) 
mut method 
Outer1 #start() 
read method 
Outer1 start() 
mut method 
Outer1 #end() 
read method 
Outer1 end() 
mut method 
Void #next() exception Void 
read method 
Void #checkEnd() 
read method 
Outer1 #inner() 
read method 
Void #close() }
ParseFail:{<:Outer2.Guard.ParseFail, Outer2.Message
type method 
This #apply(Outer2.S _text, Outer2.Message.Opt cause) 
mut method 
Outer2.S #_text() 
read method 
Outer2.S _text() 
mut method 
Outer2.Message.Opt #cause() 
read method 
Outer2.Message.Opt cause() 
method 
This #apply(Outer2.Message that) 
method 
Outer2.Bool #bangequal(This that) 
method 
Outer2.Bool #equalequal(This that) 
type method 
This #apply(Outer2.S text) 
type method 
This #apply(Outer2.S text, Outer2.Message cause) 
type method 
mut Outer2.S.SBuilder #builder() 
type method 
This #from(Outer2.S.SBuilder builder) 
method 
This.SConcat #begin() 
SConcat:{
type method 
This #apply(Outer3.Concept.ToS old, Outer3.S accumulator) 
mut method 
Outer3.Concept.ToS #old() 
read method 
Outer3.Concept.ToS old() 
mut method 
Outer3.S #accumulator() 
read method 
Outer3.S accumulator() 
method 
This #add(Outer3.Concept.ToS that) 
method 
This #add(Outer3.Concept.ToS that, Outer3.Concept.ToS separedBy) 
method 
This #end() 
method 
mut Outer3.S.SBuilder #builder() 
method 
Outer1 #from(Outer3.S.SBuilder builder) }}}
Bool:{<:Outer1.Concept.ToS, Outer1.Concept.Equals, Outer1.Concept.Named
method 
Void #checkTrue() exception Void 
type method 
This true() 
type method 
This false() 
method 
This #and(This that) 
method 
This #or(This that) 
method 
This #bang() 
type method 
This fromS(read Outer1.Concept.ToS that) 
method 
This #equalequal(This that) 
method 
This #bangequal(This that) 
type method 
Any parseError(Outer1.S that) 
ParseFail:{<:Outer2.Guard.ParseFail, Outer2.Message
type method 
This #apply(Outer2.S _text, Outer2.Message.Opt cause) 
mut method 
Outer2.S #_text() 
read method 
Outer2.S _text() 
mut method 
Outer2.Message.Opt #cause() 
read method 
Outer2.Message.Opt cause() 
method 
This #apply(Outer2.Message that) 
method 
Outer1 #bangequal(This that) 
method 
Outer1 #equalequal(This that) 
type method 
This #apply(Outer2.S text) 
type method 
This #apply(Outer2.S text, Outer2.Message cause) 
type method 
mut Outer2.S.SBuilder #builder() 
type method 
This #from(Outer2.S.SBuilder builder) 
method 
This.SConcat #begin() 
SConcat:{
type method 
This #apply(Outer3.Concept.ToS old, Outer3.S accumulator) 
mut method 
Outer3.Concept.ToS #old() 
read method 
Outer3.Concept.ToS old() 
mut method 
Outer3.S #accumulator() 
read method 
Outer3.S accumulator() 
method 
This #add(Outer3.Concept.ToS that) 
method 
This #add(Outer3.Concept.ToS that, Outer3.Concept.ToS separedBy) 
method 
This #end() 
method 
mut Outer3.S.SBuilder #builder() 
method 
Outer1 #from(Outer3.S.SBuilder builder) }}}
ExitCode:{
type method 
Library normal() 
type method 
Library failure() }
Alu:{'@plugin
'L42.is/connected/withAlu
}}
type method 
Void printHelloWorld() This.Abstract.Debug.#apply(that:This.Abstract.S.#from(builder:(
  This.Abstract.S::#builder() b=This.Abstract.S.#builder()
  Void unused=b.#H()
  Void unused0=b.#e()
  Void unused1=b.#l()
  Void unused2=b.#l()
  Void unused3=b.#o()
  Void unused4=b.#space()
  Void unused5=b.#W()
  Void unused6=b.#o()
  Void unused7=b.#r()
  Void unused8=b.#l()
  Void unused9=b.#d()
  Void unused10=b.#space()
  Void unused11=b.#D()
  Void unused12=b.#e()
  Void unused13=b.#p()
  Void unused14=b.#l()
  Void unused15=b.#o()
  Void unused16=b.#y()
  Void unused17=b.#e()
  Void unused18=b.#d()
  b
  )))}