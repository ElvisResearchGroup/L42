{'could be in another file

Abstract:{
Load:{'shape of a loadable library:
' This contains actual library, but
' Abstract:{} contains abstract classes, and 
' Abstract.ConceptMap mapps concepts names to abstract classes

type method 
This0 #begin() 
method 
This0 #end() 
ConceptMapMismatch:{<:This2.MetaGuard, This2.Message
type method 
This0 #apply(This2.S _text, This2.Message.Opt cause) 
mut method 
This2.S #_text() 
read method 
This2.S _text() 
mut method 
This2.Message.Opt #cause() 
read method 
This2.Message.Opt cause() 
method 
This0 #apply(This2.Message that) 
method 
This2.Bool #bangequal(This0 that) 
method 
This2.Bool #equalequal(This0 that) 
type method 
This0 #apply(This2.S text) 
type method 
This0 #apply(This2.S text, This2.Message cause) 
type method 
mut This2.S.SBuilder #builder() 
type method 
This0 #from(This2.S.SBuilder builder) 
method 
This0.SConcat #begin() 
SConcat:{
type method 
This0 #apply(This3.Concept.ToS old, This3.S accumulator) 
mut method 
This3.Concept.ToS #old() 
read method 
This3.Concept.ToS old() 
mut method 
This3.S #accumulator() 
read method 
This3.S accumulator() 
method 
This0 #add(This3.Concept.ToS that) 
method 
This0 #add(This3.Concept.ToS that, This3.Concept.ToS separedBy) 
method 
This0 #end() 
method 
mut This3.S.SBuilder #builder() 
method 
This1 #from(This3.S.SBuilder builder) }}
ConceptMapUnavailable:{<:This2.MetaGuard, This2.Message
type method 
This0 #apply(This2.S _text, This2.Message.Opt cause) 
mut method 
This2.S #_text() 
read method 
This2.S _text() 
mut method 
This2.Message.Opt #cause() 
read method 
This2.Message.Opt cause() 
method 
This0 #apply(This2.Message that) 
method 
This2.Bool #bangequal(This0 that) 
method 
This2.Bool #equalequal(This0 that) 
type method 
This0 #apply(This2.S text) 
type method 
This0 #apply(This2.S text, This2.Message cause) 
type method 
mut This2.S.SBuilder #builder() 
type method 
This0 #from(This2.S.SBuilder builder) 
method 
This0.SConcat #begin() 
SConcat:{
type method 
This0 #apply(This3.Concept.ToS old, This3.S accumulator) 
mut method 
This3.Concept.ToS #old() 
read method 
This3.Concept.ToS old() 
mut method 
This3.S #accumulator() 
read method 
This3.S accumulator() 
method 
This0 #add(This3.Concept.ToS that) 
method 
This0 #add(This3.Concept.ToS that, This3.Concept.ToS separedBy) 
method 
This0 #end() 
method 
mut This3.S.SBuilder #builder() 
method 
This1 #from(This3.S.SBuilder builder) }}
method 
Library #leftleft(Library that) exception This0.ConceptMapMismatch, This0.ConceptMapUnavailable 
DeployLibrary:{
type method 
This0 #apply(This2.Path path, This2.Url url) 
mut method 
This2.Path #path() 
read method 
This2.Path path() 
mut method 
This2.Url #url() 
read method 
This2.Url url() 
type method 
Library moveToAbstract(This2.Path that, Library of) 
type method 
Library exposeAsLibrary(Library that, This2.Path path) exception This2.MetaGuard.NestedClassUnavailable, This2.MetaGuard.PrivacyCoupuled 
type method 
Void checkTargetExists(Library that, This2.Path path) exception This2.MetaGuard.NestedClassUnavailable 
type method 
type This0 #begin() 
method 
This0 #end() 
type method 
This0 #add(This2.Path that, This2.Url url) 
method 
Library #leftleft(Library that) exception This2.MetaGuard.NestedClassUnavailable, This2.MetaGuard.PrivacyCoupuled }}
PreferentialComposition:{'members of PreferentialComposition

$:{interface 
method 
Library solveConflict(Library that, This1.SrcDest location) }
SrcDest:{
type method 
This0 #apply(This2.Path path, This2.Selector src, This2.Selector dest) 
mut method 
This2.Path #path() 
read method 
This2.Path path() 
mut method 
This2.Selector #src() 
read method 
This2.Selector src() 
mut method 
This2.Selector #dest() 
read method 
This2.Selector dest() }
SrcDests:{' generic linked list class, elements of type Elem
<:This2.Concept.Named
type method 
This0 _new(This0.Cell head) 
mut method 
This0.Cell #head() 
read method 
This0.Cell head() 
type method 
This0 #apply() 
method 
This2.Bool isEmpty() 
method 
This1.SrcDest top() 
method 
mut This0.Iterator vals() 
method 
mut This0.Iterator valsCut() 
method 
This0 pop() 
method 
This0 #plusplus(This0 that) 
type method 
This0 #begin() 
method 
This0 #add(This1.SrcDest that) 
method 
This0 #end() 
Cell:{interface 
method 
mut This1.Iterator vals(This3.Bool terminate) 
method 
This0 #next() exception Void 
method 
This2.SrcDest #inner() 
method 
Void #checkEnd() }
CellEnd:{<:This1.Cell
type method 
This0 #apply() }
CellNext:{<:This1.Cell
type method 
This0 #apply(This2.SrcDest elem, This1.Cell nextCell) 
mut method 
This2.SrcDest #elem() 
read method 
This2.SrcDest elem() 
mut method 
This1.Cell #nextCell() 
read method 
This1.Cell nextCell() }
Iterator:{
type method 
mut This0 #apply(This1.Cell that, This3.Bool terminate) 
mut method 
Void that(This1.Cell that) 
mut method 
This1.Cell #that() 
read method 
This1.Cell that() 
mut method 
This3.Bool #terminate() 
read method 
This3.Bool terminate() 
mut method 
Void #next() exception Void 
read method 
Void #checkEnd() 
read method 
This2.SrcDest #inner() 
read method 
Void #close() }}
type method 
This0.SrcDests renameMap(Library that, This1.S prefix, This1.Path path, This1.Introspection.Methods ms) 
type method 
This1.Bool needRename(This1.Introspection.NestedClass that, This1.Introspection.Method meth) 
type method 
Library #leftleft(Library that) exception This1.MetaGuard.ClassClash, This1.MetaGuard.MethodClash }
DeployTowel:{
type method '(Any fileName)
This0 #apply(This1.Url fileName) 
mut method '(Any fileName)
This1.Url #fileName() 
read method '(Any fileName)
This1.Url fileName() 
type method 
Library binaryReprFrom(Library lib) 
method 
Library #leftleft(Library that) }
LinkedList:{
ListCode:{
type method 
Library #apply() }
type method 
Library list(type Any that) 
type method 
Library eqList(type Any that) 
ListCodeEq:{
type method 
Library #apply() }}
Default:{
DecorationUnfeasable:{<:This2.MetaGuard, This2.Message
type method 
This0 #apply(This2.S _text, This2.Message.Opt cause) 
mut method 
This2.S #_text() 
read method 
This2.S _text() 
mut method 
This2.Message.Opt #cause() 
read method 
This2.Message.Opt cause() 
method 
This0 #apply(This2.Message that) 
method 
This2.Bool #bangequal(This0 that) 
method 
This2.Bool #equalequal(This0 that) 
type method 
This0 #apply(This2.S text) 
type method 
This0 #apply(This2.S text, This2.Message cause) 
type method 
mut This2.S.SBuilder #builder() 
type method 
This0 #from(This2.S.SBuilder builder) 
method 
This0.SConcat #begin() 
SConcat:{
type method 
This0 #apply(This3.Concept.ToS old, This3.S accumulator) 
mut method 
This3.Concept.ToS #old() 
read method 
This3.Concept.ToS old() 
mut method 
This3.S #accumulator() 
read method 
This3.S accumulator() 
method 
This0 #add(This3.Concept.ToS that) 
method 
This0 #add(This3.Concept.ToS that, This3.Concept.ToS separedBy) 
method 
This0 #end() 
method 
mut This3.S.SBuilder #builder() 
method 
This1 #from(This3.S.SBuilder builder) }}
Parsable:{
type method 
Library #leftleft(Library that) exception This1.DecorationUnfeasable }
SealState:{' how to specify which factory to keep out? what getters

type method 
Library #leftleft(Library that) }
DataFromToS:{' in the future we can add also hashCode and > =>

type method 
Library #leftleft(Library that) exception This1.DecorationUnfeasable }
Equals:{
type method 
Library #leftleft(Library that) exception This1.DecorationUnfeasable }
Named:{
type method 
Library #leftleft(Library that) exception This1.DecorationUnfeasable }}
Use:{'members of each produced class
<:This1.PreferentialComposition.$, This1.PreferentialComposition.$
method 
This0 #add(Library that) 
type method 
This0 #begin() 
method 
This0 #end() 
method 
Library #leftleft(Library that) exception This1.MetaGuard.ClassClash, This1.MetaGuard.MethodClash 
method 
This0 #plusplus(This0 that) }
Extends:{'members of each produced class
<:This1.PreferentialComposition.$, This1.PreferentialComposition.$
method 
This0 #add(Library that) 
type method 
This0 #begin() 
method 
This0 #end() 
method 
Library #leftleft(Library that) exception This1.MetaGuard.ClassClash, This1.MetaGuard.MethodClash 
method 
This0 #plusplus(This0 that) }
Opt:{
type method 
Library #apply(type Any that) }
Optimize:{
RemoveUnreachableCode:{
type method 
This0 #apply() 
type method 
This0 #begin() 
method 
This0 #end() 
method 
Library #leftleft(Library that) }}
Refactor:{
type method 
Library compose(Library left, Library right) exception This1.MetaGuard.ClassClash, This1.MetaGuard.MethodClash 
type method 
Void checkTargetExists(Library that, This1.Path path) exception This1.MetaGuard.NestedClassUnavailable 
Redirect:{
type method 
This0 #apply(This2.Path that, type Any to) 
mut method 
This2.Path #that() 
read method 
This2.Path that() 
mut method 
type Any #to() 
read method 
type Any to() 
method 
Library #leftleft(Library that) exception This2.MetaGuard.NestedClassUnavailable, This2.MetaGuard.InvalidOnTopLevel, This2.MetaGuard.SourceUnfit, This2.MetaGuard.MethodClash, This2.MetaGuard.IncoherentRedirectMapping }
RenameSelector:{
type method 
This0 #apply(This2.Selector that, This2.Path of, This2.Selector to) 
mut method 
This2.Selector #that() 
read method 
This2.Selector that() 
mut method 
This2.Path #of() 
read method 
This2.Path of() 
mut method 
This2.Selector #to() 
read method 
This2.Selector to() 
method 
Library #leftleft(Library that) exception This2.MetaGuard.MemberUnavailable, This2.MetaGuard.MethodClash }
RenamePath:{
type method 
This0 #apply(This2.Path that, This2.Path to) 
mut method 
This2.Path #that() 
read method 
This2.Path that() 
mut method 
This2.Path #to() 
read method 
This2.Path to() 
method 
Library #leftleft(Library that) exception This2.MetaGuard.NestedClassUnavailable, This2.MetaGuard.MethodClash, This2.MetaGuard.ClassClash }
RemoveImplementationSelector:{
type method 
This0 #apply(This2.Selector that, This2.Path of) 
mut method 
This2.Selector #that() 
read method 
This2.Selector that() 
mut method 
This2.Path #of() 
read method 
This2.Path of() 
method 
Library #leftleft(Library that) exception This2.MetaGuard.MemberUnavailable }
MoveImplementationSelector:{
type method 
This0 #apply(This2.Selector that, This2.Path of, This2.Selector to) 
mut method 
This2.Selector #that() 
read method 
This2.Selector that() 
mut method 
This2.Path #of() 
read method 
This2.Path of() 
mut method 
This2.Selector #to() 
read method 
This2.Selector to() 
method 
Library #leftleft(Library that) exception This2.MetaGuard.MemberUnavailable, This2.MetaGuard.MethodClash }
RemoveImplementationPath:{
type method 
This0 #apply(This2.Path that) 
mut method 
This2.Path #that() 
read method 
This2.Path that() 
method 
Library #leftleft(Library that) exception This2.MetaGuard.NestedClassUnavailable, This2.MetaGuard.PrivacyCoupuled }
AddDocumentationSelector:{
type method 
This0 #apply(This2.Selector that, This2.Path of, This2.Introspection.Doc doc) 
mut method 
This2.Selector #that() 
read method 
This2.Selector that() 
mut method 
This2.Path #of() 
read method 
This2.Path of() 
mut method 
This2.Introspection.Doc #doc() 
read method 
This2.Introspection.Doc doc() 
method 
Library #leftleft(Library that) exception This2.MetaGuard.MemberUnavailable }
AddDocumentationPath:{
type method 
This0 #apply(This2.Path that, This2.Introspection.Doc doc) 
mut method 
This2.Path #that() 
read method 
This2.Path that() 
mut method 
This2.Introspection.Doc #doc() 
read method 
This2.Introspection.Doc doc() 
method 
Library #leftleft(Library that) exception This2.MetaGuard.NestedClassUnavailable, This2.MetaGuard.InvalidOnTopLevel }
MakePrivatePath:{
type method 
This0 #apply(This2.Path that) 
mut method 
This2.Path #that() 
read method 
This2.Path that() 
method 
Library #leftleft(Library that) exception This2.MetaGuard.MemberUnavailable, This2.MetaGuard.InvalidOnTopLevel }
MakePrivateSelector:{
type method 
This0 #apply(This2.Selector that, This2.Path of) 
mut method 
This2.Selector #that() 
read method 
This2.Selector that() 
mut method 
This2.Path #of() 
read method 
This2.Path of() 
method 
Library #leftleft(Library that) exception This2.MetaGuard.MemberUnavailable }
SumMethods:{
type method 
This0 #apply(This2.Selector that, This2.Selector and, This2.Path of, This2.S over, This2.Selector to) 
mut method 
This2.Selector #that() 
read method 
This2.Selector that() 
mut method 
This2.Selector #and() 
read method 
This2.Selector and() 
mut method 
This2.Path #of() 
read method 
This2.Path of() 
mut method 
This2.S #over() 
read method 
This2.S over() 
mut method 
This2.Selector #to() 
read method 
This2.Selector to() 
method 
Library #leftleft(Library that) exception This2.MetaGuard.MemberUnavailable, This2.MetaGuard.MethodClash, This2.MetaGuard.ParameterMismatch }
Tools:{
type method 
This2.S getToSOrName(read Any that) }}
Introspection:{'findMeIntrospection

type method 
This0.NestedClass #apply(Library lib) 
type method 
This0.NestedClass #apply(Library lib, This1.Path path) exception This1.MetaGuard.NestedClassUnavailable 
type method 
This0.NestedClass #apply(type Any clazz) 
type method 
This0.NestedClass #apply(type Any clazz, This1.Path path) 
MirrorPr:{interface <:This2.Concept.ToS
method 
This1.NestedClass introspectReport(fwd This1.NestedClass root, This2.Path path) exception This2.MetaGuard.NestedClassUnavailable 
method 
This1.Member introspectReportMember(fwd This1.NestedClass root, This2.Path path, This2.N memberN) exception This2.MetaGuard.MemberUnavailable, Void 
method 
This1.Type introspectReportType(fwd This1.NestedClass root, This2.Path path, This2.N memberN, This2.N typeN) exception This2.MetaGuard.MemberUnavailable, Void 
method 
This2.S introspectDocAsString(This2.Path path) exception This2.MetaGuard.NestedClassUnavailable 
method 
This2.S introspectDocAsString(This2.Path path, This2.N annotationN) exception This2.MetaGuard.NestedClassUnavailable, Void 
method 
type Any introspectDocPath(This2.Path path, This2.N annotationN) exception This2.MetaGuard.NestedClassUnavailable, Void 
Lib:{<:This1
type method 
This0 #apply(Library lib) 
mut method 
Library #lib() 
read method 
Library lib() }
Class:{<:This1
type method 
This0 #apply(type Any lib) 
mut method 
type Any #lib() 
read method 
type Any lib() }}
Doc:{<:This2.Concept.ToS, This2.Concept.Named
Annotation:{<:This3.Concept.ToS, This3.Concept.Named
type method 
This0 #apply(Library _binaryRepr, This3.S text, This3.N index) 
mut method 
Library #_binaryRepr() 
read method 
Library _binaryRepr() 
mut method 
This3.S #text() 
read method 
This3.S text() 
mut method 
This3.N #index() 
read method 
This3.N index() 
method 
type Any referredClass() 
method 
This3.Bool hasReferredClass() }
Annotations:{' generic linked list class, elements of type Elem
<:This3.Concept.Named
type method 
This0 _new(This0.Cell head) 
mut method 
This0.Cell #head() 
read method 
This0.Cell head() 
type method 
This0 #apply() 
method 
This3.Bool isEmpty() 
method 
This1.Annotation top() 
method 
mut This0.Iterator vals() 
method 
mut This0.Iterator valsCut() 
method 
This0 pop() 
method 
This0 #plusplus(This0 that) 
type method 
This0 #begin() 
method 
This0 #add(This1.Annotation that) 
method 
This0 #end() 
Cell:{interface 
method 
mut This1.Iterator vals(This4.Bool terminate) 
method 
This0 #next() exception Void 
method 
This2.Annotation #inner() 
method 
Void #checkEnd() }
CellEnd:{<:This1.Cell
type method 
This0 #apply() }
CellNext:{<:This1.Cell
type method 
This0 #apply(This2.Annotation elem, This1.Cell nextCell) 
mut method 
This2.Annotation #elem() 
read method 
This2.Annotation elem() 
mut method 
This1.Cell #nextCell() 
read method 
This1.Cell nextCell() }
Iterator:{
type method 
mut This0 #apply(This1.Cell that, This4.Bool terminate) 
mut method 
Void that(This1.Cell that) 
mut method 
This1.Cell #that() 
read method 
This1.Cell that() 
mut method 
This4.Bool #terminate() 
read method 
This4.Bool terminate() 
mut method 
Void #next() exception Void 
read method 
Void #checkEnd() 
read method 
This2.Annotation #inner() 
read method 
Void #close() }}
type method 
This0 #apply(Library that) 
type method 
mut This2.S.SBuilder #builder() 
type method 
This0 #from(This2.S.SBuilder builder) 
method 
Library binaryRepr() 
method 
This0.Annotations annotations() }
Record:{
type method 
This0 #apply(This1.MirrorPr that) 
mut method 
This1.MirrorPr #that() 
read method 
This1.MirrorPr that() 
type method 
This0 #apply(type Any clazz) 
type method 
This0 #apply(Library lib) 
method 
Void dbg() 
method 
mut This2.S.SBuilder #builder() 
method 
This2.S #from(This2.S.SBuilder builder) 
method 
This1.Doc docOf(This2.Path path) 
RootForMember:' toPutAs private
{interface 
method 
This2.Member #apply(fwd This2.NestedClass root) }
RootForNested:' toPutAs private
{<:This1.RootForMember
type method 
This0 #apply(This3.Path path, This2.MirrorPr mirror, This1 _report) 
mut method 
This3.Path #path() 
read method 
This3.Path path() 
mut method 
This2.MirrorPr #mirror() 
read method 
This2.MirrorPr mirror() 
mut method 
This1 #_report() 
read method 
This1 _report() }
RootForMethod:' toPutAs private
{<:This1.RootForMember
type method 
This0 #apply(This3.Path path, This3.N memberN, This1 _report) 
mut method 
This3.Path #path() 
read method 
This3.Path path() 
mut method 
This3.N #memberN() 
read method 
This3.N memberN() 
mut method 
This1 #_report() 
read method 
This1 _report() }
type method 
This1.Member dispatch(fwd This1.NestedClass root, This2.Path path, This1.MirrorPr mirror, This2.N memberN, Library record) }
Member:{interface <:This2.Concept.ToS, This2.Concept.Named, This2.Concept.Equals}
Members:{' generic linked list class, elements of type Elem
<:This2.Concept.Named
type method 
This0 _new(This0.Cell head) 
mut method 
This0.Cell #head() 
read method 
This0.Cell head() 
type method 
This0 #apply() 
method 
This2.Bool isEmpty() 
method 
This1.Member top() 
method 
mut This0.Iterator vals() 
method 
mut This0.Iterator valsCut() 
method 
This0 pop() 
method 
This0 #plusplus(This0 that) 
type method 
This0 #begin() 
method 
This0 #add(This1.Member that) 
method 
This0 #end() 
Cell:{interface 
method 
mut This1.Iterator vals(This3.Bool terminate) 
method 
This0 #next() exception Void 
method 
This2.Member #inner() 
method 
Void #checkEnd() }
CellEnd:{<:This1.Cell
type method 
This0 #apply() }
CellNext:{<:This1.Cell
type method 
This0 #apply(This2.Member elem, This1.Cell nextCell) 
mut method 
This2.Member #elem() 
read method 
This2.Member elem() 
mut method 
This1.Cell #nextCell() 
read method 
This1.Cell nextCell() }
Iterator:{
type method 
mut This0 #apply(This1.Cell that, This3.Bool terminate) 
mut method 
Void that(This1.Cell that) 
mut method 
This1.Cell #that() 
read method 
This1.Cell that() 
mut method 
This3.Bool #terminate() 
read method 
This3.Bool terminate() 
mut method 
Void #next() exception Void 
read method 
Void #checkEnd() 
read method 
This2.Member #inner() 
read method 
Void #close() }
method 
This2.Bool contains(This1.Member that) 
method 
This0 remove(This1.Member that) 
method 
This2.Bool #equalequal(This0 that) 
method 
This2.Bool equals(Any that) }
Method:{<:This1.Member, This2.Concept.Equals
method 
This2.Bool #equalequal(This0 that) 
method 
This2.Bool #bangequal(This0 that) 
method 
This1.Doc doc() 
method 
This2.S thisMdf() 
method ' invariant NestedClass(...).nestedClassFromRoot(path).pathFromRoot()==path
This2.Path pathFromRoot() 
method 
This2.Selector selector() 
method 
This2.S methodKind() 
method 
This2.S allAsString() 
method 
This1.Type returnType() 
method 
This1.Types exceptions() 
method 
This1.Types parameterTypes() 
method 
This2.Bool isPrivate() 
method 
This1.NestedClass root() }
Methods:{' generic linked list class, elements of type Elem
<:This2.Concept.Named
type method 
This0 _new(This0.Cell head) 
mut method 
This0.Cell #head() 
read method 
This0.Cell head() 
type method 
This0 #apply() 
method 
This2.Bool isEmpty() 
method 
This1.Method top() 
method 
mut This0.Iterator vals() 
method 
mut This0.Iterator valsCut() 
method 
This0 pop() 
method 
This0 #plusplus(This0 that) 
type method 
This0 #begin() 
method 
This0 #add(This1.Method that) 
method 
This0 #end() 
Cell:{interface 
method 
mut This1.Iterator vals(This3.Bool terminate) 
method 
This0 #next() exception Void 
method 
This2.Method #inner() 
method 
Void #checkEnd() }
CellEnd:{<:This1.Cell
type method 
This0 #apply() }
CellNext:{<:This1.Cell
type method 
This0 #apply(This2.Method elem, This1.Cell nextCell) 
mut method 
This2.Method #elem() 
read method 
This2.Method elem() 
mut method 
This1.Cell #nextCell() 
read method 
This1.Cell nextCell() }
Iterator:{
type method 
mut This0 #apply(This1.Cell that, This3.Bool terminate) 
mut method 
Void that(This1.Cell that) 
mut method 
This1.Cell #that() 
read method 
This1.Cell that() 
mut method 
This3.Bool #terminate() 
read method 
This3.Bool terminate() 
mut method 
Void #next() exception Void 
read method 
Void #checkEnd() 
read method 
This2.Method #inner() 
read method 
Void #close() }
method 
This2.Bool contains(This1.Method that) 
method 
This0 remove(This1.Method that) 
method 
This2.Bool #equalequal(This0 that) 
method 
This2.Bool equals(Any that) }
NestedClass:{'findMeNestedClass
<:This1.Member, This2.Concept.Equals
method 
This2.Bool #equalequal(This0 that) 
method 
This2.Bool #bangequal(This0 that) 
method 
This0 root() 
method 'error for This
This1.Doc nestedDoc() 
method 'of the library literal
This1.Doc doc() 
method 
This2.Path pathFromRoot() 
method 
This2.Bool hasExternalType() 
method 
type Any externalType() 
method 
This2.S externalTypeToS() 
method 
This2.S classKind() 
method 
This2.S allAsString() 
method 
This1.Members members() 
method 
This1.Methods methods() 
method 
This1.NestedClasses nestedClasses() 
method 
This1.NestedClasses transitivelyNestedClasses() 
method 
This1.Types implementedInterfaces() 
method 
This1.Types transitivelyImplementedInterfaces() 
method 
This1.Methods stateCandidate() 
method 
This1.Methods state() 
method 
This1.Method methodFromSelector(This2.Selector that) exception This2.MetaGuard.MethodUnavailable 
method 
This2.Bool has(This2.Selector selector) 
method 
This0 nestedClassFromRoot(This2.Path that) exception This2.MetaGuard.NestedClassUnavailable 
method 
This2.Bool has(This2.Path fromRoot) 
method 
This2.Bool isPrivate() }
NestedClasses:{' generic linked list class, elements of type Elem
<:This2.Concept.Named
type method 
This0 _new(This0.Cell head) 
mut method 
This0.Cell #head() 
read method 
This0.Cell head() 
type method 
This0 #apply() 
method 
This2.Bool isEmpty() 
method 
This1.NestedClass top() 
method 
mut This0.Iterator vals() 
method 
mut This0.Iterator valsCut() 
method 
This0 pop() 
method 
This0 #plusplus(This0 that) 
type method 
This0 #begin() 
method 
This0 #add(This1.NestedClass that) 
method 
This0 #end() 
Cell:{interface 
method 
mut This1.Iterator vals(This3.Bool terminate) 
method 
This0 #next() exception Void 
method 
This2.NestedClass #inner() 
method 
Void #checkEnd() }
CellEnd:{<:This1.Cell
type method 
This0 #apply() }
CellNext:{<:This1.Cell
type method 
This0 #apply(This2.NestedClass elem, This1.Cell nextCell) 
mut method 
This2.NestedClass #elem() 
read method 
This2.NestedClass elem() 
mut method 
This1.Cell #nextCell() 
read method 
This1.Cell nextCell() }
Iterator:{
type method 
mut This0 #apply(This1.Cell that, This3.Bool terminate) 
mut method 
Void that(This1.Cell that) 
mut method 
This1.Cell #that() 
read method 
This1.Cell that() 
mut method 
This3.Bool #terminate() 
read method 
This3.Bool terminate() 
mut method 
Void #next() exception Void 
read method 
Void #checkEnd() 
read method 
This2.NestedClass #inner() 
read method 
Void #close() }
method 
This2.Bool contains(This1.NestedClass that) 
method 
This0 remove(This1.NestedClass that) 
method 
This2.Bool #equalequal(This0 that) 
method 
This2.Bool equals(Any that) }
Type:{<:This2.Concept.ToS, This2.Concept.Named
method 
This2.S allAsString() 
method 
This2.S strRepr() 
method 
This2.S typeKind() 
method 
This2.S mdf() 
method 
This1.NestedClass referencedPath() 
method 
This1.NestedClass resolvedReferencedPath() 
method 
This2.Bool partial() 
method 
This2.Bool resolvedPartial() 
method 
This2.S suffix() 
method 
This1.Doc doc() }
Types:{' generic linked list class, elements of type Elem
<:This2.Concept.Named
type method 
This0 _new(This0.Cell head) 
mut method 
This0.Cell #head() 
read method 
This0.Cell head() 
type method 
This0 #apply() 
method 
This2.Bool isEmpty() 
method 
This1.Type top() 
method 
mut This0.Iterator vals() 
method 
mut This0.Iterator valsCut() 
method 
This0 pop() 
method 
This0 #plusplus(This0 that) 
type method 
This0 #begin() 
method 
This0 #add(This1.Type that) 
method 
This0 #end() 
Cell:{interface 
method 
mut This1.Iterator vals(This3.Bool terminate) 
method 
This0 #next() exception Void 
method 
This2.Type #inner() 
method 
Void #checkEnd() }
CellEnd:{<:This1.Cell
type method 
This0 #apply() }
CellNext:{<:This1.Cell
type method 
This0 #apply(This2.Type elem, This1.Cell nextCell) 
mut method 
This2.Type #elem() 
read method 
This2.Type elem() 
mut method 
This1.Cell #nextCell() 
read method 
This1.Cell nextCell() }
Iterator:{
type method 
mut This0 #apply(This1.Cell that, This3.Bool terminate) 
mut method 
Void that(This1.Cell that) 
mut method 
This1.Cell #that() 
read method 
This1.Cell that() 
mut method 
This3.Bool #terminate() 
read method 
This3.Bool terminate() 
mut method 
Void #next() exception Void 
read method 
Void #checkEnd() 
read method 
This2.Type #inner() 
read method 
Void #close() }}}
MetaGuard:{interface <:This1.Guard
RecordWrapper:' can not be private, I need to Patch it.
{
type method 
This2.S libToS(Library that) 
type method 
Library recordWrapperToSTrait() 
type method 
Library recordWrapperTrait() 
type method 
Library #leftleft(Library that) }
SourceUnfit:{<:This1, This1
type method 
This2.S libName() 
type method 
This0 #apply(This2.Introspection.Record record, Library lib) 
method 
This2.Bool #bangequal(This0 that) 
method 
This2.Bool #equalequal(This0 that) 
type method 
Void #apply(Library lift) exception This0 
method 
Library lib() }
IncoherentRedirectMapping:{<:This1, This1
type method 
This2.S libName() 
type method 
This0 #apply(This2.Introspection.Record record, Library lib) 
method 
This2.Bool #bangequal(This0 that) 
method 
This2.Bool #equalequal(This0 that) 
type method 
Void #apply(Library lift) exception This0 
method 
Library lib() }
ClassClash:{<:This1, This1
type method 
This2.S libName() 
type method 
This0 #apply(This2.Introspection.Record record, Library lib) 
method 
This2.Bool #bangequal(This0 that) 
method 
This2.Bool #equalequal(This0 that) 
type method 
Void #apply(Library lift) exception This0 
method 
Library lib() }
MethodClash:{<:This1, This1
type method 
This2.S libName() 
type method 
This0 #apply(This2.Introspection.Record record, Library lib) 
method 
This2.Bool #bangequal(This0 that) 
method 
This2.Bool #equalequal(This0 that) 
type method 
Void #apply(Library lift) exception This0 
method 
Library lib() }
InvalidOnTopLevel:{<:This1, This1
type method 
This2.S libName() 
type method 
This0 #apply(This2.Introspection.Record record, Library lib) 
method 
This2.Bool #bangequal(This0 that) 
method 
This2.Bool #equalequal(This0 that) 
type method 
Void #apply(Library lift) exception This0 
method 
Library lib() }
PrivacyCoupuled:{<:This1, This1
type method 
This2.S libName() 
type method 
This0 #apply(This2.Introspection.Record record, Library lib) 
method 
This2.Bool #bangequal(This0 that) 
method 
This2.Bool #equalequal(This0 that) 
type method 
Void #apply(Library lift) exception This0 
method 
Library lib() }
ParameterMismatch:{<:This1, This1
type method 
This2.S libName() 
type method 
This0 #apply(This2.Introspection.Record record, Library lib) 
method 
This2.Bool #bangequal(This0 that) 
method 
This2.Bool #equalequal(This0 that) 
type method 
Void #apply(Library lift) exception This0 
method 
Library lib() }
MemberUnavailable:{interface <:This1}
DispatchMemberUnavailable:{
type method 
Void #apply(Library that) exception This1.MemberUnavailable }
NestedClassUnavailable:{<:This1.MemberUnavailable, This1
type method 
This0 #apply(This2.Path path, This2.Bool isPrivate) 
mut method 
This2.Path #path() 
read method 
This2.Path path() 
mut method 
This2.Bool #isPrivate() 
read method 
This2.Bool isPrivate() 
type method 
This0 #apply(This2.Introspection.Record record, Library lib) 
type method 
This2.S libName() 
method 
This2.Bool #bangequal(This0 that) 
method 
This2.Bool #equalequal(This0 that) 
type method 
Void #apply(Library lift) exception This0 }
MethodUnavailable:{<:This1.MemberUnavailable, This1
type method 
This0 #apply(This2.Path path, This2.Selector selector, This2.Bool isPrivate) 
mut method 
This2.Path #path() 
read method 
This2.Path path() 
mut method 
This2.Selector #selector() 
read method 
This2.Selector selector() 
mut method 
This2.Bool #isPrivate() 
read method 
This2.Bool isPrivate() 
type method 
This0 #apply(This2.Introspection.Record record, Library lib) 
type method 
This2.S libName() 
method 
This2.Bool #bangequal(This0 that) 
method 
This2.Bool #equalequal(This0 that) 
type method 
Void #apply(Library lift) exception This0 }}
Selector:{<:This1.Concept.ToS, This1.Concept.Equals, This1.Concept.Named
type method 
This0 fromS(This1.Concept.ToS that) 
type method 
This0 #from(This1.S.SBuilder builder) 
type method 
mut This1.S.SBuilder #builder() 
type method 
This0 #from(Library binaryRepr) 
type method 
Any parseError(This1.S that) 
type method 
This0 from(This1.S name, This1.Strings names) 
method 
This1.S nameAsField() 
method 
This1.S prefixAsField() 
method 
Library binaryRepr() 
method 
This1.Bool #bangequal(This0 that) 
method 
This1.Bool #equalequal(This0 that) 
method 
This1.Bool isOperator() 
method 
This1.S name() 
method 
This1.Strings names() 
type method 
This0 fresh(This0 that) 
ParseFail:{<:This2.Guard.ParseFail, This2.Message
type method 
This0 #apply(This2.S _text, This2.Message.Opt cause) 
mut method 
This2.S #_text() 
read method 
This2.S _text() 
mut method 
This2.Message.Opt #cause() 
read method 
This2.Message.Opt cause() 
method 
This0 #apply(This2.Message that) 
method 
This2.Bool #bangequal(This0 that) 
method 
This2.Bool #equalequal(This0 that) 
type method 
This0 #apply(This2.S text) 
type method 
This0 #apply(This2.S text, This2.Message cause) 
type method 
mut This2.S.SBuilder #builder() 
type method 
This0 #from(This2.S.SBuilder builder) 
method 
This0.SConcat #begin() 
SConcat:{
type method 
This0 #apply(This3.Concept.ToS old, This3.S accumulator) 
mut method 
This3.Concept.ToS #old() 
read method 
This3.Concept.ToS old() 
mut method 
This3.S #accumulator() 
read method 
This3.S accumulator() 
method 
This0 #add(This3.Concept.ToS that) 
method 
This0 #add(This3.Concept.ToS that, This3.Concept.ToS separedBy) 
method 
This0 #end() 
method 
mut This3.S.SBuilder #builder() 
method 
This1 #from(This3.S.SBuilder builder) }}}
Path:{<:This1.Concept.ToS, This1.Concept.Equals, This1.Concept.Named
type method 
This0 fromDocInternalizedS(This1.S that) 
type method 
This0 fromS(This1.Concept.ToS that) 
type method 
This0 #from(This1.S.SBuilder builder) 
type method 
mut This1.S.SBuilder #builder() 
type method 
This0 #from(Library binaryRepr) 
type method 
Any parseError(This1.S that) 
type method 
Any parseError(This1.S that, This1.Message cause) 
method 
Library binaryRepr() 
method 
This1.Bool #bangequal(This0 that) 
method 
This1.Bool #equalequal(This0 that) 
method 
This0 #plusplus(This0 that) 
method 
This1.Strings names() 
type method 
This0 from(This1.Strings names) 
type method 
This0 fresh(This1.S name) 
type method 
This0 fresh() 
type method 
This0 fresh(This0 path) 
ParseFail:{<:This2.Guard.ParseFail, This2.Message
type method 
This0 #apply(This2.S _text, This2.Message.Opt cause) 
mut method 
This2.S #_text() 
read method 
This2.S _text() 
mut method 
This2.Message.Opt #cause() 
read method 
This2.Message.Opt cause() 
method 
This0 #apply(This2.Message that) 
method 
This2.Bool #bangequal(This0 that) 
method 
This2.Bool #equalequal(This0 that) 
type method 
This0 #apply(This2.S text) 
type method 
This0 #apply(This2.S text, This2.Message cause) 
type method 
mut This2.S.SBuilder #builder() 
type method 
This0 #from(This2.S.SBuilder builder) 
method 
This0.SConcat #begin() 
SConcat:{
type method 
This0 #apply(This3.Concept.ToS old, This3.S accumulator) 
mut method 
This3.Concept.ToS #old() 
read method 
This3.Concept.ToS old() 
mut method 
This3.S #accumulator() 
read method 
This3.S accumulator() 
method 
This0 #add(This3.Concept.ToS that) 
method 
This0 #add(This3.Concept.ToS that, This3.Concept.ToS separedBy) 
method 
This0 #end() 
method 
mut This3.S.SBuilder #builder() 
method 
This1 #from(This3.S.SBuilder builder) }}}
Url:{'ParseFailure:Message:S[]<<{<:Guard} no need, related to invariant?
<:This1.Concept.ToS
type method ' if you do not implement it, it is a constructor?
This0 fromS(read This1.Concept.ToS that) 
type method 
This0 #from(This1.S.SBuilder builder) 
type method 
mut This1.S.SBuilder #builder() 
type method 
This0 #apply(This1.S inner) 
mut method 
This1.S #inner() 
read method 
This1.S inner() 
method 
Library binaryRepr() }
ConceptMap:{interface 
method 
This1.Alu _Alu() 
method 
This1.ExitCode _ExitCode() 
method 
This1.Bool _Bool() 
method 
This1.N _N() 
method 
This1.S _S() 
method 
This1.Concept _Concept() 
method 
This1.Message _Message() 
method 
This1.Guard _Guard() 
method 
This1.System _System() 
method 
This1.Assert _Assert() 
method 
This1.Strings _Strings() 
method 
This1.Debug _Debug() 
method 
This0 _ConceptMap() 
method 
This1.Url _Url() 
method 
This1.Path _Path() 
method 
This1.Selector _Selector() 
method 
This1.MetaGuard _MetaGuard() 
method 
This1.Introspection _Introspection() 
method 
This1.Refactor _Refactor() 
method 
This1.Optimize _Optimize() 
method 
This1.Opt _Opt() 
method 
This1.Extends _Extends() 
method 
This1.Use _Use() 
method 
This1.Default _Default() 
method 
This1.LinkedList _LinkedList() 
method 
This1.DeployTowel _DeployTowel() 
method 
This1.PreferentialComposition _PreferentialComposition() 
method 
This1.Load _Load() }
Debug:{
type method 
Void #apply(This1.Concept.ToS that) 
type method 
Void #apply(Library lib) 
type method 
Void #apply(This1.Concept.ToS fileName, This1.Concept.ToS content) }
Strings:{' generic linked list class, elements of type Elem
<:This1.Concept.Named
type method 
This0 _new(This0.Cell head) 
mut method 
This0.Cell #head() 
read method 
This0.Cell head() 
type method 
This0 #apply() 
method 
This1.Bool isEmpty() 
method 
This1.S top() 
method 
mut This0.Iterator vals() 
method 
mut This0.Iterator valsCut() 
method 
This0 pop() 
method 
This0 #plusplus(This0 that) 
type method 
This0 #begin() 
method 
This0 #add(This1.S that) 
method 
This0 #end() 
Cell:{interface 
method 
mut This1.Iterator vals(This2.Bool terminate) 
method 
This0 #next() exception Void 
method 
This2.S #inner() 
method 
Void #checkEnd() }
CellEnd:{<:This1.Cell
type method 
This0 #apply() }
CellNext:{<:This1.Cell
type method 
This0 #apply(This2.S elem, This1.Cell nextCell) 
mut method 
This2.S #elem() 
read method 
This2.S elem() 
mut method 
This1.Cell #nextCell() 
read method 
This1.Cell nextCell() }
Iterator:{
type method 
mut This0 #apply(This1.Cell that, This2.Bool terminate) 
mut method 
Void that(This1.Cell that) 
mut method 
This1.Cell #that() 
read method 
This1.Cell that() 
mut method 
This2.Bool #terminate() 
read method 
This2.Bool terminate() 
mut method 
Void #next() exception Void 
read method 
Void #checkEnd() 
read method 
This2.S #inner() 
read method 
Void #close() }
method 
This1.Bool contains(This1.S that) 
method 
This0 remove(This1.S that) 
method 
This1.Bool #equalequal(This0 that) 
method 
This1.Bool equals(Any that) }
Assert:{interface <:This1.Message
NotImplementedYet:{<:This1, This2.Message
type method 
This0 #apply(This2.S _text, This2.Message.Opt cause) 
mut method 
This2.S #_text() 
read method 
This2.S _text() 
mut method 
This2.Message.Opt #cause() 
read method 
This2.Message.Opt cause() 
method 
This0 #apply(This2.Message that) 
method 
This2.Bool #bangequal(This0 that) 
method 
This2.Bool #equalequal(This0 that) 
type method 
This0 #apply(This2.S text) 
type method 
This0 #apply(This2.S text, This2.Message cause) 
type method 
mut This2.S.SBuilder #builder() 
type method 
This0 #from(This2.S.SBuilder builder) 
method 
This0.SConcat #begin() 
SConcat:{
type method 
This0 #apply(This3.Concept.ToS old, This3.S accumulator) 
mut method 
This3.Concept.ToS #old() 
read method 
This3.Concept.ToS old() 
mut method 
This3.S #accumulator() 
read method 
This3.S accumulator() 
method 
This0 #add(This3.Concept.ToS that) 
method 
This0 #add(This3.Concept.ToS that, This3.Concept.ToS separedBy) 
method 
This0 #end() 
method 
mut This3.S.SBuilder #builder() 
method 
This1 #from(This3.S.SBuilder builder) }}
ObservedBug:{<:This1, This2.Message
type method 
This0 #apply(This2.S _text, This2.Message.Opt cause) 
mut method 
This2.S #_text() 
read method 
This2.S _text() 
mut method 
This2.Message.Opt #cause() 
read method 
This2.Message.Opt cause() 
method 
This0 #apply(This2.Message that) 
method 
This2.Bool #bangequal(This0 that) 
method 
This2.Bool #equalequal(This0 that) 
type method 
This0 #apply(This2.S text) 
type method 
This0 #apply(This2.S text, This2.Message cause) 
type method 
mut This2.S.SBuilder #builder() 
type method 
This0 #from(This2.S.SBuilder builder) 
method 
This0.SConcat #begin() 
SConcat:{
type method 
This0 #apply(This3.Concept.ToS old, This3.S accumulator) 
mut method 
This3.Concept.ToS #old() 
read method 
This3.Concept.ToS old() 
mut method 
This3.S #accumulator() 
read method 
This3.S accumulator() 
method 
This0 #add(This3.Concept.ToS that) 
method 
This0 #add(This3.Concept.ToS that, This3.Concept.ToS separedBy) 
method 
This0 #end() 
method 
mut This3.S.SBuilder #builder() 
method 
This1 #from(This3.S.SBuilder builder) }}
CodeNotReachable:{<:This1, This2.Message
type method 
This0 #apply(This2.S _text, This2.Message.Opt cause) 
mut method 
This2.S #_text() 
read method 
This2.S _text() 
mut method 
This2.Message.Opt #cause() 
read method 
This2.Message.Opt cause() 
method 
This0 #apply(This2.Message that) 
method 
This2.Bool #bangequal(This0 that) 
method 
This2.Bool #equalequal(This0 that) 
type method 
This0 #apply(This2.S text) 
type method 
This0 #apply(This2.S text, This2.Message cause) 
type method 
mut This2.S.SBuilder #builder() 
type method 
This0 #from(This2.S.SBuilder builder) 
method 
This0.SConcat #begin() 
SConcat:{
type method 
This0 #apply(This3.Concept.ToS old, This3.S accumulator) 
mut method 
This3.Concept.ToS #old() 
read method 
This3.Concept.ToS old() 
mut method 
This3.S #accumulator() 
read method 
This3.S accumulator() 
method 
This0 #add(This3.Concept.ToS that) 
method 
This0 #add(This3.Concept.ToS that, This3.Concept.ToS separedBy) 
method 
This0 #end() 
method 
mut This3.S.SBuilder #builder() 
method 
This1 #from(This3.S.SBuilder builder) }}
$:{
type method 
This0 #apply(This2.N that) 
mut method 
This2.N #that() 
read method 
This2.N that() 
type method 
This0 #begin() 
method 
Void #end() 
method 
This0 #add(This2.Bool that) 
method 
This0 #add(This2.Bool that, This2.Concept.ToS msg) }
AssertMessage:{<:This1, This2.Message
type method 
This0 #apply(This2.S _text, This2.Message.Opt cause) 
mut method 
This2.S #_text() 
read method 
This2.S _text() 
mut method 
This2.Message.Opt #cause() 
read method 
This2.Message.Opt cause() 
method 
This0 #apply(This2.Message that) 
method 
This2.Bool #bangequal(This0 that) 
method 
This2.Bool #equalequal(This0 that) 
type method 
This0 #apply(This2.S text) 
type method 
This0 #apply(This2.S text, This2.Message cause) 
type method 
mut This2.S.SBuilder #builder() 
type method 
This0 #from(This2.S.SBuilder builder) 
method 
This0.SConcat #begin() 
SConcat:{
type method 
This0 #apply(This3.Concept.ToS old, This3.S accumulator) 
mut method 
This3.Concept.ToS #old() 
read method 
This3.Concept.ToS old() 
mut method 
This3.S #accumulator() 
read method 
This3.S accumulator() 
method 
This0 #add(This3.Concept.ToS that) 
method 
This0 #add(This3.Concept.ToS that, This3.Concept.ToS separedBy) 
method 
This0 #end() 
method 
mut This3.S.SBuilder #builder() 
method 
This1 #from(This3.S.SBuilder builder) }}}
System:{
Guard:{'<:Outer.Guard soon (remove "interface" for a bad translation bug: This1_System_Guard is not abstract and does not override abstract method MtoS()
interface <:This2.Guard
PluginFailure:{<:This1, This3.Message
type method 
This0 #apply(This3.S _text, This3.Message.Opt cause) 
mut method 
This3.S #_text() 
read method 
This3.S _text() 
mut method 
This3.Message.Opt #cause() 
read method 
This3.Message.Opt cause() 
method 
This0 #apply(This3.Message that) 
method 
This3.Bool #bangequal(This0 that) 
method 
This3.Bool #equalequal(This0 that) 
type method 
This0 #apply(This3.S text) 
type method 
This0 #apply(This3.S text, This3.Message cause) 
type method 
mut This3.S.SBuilder #builder() 
type method 
This0 #from(This3.S.SBuilder builder) 
method 
This0.SConcat #begin() 
SConcat:{
type method 
This0 #apply(This4.Concept.ToS old, This4.S accumulator) 
mut method 
This4.Concept.ToS #old() 
read method 
This4.Concept.ToS old() 
mut method 
This4.S #accumulator() 
read method 
This4.S accumulator() 
method 
This0 #add(This4.Concept.ToS that) 
method 
This0 #add(This4.Concept.ToS that, This4.Concept.ToS separedBy) 
method 
This0 #end() 
method 
mut This4.S.SBuilder #builder() 
method 
This1 #from(This4.S.SBuilder builder) }}}}
Guard:{' exception as Guard bureocracy, error as Guard detection
'-is a check guarenteed to be performed, program logic can rely on this being enforced.
'  as exceptions, Guards objects are a way to report/guard complex operations,
' where checking the shape of the input can be unconvenient.
'as errors, they represent precondition violations. 
'Turning an exception Guard into an error Guard
' is equivalent of declaring that such misuse should not happen (blame on the caller),
' still, there is no bug in the program at this stage. Is legit for the caller to try and be blamed
interface <:This1.Message'all other guards should implement this one

Operation:{<:This1, This2.Message
type method 
This0 #apply(This2.S _text, This2.Message.Opt cause) 
mut method 
This2.S #_text() 
read method 
This2.S _text() 
mut method 
This2.Message.Opt #cause() 
read method 
This2.Message.Opt cause() 
method 
This0 #apply(This2.Message that) 
method 
This2.Bool #bangequal(This0 that) 
method 
This2.Bool #equalequal(This0 that) 
type method 
This0 #apply(This2.S text) 
type method 
This0 #apply(This2.S text, This2.Message cause) 
type method 
mut This2.S.SBuilder #builder() 
type method 
This0 #from(This2.S.SBuilder builder) 
method 
This0.SConcat #begin() 
SConcat:{
type method 
This0 #apply(This3.Concept.ToS old, This3.S accumulator) 
mut method 
This3.Concept.ToS #old() 
read method 
This3.Concept.ToS old() 
mut method 
This3.S #accumulator() 
read method 
This3.S accumulator() 
method 
This0 #add(This3.Concept.ToS that) 
method 
This0 #add(This3.Concept.ToS that, This3.Concept.ToS separedBy) 
method 
This0 #end() 
method 
mut This3.S.SBuilder #builder() 
method 
This1 #from(This3.S.SBuilder builder) }}
Parameter:{<:This1, This2.Message
type method 
This0 #apply(This2.S _text, This2.Message.Opt cause) 
mut method 
This2.S #_text() 
read method 
This2.S _text() 
mut method 
This2.Message.Opt #cause() 
read method 
This2.Message.Opt cause() 
method 
This0 #apply(This2.Message that) 
method 
This2.Bool #bangequal(This0 that) 
method 
This2.Bool #equalequal(This0 that) 
type method 
This0 #apply(This2.S text) 
type method 
This0 #apply(This2.S text, This2.Message cause) 
type method 
mut This2.S.SBuilder #builder() 
type method 
This0 #from(This2.S.SBuilder builder) 
method 
This0.SConcat #begin() 
SConcat:{
type method 
This0 #apply(This3.Concept.ToS old, This3.S accumulator) 
mut method 
This3.Concept.ToS #old() 
read method 
This3.Concept.ToS old() 
mut method 
This3.S #accumulator() 
read method 
This3.S accumulator() 
method 
This0 #add(This3.Concept.ToS that) 
method 
This0 #add(This3.Concept.ToS that, This3.Concept.ToS separedBy) 
method 
This0 #end() 
method 
mut This3.S.SBuilder #builder() 
method 
This1 #from(This3.S.SBuilder builder) }}
Precondition:{<:This1, This2.Message
type method 
This0 #apply(This2.S _text, This2.Message.Opt cause) 
mut method 
This2.S #_text() 
read method 
This2.S _text() 
mut method 
This2.Message.Opt #cause() 
read method 
This2.Message.Opt cause() 
method 
This0 #apply(This2.Message that) 
method 
This2.Bool #bangequal(This0 that) 
method 
This2.Bool #equalequal(This0 that) 
type method 
This0 #apply(This2.S text) 
type method 
This0 #apply(This2.S text, This2.Message cause) 
type method 
mut This2.S.SBuilder #builder() 
type method 
This0 #from(This2.S.SBuilder builder) 
method 
This0.SConcat #begin() 
SConcat:{
type method 
This0 #apply(This3.Concept.ToS old, This3.S accumulator) 
mut method 
This3.Concept.ToS #old() 
read method 
This3.Concept.ToS old() 
mut method 
This3.S #accumulator() 
read method 
This3.S accumulator() 
method 
This0 #add(This3.Concept.ToS that) 
method 
This0 #add(This3.Concept.ToS that, This3.Concept.ToS separedBy) 
method 
This0 #end() 
method 
mut This3.S.SBuilder #builder() 
method 
This1 #from(This3.S.SBuilder builder) }}
ParseFail:{interface <:This1}}
Message:{interface <:This1.Concept.ToS, This1.Concept.Equals, This1.Concept.Classable, This1.Concept.Named
type method 
This1.S kind() 
method 
This1.S text() 
method 
This0.Opt responseOf() 
read method 
type This0 clazz() 
Opt:{
type method 
This0 #new(This0.TOpt that) 
mut method 
This0.TOpt #that() 
read method 
This0.TOpt that() 
TOpt:{interface 
method 
This2 get() }
TEmpty:{<:This1.TOpt, This1.TOpt
type method 
This0 #apply() }
TOf:{<:This1.TOpt
type method 
This0 #apply(This2 that) 
mut method 
This2 #that() 
read method 
This2 that() }
method 
This1 #tilde() 
method 
This2.Bool isPresent() 
type method 
This0 #apply() 
type method 
This0 #apply(This1 that) }
EqualMessages:{
type method 
This2.Bool #apply(This1 that, This1 other) }
$:{
type method 
This0 #apply() 
type method 
Library #leftleft(Library that) 
type method 
Library messageTrait() }}
Concept:{
ToS:{interface 
read method 
This2.S toS() }
Classable:{interface 
read method 
type Any classAny() }
Named:{interface 
type method 
This2.S myName() }
Wrapper:{interface 
read method 
Any inner() }
TypeWrapper:{interface 
read method 
type Any inner() }
ReadWrapper:{interface 
read method 
read Any inner() }
MutWrapper:{interface <:This1.ReadWrapper
mut method 
mut Any #inner() }
LentWrapper:{interface <:This1.ReadWrapper
mut method 
lent Any #inner() }
Equals:{interface 
read method 
This2.Bool equals(read Any that) }
Comparable:{interface 
read method 
This2.Bool greater(read Any that) }
Boollable:{interface 
read method 
Void #checkTrue() exception Void }
Decorator:{interface 'method Library>>(Library that) exception MetaGuard(specific)
'method Library decorate(Library that) exception MetaGuard I can link metaguard for circularity
}
Contains:{interface 'read method Bool >>(read Elem that)

read method 
This2.Bool contains(read Any that) }
Parsable:{interface 'type method capsule This fromS(S that) exception Guard.Parameter(specific) invalid string
'''type method capsule This #fromS(S that) exception Guard.Parameter
}
Invariant:{interface 
read method ' can throw error or return false, as more opportune
This2.Bool invariant() }
RandomAccess:{interface 'read method read Elem (N that)
'mut method mut Elem #(N that)

read method 
read Any get(This2.N that) 
mut method 
mut Any #get(This2.N that) }
Sizable:{interface 
read method 
This2.N size() 
read method 
This2.Bool isEmpty() }
Iterator:{interface 
mut method 
Void #next() exception Void 
read method 
Void #checkEnd() 
read method 
Void #close() }}
S:{<:This1.Concept.ToS, This1.Concept.Equals, This1.Concept.Named
type method 
This0 #from(Library binaryRepr) 
method 
Library binaryRepr() 
method 
This0 #plusplus(This0 that) 
method 
This1.Bool #bangequal(This0 that) 
method 
This1.Bool #equalequal(This0 that) 
method 
This0 #apply(This1.N start, This1.N end) 
method 
This0 #apply(This1.N that) 
method 
This0 #apply(This1.N start) 
method 
This0 #apply(This1.N end) 
method 
This1.Bool beginsWith(This0 that) 
method 
This1.N firstIndexOf(This0 that) 
type method 
Void subStringNotPresent(This0 string, This0 subString) 
method 
This1.Bool contains(This0 that) 
method 
This1.Bool isASCIILowerCase(This1.N that) 
method 
This1.Bool isASCIIUpperCase(This1.N that) 
method 
This1.N size() 
type method 
This0 doubleQuote() 
type method 
This0 nl() 
method 
This0 replace(This0 that, This0 into) 
method 
This0.SConcat #begin() 
SConcat:{
type method 
This0 #apply(This1 old, This1 accumulator) 
mut method 
This1 #old() 
read method 
This1 old() 
mut method 
This1 #accumulator() 
read method 
This1 accumulator() 
method 
This0 #add(This2.Concept.ToS that) 
method 
This0 #add(This2.Concept.ToS that, This2.Concept.ToS separedBy) 
method 
This0 #end() 
method 
mut This1.SBuilder #builder() 
method 
This1 #from(This1.SBuilder builder) }
SBuilder:{
read method 
Library binaryRepr() 
mut method 
Void acc(Library that) 
type method 
mut This0 empty() 
mut method 
Void #0() 
mut method 
Void #1() 
mut method 
Void #2() 
mut method 
Void #3() 
mut method 
Void #4() 
mut method 
Void #5() 
mut method 
Void #6() 
mut method 
Void #7() 
mut method 
Void #8() 
mut method 
Void #9() 
mut method 
Void #q() 
mut method 
Void #w() 
mut method 
Void #e() 
mut method 
Void #r() 
mut method 
Void #t() 
mut method 
Void #y() 
mut method 
Void #u() 
mut method 
Void #i() 
mut method 
Void #o() 
mut method 
Void #p() 
mut method 
Void #a() 
mut method 
Void #s() 
mut method 
Void #d() 
mut method 
Void #f() 
mut method 
Void #g() 
mut method 
Void #h() 
mut method 
Void #j() 
mut method 
Void #k() 
mut method 
Void #l() 
mut method 
Void #z() 
mut method 
Void #x() 
mut method 
Void #c() 
mut method 
Void #v() 
mut method 
Void #b() 
mut method 
Void #n() 
mut method 
Void #m() 
mut method 
Void #Q() 
mut method 
Void #W() 
mut method 
Void #E() 
mut method 
Void #R() 
mut method 
Void #T() 
mut method 
Void #Y() 
mut method 
Void #U() 
mut method 
Void #I() 
mut method 
Void #O() 
mut method 
Void #P() 
mut method 
Void #A() 
mut method 
Void #S() 
mut method 
Void #D() 
mut method 
Void #F() 
mut method 
Void #G() 
mut method 
Void #H() 
mut method 
Void #J() 
mut method 
Void #K() 
mut method 
Void #L() 
mut method 
Void #Z() 
mut method 
Void #X() 
mut method 
Void #C() 
mut method 
Void #V() 
mut method 
Void #B() 
mut method 
Void #N() 
mut method 
Void #M() 
mut method 
Void #%() 
mut method 
Void #$() 
mut method 
Void #left() 
mut method 
Void #right() 
mut method 
Void #bang() 
mut method 
Void #tilde() 
mut method 
Void #plus() 
mut method 
Void #times() 
mut method 
Void #divide() 
mut method 
Void #less() 
mut method 
Void #and() 
mut method 
Void #or() 
mut method 
Void #oRound() 
mut method 
Void #cRound() 
mut method 
Void #oSquare() 
mut method 
Void #cSquare() 
mut method 
Void #oCurly() 
mut method 
Void #cCurly() 
mut method 
Void #dQuote() 
mut method 
Void #sQuote() 
mut method 
Void #hQuote() 
mut method 
Void #equal() 
mut method 
Void #qMark() 
mut method 
Void #hat() 
mut method 
Void #comma() 
mut method 
Void #semicolon() 
mut method 
Void #colon() 
mut method 
Void #dot() 
mut method 
Void #underscore() 
mut method 
Void #hash() 
mut method 
Void #at() 
mut method 
Void #backslash() 
mut method 
Void #space() 
mut method 
Void #newline() }
type method 
This0 #from(This0.SBuilder builder) 
type method 
mut This0.SBuilder #builder() 
SubStringNotPresent:{<:This2.Guard, This2.Message
type method 
This0 #apply(This1 _text, This2.Message.Opt cause) 
mut method 
This1 #_text() 
read method 
This1 _text() 
mut method 
This2.Message.Opt #cause() 
read method 
This2.Message.Opt cause() 
method 
This0 #apply(This2.Message that) 
method 
This2.Bool #bangequal(This0 that) 
method 
This2.Bool #equalequal(This0 that) 
type method 
This0 #apply(This1 text) 
type method 
This0 #apply(This1 text, This2.Message cause) 
type method 
mut This1.SBuilder #builder() 
type method 
This0 #from(This1.SBuilder builder) 
method 
This0.SConcat #begin() 
SConcat:{
type method 
This0 #apply(This3.Concept.ToS old, This2 accumulator) 
mut method 
This3.Concept.ToS #old() 
read method 
This3.Concept.ToS old() 
mut method 
This2 #accumulator() 
read method 
This2 accumulator() 
method 
This0 #add(This3.Concept.ToS that) 
method 
This0 #add(This3.Concept.ToS that, This3.Concept.ToS separedBy) 
method 
This0 #end() 
method 
mut This2.SBuilder #builder() 
method 
This1 #from(This2.SBuilder builder) }}}
N:{<:This1.Concept.ToS, This1.Concept.Equals, This1.Concept.Named
type method 
This0 fromS(This1.Concept.ToS that) 
type method 
This0 #from(Library binaryRepr) 
method 
Library binaryRepr() 
type method 
mut This1.S.SBuilder #builder() 
type method 
This0 #from(This1.S.SBuilder builder) 
type method 
Any parseError(This1.S that) 
method 
This0 #plus(This0 that) 
method 
This0 #less(This0 that) 
method 
This0 #times(This0 that) 
method 
This0 #divide(This0 that) 
method 
This1.Bool #equalequal(This0 that) 
method 
This1.Bool #left(This0 that) 
method 
This1.Bool #leftequal(This0 that) 
method 
This1.Bool #bangequal(This0 that) 
method 
This1.Bool #right(This0 that) 
method 
This1.Bool #rightequal(This0 that) 
method 
mut This0.Iterator vals() 
method 
mut This0.Iterator vals(This0 upTo) 
Iterator:{
type method 
mut This0 #apply(This1 start, This1 end) 
mut method 
Void start(This1 that) 
mut method 
This1 #start() 
read method 
This1 start() 
mut method 
This1 #end() 
read method 
This1 end() 
mut method 
Void #next() exception Void 
read method 
Void #checkEnd() 
read method 
This1 #inner() 
read method 
Void #close() }
ParseFail:{<:This2.Guard.ParseFail, This2.Message
type method 
This0 #apply(This2.S _text, This2.Message.Opt cause) 
mut method 
This2.S #_text() 
read method 
This2.S _text() 
mut method 
This2.Message.Opt #cause() 
read method 
This2.Message.Opt cause() 
method 
This0 #apply(This2.Message that) 
method 
This2.Bool #bangequal(This0 that) 
method 
This2.Bool #equalequal(This0 that) 
type method 
This0 #apply(This2.S text) 
type method 
This0 #apply(This2.S text, This2.Message cause) 
type method 
mut This2.S.SBuilder #builder() 
type method 
This0 #from(This2.S.SBuilder builder) 
method 
This0.SConcat #begin() 
SConcat:{
type method 
This0 #apply(This3.Concept.ToS old, This3.S accumulator) 
mut method 
This3.Concept.ToS #old() 
read method 
This3.Concept.ToS old() 
mut method 
This3.S #accumulator() 
read method 
This3.S accumulator() 
method 
This0 #add(This3.Concept.ToS that) 
method 
This0 #add(This3.Concept.ToS that, This3.Concept.ToS separedBy) 
method 
This0 #end() 
method 
mut This3.S.SBuilder #builder() 
method 
This1 #from(This3.S.SBuilder builder) }}}
Bool:{<:This1.Concept.ToS, This1.Concept.Equals, This1.Concept.Named
method 
Void #checkTrue() exception Void 
type method 
This0 true() 
type method 
This0 false() 
method 
This0 #and(This0 that) 
method 
This0 #or(This0 that) 
method 
This0 #bang() 
type method 
This0 fromS(read This1.Concept.ToS that) 
method 
This0 #equalequal(This0 that) 
method 
This0 #bangequal(This0 that) 
type method 
Any parseError(This1.S that) 
ParseFail:{<:This2.Guard.ParseFail, This2.Message
type method 
This0 #apply(This2.S _text, This2.Message.Opt cause) 
mut method 
This2.S #_text() 
read method 
This2.S _text() 
mut method 
This2.Message.Opt #cause() 
read method 
This2.Message.Opt cause() 
method 
This0 #apply(This2.Message that) 
method 
This1 #bangequal(This0 that) 
method 
This1 #equalequal(This0 that) 
type method 
This0 #apply(This2.S text) 
type method 
This0 #apply(This2.S text, This2.Message cause) 
type method 
mut This2.S.SBuilder #builder() 
type method 
This0 #from(This2.S.SBuilder builder) 
method 
This0.SConcat #begin() 
SConcat:{
type method 
This0 #apply(This3.Concept.ToS old, This3.S accumulator) 
mut method 
This3.Concept.ToS #old() 
read method 
This3.Concept.ToS old() 
mut method 
This3.S #accumulator() 
read method 
This3.S accumulator() 
method 
This0 #add(This3.Concept.ToS that) 
method 
This0 #add(This3.Concept.ToS that, This3.Concept.ToS separedBy) 
method 
This0 #end() 
method 
mut This3.S.SBuilder #builder() 
method 
This1 #from(This3.S.SBuilder builder) }}}
ExitCode:{
type method 
Library normal() 
type method 
Library failure() }
Alu:{'@plugin
'L42.is/connected/withAlu
}}
type method 
Void printHelloWorld() This0.Abstract.Debug.#apply(that:This0.Abstract.S.#from(builder:(
  This0.Abstract.S::#builder() b=This0.Abstract.S.#builder()
  Void unused=b.#H()
  Void unused0=b.#e()
  Void unused1=b.#l()
  Void unused2=b.#l()
  Void unused3=b.#o()
  Void unused4=b.#space()
  Void unused5=b.#W()
  Void unused6=b.#o()
  Void unused7=b.#r()
  Void unused8=b.#l()
  Void unused9=b.#d()
  Void unused10=b.#space()
  Void unused11=b.#D()
  Void unused12=b.#e()
  Void unused13=b.#p()
  Void unused14=b.#l()
  Void unused15=b.#o()
  Void unused16=b.#y()
  Void unused17=b.#e()
  Void unused18=b.#d()
  b
  )))}