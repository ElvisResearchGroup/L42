{
Abstract:{
Load:{'shape of a loadable library:
' Outer0 contains actual library, but
' Abstract:{} contains abstract classes, and 
' Abstract::ConceptMap mapps concepts names to abstract classes

type method 
Outer0 #begin() 
method 
Outer0 #end() 
ConceptMapMismatch:{<:Outer2::MetaGuard, Outer2::Guard, Outer2::Message, Outer2::Concept::ToS, Outer2::Concept::Equals, Outer2::Concept::Classable, Outer2::Concept::Named
type method 
Outer0 #apply(Outer2::S _text, Outer2::Message::Opt cause) 
mut method 
Outer2::S #_text() 
read method 
Outer2::S _text() 
mut method 
Outer2::Message::Opt #cause() 
read method 
Outer2::Message::Opt cause() 
type method 
Outer0 #stringParser(Library that) 
method 
Outer0 #apply(Outer2::Message that) 
method 
Outer2::Bool #bangequal(Outer0 that) 
method 
Outer2::Bool #equalequal(Outer0 that) 
type method 
Outer0 #apply(Outer2::S text) 
type method 
Outer0 #apply(Outer2::S text, Outer2::Message cause) 
method 
Outer0::SConcat #begin() 
SConcat:{
type method 
Outer0 #apply(Outer3::S accumulator) 
mut method 
Outer3::S #accumulator() 
read method 
Outer3::S accumulator() 
method 
Outer0 #add(Outer3::Concept::ToS that) 
method 
Outer0 #end() 
method 
Outer1 #stringParser(Library that) }}
ConceptMapUnavailable:{<:Outer2::MetaGuard, Outer2::Guard, Outer2::Message, Outer2::Concept::ToS, Outer2::Concept::Equals, Outer2::Concept::Classable, Outer2::Concept::Named
type method 
Outer0 #apply(Outer2::S _text, Outer2::Message::Opt cause) 
mut method 
Outer2::S #_text() 
read method 
Outer2::S _text() 
mut method 
Outer2::Message::Opt #cause() 
read method 
Outer2::Message::Opt cause() 
type method 
Outer0 #stringParser(Library that) 
method 
Outer0 #apply(Outer2::Message that) 
method 
Outer2::Bool #bangequal(Outer0 that) 
method 
Outer2::Bool #equalequal(Outer0 that) 
type method 
Outer0 #apply(Outer2::S text) 
type method 
Outer0 #apply(Outer2::S text, Outer2::Message cause) 
method 
Outer0::SConcat #begin() 
SConcat:{
type method 
Outer0 #apply(Outer3::S accumulator) 
mut method 
Outer3::S #accumulator() 
read method 
Outer3::S accumulator() 
method 
Outer0 #add(Outer3::Concept::ToS that) 
method 
Outer0 #end() 
method 
Outer1 #stringParser(Library that) }}
method 
Library #leftleft(Library that) exception Outer0::ConceptMapMismatch, Outer0::ConceptMapUnavailable 
DeployLibrary:{
type method 
Outer0 #apply(Outer2::Path path, Outer2::Url url) 
mut method 
Outer2::Path #path() 
read method 
Outer2::Path path() 
mut method 
Outer2::Url #url() 
read method 
Outer2::Url url() 
type method 
Library exposeAsLibrary(Library that, Outer2::Path path) exception Outer2::MetaGuard::NestedClassUnavailable, Outer2::MetaGuard::PrivacyCoupuled 
type method 
Void checkTargetExists(Library that, Outer2::Path path) exception Outer2::MetaGuard::NestedClassUnavailable 
type method 
type Outer0 #begin() 
method 
Outer0 #end() 
type method 
Outer0 #add(Outer2::Path that, Outer2::Url url) 
method 
Library #leftleft(Library that) exception Outer2::MetaGuard::NestedClassUnavailable, Outer2::MetaGuard::PrivacyCoupuled }}
PreferentialComposition:{'members of PreferentialComposition

$:{interface 
method 
Library solveConflict(Library that, Outer1::SrcDest location) exception Outer2::MetaGuard }
SrcDest:{
type method 
Outer0 #apply(Outer2::Path path, Outer2::Selector src, Outer2::Selector dest) 
mut method 
Outer2::Path #path() 
read method 
Outer2::Path path() 
mut method 
Outer2::Selector #src() 
read method 
Outer2::Selector src() 
mut method 
Outer2::Selector #dest() 
read method 
Outer2::Selector dest() }
SrcDests:{' generic linked list class, elements of type Elem
<:Outer2::Concept::Named
type method 
Outer0 _new(Outer0::Cell head) 
mut method 
Outer0::Cell #head() 
read method 
Outer0::Cell head() 
type method 
Outer0 #apply() 
method 
Outer2::Bool isEmpty() 
method 
Outer1::SrcDest top() 
method 
mut Outer0::Iterator vals() 
method 
mut Outer0::Iterator valsCut() 
method 
Outer0 pop() 
method 
Outer0 #plusplus(Outer0 that) 
type method 
Outer0 #begin() 
method 
Outer0 #add(Outer1::SrcDest that) 
method 
Outer0 #end() 
Cell:{interface 
method 
mut Outer1::Iterator vals(Outer3::Bool terminate) 
method 
Outer0 #next() exception Void 
method 
Outer2::SrcDest #inner() 
method 
Void #checkEnd() }
CellEnd:{<:Outer1::Cell
type method 
Outer0 #apply() }
CellNext:{<:Outer1::Cell
type method 
Outer0 #apply(Outer2::SrcDest elem, Outer1::Cell nextCell) 
mut method 
Outer2::SrcDest #elem() 
read method 
Outer2::SrcDest elem() 
mut method 
Outer1::Cell #nextCell() 
read method 
Outer1::Cell nextCell() }
Iterator:{
type method 
mut Outer0 #apply(Outer1::Cell that, Outer3::Bool terminate) 
mut method 
Void that(Outer1::Cell that) 
mut method 
Outer1::Cell #that() 
read method 
Outer1::Cell that() 
mut method 
Outer3::Bool #terminate() 
read method 
Outer3::Bool terminate() 
mut method 
Void #next() exception Void 
read method 
Void #checkEnd() 
read method 
Outer2::SrcDest #inner() 
read method 
Void #close() }}
type method 
Outer0::SrcDests renameMap(Library that, Outer1::S prefix, Outer1::Path path, Outer1::Introspection::Methods ms) 
type method 
Outer1::Bool needRename(Outer1::Introspection::NestedClass that, Outer1::Introspection::Method meth) 
type method 
Library #leftleft(Library that) exception Outer1::MetaGuard::ClassClash, Outer1::MetaGuard::MethodClash }
DeployTowel:{
type method 
Outer0 #apply(Library fileName) 
mut method 
Library #fileName() 
read method 
Library fileName() 
type method 
type Outer0 #begin() 
type method 
Outer0 #add(Library fileName) 
method 
Outer0 #end() 
type method 
Library binaryReprFrom(Library lib) 
method 
Library #leftleft(Library that) 
Alu:'  toPutAs private
{'@plugin
'L42.is/connected/withAlu
}
type method 
Library #stringParser(Library that) 
type method 
Library #numberParser(Library that) }
LinkedList:{
ListCode:{
type method 
Library #apply() }
type method 
Library list(type Any that) }
Default:{
DecorationUnfeasable:{<:Outer2::MetaGuard, Outer2::Guard, Outer2::Message, Outer2::Concept::ToS, Outer2::Concept::Equals, Outer2::Concept::Classable, Outer2::Concept::Named
type method 
Outer0 #apply(Outer2::S _text, Outer2::Message::Opt cause) 
mut method 
Outer2::S #_text() 
read method 
Outer2::S _text() 
mut method 
Outer2::Message::Opt #cause() 
read method 
Outer2::Message::Opt cause() 
type method 
Outer0 #stringParser(Library that) 
method 
Outer0 #apply(Outer2::Message that) 
method 
Outer2::Bool #bangequal(Outer0 that) 
method 
Outer2::Bool #equalequal(Outer0 that) 
type method 
Outer0 #apply(Outer2::S text) 
type method 
Outer0 #apply(Outer2::S text, Outer2::Message cause) 
method 
Outer0::SConcat #begin() 
SConcat:{
type method 
Outer0 #apply(Outer3::S accumulator) 
mut method 
Outer3::S #accumulator() 
read method 
Outer3::S accumulator() 
method 
Outer0 #add(Outer3::Concept::ToS that) 
method 
Outer0 #end() 
method 
Outer1 #stringParser(Library that) }}
Parsable:{
type method 
Library #leftleft(Library that) exception Outer1::DecorationUnfeasable }
SealState:{' how to specify which factory to keep out? what getters

type method 
Library #leftleft(Library that) }
Invariant:{
type method 
Outer2::Bool isInvariant(Outer2::Introspection::NestedClass that) 
type method 
Library #leftleft(Library that) exception Outer1::DecorationUnfeasable }
DataFromToS:{' in the future we can add also hashCode and > =>

type method 
Library #leftleft(Library that) exception Outer1::DecorationUnfeasable }
Equals:{
type method 
Library #leftleft(Library that) exception Outer1::DecorationUnfeasable }
Named:{
type method 
Library #leftleft(Library that) exception Outer1::DecorationUnfeasable }}
Use:{'members of each produced class
<:Outer1::PreferentialComposition::$
method 
Outer0 #add(Library that) 
type method 
Outer0 #begin() 
method 
Outer0 #end() 
method 
Library #leftleft(Library that) exception Outer1::MetaGuard::ClassClash, Outer1::MetaGuard::MethodClash 
method 
Outer0 #plusplus(Outer0 that) }
Extends:{'members of each produced class
<:Outer1::PreferentialComposition::$
method 
Outer0 #add(Library that) 
type method 
Outer0 #begin() 
method 
Outer0 #end() 
method 
Library #leftleft(Library that) exception Outer1::MetaGuard::ClassClash, Outer1::MetaGuard::MethodClash 
method 
Outer0 #plusplus(Outer0 that) }
Opt:{
type method 
Library #apply(type Any that) }
Optimize:{
RemoveUnreachableCode:{
type method 
Outer0 #apply() 
type method 
Outer0 #begin() 
method 
Outer0 #end() 
method 
Library #leftleft(Library that) }}
Refactor:{
type method 
Library compose(Library left, Library right) exception Outer1::MetaGuard::ClassClash, Outer1::MetaGuard::MethodClash 
type method 
Void checkTargetExists(Library that, Outer1::Path path) exception Outer1::MetaGuard::NestedClassUnavailable 
Squares:'  toPutAs private
{'findMeSquares

type method 
Library #leftleft(Library that) }
Redirect:{
type method 
Outer0 #add(Outer2::Path that, type Any to) 
mut method 
Outer2::Path #that() 
read method 
Outer2::Path that() 
mut method 
type Any #to() 
read method 
type Any to() 
method 
Library #leftleft(Library that) exception Outer2::MetaGuard::NestedClassUnavailable, Outer2::MetaGuard::InvalidOnTopLevel, Outer2::MetaGuard::SourceUnfit, Outer2::MetaGuard::MethodClash, Outer2::MetaGuard::IncoherentRedirectMapping 
type method 
type Outer0 #begin() 
method 
Outer0 #end() }
RenameSelector:{
type method 
Outer0 #add(Outer2::Selector that, Outer2::Path of, Outer2::Selector to) 
mut method 
Outer2::Selector #that() 
read method 
Outer2::Selector that() 
mut method 
Outer2::Path #of() 
read method 
Outer2::Path of() 
mut method 
Outer2::Selector #to() 
read method 
Outer2::Selector to() 
method 
Library #leftleft(Library that) exception Outer2::MetaGuard::MemberUnavailable, Outer2::MetaGuard::MethodClash 
type method 
type Outer0 #begin() 
method 
Outer0 #end() }
RenamePath:{
type method 
Outer0 #add(Outer2::Path that, Outer2::Path to) 
mut method 
Outer2::Path #that() 
read method 
Outer2::Path that() 
mut method 
Outer2::Path #to() 
read method 
Outer2::Path to() 
method 
Library #leftleft(Library that) exception Outer2::MetaGuard::NestedClassUnavailable, Outer2::MetaGuard::MethodClash, Outer2::MetaGuard::ClassClash 
type method 
type Outer0 #begin() 
method 
Outer0 #end() }
RemoveImplementationSelector:{
type method 
Outer0 #add(Outer2::Selector that, Outer2::Path of) 
mut method 
Outer2::Selector #that() 
read method 
Outer2::Selector that() 
mut method 
Outer2::Path #of() 
read method 
Outer2::Path of() 
method 
Library #leftleft(Library that) exception Outer2::MetaGuard::MemberUnavailable 
type method 
type Outer0 #begin() 
method 
Outer0 #end() }
MoveImplementationSelector:{
type method 
Outer0 #add(Outer2::Selector that, Outer2::Path of, Outer2::Selector to) 
mut method 
Outer2::Selector #that() 
read method 
Outer2::Selector that() 
mut method 
Outer2::Path #of() 
read method 
Outer2::Path of() 
mut method 
Outer2::Selector #to() 
read method 
Outer2::Selector to() 
method 
Library #leftleft(Library that) exception Outer2::MetaGuard::MemberUnavailable, Outer2::MetaGuard::MethodClash 
type method 
type Outer0 #begin() 
method 
Outer0 #end() }
RemoveImplementationPath:{
type method 
Outer0 #add(Outer2::Path that) 
mut method 
Outer2::Path #that() 
read method 
Outer2::Path that() 
method 
Library #leftleft(Library that) exception Outer2::MetaGuard::NestedClassUnavailable, Outer2::MetaGuard::PrivacyCoupuled 
type method 
type Outer0 #begin() 
method 
Outer0 #end() }
AddDocumentationSelector:{
type method 
Outer0 #add(Outer2::Selector that, Outer2::Path of, Outer2::Introspection::Doc doc) 
mut method 
Outer2::Selector #that() 
read method 
Outer2::Selector that() 
mut method 
Outer2::Path #of() 
read method 
Outer2::Path of() 
mut method 
Outer2::Introspection::Doc #doc() 
read method 
Outer2::Introspection::Doc doc() 
method 
Library #leftleft(Library that) exception Outer2::MetaGuard::MemberUnavailable 
type method 
type Outer0 #begin() 
method 
Outer0 #end() }
AddDocumentationPath:{
type method 
Outer0 #add(Outer2::Path that, Outer2::Introspection::Doc doc) 
mut method 
Outer2::Path #that() 
read method 
Outer2::Path that() 
mut method 
Outer2::Introspection::Doc #doc() 
read method 
Outer2::Introspection::Doc doc() 
method 
Library #leftleft(Library that) exception Outer2::MetaGuard::NestedClassUnavailable, Outer2::MetaGuard::InvalidOnTopLevel 
type method 
type Outer0 #begin() 
method 
Outer0 #end() }
MakePrivatePath:{
type method 
Outer0 #add(Outer2::Path that) 
mut method 
Outer2::Path #that() 
read method 
Outer2::Path that() 
method 
Library #leftleft(Library that) exception Outer2::MetaGuard::MemberUnavailable, Outer2::MetaGuard::InvalidOnTopLevel 
type method 
type Outer0 #begin() 
method 
Outer0 #end() }
MakePrivateSelector:{
type method 
Outer0 #add(Outer2::Selector that, Outer2::Path of) 
mut method 
Outer2::Selector #that() 
read method 
Outer2::Selector that() 
mut method 
Outer2::Path #of() 
read method 
Outer2::Path of() 
method 
Library #leftleft(Library that) exception Outer2::MetaGuard::MemberUnavailable 
type method 
type Outer0 #begin() 
method 
Outer0 #end() }
SumMethods:{
type method 
Outer0 #add(Outer2::Selector that, Outer2::Selector and, Outer2::Path of, Outer2::Selector to) 
mut method 
Outer2::Selector #that() 
read method 
Outer2::Selector that() 
mut method 
Outer2::Selector #and() 
read method 
Outer2::Selector and() 
mut method 
Outer2::Path #of() 
read method 
Outer2::Path of() 
mut method 
Outer2::Selector #to() 
read method 
Outer2::Selector to() 
method 
Library #leftleft(Library that) exception Outer2::MetaGuard::MemberUnavailable, Outer2::MetaGuard::MethodClash, Outer2::MetaGuard::ParameterMismatch 
type method 
type Outer0 #begin() 
method 
Outer0 #end() }
Tools:{
type method 
Outer2::S getToSOrName(read Any that) }}
Introspection:{'findMeIntrospection

type method 
Outer0::NestedClass #apply(Library lib) 
type method 
Outer0::NestedClass #apply(Library lib, Outer1::Path path) exception Outer1::MetaGuard::NestedClassUnavailable 
type method 
Outer0::NestedClass #apply(type Any clazz) 
type method 
Outer0::NestedClass #apply(type Any clazz, Outer1::Path path) 
MirrorPr:{interface 
method 
Outer1::NestedClass introspectReport(fwd Outer1::NestedClass root, Outer2::Path path) exception Outer2::MetaGuard::NestedClassUnavailable 
method 
Outer1::Member introspectReportMember(fwd Outer1::NestedClass root, Outer2::Path path, Outer2::N memberN) exception Outer2::MetaGuard::MemberUnavailable, Void 
method 
Outer1::Type introspectReportType(fwd Outer1::NestedClass root, Outer2::Path path, Outer2::N memberN, Outer2::N typeN) exception Outer2::MetaGuard::MemberUnavailable, Void 
method 
Outer2::S introspectDocAsString(Outer2::Path path) exception Outer2::MetaGuard::NestedClassUnavailable 
method 
Outer2::S introspectDocAsString(Outer2::Path path, Outer2::N annotationN) exception Outer2::MetaGuard::NestedClassUnavailable, Void 
method 
type Any introspectDocPath(Outer2::Path path, Outer2::N annotationN) exception Outer2::MetaGuard::NestedClassUnavailable, Void 
Lib:{<:Outer1
type method 
Outer0 #apply(Library lib) 
mut method 
Library #lib() 
read method 
Library lib() }
Class:{<:Outer1
type method 
Outer0 #apply(type Any lib) 
mut method 
type Any #lib() 
read method 
type Any lib() }}
Doc:{<:Outer2::Concept::ToS, Outer2::Concept::Named
Annotation:{<:Outer3::Concept::ToS, Outer3::Concept::Named
type method 
Outer0 #apply(Library _binaryRepr, Outer3::S text, Outer3::N index) 
mut method 
Library #_binaryRepr() 
read method 
Library _binaryRepr() 
mut method 
Outer3::S #text() 
read method 
Outer3::S text() 
mut method 
Outer3::N #index() 
read method 
Outer3::N index() 
method 
type Any referredClass() 
method 
Outer3::Bool hasReferredClass() }
Annotations:{' generic linked list class, elements of type Elem
<:Outer3::Concept::Named
type method 
Outer0 _new(Outer0::Cell head) 
mut method 
Outer0::Cell #head() 
read method 
Outer0::Cell head() 
type method 
Outer0 #apply() 
method 
Outer3::Bool isEmpty() 
method 
Outer1::Annotation top() 
method 
mut Outer0::Iterator vals() 
method 
mut Outer0::Iterator valsCut() 
method 
Outer0 pop() 
method 
Outer0 #plusplus(Outer0 that) 
type method 
Outer0 #begin() 
method 
Outer0 #add(Outer1::Annotation that) 
method 
Outer0 #end() 
Cell:{interface 
method 
mut Outer1::Iterator vals(Outer4::Bool terminate) 
method 
Outer0 #next() exception Void 
method 
Outer2::Annotation #inner() 
method 
Void #checkEnd() }
CellEnd:{<:Outer1::Cell
type method 
Outer0 #apply() }
CellNext:{<:Outer1::Cell
type method 
Outer0 #apply(Outer2::Annotation elem, Outer1::Cell nextCell) 
mut method 
Outer2::Annotation #elem() 
read method 
Outer2::Annotation elem() 
mut method 
Outer1::Cell #nextCell() 
read method 
Outer1::Cell nextCell() }
Iterator:{
type method 
mut Outer0 #apply(Outer1::Cell that, Outer4::Bool terminate) 
mut method 
Void that(Outer1::Cell that) 
mut method 
Outer1::Cell #that() 
read method 
Outer1::Cell that() 
mut method 
Outer4::Bool #terminate() 
read method 
Outer4::Bool terminate() 
mut method 
Void #next() exception Void 
read method 
Void #checkEnd() 
read method 
Outer2::Annotation #inner() 
read method 
Void #close() }}
type method 
Outer0 #apply(Library that) 
type method 
Outer0 #stringParser(Library that) 
method 
Library binaryRepr() 
method 
Outer0::Annotations annotations() }
Record:{
type method 
Outer0 #apply(Outer1::MirrorPr that) 
mut method 
Outer1::MirrorPr #that() 
read method 
Outer1::MirrorPr that() 
type method 
Outer0 #apply(type Any clazz) 
type method 
Outer0 #apply(Library lib) 
method 
Void dbg() 
method 
Outer2::S #stringParser(Library that) 
method 
Outer1::Doc docOf(Outer2::Path path) 
RootForMember:' toPutAs private
{interface 
method 
Outer2::Member #apply(fwd Outer2::NestedClass root) }
RootForNested:' toPutAs private
{<:Outer1::RootForMember
type method 
Outer0 #apply(Outer3::Path path, Outer2::MirrorPr mirror, Outer1 _report) 
mut method 
Outer3::Path #path() 
read method 
Outer3::Path path() 
mut method 
Outer2::MirrorPr #mirror() 
read method 
Outer2::MirrorPr mirror() 
mut method 
Outer1 #_report() 
read method 
Outer1 _report() }
RootForMethod:' toPutAs private
{<:Outer1::RootForMember
type method 
Outer0 #apply(Outer3::Path path, Outer3::N memberN, Outer1 _report) 
mut method 
Outer3::Path #path() 
read method 
Outer3::Path path() 
mut method 
Outer3::N #memberN() 
read method 
Outer3::N memberN() 
mut method 
Outer1 #_report() 
read method 
Outer1 _report() }
type method 
Outer1::Member dispatch(fwd Outer1::NestedClass root, Outer2::Path path, Outer1::MirrorPr mirror, Outer2::N memberN, Library record) }
Member:{interface <:Outer2::Concept::ToS, Outer2::Concept::Named, Outer2::Concept::Equals}
Members:{' generic linked list class, elements of type Elem
<:Outer2::Concept::Named
type method 
Outer0 _new(Outer0::Cell head) 
mut method 
Outer0::Cell #head() 
read method 
Outer0::Cell head() 
type method 
Outer0 #apply() 
method 
Outer2::Bool isEmpty() 
method 
Outer1::Member top() 
method 
mut Outer0::Iterator vals() 
method 
mut Outer0::Iterator valsCut() 
method 
Outer0 pop() 
method 
Outer0 #plusplus(Outer0 that) 
type method 
Outer0 #begin() 
method 
Outer0 #add(Outer1::Member that) 
method 
Outer0 #end() 
Cell:{interface 
method 
mut Outer1::Iterator vals(Outer3::Bool terminate) 
method 
Outer0 #next() exception Void 
method 
Outer2::Member #inner() 
method 
Void #checkEnd() }
CellEnd:{<:Outer1::Cell
type method 
Outer0 #apply() }
CellNext:{<:Outer1::Cell
type method 
Outer0 #apply(Outer2::Member elem, Outer1::Cell nextCell) 
mut method 
Outer2::Member #elem() 
read method 
Outer2::Member elem() 
mut method 
Outer1::Cell #nextCell() 
read method 
Outer1::Cell nextCell() }
Iterator:{
type method 
mut Outer0 #apply(Outer1::Cell that, Outer3::Bool terminate) 
mut method 
Void that(Outer1::Cell that) 
mut method 
Outer1::Cell #that() 
read method 
Outer1::Cell that() 
mut method 
Outer3::Bool #terminate() 
read method 
Outer3::Bool terminate() 
mut method 
Void #next() exception Void 
read method 
Void #checkEnd() 
read method 
Outer2::Member #inner() 
read method 
Void #close() }}
Method:{<:Outer1::Member, Outer2::Concept::ToS, Outer2::Concept::Named, Outer2::Concept::Equals
method 
Outer2::Bool #equalequal(Outer0 that) 
method 
Outer2::Bool #bangequal(Outer0 that) 
method 
Outer1::Doc doc() 
method 
Outer2::S thisMdf() 
method ' invariant NestedClass(...).nestedClassFromRoot(path).pathFromRoot()==path
Outer2::Path pathFromRoot() 
method 
Outer2::Selector selector() 
method 
Outer2::S methodKind() 
method 
Outer2::S allAsString() 
method 
Outer1::Type returnType() 
method 
Outer1::Types exceptions() 
method 
Outer1::Types parameterTypes() 
method 
Outer2::Bool isPrivate() 
method 
Outer1::NestedClass root() }
Methods:{' generic linked list class, elements of type Elem
<:Outer2::Concept::Named
type method 
Outer0 _new(Outer0::Cell head) 
mut method 
Outer0::Cell #head() 
read method 
Outer0::Cell head() 
type method 
Outer0 #apply() 
method 
Outer2::Bool isEmpty() 
method 
Outer1::Method top() 
method 
mut Outer0::Iterator vals() 
method 
mut Outer0::Iterator valsCut() 
method 
Outer0 pop() 
method 
Outer0 #plusplus(Outer0 that) 
type method 
Outer0 #begin() 
method 
Outer0 #add(Outer1::Method that) 
method 
Outer0 #end() 
Cell:{interface 
method 
mut Outer1::Iterator vals(Outer3::Bool terminate) 
method 
Outer0 #next() exception Void 
method 
Outer2::Method #inner() 
method 
Void #checkEnd() }
CellEnd:{<:Outer1::Cell
type method 
Outer0 #apply() }
CellNext:{<:Outer1::Cell
type method 
Outer0 #apply(Outer2::Method elem, Outer1::Cell nextCell) 
mut method 
Outer2::Method #elem() 
read method 
Outer2::Method elem() 
mut method 
Outer1::Cell #nextCell() 
read method 
Outer1::Cell nextCell() }
Iterator:{
type method 
mut Outer0 #apply(Outer1::Cell that, Outer3::Bool terminate) 
mut method 
Void that(Outer1::Cell that) 
mut method 
Outer1::Cell #that() 
read method 
Outer1::Cell that() 
mut method 
Outer3::Bool #terminate() 
read method 
Outer3::Bool terminate() 
mut method 
Void #next() exception Void 
read method 
Void #checkEnd() 
read method 
Outer2::Method #inner() 
read method 
Void #close() }}
NestedClass:{'findMeNestedClass
<:Outer1::Member, Outer2::Concept::ToS, Outer2::Concept::Named, Outer2::Concept::Equals
method 
Outer2::Bool #equalequal(Outer0 that) 
method 
Outer2::Bool #bangequal(Outer0 that) 
method 
Outer0 root() 
method 'error for Outer0
Outer1::Doc nestedDoc() 
method 'of the library literal
Outer1::Doc doc() 
method 
Outer2::Path pathFromRoot() 
method 
Outer2::Bool hasExternalType() 
method 
type Any externalType() 
method 
Outer2::S externalTypeToS() 
method 
Outer2::S classKind() 
method 
Outer2::S allAsString() 
method 
Outer1::Members members() 
method 
Outer1::Methods methods() 
method 
Outer1::NestedClasses nestedClasses() 
method 
Outer1::NestedClasses transitivelyNestedClasses() 
method 
Outer1::Types implementedInterfaces() 
method 
Outer1::Types transitivelyImplementedInterfaces() 
method 
Outer1::Methods stateCandidate() 
method 
Outer1::Methods state() 
method 
Outer1::Method methodFromSelector(Outer2::Selector that) exception Outer2::MetaGuard::MethodUnavailable 
method 
Outer2::Bool has(Outer2::Selector selector) 
method 
Outer0 nestedClassFromRoot(Outer2::Path that) exception Outer2::MetaGuard::NestedClassUnavailable 
method 
Outer2::Bool has(Outer2::Path fromRoot) 
method 
Outer2::Bool isPrivate() }
NestedClasses:{' generic linked list class, elements of type Elem
<:Outer2::Concept::Named
type method 
Outer0 _new(Outer0::Cell head) 
mut method 
Outer0::Cell #head() 
read method 
Outer0::Cell head() 
type method 
Outer0 #apply() 
method 
Outer2::Bool isEmpty() 
method 
Outer1::NestedClass top() 
method 
mut Outer0::Iterator vals() 
method 
mut Outer0::Iterator valsCut() 
method 
Outer0 pop() 
method 
Outer0 #plusplus(Outer0 that) 
type method 
Outer0 #begin() 
method 
Outer0 #add(Outer1::NestedClass that) 
method 
Outer0 #end() 
Cell:{interface 
method 
mut Outer1::Iterator vals(Outer3::Bool terminate) 
method 
Outer0 #next() exception Void 
method 
Outer2::NestedClass #inner() 
method 
Void #checkEnd() }
CellEnd:{<:Outer1::Cell
type method 
Outer0 #apply() }
CellNext:{<:Outer1::Cell
type method 
Outer0 #apply(Outer2::NestedClass elem, Outer1::Cell nextCell) 
mut method 
Outer2::NestedClass #elem() 
read method 
Outer2::NestedClass elem() 
mut method 
Outer1::Cell #nextCell() 
read method 
Outer1::Cell nextCell() }
Iterator:{
type method 
mut Outer0 #apply(Outer1::Cell that, Outer3::Bool terminate) 
mut method 
Void that(Outer1::Cell that) 
mut method 
Outer1::Cell #that() 
read method 
Outer1::Cell that() 
mut method 
Outer3::Bool #terminate() 
read method 
Outer3::Bool terminate() 
mut method 
Void #next() exception Void 
read method 
Void #checkEnd() 
read method 
Outer2::NestedClass #inner() 
read method 
Void #close() }}
Type:{<:Outer2::Concept::ToS, Outer2::Concept::Named
method 
Outer2::S allAsString() 
method 
Outer2::S typeKind() 
method 
Outer2::S mdf() 
method 
Outer1::NestedClass referencedPath() 
method 
Outer1::NestedClass resolvedReferencedPath() 
method 
Outer2::Bool partial() 
method 
Outer2::Bool resolvedPartial() 
method 
Outer2::S suffix() 
method 
Outer1::Doc doc() }
Types:{' generic linked list class, elements of type Elem
<:Outer2::Concept::Named
type method 
Outer0 _new(Outer0::Cell head) 
mut method 
Outer0::Cell #head() 
read method 
Outer0::Cell head() 
type method 
Outer0 #apply() 
method 
Outer2::Bool isEmpty() 
method 
Outer1::Type top() 
method 
mut Outer0::Iterator vals() 
method 
mut Outer0::Iterator valsCut() 
method 
Outer0 pop() 
method 
Outer0 #plusplus(Outer0 that) 
type method 
Outer0 #begin() 
method 
Outer0 #add(Outer1::Type that) 
method 
Outer0 #end() 
Cell:{interface 
method 
mut Outer1::Iterator vals(Outer3::Bool terminate) 
method 
Outer0 #next() exception Void 
method 
Outer2::Type #inner() 
method 
Void #checkEnd() }
CellEnd:{<:Outer1::Cell
type method 
Outer0 #apply() }
CellNext:{<:Outer1::Cell
type method 
Outer0 #apply(Outer2::Type elem, Outer1::Cell nextCell) 
mut method 
Outer2::Type #elem() 
read method 
Outer2::Type elem() 
mut method 
Outer1::Cell #nextCell() 
read method 
Outer1::Cell nextCell() }
Iterator:{
type method 
mut Outer0 #apply(Outer1::Cell that, Outer3::Bool terminate) 
mut method 
Void that(Outer1::Cell that) 
mut method 
Outer1::Cell #that() 
read method 
Outer1::Cell that() 
mut method 
Outer3::Bool #terminate() 
read method 
Outer3::Bool terminate() 
mut method 
Void #next() exception Void 
read method 
Void #checkEnd() 
read method 
Outer2::Type #inner() 
read method 
Void #close() }}}
MetaGuard:{interface <:Outer1::Guard, Outer1::Message, Outer1::Concept::ToS, Outer1::Concept::Equals, Outer1::Concept::Classable, Outer1::Concept::Named
SourceUnfit:{<:Outer1, Outer2::Guard, Outer2::Message, Outer2::Concept::ToS, Outer2::Concept::Equals, Outer2::Concept::Classable, Outer2::Concept::Named
type method 
Outer0 #apply(Outer2::Introspection::Record record) 
method 
Outer2::Bool #bangequal(Outer0 that) 
method 
Outer2::Bool #equalequal(Outer0 that) }
IncoherentRedirectMapping:{<:Outer1, Outer2::Guard, Outer2::Message, Outer2::Concept::ToS, Outer2::Concept::Equals, Outer2::Concept::Classable, Outer2::Concept::Named
type method 
Outer0 #apply(Outer2::Introspection::Record record) 
method 
Outer2::Bool #bangequal(Outer0 that) 
method 
Outer2::Bool #equalequal(Outer0 that) }
ClassClash:{<:Outer1, Outer2::Guard, Outer2::Message, Outer2::Concept::ToS, Outer2::Concept::Equals, Outer2::Concept::Classable, Outer2::Concept::Named
type method 
Outer0 #apply(Outer2::Introspection::Record record) 
method 
Outer2::Bool #bangequal(Outer0 that) 
method 
Outer2::Bool #equalequal(Outer0 that) }
MethodClash:{<:Outer1, Outer2::Guard, Outer2::Message, Outer2::Concept::ToS, Outer2::Concept::Equals, Outer2::Concept::Classable, Outer2::Concept::Named
type method 
Outer0 #apply(Outer2::Introspection::Record record) 
method 
Outer2::Bool #bangequal(Outer0 that) 
method 
Outer2::Bool #equalequal(Outer0 that) }
InvalidOnTopLevel:{<:Outer1, Outer2::Guard, Outer2::Message, Outer2::Concept::ToS, Outer2::Concept::Equals, Outer2::Concept::Classable, Outer2::Concept::Named
type method 
Outer0 #apply(Outer2::Introspection::Record record) 
method 
Outer2::Bool #bangequal(Outer0 that) 
method 
Outer2::Bool #equalequal(Outer0 that) }
PrivacyCoupuled:{<:Outer1, Outer2::Guard, Outer2::Message, Outer2::Concept::ToS, Outer2::Concept::Equals, Outer2::Concept::Classable, Outer2::Concept::Named
type method 
Outer0 #apply(Outer2::Introspection::Record record) 
method 
Outer2::Bool #bangequal(Outer0 that) 
method 
Outer2::Bool #equalequal(Outer0 that) }
ParameterMismatch:{<:Outer1, Outer2::Guard, Outer2::Message, Outer2::Concept::ToS, Outer2::Concept::Equals, Outer2::Concept::Classable, Outer2::Concept::Named
type method 
Outer0 #apply(Outer2::Introspection::Record record) 
method 
Outer2::Bool #bangequal(Outer0 that) 
method 
Outer2::Bool #equalequal(Outer0 that) }
MemberUnavailable:{interface <:Outer1, Outer2::Guard, Outer2::Message, Outer2::Concept::ToS, Outer2::Concept::Equals, Outer2::Concept::Classable, Outer2::Concept::Named}
DispatchMemberUnavailable:{
type method 
Outer1::MemberUnavailable #apply(Library that) }
NestedClassUnavailable:{<:Outer1::MemberUnavailable, Outer1, Outer2::Guard, Outer2::Message, Outer2::Concept::ToS, Outer2::Concept::Equals, Outer2::Concept::Classable, Outer2::Concept::Named
type method 
Outer0 #apply(Outer2::Path path, Outer2::Bool isPrivate) 
mut method 
Outer2::Path #path() 
read method 
Outer2::Path path() 
mut method 
Outer2::Bool #isPrivate() 
read method 
Outer2::Bool isPrivate() 
type method 
Outer0 #apply(Outer2::Introspection::Record record) 
method 
Outer2::Bool #bangequal(Outer0 that) 
method 
Outer2::Bool #equalequal(Outer0 that) }
MethodUnavailable:{<:Outer1::MemberUnavailable, Outer1, Outer2::Guard, Outer2::Message, Outer2::Concept::ToS, Outer2::Concept::Equals, Outer2::Concept::Classable, Outer2::Concept::Named
type method 
Outer0 #apply(Outer2::Path path, Outer2::Selector selector, Outer2::Bool isPrivate) 
mut method 
Outer2::Path #path() 
read method 
Outer2::Path path() 
mut method 
Outer2::Selector #selector() 
read method 
Outer2::Selector selector() 
mut method 
Outer2::Bool #isPrivate() 
read method 
Outer2::Bool isPrivate() 
type method 
Outer0 #apply(Outer2::Introspection::Record record) 
method 
Outer2::Bool #bangequal(Outer0 that) 
method 
Outer2::Bool #equalequal(Outer0 that) }}
Selector:{<:Outer1::Concept::ToS, Outer1::Concept::Equals, Outer1::Concept::Named
type method 
Outer0 fromS(Outer1::Concept::ToS that) 
type method 
Outer0 #stringParser(Library that) 
type method 
Any parseError(Outer1::S that) 
type method 
Outer0 from(Outer1::S name, Outer1::Strings names) 
method 
Outer1::S nameAsField() 
method 
Outer1::S prefixAsField() 
method 
Library binaryRepr() 
method 
Outer1::Bool #bangequal(Outer0 that) 
method 
Outer1::Bool #equalequal(Outer0 that) 
method 
Outer1::Bool isOperator() 
method 
Outer1::S name() 
method 
Outer1::Strings names() 
type method 
Outer0 fresh(Outer0 that) 
ParseFail:{<:Outer2::Guard::ParseFail, Outer2::Guard, Outer2::Message, Outer2::Concept::ToS, Outer2::Concept::Equals, Outer2::Concept::Classable, Outer2::Concept::Named
type method 
Outer0 #apply(Outer2::S _text, Outer2::Message::Opt cause) 
mut method 
Outer2::S #_text() 
read method 
Outer2::S _text() 
mut method 
Outer2::Message::Opt #cause() 
read method 
Outer2::Message::Opt cause() 
type method 
Outer0 #stringParser(Library that) 
method 
Outer0 #apply(Outer2::Message that) 
method 
Outer2::Bool #bangequal(Outer0 that) 
method 
Outer2::Bool #equalequal(Outer0 that) 
type method 
Outer0 #apply(Outer2::S text) 
type method 
Outer0 #apply(Outer2::S text, Outer2::Message cause) 
method 
Outer0::SConcat #begin() 
SConcat:{
type method 
Outer0 #apply(Outer3::S accumulator) 
mut method 
Outer3::S #accumulator() 
read method 
Outer3::S accumulator() 
method 
Outer0 #add(Outer3::Concept::ToS that) 
method 
Outer0 #end() 
method 
Outer1 #stringParser(Library that) }}}
Path:{<:Outer1::Concept::ToS, Outer1::Concept::Equals, Outer1::Concept::Named
type method 
Outer0 fromDocInternalizedS(Outer1::S that) 
type method 
Outer0 fromS(Outer1::Concept::ToS that) 
type method 
Outer0 #stringParser(Library that) 
type method 
Any parseError(Outer1::S that) 
type method 
Any parseError(Outer1::S that, Outer1::Message cause) 
method 
Library binaryRepr() 
method 
Outer1::Bool #bangequal(Outer0 that) 
method 
Outer1::Bool #equalequal(Outer0 that) 
method 
Outer0 #plusplus(Outer0 that) 
method 
Outer1::Strings names() 
type method 
Outer0 from(Outer1::Strings names) 
type method 
Outer0 fresh(Outer1::S name) 
type method 
Outer0 fresh() 
type method 
Outer0 fresh(Outer0 path) 
ParseFail:{<:Outer2::Guard::ParseFail, Outer2::Guard, Outer2::Message, Outer2::Concept::ToS, Outer2::Concept::Equals, Outer2::Concept::Classable, Outer2::Concept::Named
type method 
Outer0 #apply(Outer2::S _text, Outer2::Message::Opt cause) 
mut method 
Outer2::S #_text() 
read method 
Outer2::S _text() 
mut method 
Outer2::Message::Opt #cause() 
read method 
Outer2::Message::Opt cause() 
type method 
Outer0 #stringParser(Library that) 
method 
Outer0 #apply(Outer2::Message that) 
method 
Outer2::Bool #bangequal(Outer0 that) 
method 
Outer2::Bool #equalequal(Outer0 that) 
type method 
Outer0 #apply(Outer2::S text) 
type method 
Outer0 #apply(Outer2::S text, Outer2::Message cause) 
method 
Outer0::SConcat #begin() 
SConcat:{
type method 
Outer0 #apply(Outer3::S accumulator) 
mut method 
Outer3::S #accumulator() 
read method 
Outer3::S accumulator() 
method 
Outer0 #add(Outer3::Concept::ToS that) 
method 
Outer0 #end() 
method 
Outer1 #stringParser(Library that) }}}
Url:{'ParseFailure:Message:S[]<<{<:Guard} no need, related to invariant?
<:Outer1::Concept::ToS
type method ' if you do not implement it, it is a constructor?
Outer0 fromS(read Outer1::Concept::ToS that) 
type method 
Outer0 #stringParser(Library that) 
type method 
Outer0 #apply(Outer1::S inner) 
mut method 
Outer1::S #inner() 
read method 
Outer1::S inner() 
method 
Library binaryRepr() }
ConceptMap:{interface 
method 
Outer1::Alu _Alu() 
method 
Outer1::ExitCode _ExitCode() 
method 
Outer1::Bool _Bool() 
method 
Outer1::N _N() 
method 
Outer1::S _S() 
method 
Outer1::Concept _Concept() 
method 
Outer1::Message _Message() 
method 
Outer1::Guard _Guard() 
method 
Outer1::System _System() 
method 
Outer1::Assert _Assert() 
method 
Outer1::Strings _Strings() 
method 
Outer1::Debug _Debug() 
method 
Outer0 _ConceptMap() 
method 
Outer1::Url _Url() 
method 
Outer1::Path _Path() 
method 
Outer1::Selector _Selector() 
method 
Outer1::MetaGuard _MetaGuard() 
method 
Outer1::Introspection _Introspection() 
method 
Outer1::Refactor _Refactor() 
method 
Outer1::Optimize _Optimize() 
method 
Outer1::Opt _Opt() 
method 
Outer1::Extends _Extends() 
method 
Outer1::Use _Use() 
method 
Outer1::Default _Default() 
method 
Outer1::LinkedList _LinkedList() 
method 
Outer1::DeployTowel _DeployTowel() 
method 
Outer1::PreferentialComposition _PreferentialComposition() 
method 
Outer1::Load _Load() }
Debug:{
type method 
Void #apply(Outer1::Concept::ToS that) 
type method 
Void #apply(Library lib) 
type method 
Void #apply(Outer1::Concept::ToS fileName, Outer1::Concept::ToS content) }
Strings:{' generic linked list class, elements of type Elem
<:Outer1::Concept::Named
type method 
Outer0 _new(Outer0::Cell head) 
mut method 
Outer0::Cell #head() 
read method 
Outer0::Cell head() 
type method 
Outer0 #apply() 
method 
Outer1::Bool isEmpty() 
method 
Outer1::S top() 
method 
mut Outer0::Iterator vals() 
method 
mut Outer0::Iterator valsCut() 
method 
Outer0 pop() 
method 
Outer0 #plusplus(Outer0 that) 
type method 
Outer0 #begin() 
method 
Outer0 #add(Outer1::S that) 
method 
Outer0 #end() 
Cell:{interface 
method 
mut Outer1::Iterator vals(Outer2::Bool terminate) 
method 
Outer0 #next() exception Void 
method 
Outer2::S #inner() 
method 
Void #checkEnd() }
CellEnd:{<:Outer1::Cell
type method 
Outer0 #apply() }
CellNext:{<:Outer1::Cell
type method 
Outer0 #apply(Outer2::S elem, Outer1::Cell nextCell) 
mut method 
Outer2::S #elem() 
read method 
Outer2::S elem() 
mut method 
Outer1::Cell #nextCell() 
read method 
Outer1::Cell nextCell() }
Iterator:{
type method 
mut Outer0 #apply(Outer1::Cell that, Outer2::Bool terminate) 
mut method 
Void that(Outer1::Cell that) 
mut method 
Outer1::Cell #that() 
read method 
Outer1::Cell that() 
mut method 
Outer2::Bool #terminate() 
read method 
Outer2::Bool terminate() 
mut method 
Void #next() exception Void 
read method 
Void #checkEnd() 
read method 
Outer2::S #inner() 
read method 
Void #close() }}
Assert:{interface <:Outer1::Message, Outer1::Concept::ToS, Outer1::Concept::Equals, Outer1::Concept::Classable, Outer1::Concept::Named
NotImplementedYet:{<:Outer1, Outer2::Message, Outer2::Concept::ToS, Outer2::Concept::Equals, Outer2::Concept::Classable, Outer2::Concept::Named
type method 
Outer0 #apply(Outer2::S _text, Outer2::Message::Opt cause) 
mut method 
Outer2::S #_text() 
read method 
Outer2::S _text() 
mut method 
Outer2::Message::Opt #cause() 
read method 
Outer2::Message::Opt cause() 
type method 
Outer0 #stringParser(Library that) 
method 
Outer0 #apply(Outer2::Message that) 
method 
Outer2::Bool #bangequal(Outer0 that) 
method 
Outer2::Bool #equalequal(Outer0 that) 
type method 
Outer0 #apply(Outer2::S text) 
type method 
Outer0 #apply(Outer2::S text, Outer2::Message cause) 
method 
Outer0::SConcat #begin() 
SConcat:{
type method 
Outer0 #apply(Outer3::S accumulator) 
mut method 
Outer3::S #accumulator() 
read method 
Outer3::S accumulator() 
method 
Outer0 #add(Outer3::Concept::ToS that) 
method 
Outer0 #end() 
method 
Outer1 #stringParser(Library that) }}
ObservedBug:{<:Outer1, Outer2::Message, Outer2::Concept::ToS, Outer2::Concept::Equals, Outer2::Concept::Classable, Outer2::Concept::Named
type method 
Outer0 #apply(Outer2::S _text, Outer2::Message::Opt cause) 
mut method 
Outer2::S #_text() 
read method 
Outer2::S _text() 
mut method 
Outer2::Message::Opt #cause() 
read method 
Outer2::Message::Opt cause() 
type method 
Outer0 #stringParser(Library that) 
method 
Outer0 #apply(Outer2::Message that) 
method 
Outer2::Bool #bangequal(Outer0 that) 
method 
Outer2::Bool #equalequal(Outer0 that) 
type method 
Outer0 #apply(Outer2::S text) 
type method 
Outer0 #apply(Outer2::S text, Outer2::Message cause) 
method 
Outer0::SConcat #begin() 
SConcat:{
type method 
Outer0 #apply(Outer3::S accumulator) 
mut method 
Outer3::S #accumulator() 
read method 
Outer3::S accumulator() 
method 
Outer0 #add(Outer3::Concept::ToS that) 
method 
Outer0 #end() 
method 
Outer1 #stringParser(Library that) }}
CodeNotReachable:{<:Outer1, Outer2::Message, Outer2::Concept::ToS, Outer2::Concept::Equals, Outer2::Concept::Classable, Outer2::Concept::Named
type method 
Outer0 #apply(Outer2::S _text, Outer2::Message::Opt cause) 
mut method 
Outer2::S #_text() 
read method 
Outer2::S _text() 
mut method 
Outer2::Message::Opt #cause() 
read method 
Outer2::Message::Opt cause() 
type method 
Outer0 #stringParser(Library that) 
method 
Outer0 #apply(Outer2::Message that) 
method 
Outer2::Bool #bangequal(Outer0 that) 
method 
Outer2::Bool #equalequal(Outer0 that) 
type method 
Outer0 #apply(Outer2::S text) 
type method 
Outer0 #apply(Outer2::S text, Outer2::Message cause) 
method 
Outer0::SConcat #begin() 
SConcat:{
type method 
Outer0 #apply(Outer3::S accumulator) 
mut method 
Outer3::S #accumulator() 
read method 
Outer3::S accumulator() 
method 
Outer0 #add(Outer3::Concept::ToS that) 
method 
Outer0 #end() 
method 
Outer1 #stringParser(Library that) }}
$:{
type method 
Outer0 #apply(Outer2::N that) 
mut method 
Outer2::N #that() 
read method 
Outer2::N that() 
type method 
Outer0 #begin() 
method 
Void #end() 
method 
Outer0 #add(Outer2::Bool that) 
method 
Outer0 #add(Outer2::Bool that, Outer2::Concept::ToS msg) }
AssertMessage:{<:Outer1, Outer2::Message, Outer2::Concept::ToS, Outer2::Concept::Equals, Outer2::Concept::Classable, Outer2::Concept::Named
type method 
Outer0 #apply(Outer2::S _text, Outer2::Message::Opt cause) 
mut method 
Outer2::S #_text() 
read method 
Outer2::S _text() 
mut method 
Outer2::Message::Opt #cause() 
read method 
Outer2::Message::Opt cause() 
type method 
Outer0 #stringParser(Library that) 
method 
Outer0 #apply(Outer2::Message that) 
method 
Outer2::Bool #bangequal(Outer0 that) 
method 
Outer2::Bool #equalequal(Outer0 that) 
type method 
Outer0 #apply(Outer2::S text) 
type method 
Outer0 #apply(Outer2::S text, Outer2::Message cause) 
method 
Outer0::SConcat #begin() 
SConcat:{
type method 
Outer0 #apply(Outer3::S accumulator) 
mut method 
Outer3::S #accumulator() 
read method 
Outer3::S accumulator() 
method 
Outer0 #add(Outer3::Concept::ToS that) 
method 
Outer0 #end() 
method 
Outer1 #stringParser(Library that) }}}
System:{
Guard:{'<:Outer::Guard soon (remove "interface" for a bad translation bug: Outer1_System_Guard is not abstract and does not override abstract method MtoS()
interface <:Outer2::Guard, Outer2::Message, Outer2::Concept::ToS, Outer2::Concept::Equals, Outer2::Concept::Classable, Outer2::Concept::Named
PluginFailure:{<:Outer1, Outer3::Guard, Outer3::Message, Outer3::Concept::ToS, Outer3::Concept::Equals, Outer3::Concept::Classable, Outer3::Concept::Named
type method 
Outer0 #apply(Outer3::S _text, Outer3::Message::Opt cause) 
mut method 
Outer3::S #_text() 
read method 
Outer3::S _text() 
mut method 
Outer3::Message::Opt #cause() 
read method 
Outer3::Message::Opt cause() 
type method 
Outer0 #stringParser(Library that) 
method 
Outer0 #apply(Outer3::Message that) 
method 
Outer3::Bool #bangequal(Outer0 that) 
method 
Outer3::Bool #equalequal(Outer0 that) 
type method 
Outer0 #apply(Outer3::S text) 
type method 
Outer0 #apply(Outer3::S text, Outer3::Message cause) 
method 
Outer0::SConcat #begin() 
SConcat:{
type method 
Outer0 #apply(Outer4::S accumulator) 
mut method 
Outer4::S #accumulator() 
read method 
Outer4::S accumulator() 
method 
Outer0 #add(Outer4::Concept::ToS that) 
method 
Outer0 #end() 
method 
Outer1 #stringParser(Library that) }}}}
Guard:{' exception as Guard bureocracy, error as Guard detection
'-is a check guarenteed to be performed, program logic can rely on this being enforced.
'  as exceptions, Guards objects are a way to report/guard complex operations,
' where checking the shape of the input can be unconvenient.
'as errors, they represent precondition violations. 
'Turning an exception Gard into an error Gard
' is equivalent of declaring that such misuse should not happen (blame on the caller),
' still, there is no bug in the program at this stage. Is legit for the caller to try and be blamed
interface <:Outer1::Message, Outer1::Concept::ToS, Outer1::Concept::Equals, Outer1::Concept::Classable, Outer1::Concept::Named'all other guards should implement this one

Operation:{<:Outer1, Outer2::Message, Outer2::Concept::ToS, Outer2::Concept::Equals, Outer2::Concept::Classable, Outer2::Concept::Named
type method 
Outer0 #apply(Outer2::S _text, Outer2::Message::Opt cause) 
mut method 
Outer2::S #_text() 
read method 
Outer2::S _text() 
mut method 
Outer2::Message::Opt #cause() 
read method 
Outer2::Message::Opt cause() 
type method 
Outer0 #stringParser(Library that) 
method 
Outer0 #apply(Outer2::Message that) 
method 
Outer2::Bool #bangequal(Outer0 that) 
method 
Outer2::Bool #equalequal(Outer0 that) 
type method 
Outer0 #apply(Outer2::S text) 
type method 
Outer0 #apply(Outer2::S text, Outer2::Message cause) 
method 
Outer0::SConcat #begin() 
SConcat:{
type method 
Outer0 #apply(Outer3::S accumulator) 
mut method 
Outer3::S #accumulator() 
read method 
Outer3::S accumulator() 
method 
Outer0 #add(Outer3::Concept::ToS that) 
method 
Outer0 #end() 
method 
Outer1 #stringParser(Library that) }}
Parameter:{<:Outer1, Outer2::Message, Outer2::Concept::ToS, Outer2::Concept::Equals, Outer2::Concept::Classable, Outer2::Concept::Named
type method 
Outer0 #apply(Outer2::S _text, Outer2::Message::Opt cause) 
mut method 
Outer2::S #_text() 
read method 
Outer2::S _text() 
mut method 
Outer2::Message::Opt #cause() 
read method 
Outer2::Message::Opt cause() 
type method 
Outer0 #stringParser(Library that) 
method 
Outer0 #apply(Outer2::Message that) 
method 
Outer2::Bool #bangequal(Outer0 that) 
method 
Outer2::Bool #equalequal(Outer0 that) 
type method 
Outer0 #apply(Outer2::S text) 
type method 
Outer0 #apply(Outer2::S text, Outer2::Message cause) 
method 
Outer0::SConcat #begin() 
SConcat:{
type method 
Outer0 #apply(Outer3::S accumulator) 
mut method 
Outer3::S #accumulator() 
read method 
Outer3::S accumulator() 
method 
Outer0 #add(Outer3::Concept::ToS that) 
method 
Outer0 #end() 
method 
Outer1 #stringParser(Library that) }}
Precondition:{<:Outer1, Outer2::Message, Outer2::Concept::ToS, Outer2::Concept::Equals, Outer2::Concept::Classable, Outer2::Concept::Named
type method 
Outer0 #apply(Outer2::S _text, Outer2::Message::Opt cause) 
mut method 
Outer2::S #_text() 
read method 
Outer2::S _text() 
mut method 
Outer2::Message::Opt #cause() 
read method 
Outer2::Message::Opt cause() 
type method 
Outer0 #stringParser(Library that) 
method 
Outer0 #apply(Outer2::Message that) 
method 
Outer2::Bool #bangequal(Outer0 that) 
method 
Outer2::Bool #equalequal(Outer0 that) 
type method 
Outer0 #apply(Outer2::S text) 
type method 
Outer0 #apply(Outer2::S text, Outer2::Message cause) 
method 
Outer0::SConcat #begin() 
SConcat:{
type method 
Outer0 #apply(Outer3::S accumulator) 
mut method 
Outer3::S #accumulator() 
read method 
Outer3::S accumulator() 
method 
Outer0 #add(Outer3::Concept::ToS that) 
method 
Outer0 #end() 
method 
Outer1 #stringParser(Library that) }}
ParseFail:{interface <:Outer1, Outer2::Message, Outer2::Concept::ToS, Outer2::Concept::Equals, Outer2::Concept::Classable, Outer2::Concept::Named}}
Message:{interface <:Outer1::Concept::ToS, Outer1::Concept::Equals, Outer1::Concept::Classable, Outer1::Concept::Named
type method 
Outer1::S kind() 
method 
Outer1::S text() 
method 
Outer0::Opt responseOf() 
read method 
type Outer0 clazz() 
Opt:{
type method 
Outer0 #new(Outer0::TOpt that) 
mut method 
Outer0::TOpt #that() 
read method 
Outer0::TOpt that() 
TOpt:{interface 
method 
Outer2 get() }
TEmpty:{<:Outer1::TOpt
type method 
Outer0 #apply() }
TOf:{<:Outer1::TOpt
type method 
Outer0 #apply(Outer2 that) 
mut method 
Outer2 #that() 
read method 
Outer2 that() }
method 
Outer1 #tilde() 
method 
Outer2::Bool isPresent() 
type method 
Outer0 #apply() 
type method 
Outer0 #apply(Outer1 that) }
EqualMessages:{
type method 
Outer2::Bool #apply(Outer1 that, Outer1 other) }
$:{
type method 
Outer0 #apply() 
type method 
Outer0 #begin() 
method 
Outer0 #end() 
method 
Library #leftleft(Library that) 
type method 
Library messageTrait() }}
Concept:{
ToS:{interface 
read method 
Outer2::S toS() }
Classable:{interface 
read method 
type Any classAny() }
Named:{interface 
type method 
Outer2::S myName() }
Wrapper:{interface 
read method 
Any inner() }
TypeWrapper:{interface 
read method 
type Any inner() }
ReadWrapper:{interface 
read method 
read Any inner() }
MutWrapper:{interface <:Outer1::ReadWrapper
mut method 
mut Any #inner() }
LentWrapper:{interface <:Outer1::ReadWrapper
mut method 
lent Any #inner() }
Equals:{interface 
read method 
Outer2::Bool equals(read Any that) }
Comparable:{interface 
read method 
Outer2::Bool greater(read Any that) }
Boollable:{interface 
read method 
Void #checkTrue() exception Void }
Decorator:{interface 'method Library>>(Library that) exception MetaGuard(specific)
'method Library decorate(Library that) exception MetaGuard I can link metaguard for circularity
}
Contains:{interface 'read method Bool >>(read Elem that)

read method 
Outer2::Bool contains(read Any that) }
Parsable:{interface 'type method capsule Outer0 fromS(S that) exception Guard::Parameter(specific) invalid string
'''type method capsule Outer0 #fromS(S that) exception Guard::Parameter
}
Invariant:{interface 
read method ' can throw error or return false, as more opportune
Outer2::Bool invariant() }
RandomAccess:{interface 'read method read Elem (N that)
'mut method mut Elem #(N that)

read method 
read Any get(Outer2::N that) 
mut method 
mut Any #get(Outer2::N that) }
Sizable:{interface 
read method 
Outer2::N size() 
read method 
Outer2::Bool isEmpty() }
Iterator:{interface 
mut method 
Void #next() exception Void 
read method 
Void #checkEnd() 
read method 
Void #close() }}
S:{<:Outer1::Concept::ToS, Outer1::Concept::Equals, Outer1::Concept::Named
type method 
Outer0 #stringParser(Library that) 
method 
Library binaryRepr() 
method 
Outer0 #plusplus(Outer0 that) 
method 
Outer1::Bool #bangequal(Outer0 that) 
method 
Outer1::Bool #equalequal(Outer0 that) 
method 
Outer0 #apply(Outer1::N start, Outer1::N end) 
method 
Outer0 #apply(Outer1::N that) 
method 
Outer0 #apply(Outer1::N start) 
method 
Outer0 #apply(Outer1::N end) 
method 
Outer1::Bool beginsWith(Outer0 that) 
method 
Outer1::N firstIndexOf(Outer0 that) 
SubstringNotPresent:{
type method 
Outer0 #apply(Outer1 string, Outer1 subString) 
mut method 
Outer1 #string() 
read method 
Outer1 string() 
mut method 
Outer1 #subString() 
read method 
Outer1 subString() }
method 
Outer1::Bool contains(Outer0 that) 
method 
Outer1::Bool isASCIILowerCase(Outer1::N that) 
method 
Outer1::Bool isASCIIUpperCase(Outer1::N that) 
method 
Outer1::N size() 
type method 
Outer0 doubleQuote() 
type method 
Outer0 nl() 
method 
Outer0 replace(Outer0 that, Outer0 into) 
method 
Outer0::SConcat #begin() 
SConcat:{
type method 
Outer0 #apply(Outer1 accumulator) 
mut method 
Outer1 #accumulator() 
read method 
Outer1 accumulator() 
method 
Outer0 #add(Outer2::Concept::ToS that) 
method 
Outer0 #end() 
method 
Outer1 #stringParser(Library that) }}
N:{<:Outer1::Concept::ToS, Outer1::Concept::Equals, Outer1::Concept::Named
type method 
Outer0 fromS(Outer1::Concept::ToS that) 
method 
Library binaryRepr() 
type method 
Outer0 #numberParser(Library that) 
type method 
Any parseError(Outer1::S that) 
method 
Outer0 #plus(Outer0 that) 
method 
Outer0 #less(Outer0 that) 
method 
Outer0 #times(Outer0 that) 
method 
Outer0 #divide(Outer0 that) 
method 
Outer1::Bool #equalequal(Outer0 that) 
method 
Outer1::Bool #left(Outer0 that) 
method 
Outer1::Bool #leftequal(Outer0 that) 
method 
Outer1::Bool #bangequal(Outer0 that) 
method 
Outer1::Bool #right(Outer0 that) 
method 
Outer1::Bool #rightequal(Outer0 that) 
method 
mut Outer0::Iterator vals() 
method 
mut Outer0::Iterator vals(Outer0 upTo) 
Iterator:{
type method 
mut Outer0 #apply(Outer1 start, Outer1 end) 
mut method 
Void start(Outer1 that) 
mut method 
Outer1 #start() 
read method 
Outer1 start() 
mut method 
Outer1 #end() 
read method 
Outer1 end() 
mut method 
Void #next() exception Void 
read method 
Void #checkEnd() 
read method 
Outer1 #inner() 
read method 
Void #close() }
ParseFail:{<:Outer2::Guard::ParseFail, Outer2::Guard, Outer2::Message, Outer2::Concept::ToS, Outer2::Concept::Equals, Outer2::Concept::Classable, Outer2::Concept::Named
type method 
Outer0 #apply(Outer2::S _text, Outer2::Message::Opt cause) 
mut method 
Outer2::S #_text() 
read method 
Outer2::S _text() 
mut method 
Outer2::Message::Opt #cause() 
read method 
Outer2::Message::Opt cause() 
type method 
Outer0 #stringParser(Library that) 
method 
Outer0 #apply(Outer2::Message that) 
method 
Outer2::Bool #bangequal(Outer0 that) 
method 
Outer2::Bool #equalequal(Outer0 that) 
type method 
Outer0 #apply(Outer2::S text) 
type method 
Outer0 #apply(Outer2::S text, Outer2::Message cause) 
method 
Outer0::SConcat #begin() 
SConcat:{
type method 
Outer0 #apply(Outer3::S accumulator) 
mut method 
Outer3::S #accumulator() 
read method 
Outer3::S accumulator() 
method 
Outer0 #add(Outer3::Concept::ToS that) 
method 
Outer0 #end() 
method 
Outer1 #stringParser(Library that) }}}
Bool:{<:Outer1::Concept::ToS, Outer1::Concept::Equals, Outer1::Concept::Named
method 
Void #checkTrue() exception Void 
type method 
Outer0 true() 
type method 
Outer0 false() 
method 
Outer0 #and(Outer0 that) 
method 
Outer0 #or(Outer0 that) 
method 
Outer0 #bang() 
type method 
Outer0 fromS(read Outer1::Concept::ToS that) 
method 
Outer0 #equalequal(Outer0 that) 
method 
Outer0 #bangequal(Outer0 that) 
type method 
Any parseError(Outer1::S that) 
ParseFail:{<:Outer2::Guard::ParseFail, Outer2::Guard, Outer2::Message, Outer2::Concept::ToS, Outer2::Concept::Equals, Outer2::Concept::Classable, Outer2::Concept::Named
type method 
Outer0 #apply(Outer2::S _text, Outer2::Message::Opt cause) 
mut method 
Outer2::S #_text() 
read method 
Outer2::S _text() 
mut method 
Outer2::Message::Opt #cause() 
read method 
Outer2::Message::Opt cause() 
type method 
Outer0 #stringParser(Library that) 
method 
Outer0 #apply(Outer2::Message that) 
method 
Outer1 #bangequal(Outer0 that) 
method 
Outer1 #equalequal(Outer0 that) 
type method 
Outer0 #apply(Outer2::S text) 
type method 
Outer0 #apply(Outer2::S text, Outer2::Message cause) 
method 
Outer0::SConcat #begin() 
SConcat:{
type method 
Outer0 #apply(Outer3::S accumulator) 
mut method 
Outer3::S #accumulator() 
read method 
Outer3::S accumulator() 
method 
Outer0 #add(Outer3::Concept::ToS that) 
method 
Outer0 #end() 
method 
Outer1 #stringParser(Library that) }}}
ExitCode:{
type method 
Library normal() 
type method 
Library failure() }
Alu:{'@plugin
'L42.is/connected/withAlu
}}
type method '@private
Library generateVector_$%$%$%$%$%$%$%$%$%$%26_1__126_1(type Any that, Library lib) (
  Void unused=(
    Library res=lib
    mut Outer0::Varres_$%$%$%$%$%$%$%$%$%$%122_1__138_1 varres=Outer0::Varres_$%$%$%$%$%$%$%$%$%$%122_1__138_1.#apply(inner:res)
    Void unused0=varres.inner(that:Outer0::Abstract::Refactor::RenamePath.#begin().#add(that:Outer0::Abstract::Path.#stringParser(that:{'@stringU
    'VectorStruct
    }), to:Outer0::Abstract::Path.#stringParser(that:{'@stringU
    'Outer0
    })).#end().#leftleft(that:varres.#inner()))
    Void unused1=varres.inner(that:Outer0::Abstract::Refactor::Redirect.#begin().#add(that:Outer0::Abstract::Path.#stringParser(that:{'@stringU
    'Elem
    }), to:that).#end().#leftleft(that:varres.#inner()))
    Void unused2=varres.inner(that:Outer0::Abstract::Refactor::MakePrivatePath.#begin().#add(that:Outer0::Abstract::Path.#stringParser(that:{'@stringU
    'Cell
    })).#end().#leftleft(that:varres.#inner()))
    Void unused3=varres.inner(that:Outer0::Abstract::Refactor::MakePrivatePath.#begin().#add(that:Outer0::Abstract::Path.#stringParser(that:{'@stringU
    'CellNext
    })).#end().#leftleft(that:varres.#inner()))
    Void unused4=varres.inner(that:Outer0::Abstract::Refactor::MakePrivatePath.#begin().#add(that:Outer0::Abstract::Path.#stringParser(that:{'@stringU
    'CellEnd
    })).#end().#leftleft(that:varres.#inner()))
    Void unused5=return varres.#inner()
    catch exception err (
      on Outer0::Abstract::Guard error err
      )
    void
    )
  catch return result (
    on Library result
    )
  error {'@stringU
  'CurlyBlock-Should be unreachable code
  }
  )
type method 
Library vector(type Any of) Outer0.generateVector_$%$%$%$%$%$%$%$%$%$%26_1__126_1(that:of, lib:{
Elem:{}
Kind:' private
{interface 
type method 
Outer1::Elem elem() 
type method 
Outer1::Elem elemRead() }
VectorStruct:{
type method ' size should be computed?
mut Outer0 #apply(mut Outer0::Cell head, Outer2::Abstract::N size) 
mut method ' size should be computed?
Void head(mut Outer0::Cell that) 
mut method ' size should be computed?
mut Outer0::Cell #head() 
read method ' size should be computed?
read Outer0::Cell head() 
mut method ' size should be computed?
Void size(Outer2::Abstract::N that) 
mut method ' size should be computed?
Outer2::Abstract::N #size() 
read method ' size should be computed?
Outer2::Abstract::N size() 
Cell:{interface }
CellNext:{<:Outer1::Cell
type method 
mut Outer0 #apply(Outer2::Kind::elem() val, mut Outer1::Cell next) 
mut method 
Outer2::Kind::elem() #val() 
mut method 
mut Outer1::Cell #next() 
read method 
read Outer1::Cell next() 
read method 
Outer2::Kind::elemRead() val() }
CellEnd:{<:Outer1::Cell
type method 
mut Outer0 #apply() }
read method 
Void reportError(Outer2::Abstract::N that) error Outer2::Abstract::S.#stringParser(that:{'@stringU
'IndexOutOfBound: max is 
}).#begin().#add(that:this.size()).#end().#stringParser(that:{'@stringU
' proposed is 
}).#begin().#add(that:that).#end().#stringParser(that:{'@stringU
'
})
read method 
Void reportUnexpected(Outer2::Abstract::N that) error Outer2::Abstract::S.#stringParser(that:{'@stringU
'Unexpected failure like IndexOutOfBound: max is 
}).#begin().#add(that:this.size()).#end().#stringParser(that:{'@stringU
' proposed is 
}).#begin().#add(that:that).#end().#stringParser(that:{'@stringU
'
})
read method 
Outer1::Kind::elemRead() #apply(Outer2::Abstract::N that) (
  Void unused=(
    Outer2::Abstract::N::#rightequal(that ) cond=that.#rightequal(that:this.size())
    (
      Void unused0=cond.#checkTrue()
      catch exception unused1 (
        on Void void
        )
      this.reportError(that:that)
      )
    )
  Outer0.auxGet(that:that, cell:this.head())
  )
type method 
Outer1::Kind::elemRead() auxGet(Outer2::Abstract::N that, read Outer0::Cell cell) (
  Void unused=(
    Void unused0=(
      Void unused2=(
        read Outer0::CellNext cell2=(
          Void unused3=return cell
          catch return casted1 (
            on read Outer0::CellNext casted1
            
            on read Any exception void
            )
          error {'@stringU
          'CastT-Should be unreachable code
          }
          )
        catch exception unused4 (
          on Void void
          )
        (
          Void unused5=(
            Outer2::Abstract::N::#equalequal(that ) cond=that.#equalequal(that:Outer2::Abstract::N.#numberParser(that:{'@stringU
            '0
            }))
            (
              Void unused6=cond.#checkTrue()
              catch exception unused7 (
                on Void exception void
                )
              void
              )
            )
          void
          )
        )
      read Outer0::CellNext cell1=(
        Void unused8=return cell
        catch return casted0 (
          on read Outer0::CellNext casted0
          
          on read Any exception void
          )
        error {'@stringU
        'CastT-Should be unreachable code
        }
        )
      catch exception unused9 (
        on Void (
          read Outer0::CellNext cell0=(
            Void unused10=return cell
            catch return casted (
              on read Outer0::CellNext casted
              
              on read Any exception void
              )
            error {'@stringU
            'CastT-Should be unreachable code
            }
            )
          catch exception unused11 (
            on Void void
            )
          (
            Void unused12=return Outer0.auxGet(that:that.#less(that:Outer2::Abstract::N.#numberParser(that:{'@stringU
            '1
            })), cell:cell0.next())
            void
            )
          )
        )
      (
        Void unused13=return cell1.val()
        void
        )
      )
    Void unused1=error Outer2::Abstract::S.#stringParser(that:{'@stringU
    'Unreachable
    })
    void
    )
  catch return result (
    on Outer1::Kind::elemRead() result
    )
  error {'@stringU
  'CurlyBlock-Should be unreachable code
  }
  )
mut method 
Void #apply(Outer2::Abstract::N that, Outer1::Kind::elem() val) (
  Void unused=(
    Outer2::Abstract::N::#rightequal(that ) cond=that.#rightequal(that:this.size())
    (
      Void unused0=cond.#checkTrue()
      catch exception unused1 (
        on Void void
        )
      this.reportError(that:that)
      )
    )
  this.head(that:Outer0.auxSet(that:that, val:val, cell:this.#head()))
  )
type method 
mut Outer0::CellNext auxSet(Outer2::Abstract::N that, Outer1::Kind::elem() val, mut Outer0::Cell cell) (
  Void unused=(
    Void unused0=(
      Void unused2=(
        mut Outer0::CellNext cell2=(
          Void unused3=return cell
          catch return casted1 (
            on mut Outer0::CellNext casted1
            
            on mut Any exception void
            )
          error {'@stringU
          'CastT-Should be unreachable code
          }
          )
        catch exception unused4 (
          on Void void
          )
        (
          Void unused5=(
            Outer2::Abstract::N::#equalequal(that ) cond=that.#equalequal(that:Outer2::Abstract::N.#numberParser(that:{'@stringU
            '0
            }))
            (
              Void unused6=cond.#checkTrue()
              catch exception unused7 (
                on Void exception void
                )
              void
              )
            )
          void
          )
        )
      mut Outer0::CellNext cell1=(
        Void unused8=return cell
        catch return casted0 (
          on mut Outer0::CellNext casted0
          
          on mut Any exception void
          )
        error {'@stringU
        'CastT-Should be unreachable code
        }
        )
      catch exception unused9 (
        on Void (
          mut Outer0::CellNext cell0=(
            Void unused10=return cell
            catch return casted (
              on mut Outer0::CellNext casted
              
              on mut Any exception void
              )
            error {'@stringU
            'CastT-Should be unreachable code
            }
            )
          catch exception unused11 (
            on Void void
            )
          (
            Void unused12=return Outer0::CellNext.#apply(val:cell0.val(), next:Outer0.auxSet(that:that.#less(that:Outer2::Abstract::N.#numberParser(that:{'@stringU
            '1
            })), val:val, cell:cell0.#next()))
            void
            )
          )
        )
      (
        Void unused13=return Outer0::CellNext.#apply(val:val, next:cell1.#next())
        void
        )
      )
    Void unused1=error Outer2::Abstract::S.#stringParser(that:{'@stringU
    'Unreachable
    })
    void
    )
  catch return result (
    on mut Outer0::CellNext result
    )
  error {'@stringU
  'CurlyBlock-Should be unreachable code
  }
  )
type method 
mut Outer0 #apply() Outer0.#apply(head:Outer0::CellEnd.#apply(), size:Outer2::Abstract::N.#numberParser(that:{'@stringU
'0
}))
mut method 
mut Outer0 add(Outer1::Kind::elem() that) (
  Void unused=this.size(that:this.size().#plus(that:Outer2::Abstract::N.#numberParser(that:{'@stringU
  '1
  })))
  Void unused0=this.head(that:Outer0.auxAdd(that:that, cell:this.#head()))
  this
  )
type method 
mut Outer0::Cell auxAdd(Outer1::Kind::elem() that, mut Outer0::Cell cell) (
  Void unused=(
    Void unused0=(
      mut Outer0::CellEnd cell1=(
        Void unused2=return cell
        catch return casted0 (
          on mut Outer0::CellEnd casted0
          
          on mut Any exception void
          )
        error {'@stringU
        'CastT-Should be unreachable code
        }
        )
      catch exception unused3 (
        on Void (
          mut Outer0::CellNext cell0=(
            Void unused4=return cell
            catch return casted (
              on mut Outer0::CellNext casted
              
              on mut Any exception void
              )
            error {'@stringU
            'CastT-Should be unreachable code
            }
            )
          catch exception unused5 (
            on Void void
            )
          (
            Void unused6=return Outer0::CellNext.#apply(val:cell0.val(), next:Outer0.auxAdd(that:that, cell:cell0.#next()))
            void
            )
          )
        )
      (
        Void unused7=return Outer0::CellNext.#apply(val:that, next:cell1)
        void
        )
      )
    Void unused1=error Outer2::Abstract::S.#stringParser(that:{'@stringU
    'Unreachable
    })
    void
    )
  catch return result (
    on mut Outer0::Cell result
    )
  error {'@stringU
  'CurlyBlock-Should be unreachable code
  }
  )
type method 
mut Outer0 #begin() Outer0.#apply()
mut method 
mut Outer0 #end() this
mut method 
mut Outer0 #add(Outer1::Kind::elem() that) this.add(that:that)
OptMax:{
type method 
Outer0 #new(Outer0::TOpt that) 
mut method 
Outer0::TOpt #that() 
read method 
Outer0::TOpt that() 
TOpt:{interface 
method 
Outer4::Abstract::N get() }
TEmpty:{<:Outer1::TOpt
type method 
Outer0 #apply() 
method get() error Outer4::Abstract::Guard::Operation.#stringParser(that:{'@stringU
'TEmpty.get() Value not present in Optional
})}
TOf:{<:Outer1::TOpt
type method 
Outer0 #apply(Outer4::Abstract::N that) 
mut method 
Outer4::Abstract::N #that() 
read method 
Outer4::Abstract::N that() 
method get() this.that()}
method 
Outer3::Abstract::N #tilde() this.that().get()
method 
Outer3::Abstract::Bool isPresent() (
  Void unused=(
    Outer0::#tilde() aux=this.#tilde()
    Void unused0=return Outer3::Abstract::Bool.true()
    catch error unused1 (
      on Any return Outer3::Abstract::Bool.false()
      )
    void
    )
  catch return result (
    on Outer3::Abstract::Bool result
    )
  error {'@stringU
  'CurlyBlock-Should be unreachable code
  }
  )
type method 
Outer0 #apply() Outer0.#new(that:Outer0::TEmpty.#apply())
type method 
Outer0 #apply(Outer3::Abstract::N that) Outer0.#new(that:Outer0::TOf.#apply(that:that))}
OptFill:{
type method 
Outer0 #new(Outer0::TOpt that) 
mut method 
Outer0::TOpt #that() 
read method 
Outer0::TOpt that() 
TOpt:{interface 
method 
Outer3::Elem get() }
TEmpty:{<:Outer1::TOpt
type method 
Outer0 #apply() 
method get() error Outer4::Abstract::Guard::Operation.#stringParser(that:{'@stringU
'TEmpty.get() Value not present in Optional
})}
TOf:{<:Outer1::TOpt
type method 
Outer0 #apply(Outer3::Elem that) 
mut method 
Outer3::Elem #that() 
read method 
Outer3::Elem that() 
method get() this.that()}
method 
Outer2::Elem #tilde() this.that().get()
method 
Outer3::Abstract::Bool isPresent() (
  Void unused=(
    Outer0::#tilde() aux=this.#tilde()
    Void unused0=return Outer3::Abstract::Bool.true()
    catch error unused1 (
      on Any return Outer3::Abstract::Bool.false()
      )
    void
    )
  catch return result (
    on Outer3::Abstract::Bool result
    )
  error {'@stringU
  'CurlyBlock-Should be unreachable code
  }
  )
type method 
Outer0 #apply() Outer0.#new(that:Outer0::TEmpty.#apply())
type method 
Outer0 #apply(Outer2::Elem that) Outer0.#new(that:Outer0::TOf.#apply(that:that))}
Iterator:{
type method 
lent Outer0 #apply(read Outer1 that, Outer3::Abstract::N min, Outer3::Abstract::N ok, Outer1::OptMax max, Outer1::OptFill fill) 
mut method 
read Outer1 #that() 
read method 
read Outer1 that() 
mut method 
Void min(Outer3::Abstract::N that) 
mut method 
Outer3::Abstract::N #min() 
read method 
Outer3::Abstract::N min() 
mut method 
Outer3::Abstract::N #ok() 
read method 
Outer3::Abstract::N ok() 
mut method 
Outer1::OptMax #max() 
read method 
Outer1::OptMax max() 
mut method 
Outer1::OptFill #fill() 
read method 
Outer1::OptFill fill() 
mut method 
Void #next() exception Void (
  Void unused=(
    Void unused0=this.min(that:this.min().#plus(that:Outer3::Abstract::N.#numberParser(that:{'@stringU
    '1
    })))
    Void unused1=(
      Outer0::fill() ::isPresent() cond=this.fill().isPresent()
      (
        Void unused5=cond.#checkTrue()
        catch exception unused6 (
          on Void void
          )
        (
          Void unused7=(
            Outer0::max() ::isPresent() ::#bang() cond0=this.max().isPresent().#bang()
            (
              Void unused9=cond0.#checkTrue()
              catch exception unused10 (
                on Void void
                )
              return void
              )
            )
          Void unused8=(
            Outer0::min() ::#rightequal(that ) cond1=this.min().#rightequal(that:this.max().#tilde())
            (
              Void unused11=cond1.#checkTrue()
              catch exception unused12 (
                on Void void
                )
              exception void
              )
            )
          return void
          )
        )
      )
    Void unused2=(
      Outer0::max() ::isPresent() cond2=this.max().isPresent()
      (
        Void unused13=cond2.#checkTrue()
        catch exception unused14 (
          on Void void
          )
        (
          Outer0::min() ::#rightequal(that ) cond3=this.min().#rightequal(that:this.max().#tilde())
          (
            Void unused15=cond3.#checkTrue()
            catch exception unused16 (
              on Void void
              )
            exception void
            )
          )
        )
      )
    Void unused3=(
      Outer0::min() ::#rightequal(that ) cond4=this.min().#rightequal(that:this.that().size())
      (
        Void unused17=cond4.#checkTrue()
        catch exception unused18 (
          on Void void
          )
        exception void
        )
      )
    Void unused4=return void
    void
    )
  catch return result (
    on Void result
    )
  error {'@stringU
  'CurlyBlock-Should be unreachable code
  }
  )
read method 
Void #checkEnd() (
  Outer0::min() ::#left(that ) cond=this.min().#left(that:this.ok())
  (
    Void unused=cond.#checkTrue()
    catch exception unused0 (
      on Void void
      )
    error Outer3::Abstract::S.#stringParser(that:{'@stringU
    'Unexpected termination of iteration, reached 
    }).#begin().#add(that:this.min()).#end().#stringParser(that:{'@stringU
    ' instead of 
    }).#begin().#add(that:this.ok()).#end().#stringParser(that:{'@stringU
    '
    })
    )
  )
read method 
Outer2::Kind::elem() #inner() (
  Void unused=(
    Void unused0=(
      Outer0::fill() ::isPresent() ::#bang() cond=this.fill().isPresent().#bang()
      (
        Void unused3=cond.#checkTrue()
        catch exception unused4 (
          on Void void
          )
        return this.that().#apply(that:this.min())
        )
      )
    Void unused1=(
      Outer0::min() ::#left(that ) cond0=this.min().#left(that:this.that().size())
      (
        Void unused5=cond0.#checkTrue()
        catch exception unused6 (
          on Void void
          )
        return this.that().#apply(that:this.min())
        )
      )
    Void unused2=return this.fill().#tilde()
    void
    )
  catch return result (
    on Outer2::Kind::elem() result
    )
  error {'@stringU
  'CurlyBlock-Should be unreachable code
  }
  )
read method 
Void #close() void}
VarIterator:{
type method 
mut Outer0 #apply(mut Outer1 that, Outer3::Abstract::N min, Outer3::Abstract::N ok, Outer1::OptMax max, Outer1::OptFill fill) 
mut method 
mut Outer1 #that() 
read method 
read Outer1 that() 
mut method 
Void min(Outer3::Abstract::N that) 
mut method 
Outer3::Abstract::N #min() 
read method 
Outer3::Abstract::N min() 
mut method 
Outer3::Abstract::N #ok() 
read method 
Outer3::Abstract::N ok() 
mut method 
Outer1::OptMax #max() 
read method 
Outer1::OptMax max() 
mut method 
Outer1::OptFill #fill() 
read method 
Outer1::OptFill fill() 
mut method 
Void inner(Outer2::Kind::elem() that) this.#that().#apply(that:this.min(), val:that)
mut method 
Void #next() exception Void (
  Void unused=(
    Void unused0=this.min(that:this.min().#plus(that:Outer3::Abstract::N.#numberParser(that:{'@stringU
    '1
    })))
    Void unused1=(
      Outer0::fill() ::isPresent() cond=this.fill().isPresent()
      (
        Void unused5=cond.#checkTrue()
        catch exception unused6 (
          on Void void
          )
        (
          Void unused7=(
            Outer0::max() ::isPresent() ::#bang() cond0=this.max().isPresent().#bang()
            (
              Void unused9=cond0.#checkTrue()
              catch exception unused10 (
                on Void void
                )
              return void
              )
            )
          Void unused8=(
            Outer0::min() ::#rightequal(that ) cond1=this.min().#rightequal(that:this.max().#tilde())
            (
              Void unused11=cond1.#checkTrue()
              catch exception unused12 (
                on Void void
                )
              exception void
              )
            )
          return void
          )
        )
      )
    Void unused2=(
      Outer0::max() ::isPresent() cond2=this.max().isPresent()
      (
        Void unused13=cond2.#checkTrue()
        catch exception unused14 (
          on Void void
          )
        (
          Outer0::min() ::#rightequal(that ) cond3=this.min().#rightequal(that:this.max().#tilde())
          (
            Void unused15=cond3.#checkTrue()
            catch exception unused16 (
              on Void void
              )
            exception void
            )
          )
        )
      )
    Void unused3=(
      Outer0::min() ::#rightequal(that ) cond4=this.min().#rightequal(that:this.that().size())
      (
        Void unused17=cond4.#checkTrue()
        catch exception unused18 (
          on Void void
          )
        exception void
        )
      )
    Void unused4=return void
    void
    )
  catch return result (
    on Void result
    )
  error {'@stringU
  'CurlyBlock-Should be unreachable code
  }
  )
read method 
Void #checkEnd() (
  Outer0::min() ::#left(that ) cond=this.min().#left(that:this.ok())
  (
    Void unused=cond.#checkTrue()
    catch exception unused0 (
      on Void void
      )
    error Outer3::Abstract::S.#stringParser(that:{'@stringU
    'Unexpected termination of iteration, reached 
    }).#begin().#add(that:this.min()).#end().#stringParser(that:{'@stringU
    ' instead of 
    }).#begin().#add(that:this.ok()).#end().#stringParser(that:{'@stringU
    '
    })
    )
  )
read method 
Outer2::Kind::elem() #inner() (
  Void unused=(
    Void unused0=(
      Outer0::fill() ::isPresent() ::#bang() cond=this.fill().isPresent().#bang()
      (
        Void unused3=cond.#checkTrue()
        catch exception unused4 (
          on Void void
          )
        return this.that().#apply(that:this.min())
        )
      )
    Void unused1=(
      Outer0::min() ::#left(that ) cond0=this.min().#left(that:this.that().size())
      (
        Void unused5=cond0.#checkTrue()
        catch exception unused6 (
          on Void void
          )
        return this.that().#apply(that:this.min())
        )
      )
    Void unused2=return this.fill().#tilde()
    void
    )
  catch return result (
    on Outer2::Kind::elem() result
    )
  error {'@stringU
  'CurlyBlock-Should be unreachable code
  }
  )
read method 
Void #close() void}
read method 
lent Outer0::Iterator vals(Outer2::Abstract::N min, Outer2::Abstract::N ok, Outer2::Abstract::N max, Outer1::Kind::elem() fill) Outer0::Iterator.#apply(that:this, min:min.#less(that:Outer2::Abstract::N.#numberParser(that:{'@stringU
'1
})), ok:ok, max:Outer0::OptMax.#apply(that:max), fill:Outer0::OptFill.#apply(that:fill))
read method 
lent Outer0::Iterator vals(Outer2::Abstract::N min, Outer2::Abstract::N ok, Outer2::Abstract::N max) Outer0::Iterator.#apply(that:this, min:min.#less(that:Outer2::Abstract::N.#numberParser(that:{'@stringU
'1
})), ok:ok, max:Outer0::OptMax.#apply(that:max), fill:Outer0::OptFill.#apply())
read method 
lent Outer0::Iterator vals(Outer2::Abstract::N min, Outer2::Abstract::N ok, Outer1::Kind::elem() fill) Outer0::Iterator.#apply(that:this, min:min.#less(that:Outer2::Abstract::N.#numberParser(that:{'@stringU
'1
})), ok:ok, max:Outer0::OptMax.#apply(), fill:Outer0::OptFill.#apply(that:fill))
read method 
lent Outer0::Iterator vals(Outer2::Abstract::N min, Outer2::Abstract::N ok) Outer0::Iterator.#apply(that:this, min:min.#less(that:Outer2::Abstract::N.#numberParser(that:{'@stringU
'1
})), ok:ok, max:Outer0::OptMax.#apply(), fill:Outer0::OptFill.#apply())
read method 
lent Outer0::Iterator vals(Outer2::Abstract::N min, Outer2::Abstract::N max, Outer1::Kind::elem() fill) Outer0::Iterator.#apply(that:this, min:min.#less(that:Outer2::Abstract::N.#numberParser(that:{'@stringU
'1
})), ok:max, max:Outer0::OptMax.#apply(that:max), fill:Outer0::OptFill.#apply(that:fill))
read method 
lent Outer0::Iterator vals(Outer2::Abstract::N min, Outer2::Abstract::N max) Outer0::Iterator.#apply(that:this, min:min.#less(that:Outer2::Abstract::N.#numberParser(that:{'@stringU
'1
})), ok:max, max:Outer0::OptMax.#apply(that:max), fill:Outer0::OptFill.#apply())
read method 
lent Outer0::Iterator vals(Outer2::Abstract::N min, Outer1::Kind::elem() fill) Outer0::Iterator.#apply(that:this, min:min.#less(that:Outer2::Abstract::N.#numberParser(that:{'@stringU
'1
})), ok:this.size(), max:Outer0::OptMax.#apply(), fill:Outer0::OptFill.#apply(that:fill))
read method 
lent Outer0::Iterator vals(Outer2::Abstract::N min) Outer0::Iterator.#apply(that:this, min:min.#less(that:Outer2::Abstract::N.#numberParser(that:{'@stringU
'1
})), ok:this.size(), max:Outer0::OptMax.#apply(), fill:Outer0::OptFill.#apply())
read method 
lent Outer0::Iterator vals(Outer2::Abstract::N ok, Outer2::Abstract::N max, Outer1::Kind::elem() fill) Outer0::Iterator.#apply(that:this, min:Outer2::Abstract::N.#numberParser(that:{'@stringU
'-1
}), ok:ok, max:Outer0::OptMax.#apply(that:max), fill:Outer0::OptFill.#apply(that:fill))
read method 
lent Outer0::Iterator vals(Outer2::Abstract::N ok, Outer2::Abstract::N max) Outer0::Iterator.#apply(that:this, min:Outer2::Abstract::N.#numberParser(that:{'@stringU
'-1
}), ok:ok, max:Outer0::OptMax.#apply(that:max), fill:Outer0::OptFill.#apply())
read method 
lent Outer0::Iterator vals(Outer2::Abstract::N ok, Outer1::Kind::elem() fill) Outer0::Iterator.#apply(that:this, min:Outer2::Abstract::N.#numberParser(that:{'@stringU
'-1
}), ok:ok, max:Outer0::OptMax.#apply(), fill:Outer0::OptFill.#apply(that:fill))
read method 
lent Outer0::Iterator vals(Outer2::Abstract::N ok) Outer0::Iterator.#apply(that:this, min:Outer2::Abstract::N.#numberParser(that:{'@stringU
'-1
}), ok:ok, max:Outer0::OptMax.#apply(), fill:Outer0::OptFill.#apply())
read method 
lent Outer0::Iterator vals(Outer2::Abstract::N max, Outer1::Kind::elem() fill) Outer0::Iterator.#apply(that:this, min:Outer2::Abstract::N.#numberParser(that:{'@stringU
'-1
}), ok:max, max:Outer0::OptMax.#apply(that:max), fill:Outer0::OptFill.#apply(that:fill))
read method 
lent Outer0::Iterator vals(Outer2::Abstract::N max) Outer0::Iterator.#apply(that:this, min:Outer2::Abstract::N.#numberParser(that:{'@stringU
'-1
}), ok:max, max:Outer0::OptMax.#apply(that:max), fill:Outer0::OptFill.#apply())
read method 
lent Outer0::Iterator vals(Outer1::Kind::elem() fill) Outer0::Iterator.#apply(that:this, min:Outer2::Abstract::N.#numberParser(that:{'@stringU
'-1
}), ok:this.size(), max:Outer0::OptMax.#apply(), fill:Outer0::OptFill.#apply(that:fill))
read method 
lent Outer0::Iterator vals() Outer0::Iterator.#apply(that:this, min:Outer2::Abstract::N.#numberParser(that:{'@stringU
'-1
}), ok:this.size(), max:Outer0::OptMax.#apply(), fill:Outer0::OptFill.#apply())
mut method 
mut Outer0::VarIterator vars(Outer2::Abstract::N min, Outer2::Abstract::N ok, Outer2::Abstract::N max, Outer1::Kind::elem() fill) Outer0::VarIterator.#apply(that:this, min:min.#less(that:Outer2::Abstract::N.#numberParser(that:{'@stringU
'1
})), ok:ok, max:Outer0::OptMax.#apply(that:max), fill:Outer0::OptFill.#apply(that:fill))
mut method 
mut Outer0::VarIterator vars(Outer2::Abstract::N min, Outer2::Abstract::N ok, Outer2::Abstract::N max) Outer0::VarIterator.#apply(that:this, min:min.#less(that:Outer2::Abstract::N.#numberParser(that:{'@stringU
'1
})), ok:ok, max:Outer0::OptMax.#apply(that:max), fill:Outer0::OptFill.#apply())
mut method 
mut Outer0::VarIterator vars(Outer2::Abstract::N min, Outer2::Abstract::N ok, Outer1::Kind::elem() fill) Outer0::VarIterator.#apply(that:this, min:min.#less(that:Outer2::Abstract::N.#numberParser(that:{'@stringU
'1
})), ok:ok, max:Outer0::OptMax.#apply(), fill:Outer0::OptFill.#apply(that:fill))
mut method 
mut Outer0::VarIterator vars(Outer2::Abstract::N min, Outer2::Abstract::N ok) Outer0::VarIterator.#apply(that:this, min:min.#less(that:Outer2::Abstract::N.#numberParser(that:{'@stringU
'1
})), ok:ok, max:Outer0::OptMax.#apply(), fill:Outer0::OptFill.#apply())
mut method 
mut Outer0::VarIterator vars(Outer2::Abstract::N min, Outer2::Abstract::N max, Outer1::Kind::elem() fill) Outer0::VarIterator.#apply(that:this, min:min.#less(that:Outer2::Abstract::N.#numberParser(that:{'@stringU
'1
})), ok:max, max:Outer0::OptMax.#apply(that:max), fill:Outer0::OptFill.#apply(that:fill))
mut method 
mut Outer0::VarIterator vars(Outer2::Abstract::N min, Outer2::Abstract::N max) Outer0::VarIterator.#apply(that:this, min:min.#less(that:Outer2::Abstract::N.#numberParser(that:{'@stringU
'1
})), ok:max, max:Outer0::OptMax.#apply(that:max), fill:Outer0::OptFill.#apply())
mut method 
mut Outer0::VarIterator vars(Outer2::Abstract::N min, Outer1::Kind::elem() fill) Outer0::VarIterator.#apply(that:this, min:min.#less(that:Outer2::Abstract::N.#numberParser(that:{'@stringU
'1
})), ok:this.size(), max:Outer0::OptMax.#apply(), fill:Outer0::OptFill.#apply(that:fill))
mut method 
mut Outer0::VarIterator vars(Outer2::Abstract::N min) Outer0::VarIterator.#apply(that:this, min:min.#less(that:Outer2::Abstract::N.#numberParser(that:{'@stringU
'1
})), ok:this.size(), max:Outer0::OptMax.#apply(), fill:Outer0::OptFill.#apply())
mut method 
mut Outer0::VarIterator vars(Outer2::Abstract::N ok, Outer2::Abstract::N max, Outer1::Kind::elem() fill) Outer0::VarIterator.#apply(that:this, min:Outer2::Abstract::N.#numberParser(that:{'@stringU
'-1
}), ok:ok, max:Outer0::OptMax.#apply(that:max), fill:Outer0::OptFill.#apply(that:fill))
mut method 
mut Outer0::VarIterator vars(Outer2::Abstract::N ok, Outer2::Abstract::N max) Outer0::VarIterator.#apply(that:this, min:Outer2::Abstract::N.#numberParser(that:{'@stringU
'-1
}), ok:ok, max:Outer0::OptMax.#apply(that:max), fill:Outer0::OptFill.#apply())
mut method 
mut Outer0::VarIterator vars(Outer2::Abstract::N ok, Outer1::Kind::elem() fill) Outer0::VarIterator.#apply(that:this, min:Outer2::Abstract::N.#numberParser(that:{'@stringU
'-1
}), ok:ok, max:Outer0::OptMax.#apply(), fill:Outer0::OptFill.#apply(that:fill))
mut method 
mut Outer0::VarIterator vars(Outer2::Abstract::N ok) Outer0::VarIterator.#apply(that:this, min:Outer2::Abstract::N.#numberParser(that:{'@stringU
'-1
}), ok:ok, max:Outer0::OptMax.#apply(), fill:Outer0::OptFill.#apply())
mut method 
mut Outer0::VarIterator vars(Outer2::Abstract::N max, Outer1::Kind::elem() fill) Outer0::VarIterator.#apply(that:this, min:Outer2::Abstract::N.#numberParser(that:{'@stringU
'-1
}), ok:max, max:Outer0::OptMax.#apply(that:max), fill:Outer0::OptFill.#apply(that:fill))
mut method 
mut Outer0::VarIterator vars(Outer2::Abstract::N max) Outer0::VarIterator.#apply(that:this, min:Outer2::Abstract::N.#numberParser(that:{'@stringU
'-1
}), ok:max, max:Outer0::OptMax.#apply(that:max), fill:Outer0::OptFill.#apply())
mut method 
mut Outer0::VarIterator vars(Outer1::Kind::elem() fill) Outer0::VarIterator.#apply(that:this, min:Outer2::Abstract::N.#numberParser(that:{'@stringU
'-1
}), ok:this.size(), max:Outer0::OptMax.#apply(), fill:Outer0::OptFill.#apply(that:fill))
mut method 
mut Outer0::VarIterator vars() Outer0::VarIterator.#apply(that:this, min:Outer2::Abstract::N.#numberParser(that:{'@stringU
'-1
}), ok:this.size(), max:Outer0::OptMax.#apply(), fill:Outer0::OptFill.#apply())}})
Varres_$%$%$%$%$%$%$%$%$%$%122_1__138_1:'@private
{
type method 
mut Outer0 #apply(Library inner) 
mut method 
Void inner(Library that) 
mut method 
Library #inner() 
read method 
Library inner() }}