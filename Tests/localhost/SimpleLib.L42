{
class method 
Void printHelloWorld() This.Debug.#apply(that:This.S.#stringParser(that:{//@stringU
//Hello World 
}).#plusplus(that:This.N.#numberParser(that:{//@stringU
//42
})))
%privateImpl:{
ExitCode:{
class method 
Library normal() {//@exitStatus
//0
}
class method 
Library failure() {//@exitStatus
//42000
}}
Alu:{//@plugin
//L42.is/connected/withAlu

class method //@private
This _private20() }
IntrospectionPlugin:{//@plugin
//L42.is/connected/withItself

class method 
Library sumLib(Library l1, Library l2) using This check sumLib(l1:l1, l2:l2) error {
class method 
This sumLib() }
class method 
Library adaptLib(Library l1, Library l2) using This check adaptLib(l1:l1, l2:l2) error {
class method 
This adaptLib() }
class method 
Library nameToAdapter(Library that) using This check nameToAdapter(that:that) error {
class method 
This nameToAdapter() }
class method 
Library typeNameToAdapter(class Any that) using This check typeNameToAdapter(that:that) error {
class method 
This typeNameToAdapter() }
class method 
Library getFreshName(Library that) using This check getFreshName(that:that) error {
class method 
This getFreshName() }
class method 
Library adapter(class Any that, Outer2.S name) (
  Void unused=(
    This.typeNameToAdapter(that ) name1=This.typeNameToAdapter(that:that)
    This.nameToAdapter(that ) name2=This.nameToAdapter(that:name.binaryRepr())
    Void unused0=return This.adaptLib(l1:name1, l2:name2)
    void
    )
  catch return result (
    on Library result
    )
  error {//@stringU
  //CurlyBlock-Should be unreachable code
  }
  )
class method 
Library adapter(Outer2.S nameDest, Outer2.S nameSrc) (
  Void unused=(
    This.nameToAdapter(that ) name1=This.nameToAdapter(that:nameDest.binaryRepr())
    This.nameToAdapter(that ) name2=This.nameToAdapter(that:nameSrc.binaryRepr())
    Void unused0=return This.adaptLib(l1:name1, l2:name2)
    void
    )
  catch return result (
    on Library result
    )
  error {//@stringU
  //CurlyBlock-Should be unreachable code
  }
  )
class method //@private
This _private23() }
Collections:{
ListCode:{
class method 
Library #apply() {// generic linked list class, elements of class Elem

Varres:{
class method 
mut This #apply(Outer1^inner//@consistent
) 
mut method //@consistent
Void inner(Outer1 that) 
mut method //@consistent
Outer1 #inner() 
read method //@consistent
Outer1 inner() }
Varres0:{
class method 
mut This #apply(Outer1.#apply() ^inner//@consistent
) 
mut method //@consistent
Void inner(Outer1.#apply() that) 
mut method //@consistent
Outer1.#apply() #inner() }
class method 
This _new(This.Cell^head//@consistent
) 
mut method //@consistent
This.Cell #head() 
read method //@consistent
This.Cell head() 
class method 
This #apply() This._new(head:This.CellEnd.#apply())
method 
This4.Bool isEmpty() (
  Void unused=(
    Void unused0=(
      This.head() x=this.head()
      (
        This.CellEnd x0=(
          Void unused1=return x
          catch return casted (
            on This.CellEnd casted
            
            on Any exception void
            )
          error {//@stringU
          //CastT-Should be unreachable code
          }
          )
        catch exception unused2 (
          on Void return This4.Bool.false()
          )
        (
          Void unused3=return This4.Bool.true()
          void
          )
        )
      )
    void
    )
  catch return result (
    on This4.Bool result
    )
  error {//@stringU
  //CurlyBlock-Should be unreachable code
  }
  )
method 
This.Elem top() this.head().#inner()
method 
mut This.Iterator vals() this.head().vals(terminate:This4.Bool.true())
method 
mut This.Iterator valsCut() this.head().vals(terminate:This4.Bool.false())
method 
This pop() (
  Void unused=(
    Void unused0=return This._new(head:this.head().#next())
    catch exception unused1 (
      on Void error This4.S.#stringParser(that:{//@stringU
      //PopOnEmpyList
      })
      )
    void
    )
  catch return result (
    on This result
    )
  error {//@stringU
  //CurlyBlock-Should be unreachable code
  }
  )
method 
This #plusplus(This that) (
  Void unused=(
    This res=this
    mut This.Varres varres=This.Varres.#apply(inner:res)
    Void unused0=(
      This.vals() e=that.vals()
      (
        Void unused2=(
          Void unused3=(
            Void unused4=loop (
              Void unused5=e.#next()
              catch exception unused6 (
                on Void (
                  Void unused7=(
                    Void unused8=e.#checkEnd()
                    catch exception unused9 (
                      on Void void
                      )
                    void
                    )
                  exception void
                  )
                )
              varres.inner(that:varres.#inner().#add(that:e.#inner()))
              )
            catch exception unused10 (
              on Void void
              )
            void
            )
          catch exception propagated (
            on Any (
              Void unused11=e.#close()
              exception propagated
              )
            )
          void
          )
        catch return propagated0 (
          on This (
            Void unused12=e.#close()
            return propagated0
            )
          )
        e.#close()
        )
      )
    Void unused1=return varres.#inner()
    void
    )
  catch return result (
    on This result
    )
  error {//@stringU
  //CurlyBlock-Should be unreachable code
  }
  )
class method 
This #begin() This.#apply()
method 
This #add(This.Elem that) This._new(head:This.CellNext.#apply(elem:that, nextCell:this.head()))
method 
This #end() (
  This.#apply() res=This.#apply()
  mut This.Varres0 varres=This.Varres0.#apply(inner:res)
  Void unused=(
    This.vals() elem=this.vals()
    (
      Void unused0=(
        Void unused1=(
          Void unused2=loop (
            Void unused3=elem.#next()
            catch exception unused4 (
              on Void (
                Void unused5=(
                  Void unused6=elem.#checkEnd()
                  catch exception unused7 (
                    on Void void
                    )
                  void
                  )
                exception void
                )
              )
            varres.inner(that:varres.#inner().#add(that:elem.#inner()))
            )
          catch exception unused8 (
            on Void void
            )
          void
          )
        catch exception propagated (
          on Any (
            Void unused9=elem.#close()
            exception propagated
            )
          )
        void
        )
      catch return propagated0 (
        on Any (
          Void unused10=elem.#close()
          return propagated0
          )
        )
      elem.#close()
      )
    )
  varres.#inner()
  )
Elem:{}
Cell:{interface 
method 
mut Outer1.Iterator vals(This5.Bool terminate) 
method 
This #next() exception Void 
method 
Outer1.Elem #inner() 
method 
Void #checkEnd() }
CellEnd:{<:Outer1.Cell
class method 
This #apply() 
method vals(terminate ) Outer1.Iterator.#apply(that:this, terminate:terminate)
method #next() exception void
method #inner() error This5.S.#stringParser(that:{//@stringU
//InnerOnCellEnd, should not happen
})
method #checkEnd() void}
CellNext:{<:Outer1.Cell
class method 
This #apply(Outer1.Elem^elem//@consistent
, Outer1.Cell^nextCell//@consistent
) 
mut method //@consistent
Outer1.Elem #elem() 
read method //@consistent
Outer1.Elem elem() 
mut method //@consistent
Outer1.Cell #nextCell() 
read method //@consistent
Outer1.Cell nextCell() 
method vals(terminate ) (
  Void unused=(
    This.#apply(elem nextCell ) startPoint=This.#apply(elem:this.elem(), nextCell:this)
    Void unused0=return Outer1.Iterator.#apply(that:startPoint, terminate:terminate)
    void
    )
  catch return result (
    on This.vals(terminate ) result
    )
  error {//@stringU
  //CurlyBlock-Should be unreachable code
  }
  )
method #next() this.nextCell()
method #inner() this.elem()
method #checkEnd() (
  This.#checkEnd() .this.nextCell() cell=this.nextCell()
  (
    This cell0=(
      Void unused=return cell
      catch return casted (
        on This casted
        
        on Any exception void
        )
      error {//@stringU
      //CastT-Should be unreachable code
      }
      )
    catch exception unused0 (
      on Void void
      )
    (
      Void unused1=error This5.S.#stringParser(that:{//@stringU
      //IterationNotComplete,\u000a  use valsCut() to allows incomplete iterations\u000a
      })
      void
      )
    )
  )}
Iterator:{
class method 
mut This #apply(Outer1.Cell^that//@consistent
, This5.Bool^terminate//@consistent
) 
mut method //@consistent
Void that(Outer1.Cell that) 
mut method //@consistent
Outer1.Cell #that() 
read method //@consistent
Outer1.Cell that() 
mut method //@consistent
This5.Bool #terminate() 
read method //@consistent
This5.Bool terminate() 
mut method 
Void #next() exception Void (
  Void unused=(
    This.that() .#next() x=this.that().#next()
    Void unused0=(
      Outer1.CellEnd x0=(
        Void unused2=return x
        catch return casted (
          on Outer1.CellEnd casted
          
          on Any exception void
          )
        error {//@stringU
        //CastT-Should be unreachable code
        }
        )
      catch exception unused3 (
        on Void void
        )
      (
        Void unused4=exception void
        void
        )
      )
    Void unused1=return this.that(that:x)
    void
    )
  catch return result (
    on Void result
    )
  error {//@stringU
  //CurlyBlock-Should be unreachable code
  }
  )
read method 
Void #checkEnd() (
  This.terminate() cond=this.terminate()
  (
    Void unused=cond.#checkTrue()
    catch exception unused0 (
      on Void void
      )
    this.that().#checkEnd()
    )
  )
read method 
Outer1.Elem #inner() this.that().#inner()
read method 
Void #close() void}}
class method //@private
This _private24() }
class method 
Library list(class Any that) (
  Void unused=(
    Outer1.IntrospectionPlugin.typeNameToAdapter(that ) map=Outer1.IntrospectionPlugin.typeNameToAdapter(that:that)
    Outer1.IntrospectionPlugin.nameToAdapter(that ) tRen=Outer1.IntrospectionPlugin.nameToAdapter(that:Outer2.S.#stringParser(that:{//@stringU
    //Elem
    }).binaryRepr())
    Void unused0=return this.list(adapter:Outer1.IntrospectionPlugin.adaptLib(l1:map, l2:tRen))
    void
    )
  catch return result (
    on Library result
    )
  error {//@stringU
  //CurlyBlock-Should be unreachable code
  }
  )
class method 
Library list(Library adapter) Outer1.IntrospectionPlugin.adaptLib(l1:This.ListCode.#apply(), l2:adapter)
class method //@private
This _private25() }
Name:{
class method //external is "pointing out"
//internal is " A.B.C"
//not external and not internal is a method name
This #apply(Outer2.Bool^isExternal//@consistent
, Library^adapter//@consistent
) 
mut method //@consistent
Outer2.Bool #isExternal() 
read method //@consistent
Outer2.Bool isExternal() 
mut method //@consistent
Library #adapter() 
read method //@consistent
Library adapter() 
class method 
This #stringParser(Library that) This.#apply(isExternal:Outer2.Bool.false(), adapter:using Outer1.IntrospectionPlugin check nameToAdapter(that:that) error {
class method 
This nameToAdapter() })
class method 
This #apply(class Any that) This.#apply(isExternal:Outer2.Bool.true(), adapter:using Outer1.IntrospectionPlugin check typeNameToAdapter(that:that) error {
class method 
This typeNameToAdapter() })
method 
Outer2.Bool isInternalPath() (
  Void unused=(
    Outer1.Introspection.#apply(that node ) .methods() ms=Outer1.Introspection.#apply(that:this.adapter(), node:Outer2.S.#stringParser(that:{//@stringU
    //%o_0%
    })).methods()
    Void unused0=return ms.isEmpty()
    void
    )
  catch return result (
    on Outer2.Bool result
    )
  error {//@stringU
  //CurlyBlock-Should be unreachable code
  }
  )
method 
Outer2.Bool #equalequal(Any that) (
  Void unused=(
    Void unused0=(
      This that0=(
        Void unused2=return that
        catch return casted (
          on This casted
          
          on Any exception void
          )
        error {//@stringU
        //CastT-Should be unreachable code
        }
        )
      catch exception unused3 (
        on Void void
        )
      (
        Void unused4=return this.innerEquals(that:that0)
        void
        )
      )
    Void unused1=return Outer2.Bool.false()
    void
    )
  catch return result (
    on Outer2.Bool result
    )
  error {//@stringU
  //CurlyBlock-Should be unreachable code
  }
  )
method 
Outer2.Bool innerEquals(This that) Outer1.Introspection.#apply(that:this.adapter()).get().#equalequal(that:Outer1.Introspection.#apply(that:that.adapter()).get())}
Introspection:{
VarnNum:{
class method 
mut This #apply(Outer3.N^inner//@consistent
) 
mut method //@consistent
Void inner(Outer3.N that) 
mut method //@consistent
Outer3.N #inner() 
read method //@consistent
Outer3.N inner() }
Varns:{
class method 
mut This #apply(Outer1.Names^inner//@consistent
) 
mut method //@consistent
Void inner(Outer1.Names that) 
mut method //@consistent
Outer1.Names #inner() 
read method //@consistent
Outer1.Names inner() }
VarmNum:{
class method 
mut This #apply(Outer3.N^inner//@consistent
) 
mut method //@consistent
Void inner(Outer3.N that) 
mut method //@consistent
Outer3.N #inner() 
read method //@consistent
Outer3.N inner() }
Varms:{
class method 
mut This #apply(Outer1.Methods^inner//@consistent
) 
mut method //@consistent
Void inner(Outer1.Methods that) 
mut method //@consistent
Outer1.Methods #inner() 
read method //@consistent
Outer1.Methods inner() }
class method 
This #apply(Library^that//@consistent
, Outer2.S^node//@consistent
) 
mut method //@consistent
Library #that() 
read method //@consistent
Library that() 
mut method //@consistent
Outer2.S #node() 
read method //@consistent
Outer2.S node() 
class method 
This #apply(Library that) This.#apply(that:that, node:Outer2.S.#stringParser(that:{//@stringU
//This
}))
method 
Outer2.S get() Outer2.S.#stringParser(that:using Outer1.IntrospectionPlugin check get(that:this.that(), node:this.node().binaryRepr()) error {
class method 
This getThatNode() })
method 
Library getIfExists(Outer2.N interfaceNum) exception Void using Outer1.IntrospectionPlugin check getOrElse(that:this.that(), interfaceNum:interfaceNum.binaryRepr(), node:this.node().binaryRepr()) exception void
method 
This.Method get(Outer2.N methodNum) exception Void (
  Void unused=(
    Library name=using Outer1.IntrospectionPlugin check getNameOrElse(that:this.that(), methodNum:methodNum.binaryRepr(), node:this.node().binaryRepr()) exception void
    Void unused0=return This.Method.#apply(myClass:this, num:methodNum, name:Outer2.S.#stringParser(that:name))
    void
    )
  catch return result (
    on This.Method result
    )
  error {//@stringU
  //CurlyBlock-Should be unreachable code
  }
  )
method 
Outer1.Name get(Outer2.N nestedClassNum) exception Void (
  Void unused=(
    Library name=using Outer1.IntrospectionPlugin check getNameOrElse(that:this.that(), nestedClassNum:nestedClassNum.binaryRepr(), node:this.node().binaryRepr()) exception void
    Void unused0=return Outer1.Name.#stringParser(that:name)
    void
    )
  catch return result (
    on Outer1.Name result
    )
  error {//@stringU
  //CurlyBlock-Should be unreachable code
  }
  )
Method:{
VarpNum:{
class method 
mut This #apply(This4.N.#numberParser(that ) ^inner//@consistent
) 
mut method //@consistent
Void inner(This4.N.#numberParser(that ) that) 
mut method //@consistent
This4.N.#numberParser(that ) #inner() }
Varps:{
class method 
mut This #apply(Outer2.Parameters.#begin() .#end() ^inner//@consistent
) 
mut method //@consistent
Void inner(Outer2.Parameters.#begin() .#end() that) 
mut method //@consistent
Outer2.Parameters.#begin() .#end() #inner() }
class method 
This #apply(Outer1^myClass//@consistent
, Outer3.N^num//@consistent
, Outer3.S^name//@consistent
) 
mut method //@consistent
Outer1 #myClass() 
read method //@consistent
Outer1 myClass() 
mut method //@consistent
Outer3.N #num() 
read method //@consistent
Outer3.N num() 
mut method //@consistent
Outer3.S #name() 
read method //@consistent
Outer3.S name() 
method 
Outer3.S get() Outer3.S.#stringParser(that:using Outer2.IntrospectionPlugin check getOrElse(that:this.myClass().that(), methodNum:this.num().binaryRepr(), node:this.myClass().node().binaryRepr()) error {
class method 
This invalidMethodNumber() })
method 
Outer3.S getMdf() Outer3.S.#stringParser(that:using Outer2.IntrospectionPlugin check getMdfOrElse(that:this.myClass().that(), methodNum:this.num().binaryRepr(), node:this.myClass().node().binaryRepr()) error {
class method 
This invalidMethodNumber() })
method 
Outer2.Name returnClass() Outer2.Name.#apply(isExternal:Outer3.Bool.true(), adapter:using Outer2.IntrospectionPlugin check getTypePathOrElse(that:this.myClass().that(), methodNum:this.num().binaryRepr(), node:this.myClass().node().binaryRepr()) error {
class method 
This invalidMethodNumber() })
method 
Outer2.Name getName() Outer2.Name.#stringParser(//get name? unuseful!
that:using Outer2.IntrospectionPlugin check getNameOrElse(that:this.myClass().that(), methodNum:this.num().binaryRepr(), node:this.myClass().node().binaryRepr()) error {
class method 
This invalidMethodNumber() })
method 
Outer3.Bool isAbstract() (
  Void unused=(
    Void unused0=using Outer2.IntrospectionPlugin check ifIsAbstractDo(that:this.myClass().that(), methodNum:this.num().binaryRepr(), node:this.myClass().node().binaryRepr()) return Outer3.Bool.true()
    Void unused1=return Outer3.Bool.false()
    void
    )
  catch return result (
    on Outer3.Bool result
    )
  error {//@stringU
  //CurlyBlock-Should be unreachable code
  }
  )
method 
Outer1.Parameter get(Outer3.N parameterNum) exception Void (
  Void unused=(
    Library name=using Outer2.IntrospectionPlugin check getNameOrElse(that:this.myClass().that(), methodNum:this.num().binaryRepr(), parameterNum:parameterNum.binaryRepr(), node:this.myClass().node().binaryRepr()) exception void
    Void unused0=return Outer1.Parameter.#apply(myMethod:this, num:parameterNum, name:Outer3.S.#stringParser(that:name))
    void
    )
  catch return result (
    on Outer1.Parameter result
    )
  error {//@stringU
  //CurlyBlock-Should be unreachable code
  }
  )
method 
Outer1.Parameters parameters() (
  Void unused=(
    Outer1.Parameters.#begin() .#end() ps=Outer1.Parameters.#begin().#end()
    Outer3.N.#numberParser(that ) pNum=Outer3.N.#numberParser(that:{//@stringU
    //0
    })
    mut This.Varps varps=This.Varps.#apply(inner:ps)
    mut This.VarpNum varpNum=This.VarpNum.#apply(inner:pNum)
    Void unused0=(
      Void unused2=loop (
        Void unused3=Outer3.Bool.true().#checkTrue()
        (
          Void unused4=varps.inner(that:varps.#inner().#add(that:this.get(parameterNum:varpNum.#inner())))
          varpNum.inner(that:varpNum.#inner().#plus(that:Outer3.N.#numberParser(that:{//@stringU
          //1
          })))
          )
        )
      catch exception unused5 (
        on Void void
        )
      void
      )
    Void unused1=return varps.#inner()
    void
    )
  catch return result (
    on Outer1.Parameters result
    )
  error {//@stringU
  //CurlyBlock-Should be unreachable code
  }
  )}
Parameter:{
class method 
This #apply(Outer1.Method^myMethod//@consistent
, Outer3.N^num//@consistent
, Outer3.S^name//@consistent
) 
mut method //@consistent
Outer1.Method #myMethod() 
read method //@consistent
Outer1.Method myMethod() 
mut method //@consistent
Outer3.N #num() 
read method //@consistent
Outer3.N num() 
mut method //@consistent
Outer3.S #name() 
read method //@consistent
Outer3.S name() 
method 
Outer2.Name class() Outer2.Name.#apply(isExternal:Outer3.Bool.true(), adapter:using Outer2.IntrospectionPlugin check getTypePathOrElse(that:this.myMethod().myClass().that(), methodNum:this.myMethod().num().binaryRepr(), parameterNum:this.num().binaryRepr(), node:this.myMethod().myClass().node().binaryRepr()) error {
class method 
This invalidMethodNumber() })}
Parameters:{// generic linked list class, elements of class Elem

Varres:{
class method 
mut This #apply(Outer1^inner//@consistent
) 
mut method //@consistent
Void inner(Outer1 that) 
mut method //@consistent
Outer1 #inner() 
read method //@consistent
Outer1 inner() }
Varres0:{
class method 
mut This #apply(Outer1.#apply() ^inner//@consistent
) 
mut method //@consistent
Void inner(Outer1.#apply() that) 
mut method //@consistent
Outer1.#apply() #inner() }
class method 
This _new(This.Cell^head//@consistent
) 
mut method //@consistent
This.Cell #head() 
read method //@consistent
This.Cell head() 
class method 
This #apply() This._new(head:This.CellEnd.#apply())
method 
Outer3.Bool isEmpty() (
  Void unused=(
    Void unused0=(
      This.head() x=this.head()
      (
        This.CellEnd x0=(
          Void unused1=return x
          catch return casted (
            on This.CellEnd casted
            
            on Any exception void
            )
          error {//@stringU
          //CastT-Should be unreachable code
          }
          )
        catch exception unused2 (
          on Void return Outer3.Bool.false()
          )
        (
          Void unused3=return Outer3.Bool.true()
          void
          )
        )
      )
    void
    )
  catch return result (
    on Outer3.Bool result
    )
  error {//@stringU
  //CurlyBlock-Should be unreachable code
  }
  )
method 
Outer1.Parameter top() this.head().#inner()
method 
mut This.Iterator vals() this.head().vals(terminate:Outer3.Bool.true())
method 
mut This.Iterator valsCut() this.head().vals(terminate:Outer3.Bool.false())
method 
This pop() (
  Void unused=(
    Void unused0=return This._new(head:this.head().#next())
    catch exception unused1 (
      on Void error Outer3.S.#stringParser(that:{//@stringU
      //PopOnEmpyList
      })
      )
    void
    )
  catch return result (
    on This result
    )
  error {//@stringU
  //CurlyBlock-Should be unreachable code
  }
  )
method 
This #plusplus(This that) (
  Void unused=(
    This res=this
    mut This.Varres varres=This.Varres.#apply(inner:res)
    Void unused0=(
      This.vals() e=that.vals()
      (
        Void unused2=(
          Void unused3=(
            Void unused4=loop (
              Void unused5=e.#next()
              catch exception unused6 (
                on Void (
                  Void unused7=(
                    Void unused8=e.#checkEnd()
                    catch exception unused9 (
                      on Void void
                      )
                    void
                    )
                  exception void
                  )
                )
              varres.inner(that:varres.#inner().#add(that:e.#inner()))
              )
            catch exception unused10 (
              on Void void
              )
            void
            )
          catch exception propagated (
            on Any (
              Void unused11=e.#close()
              exception propagated
              )
            )
          void
          )
        catch return propagated0 (
          on This (
            Void unused12=e.#close()
            return propagated0
            )
          )
        e.#close()
        )
      )
    Void unused1=return varres.#inner()
    void
    )
  catch return result (
    on This result
    )
  error {//@stringU
  //CurlyBlock-Should be unreachable code
  }
  )
class method 
This #begin() This.#apply()
method 
This #add(Outer1.Parameter that) This._new(head:This.CellNext.#apply(elem:that, nextCell:this.head()))
method 
This #end() (
  This.#apply() res=This.#apply()
  mut This.Varres0 varres=This.Varres0.#apply(inner:res)
  Void unused=(
    This.vals() elem=this.vals()
    (
      Void unused0=(
        Void unused1=(
          Void unused2=loop (
            Void unused3=elem.#next()
            catch exception unused4 (
              on Void (
                Void unused5=(
                  Void unused6=elem.#checkEnd()
                  catch exception unused7 (
                    on Void void
                    )
                  void
                  )
                exception void
                )
              )
            varres.inner(that:varres.#inner().#add(that:elem.#inner()))
            )
          catch exception unused8 (
            on Void void
            )
          void
          )
        catch exception propagated (
          on Any (
            Void unused9=elem.#close()
            exception propagated
            )
          )
        void
        )
      catch return propagated0 (
        on Any (
          Void unused10=elem.#close()
          return propagated0
          )
        )
      elem.#close()
      )
    )
  varres.#inner()
  )
Cell:{interface 
method 
mut Outer1.Iterator vals(This4.Bool terminate) 
method 
This #next() exception Void 
method 
Outer2.Parameter #inner() 
method 
Void #checkEnd() }
CellEnd:{<:Outer1.Cell
class method 
This #apply() 
method vals(terminate ) Outer1.Iterator.#apply(that:this, terminate:terminate)
method #next() exception void
method #inner() error This4.S.#stringParser(that:{//@stringU
//InnerOnCellEnd, should not happen
})
method #checkEnd() void}
CellNext:{<:Outer1.Cell
class method 
This #apply(Outer2.Parameter^elem//@consistent
, Outer1.Cell^nextCell//@consistent
) 
mut method //@consistent
Outer2.Parameter #elem() 
read method //@consistent
Outer2.Parameter elem() 
mut method //@consistent
Outer1.Cell #nextCell() 
read method //@consistent
Outer1.Cell nextCell() 
method vals(terminate ) (
  Void unused=(
    This.#apply(elem nextCell ) startPoint=This.#apply(elem:this.elem(), nextCell:this)
    Void unused0=return Outer1.Iterator.#apply(that:startPoint, terminate:terminate)
    void
    )
  catch return result (
    on This.vals(terminate ) result
    )
  error {//@stringU
  //CurlyBlock-Should be unreachable code
  }
  )
method #next() this.nextCell()
method #inner() this.elem()
method #checkEnd() (
  This.#checkEnd() .this.nextCell() cell=this.nextCell()
  (
    This cell0=(
      Void unused=return cell
      catch return casted (
        on This casted
        
        on Any exception void
        )
      error {//@stringU
      //CastT-Should be unreachable code
      }
      )
    catch exception unused0 (
      on Void void
      )
    (
      Void unused1=error This4.S.#stringParser(that:{//@stringU
      //IterationNotComplete,\u000a  use valsCut() to allows incomplete iterations\u000a
      })
      void
      )
    )
  )}
Iterator:{
class method 
mut This #apply(Outer1.Cell^that//@consistent
, This4.Bool^terminate//@consistent
) 
mut method //@consistent
Void that(Outer1.Cell that) 
mut method //@consistent
Outer1.Cell #that() 
read method //@consistent
Outer1.Cell that() 
mut method //@consistent
This4.Bool #terminate() 
read method //@consistent
This4.Bool terminate() 
mut method 
Void #next() exception Void (
  Void unused=(
    This.that() .#next() x=this.that().#next()
    Void unused0=(
      Outer1.CellEnd x0=(
        Void unused2=return x
        catch return casted (
          on Outer1.CellEnd casted
          
          on Any exception void
          )
        error {//@stringU
        //CastT-Should be unreachable code
        }
        )
      catch exception unused3 (
        on Void void
        )
      (
        Void unused4=exception void
        void
        )
      )
    Void unused1=return this.that(that:x)
    void
    )
  catch return result (
    on Void result
    )
  error {//@stringU
  //CurlyBlock-Should be unreachable code
  }
  )
read method 
Void #checkEnd() (
  This.terminate() cond=this.terminate()
  (
    Void unused=cond.#checkTrue()
    catch exception unused0 (
      on Void void
      )
    this.that().#checkEnd()
    )
  )
read method 
Outer2.Parameter #inner() this.that().#inner()
read method 
Void #close() void}}
Methods:{// generic linked list class, elements of class Elem

Varres:{
class method 
mut This #apply(Outer1^inner//@consistent
) 
mut method //@consistent
Void inner(Outer1 that) 
mut method //@consistent
Outer1 #inner() 
read method //@consistent
Outer1 inner() }
Varres0:{
class method 
mut This #apply(Outer1.#apply() ^inner//@consistent
) 
mut method //@consistent
Void inner(Outer1.#apply() that) 
mut method //@consistent
Outer1.#apply() #inner() }
class method 
This _new(This.Cell^head//@consistent
) 
mut method //@consistent
This.Cell #head() 
read method //@consistent
This.Cell head() 
class method 
This #apply() This._new(head:This.CellEnd.#apply())
method 
Outer3.Bool isEmpty() (
  Void unused=(
    Void unused0=(
      This.head() x=this.head()
      (
        This.CellEnd x0=(
          Void unused1=return x
          catch return casted (
            on This.CellEnd casted
            
            on Any exception void
            )
          error {//@stringU
          //CastT-Should be unreachable code
          }
          )
        catch exception unused2 (
          on Void return Outer3.Bool.false()
          )
        (
          Void unused3=return Outer3.Bool.true()
          void
          )
        )
      )
    void
    )
  catch return result (
    on Outer3.Bool result
    )
  error {//@stringU
  //CurlyBlock-Should be unreachable code
  }
  )
method 
Outer1.Method top() this.head().#inner()
method 
mut This.Iterator vals() this.head().vals(terminate:Outer3.Bool.true())
method 
mut This.Iterator valsCut() this.head().vals(terminate:Outer3.Bool.false())
method 
This pop() (
  Void unused=(
    Void unused0=return This._new(head:this.head().#next())
    catch exception unused1 (
      on Void error Outer3.S.#stringParser(that:{//@stringU
      //PopOnEmpyList
      })
      )
    void
    )
  catch return result (
    on This result
    )
  error {//@stringU
  //CurlyBlock-Should be unreachable code
  }
  )
method 
This #plusplus(This that) (
  Void unused=(
    This res=this
    mut This.Varres varres=This.Varres.#apply(inner:res)
    Void unused0=(
      This.vals() e=that.vals()
      (
        Void unused2=(
          Void unused3=(
            Void unused4=loop (
              Void unused5=e.#next()
              catch exception unused6 (
                on Void (
                  Void unused7=(
                    Void unused8=e.#checkEnd()
                    catch exception unused9 (
                      on Void void
                      )
                    void
                    )
                  exception void
                  )
                )
              varres.inner(that:varres.#inner().#add(that:e.#inner()))
              )
            catch exception unused10 (
              on Void void
              )
            void
            )
          catch exception propagated (
            on Any (
              Void unused11=e.#close()
              exception propagated
              )
            )
          void
          )
        catch return propagated0 (
          on This (
            Void unused12=e.#close()
            return propagated0
            )
          )
        e.#close()
        )
      )
    Void unused1=return varres.#inner()
    void
    )
  catch return result (
    on This result
    )
  error {//@stringU
  //CurlyBlock-Should be unreachable code
  }
  )
class method 
This #begin() This.#apply()
method 
This #add(Outer1.Method that) This._new(head:This.CellNext.#apply(elem:that, nextCell:this.head()))
method 
This #end() (
  This.#apply() res=This.#apply()
  mut This.Varres0 varres=This.Varres0.#apply(inner:res)
  Void unused=(
    This.vals() elem=this.vals()
    (
      Void unused0=(
        Void unused1=(
          Void unused2=loop (
            Void unused3=elem.#next()
            catch exception unused4 (
              on Void (
                Void unused5=(
                  Void unused6=elem.#checkEnd()
                  catch exception unused7 (
                    on Void void
                    )
                  void
                  )
                exception void
                )
              )
            varres.inner(that:varres.#inner().#add(that:elem.#inner()))
            )
          catch exception unused8 (
            on Void void
            )
          void
          )
        catch exception propagated (
          on Any (
            Void unused9=elem.#close()
            exception propagated
            )
          )
        void
        )
      catch return propagated0 (
        on Any (
          Void unused10=elem.#close()
          return propagated0
          )
        )
      elem.#close()
      )
    )
  varres.#inner()
  )
Cell:{interface 
method 
mut Outer1.Iterator vals(This4.Bool terminate) 
method 
This #next() exception Void 
method 
Outer2.Method #inner() 
method 
Void #checkEnd() }
CellEnd:{<:Outer1.Cell
class method 
This #apply() 
method vals(terminate ) Outer1.Iterator.#apply(that:this, terminate:terminate)
method #next() exception void
method #inner() error This4.S.#stringParser(that:{//@stringU
//InnerOnCellEnd, should not happen
})
method #checkEnd() void}
CellNext:{<:Outer1.Cell
class method 
This #apply(Outer2.Method^elem//@consistent
, Outer1.Cell^nextCell//@consistent
) 
mut method //@consistent
Outer2.Method #elem() 
read method //@consistent
Outer2.Method elem() 
mut method //@consistent
Outer1.Cell #nextCell() 
read method //@consistent
Outer1.Cell nextCell() 
method vals(terminate ) (
  Void unused=(
    This.#apply(elem nextCell ) startPoint=This.#apply(elem:this.elem(), nextCell:this)
    Void unused0=return Outer1.Iterator.#apply(that:startPoint, terminate:terminate)
    void
    )
  catch return result (
    on This.vals(terminate ) result
    )
  error {//@stringU
  //CurlyBlock-Should be unreachable code
  }
  )
method #next() this.nextCell()
method #inner() this.elem()
method #checkEnd() (
  This.#checkEnd() .this.nextCell() cell=this.nextCell()
  (
    This cell0=(
      Void unused=return cell
      catch return casted (
        on This casted
        
        on Any exception void
        )
      error {//@stringU
      //CastT-Should be unreachable code
      }
      )
    catch exception unused0 (
      on Void void
      )
    (
      Void unused1=error This4.S.#stringParser(that:{//@stringU
      //IterationNotComplete,\u000a  use valsCut() to allows incomplete iterations\u000a
      })
      void
      )
    )
  )}
Iterator:{
class method 
mut This #apply(Outer1.Cell^that//@consistent
, This4.Bool^terminate//@consistent
) 
mut method //@consistent
Void that(Outer1.Cell that) 
mut method //@consistent
Outer1.Cell #that() 
read method //@consistent
Outer1.Cell that() 
mut method //@consistent
This4.Bool #terminate() 
read method //@consistent
This4.Bool terminate() 
mut method 
Void #next() exception Void (
  Void unused=(
    This.that() .#next() x=this.that().#next()
    Void unused0=(
      Outer1.CellEnd x0=(
        Void unused2=return x
        catch return casted (
          on Outer1.CellEnd casted
          
          on Any exception void
          )
        error {//@stringU
        //CastT-Should be unreachable code
        }
        )
      catch exception unused3 (
        on Void void
        )
      (
        Void unused4=exception void
        void
        )
      )
    Void unused1=return this.that(that:x)
    void
    )
  catch return result (
    on Void result
    )
  error {//@stringU
  //CurlyBlock-Should be unreachable code
  }
  )
read method 
Void #checkEnd() (
  This.terminate() cond=this.terminate()
  (
    Void unused=cond.#checkTrue()
    catch exception unused0 (
      on Void void
      )
    this.that().#checkEnd()
    )
  )
read method 
Outer2.Method #inner() this.that().#inner()
read method 
Void #close() void}}
Names:{// generic linked list class, elements of class Elem

Varres:{
class method 
mut This #apply(Outer1^inner//@consistent
) 
mut method //@consistent
Void inner(Outer1 that) 
mut method //@consistent
Outer1 #inner() 
read method //@consistent
Outer1 inner() }
Varres0:{
class method 
mut This #apply(Outer1.#apply() ^inner//@consistent
) 
mut method //@consistent
Void inner(Outer1.#apply() that) 
mut method //@consistent
Outer1.#apply() #inner() }
class method 
This _new(This.Cell^head//@consistent
) 
mut method //@consistent
This.Cell #head() 
read method //@consistent
This.Cell head() 
class method 
This #apply() This._new(head:This.CellEnd.#apply())
method 
Outer3.Bool isEmpty() (
  Void unused=(
    Void unused0=(
      This.head() x=this.head()
      (
        This.CellEnd x0=(
          Void unused1=return x
          catch return casted (
            on This.CellEnd casted
            
            on Any exception void
            )
          error {//@stringU
          //CastT-Should be unreachable code
          }
          )
        catch exception unused2 (
          on Void return Outer3.Bool.false()
          )
        (
          Void unused3=return Outer3.Bool.true()
          void
          )
        )
      )
    void
    )
  catch return result (
    on Outer3.Bool result
    )
  error {//@stringU
  //CurlyBlock-Should be unreachable code
  }
  )
method 
Outer2.Name top() this.head().#inner()
method 
mut This.Iterator vals() this.head().vals(terminate:Outer3.Bool.true())
method 
mut This.Iterator valsCut() this.head().vals(terminate:Outer3.Bool.false())
method 
This pop() (
  Void unused=(
    Void unused0=return This._new(head:this.head().#next())
    catch exception unused1 (
      on Void error Outer3.S.#stringParser(that:{//@stringU
      //PopOnEmpyList
      })
      )
    void
    )
  catch return result (
    on This result
    )
  error {//@stringU
  //CurlyBlock-Should be unreachable code
  }
  )
method 
This #plusplus(This that) (
  Void unused=(
    This res=this
    mut This.Varres varres=This.Varres.#apply(inner:res)
    Void unused0=(
      This.vals() e=that.vals()
      (
        Void unused2=(
          Void unused3=(
            Void unused4=loop (
              Void unused5=e.#next()
              catch exception unused6 (
                on Void (
                  Void unused7=(
                    Void unused8=e.#checkEnd()
                    catch exception unused9 (
                      on Void void
                      )
                    void
                    )
                  exception void
                  )
                )
              varres.inner(that:varres.#inner().#add(that:e.#inner()))
              )
            catch exception unused10 (
              on Void void
              )
            void
            )
          catch exception propagated (
            on Any (
              Void unused11=e.#close()
              exception propagated
              )
            )
          void
          )
        catch return propagated0 (
          on This (
            Void unused12=e.#close()
            return propagated0
            )
          )
        e.#close()
        )
      )
    Void unused1=return varres.#inner()
    void
    )
  catch return result (
    on This result
    )
  error {//@stringU
  //CurlyBlock-Should be unreachable code
  }
  )
class method 
This #begin() This.#apply()
method 
This #add(Outer2.Name that) This._new(head:This.CellNext.#apply(elem:that, nextCell:this.head()))
method 
This #end() (
  This.#apply() res=This.#apply()
  mut This.Varres0 varres=This.Varres0.#apply(inner:res)
  Void unused=(
    This.vals() elem=this.vals()
    (
      Void unused0=(
        Void unused1=(
          Void unused2=loop (
            Void unused3=elem.#next()
            catch exception unused4 (
              on Void (
                Void unused5=(
                  Void unused6=elem.#checkEnd()
                  catch exception unused7 (
                    on Void void
                    )
                  void
                  )
                exception void
                )
              )
            varres.inner(that:varres.#inner().#add(that:elem.#inner()))
            )
          catch exception unused8 (
            on Void void
            )
          void
          )
        catch exception propagated (
          on Any (
            Void unused9=elem.#close()
            exception propagated
            )
          )
        void
        )
      catch return propagated0 (
        on Any (
          Void unused10=elem.#close()
          return propagated0
          )
        )
      elem.#close()
      )
    )
  varres.#inner()
  )
Cell:{interface 
method 
mut Outer1.Iterator vals(This4.Bool terminate) 
method 
This #next() exception Void 
method 
Outer3.Name #inner() 
method 
Void #checkEnd() }
CellEnd:{<:Outer1.Cell
class method 
This #apply() 
method vals(terminate ) Outer1.Iterator.#apply(that:this, terminate:terminate)
method #next() exception void
method #inner() error This4.S.#stringParser(that:{//@stringU
//InnerOnCellEnd, should not happen
})
method #checkEnd() void}
CellNext:{<:Outer1.Cell
class method 
This #apply(Outer3.Name^elem//@consistent
, Outer1.Cell^nextCell//@consistent
) 
mut method //@consistent
Outer3.Name #elem() 
read method //@consistent
Outer3.Name elem() 
mut method //@consistent
Outer1.Cell #nextCell() 
read method //@consistent
Outer1.Cell nextCell() 
method vals(terminate ) (
  Void unused=(
    This.#apply(elem nextCell ) startPoint=This.#apply(elem:this.elem(), nextCell:this)
    Void unused0=return Outer1.Iterator.#apply(that:startPoint, terminate:terminate)
    void
    )
  catch return result (
    on This.vals(terminate ) result
    )
  error {//@stringU
  //CurlyBlock-Should be unreachable code
  }
  )
method #next() this.nextCell()
method #inner() this.elem()
method #checkEnd() (
  This.#checkEnd() .this.nextCell() cell=this.nextCell()
  (
    This cell0=(
      Void unused=return cell
      catch return casted (
        on This casted
        
        on Any exception void
        )
      error {//@stringU
      //CastT-Should be unreachable code
      }
      )
    catch exception unused0 (
      on Void void
      )
    (
      Void unused1=error This4.S.#stringParser(that:{//@stringU
      //IterationNotComplete,\u000a  use valsCut() to allows incomplete iterations\u000a
      })
      void
      )
    )
  )}
Iterator:{
class method 
mut This #apply(Outer1.Cell^that//@consistent
, This4.Bool^terminate//@consistent
) 
mut method //@consistent
Void that(Outer1.Cell that) 
mut method //@consistent
Outer1.Cell #that() 
read method //@consistent
Outer1.Cell that() 
mut method //@consistent
This4.Bool #terminate() 
read method //@consistent
This4.Bool terminate() 
mut method 
Void #next() exception Void (
  Void unused=(
    This.that() .#next() x=this.that().#next()
    Void unused0=(
      Outer1.CellEnd x0=(
        Void unused2=return x
        catch return casted (
          on Outer1.CellEnd casted
          
          on Any exception void
          )
        error {//@stringU
        //CastT-Should be unreachable code
        }
        )
      catch exception unused3 (
        on Void void
        )
      (
        Void unused4=exception void
        void
        )
      )
    Void unused1=return this.that(that:x)
    void
    )
  catch return result (
    on Void result
    )
  error {//@stringU
  //CurlyBlock-Should be unreachable code
  }
  )
read method 
Void #checkEnd() (
  This.terminate() cond=this.terminate()
  (
    Void unused=cond.#checkTrue()
    catch exception unused0 (
      on Void void
      )
    this.that().#checkEnd()
    )
  )
read method 
Outer3.Name #inner() this.that().#inner()
read method 
Void #close() void}}
method 
This.Names nestedClasses() (
  Void unused=(
    This.Names ns=This.Names.#begin().#end()
    Outer2.N nNum=Outer2.N.#numberParser(that:{//@stringU
    //0
    })
    mut This.Varns varns=This.Varns.#apply(inner:ns)
    mut This.VarnNum varnNum=This.VarnNum.#apply(inner:nNum)
    Void unused0=(
      Void unused2=loop (
        Void unused3=Outer2.Bool.true().#checkTrue()
        (
          Void unused4=varns.inner(that:varns.#inner().#add(that:this.get(nestedClassNum:varnNum.#inner())))
          varnNum.inner(that:varnNum.#inner().#plus(that:Outer2.N.#numberParser(that:{//@stringU
          //1
          })))
          )
        )
      catch exception unused5 (
        on Void void
        )
      void
      )
    Void unused1=return varns.#inner()
    void
    )
  catch return result (
    on This.Names result
    )
  error {//@stringU
  //CurlyBlock-Should be unreachable code
  }
  )
method 
This.Methods methods() (
  Void unused=(
    This.Methods ms=This.Methods.#begin().#end()
    Outer2.N mNum=Outer2.N.#numberParser(that:{//@stringU
    //0
    })
    mut This.Varms varms=This.Varms.#apply(inner:ms)
    mut This.VarmNum varmNum=This.VarmNum.#apply(inner:mNum)
    Void unused0=(
      Void unused2=loop (
        Void unused3=Outer2.Bool.true().#checkTrue()
        (
          Void unused4=varms.inner(that:varms.#inner().#add(that:this.get(methodNum:varmNum.#inner())))
          varmNum.inner(that:varmNum.#inner().#plus(that:Outer2.N.#numberParser(that:{//@stringU
          //1
          })))
          )
        )
      catch exception unused5 (
        on Void void
        )
      void
      )
    Void unused1=return varms.#inner()
    void
    )
  catch return result (
    on This.Methods result
    )
  error {//@stringU
  //CurlyBlock-Should be unreachable code
  }
  )
method 
This.Parameters fields() (
  Void unused=(
    This.methods() ms=this.methods()
    This.Method ctor=(
      Void unused1=(
        Void unused2=(
          This.methods() .vals() m=ms.vals()
          (
            Void unused4=(
              Void unused5=(
                Void unused6=loop (
                  Void unused7=m.#next()
                  catch exception unused8 (
                    on Void (
                      Void unused9=(
                        Void unused10=m.#checkEnd()
                        catch exception unused11 (
                          on Void void
                          )
                        void
                        )
                      exception void
                      )
                    )
                  (
                    This.methods() .vals() .#inner() .isAbstract() .#and(that ) cond=m.#inner().isAbstract().#and(that:m.#inner().getMdf().#equalequal(that:Outer2.S.#stringParser(that:{//@stringU
                    //Type
                    })))
                    (
                      Void unused12=cond.#checkTrue()
                      catch exception unused13 (
                        on Void void
                        )
                      return m.#inner()
                      )
                    )
                  )
                catch exception unused14 (
                  on Void void
                  )
                void
                )
              catch exception propagated (
                on Any (
                  Void unused15=m.#close()
                  exception propagated
                  )
                )
              void
              )
            catch return propagated0 (
              on This.Method (
                Void unused16=m.#close()
                return propagated0
                )
              )
            m.#close()
            )
          )
        Void unused3=error Outer2.S.#stringParser(that:{//@stringU
        //Not an instantiable class
        })
        void
        )
      catch return result0 (
        on This.Method result0
        )
      error {//@stringU
      //CurlyBlock-Should be unreachable code
      }
      )
    Void unused0=return ctor.parameters()
    void
    )
  catch return result (
    on This.Parameters result
    )
  error {//@stringU
  //CurlyBlock-Should be unreachable code
  }
  )}
Load:{
class method 
This #begin() 
method 
This #end() this
method 
Library #left(Library that) (
  Void unused=(//assume that have abstract Bool N and S
  
    Void unused0=return Outer1.Adapt.#begin().#add(that:Outer1.Name.#stringParser(that:{//@stringU
    //N
    }), into:Outer1.Name.#apply(that:Outer2.N)).#add(that:Outer1.Name.#stringParser(that:{//@stringU
    //S
    }), into:Outer1.Name.#apply(that:Outer2.S)).#add(that:Outer1.Name.#stringParser(that:{//@stringU
    //S.ToS
    }), into:Outer1.Name.#apply(that:Outer2.S.ToS)).#add(that:Outer1.Name.#stringParser(that:{//@stringU
    //Bool
    }), into:Outer1.Name.#apply(that:Outer2.Bool)).#add(that:Outer1.Name.#stringParser(that:{//@stringU
    //Debug
    }), into:Outer1.Name.#apply(that:Outer2.Debug)).#end().#left(that:that)
    void
    )
  catch return result (
    on Library result
    )
  error {//@stringU
  //CurlyBlock-Should be unreachable code
  }
  )}
Opt:{
class method 
This unused() 
class method 
Library #apply(class Any that) Outer1.Adapt.#begin().#add(that:Outer1.Name.#stringParser(that:{//@stringU
//T
}), into:Outer1.Name.#apply(that:that)).#end().#left(that:{
class method 
This #new(This.TOpt^that//@consistent
) 
mut method //@consistent
This.TOpt #that() 
read method //@consistent
This.TOpt that() 
T:{}
TOpt:{interface 
method 
Outer1.T get() }
TEmpty:{<:Outer1.TOpt
class method 
This #apply() 
method get() error This4.S.#stringParser(that:{//@stringU
//Value not present
})}
TOf:{<:Outer1.TOpt
class method 
This #apply(Outer1.T^that//@consistent
) 
mut method //@consistent
Outer1.T #that() 
read method //@consistent
Outer1.T that() 
method get() this.that()}
method 
This.T #bang() this.that().get()
method 
Outer3.Bool isPresent() (
  Void unused=(
    This.#bang() aux=this.#bang()
    Void unused0=return Outer3.Bool.true()
    catch error unused1 (
      on Any return Outer3.Bool.false()
      )
    void
    )
  catch return result (
    on Outer3.Bool result
    )
  error {//@stringU
  //CurlyBlock-Should be unreachable code
  }
  )
class method 
This #apply() This.#new(that:This.TEmpty.#apply())
class method 
This #apply(This.T that) This.#new(that:This.TOf.#apply(that:that))})}
Use:{
Varresult1:{
class method 
mut This #apply(Outer1.myLibs() .vals() .#inner() ^inner//@consistent
) 
mut method //@consistent
Void inner(Outer1.myLibs() .vals() .#inner() that) 
mut method //@consistent
Outer1.myLibs() .vals() .#inner() #inner() }
class method 
This #apply(This.Resolver^resolver//@consistent
, This.Libs^myLibs//@consistent
) 
mut method //@consistent
This.Resolver #resolver() 
read method //@consistent
This.Resolver resolver() 
mut method //@consistent
This.Libs #myLibs() 
read method //@consistent
This.Libs myLibs() 
Resolver:{
class method 
This #new(This.TOpt^that//@consistent
) 
mut method //@consistent
This.TOpt #that() 
read method //@consistent
This.TOpt that() 
TOpt:{interface 
method 
Library get() }
TEmpty:{<:Outer1.TOpt
class method 
This #apply() 
method get() error This4.S.#stringParser(that:{//@stringU
//Value not present
})}
TOf:{<:Outer1.TOpt
class method 
This #apply(Library^that//@consistent
) 
mut method //@consistent
Library #that() 
read method //@consistent
Library that() 
method get() this.that()}
method 
Library #bang() this.that().get()
method 
Outer3.Bool isPresent() (
  Void unused=(
    This.#bang() aux=this.#bang()
    Void unused0=return Outer3.Bool.true()
    catch error unused1 (
      on Any return Outer3.Bool.false()
      )
    void
    )
  catch return result (
    on Outer3.Bool result
    )
  error {//@stringU
  //CurlyBlock-Should be unreachable code
  }
  )
class method 
This #apply() This.#new(that:This.TEmpty.#apply())
class method 
This #apply(Library that) This.#new(that:This.TOf.#apply(that:that))}
Libs:{// generic linked list class, elements of class Elem

Varres:{
class method 
mut This #apply(Outer1^inner//@consistent
) 
mut method //@consistent
Void inner(Outer1 that) 
mut method //@consistent
Outer1 #inner() 
read method //@consistent
Outer1 inner() }
Varres0:{
class method 
mut This #apply(Outer1.#apply() ^inner//@consistent
) 
mut method //@consistent
Void inner(Outer1.#apply() that) 
mut method //@consistent
Outer1.#apply() #inner() }
class method 
This _new(This.Cell^head//@consistent
) 
mut method //@consistent
This.Cell #head() 
read method //@consistent
This.Cell head() 
class method 
This #apply() This._new(head:This.CellEnd.#apply())
method 
Outer3.Bool isEmpty() (
  Void unused=(
    Void unused0=(
      This.head() x=this.head()
      (
        This.CellEnd x0=(
          Void unused1=return x
          catch return casted (
            on This.CellEnd casted
            
            on Any exception void
            )
          error {//@stringU
          //CastT-Should be unreachable code
          }
          )
        catch exception unused2 (
          on Void return Outer3.Bool.false()
          )
        (
          Void unused3=return Outer3.Bool.true()
          void
          )
        )
      )
    void
    )
  catch return result (
    on Outer3.Bool result
    )
  error {//@stringU
  //CurlyBlock-Should be unreachable code
  }
  )
method 
Library top() this.head().#inner()
method 
mut This.Iterator vals() this.head().vals(terminate:Outer3.Bool.true())
method 
mut This.Iterator valsCut() this.head().vals(terminate:Outer3.Bool.false())
method 
This pop() (
  Void unused=(
    Void unused0=return This._new(head:this.head().#next())
    catch exception unused1 (
      on Void error Outer3.S.#stringParser(that:{//@stringU
      //PopOnEmpyList
      })
      )
    void
    )
  catch return result (
    on This result
    )
  error {//@stringU
  //CurlyBlock-Should be unreachable code
  }
  )
method 
This #plusplus(This that) (
  Void unused=(
    This res=this
    mut This.Varres varres=This.Varres.#apply(inner:res)
    Void unused0=(
      This.vals() e=that.vals()
      (
        Void unused2=(
          Void unused3=(
            Void unused4=loop (
              Void unused5=e.#next()
              catch exception unused6 (
                on Void (
                  Void unused7=(
                    Void unused8=e.#checkEnd()
                    catch exception unused9 (
                      on Void void
                      )
                    void
                    )
                  exception void
                  )
                )
              varres.inner(that:varres.#inner().#add(that:e.#inner()))
              )
            catch exception unused10 (
              on Void void
              )
            void
            )
          catch exception propagated (
            on Any (
              Void unused11=e.#close()
              exception propagated
              )
            )
          void
          )
        catch return propagated0 (
          on This (
            Void unused12=e.#close()
            return propagated0
            )
          )
        e.#close()
        )
      )
    Void unused1=return varres.#inner()
    void
    )
  catch return result (
    on This result
    )
  error {//@stringU
  //CurlyBlock-Should be unreachable code
  }
  )
class method 
This #begin() This.#apply()
method 
This #add(Library that) This._new(head:This.CellNext.#apply(elem:that, nextCell:this.head()))
method 
This #end() (
  This.#apply() res=This.#apply()
  mut This.Varres0 varres=This.Varres0.#apply(inner:res)
  Void unused=(
    This.vals() elem=this.vals()
    (
      Void unused0=(
        Void unused1=(
          Void unused2=loop (
            Void unused3=elem.#next()
            catch exception unused4 (
              on Void (
                Void unused5=(
                  Void unused6=elem.#checkEnd()
                  catch exception unused7 (
                    on Void void
                    )
                  void
                  )
                exception void
                )
              )
            varres.inner(that:varres.#inner().#add(that:elem.#inner()))
            )
          catch exception unused8 (
            on Void void
            )
          void
          )
        catch exception propagated (
          on Any (
            Void unused9=elem.#close()
            exception propagated
            )
          )
        void
        )
      catch return propagated0 (
        on Any (
          Void unused10=elem.#close()
          return propagated0
          )
        )
      elem.#close()
      )
    )
  varres.#inner()
  )
Cell:{interface 
method 
mut Outer1.Iterator vals(This4.Bool terminate) 
method 
This #next() exception Void 
method 
Library #inner() 
method 
Void #checkEnd() }
CellEnd:{<:Outer1.Cell
class method 
This #apply() 
method vals(terminate ) Outer1.Iterator.#apply(that:this, terminate:terminate)
method #next() exception void
method #inner() error This4.S.#stringParser(that:{//@stringU
//InnerOnCellEnd, should not happen
})
method #checkEnd() void}
CellNext:{<:Outer1.Cell
class method 
This #apply(Library^elem//@consistent
, Outer1.Cell^nextCell//@consistent
) 
mut method //@consistent
Library #elem() 
read method //@consistent
Library elem() 
mut method //@consistent
Outer1.Cell #nextCell() 
read method //@consistent
Outer1.Cell nextCell() 
method vals(terminate ) (
  Void unused=(
    This.#apply(elem nextCell ) startPoint=This.#apply(elem:this.elem(), nextCell:this)
    Void unused0=return Outer1.Iterator.#apply(that:startPoint, terminate:terminate)
    void
    )
  catch return result (
    on This.vals(terminate ) result
    )
  error {//@stringU
  //CurlyBlock-Should be unreachable code
  }
  )
method #next() this.nextCell()
method #inner() this.elem()
method #checkEnd() (
  This.#checkEnd() .this.nextCell() cell=this.nextCell()
  (
    This cell0=(
      Void unused=return cell
      catch return casted (
        on This casted
        
        on Any exception void
        )
      error {//@stringU
      //CastT-Should be unreachable code
      }
      )
    catch exception unused0 (
      on Void void
      )
    (
      Void unused1=error This4.S.#stringParser(that:{//@stringU
      //IterationNotComplete,\u000a  use valsCut() to allows incomplete iterations\u000a
      })
      void
      )
    )
  )}
Iterator:{
class method 
mut This #apply(Outer1.Cell^that//@consistent
, This4.Bool^terminate//@consistent
) 
mut method //@consistent
Void that(Outer1.Cell that) 
mut method //@consistent
Outer1.Cell #that() 
read method //@consistent
Outer1.Cell that() 
mut method //@consistent
This4.Bool #terminate() 
read method //@consistent
This4.Bool terminate() 
mut method 
Void #next() exception Void (
  Void unused=(
    This.that() .#next() x=this.that().#next()
    Void unused0=(
      Outer1.CellEnd x0=(
        Void unused2=return x
        catch return casted (
          on Outer1.CellEnd casted
          
          on Any exception void
          )
        error {//@stringU
        //CastT-Should be unreachable code
        }
        )
      catch exception unused3 (
        on Void void
        )
      (
        Void unused4=exception void
        void
        )
      )
    Void unused1=return this.that(that:x)
    void
    )
  catch return result (
    on Void result
    )
  error {//@stringU
  //CurlyBlock-Should be unreachable code
  }
  )
read method 
Void #checkEnd() (
  This.terminate() cond=this.terminate()
  (
    Void unused=cond.#checkTrue()
    catch exception unused0 (
      on Void void
      )
    this.that().#checkEnd()
    )
  )
read method 
Library #inner() this.that().#inner()
read method 
Void #close() void}}
class method 
This #apply() This.#apply(resolver:This.Resolver.#apply(), myLibs:This.Libs.#begin().#end())
method 
This #add(Library that) (
  This.myLibs() .#add(that ) ls=this.myLibs().#add(that:that)
  This.#apply(resolver:this.resolver(), myLibs:ls)
  )
method 
This #add(Library resolver) This.#apply(resolver:This.Resolver.#apply(that:resolver), myLibs:this.myLibs())
class method 
This #begin() This.#apply()
method 
This #end() this
method 
Library #left(Library that) (
  Void unused=(
    This.myLibs() .vals() it=this.myLibs().vals()
    Void unused0=it.#next()
    catch exception unused1 (
      on Void return that
      )
    (
      This.myLibs() .vals() .#inner() result=it.#inner()
      mut This.Varresult1 varresult=This.Varresult1.#apply(inner:result)
      Void unused2=(
        This.myLibs() .vals() libi=it
        (
          Void unused4=(
            Void unused5=(
              Void unused6=loop (
                Void unused7=libi.#next()
                catch exception unused8 (
                  on Void (
                    Void unused9=(
                      Void unused10=libi.#checkEnd()
                      catch exception unused11 (
                        on Void void
                        )
                      void
                      )
                    exception void
                    )
                  )
                varresult.inner(that:this.accumulate(l1:varresult.#inner(), l2:libi.#inner()))
                )
              catch exception unused12 (
                on Void void
                )
              void
              )
            catch exception propagated (
              on Any (
                Void unused13=libi.#close()
                exception propagated
                )
              )
            void
            )
          catch return propagated0 (
            on Library (
              Void unused14=libi.#close()
              return propagated0
              )
            )
          libi.#close()
          )
        )
      Void unused3=return this.accumulate(l1:varresult.#inner(), l2:that)
      void
      )
    )
  catch return result0 (
    on Library result0
    )
  error {//@stringU
  //CurlyBlock-Should be unreachable code
  }
  )
method 
Library accumulate(Library l1, Library l2) (
  Void unused=(
    Void unused0=return Outer1.IntrospectionPlugin.sumLib(l1:l1, l2:l2)
    catch error x (
      on Any (
        Void unused1=(
          This.resolver() .isPresent() .#bang() cond=this.resolver().isPresent().#bang()
          (
            Void unused2=cond.#checkTrue()
            catch exception unused3 (
              on Void void
              )
            error x
            )
          )
        Outer1.Introspection.#apply(that ) .methods() ms=Outer1.Introspection.#apply(that:this.resolver().#bang()).methods()
        Outer2.S _name=ms.pop().pop().top().name()
        Outer2.S _nameLeft=ms.pop().top().name()
        Outer2.S _nameRight=ms.top().name()
        Outer1.Name name=Outer1.Name.#stringParser(that:_name.binaryRepr())
        Outer1.Name nameLeft=Outer1.Name.#stringParser(that:_nameLeft.binaryRepr())
        Outer1.Name nameRight=Outer1.Name.#stringParser(that:_nameRight.binaryRepr())
        Outer1.Adapt.#begin() .#add(that into ) .#end() .#left(that ) l1A=Outer1.Adapt.#begin().#add(that:name, into:nameLeft).#end().#left(that:l1)
        Outer1.Adapt.#begin() .#add(that into ) .#end() .#left(that ) l2A=Outer1.Adapt.#begin().#add(that:name, into:nameRight).#end().#left(that:l2)
        Outer1.IntrospectionPlugin.sumLib(l1 l2 ) lRes=Outer1.IntrospectionPlugin.sumLib(l1:l1A, l2:l2A)
        return Outer1.Adapt.#begin().#add(makePrivate:nameLeft).#add(makePrivate:nameRight).#end().#left(that:Outer1.IntrospectionPlugin.sumLib(l1:this.resolver().#bang(), l2:lRes))
        )
      )
    void
    )
  catch return result (
    on Library result
    )
  error {//@stringU
  //CurlyBlock-Should be unreachable code
  }
  )
method 
This #plusplus(This that) (
  Void unused=(
    This.myLibs() .#plusplus(that ) list=this.myLibs().#plusplus(that:that.myLibs())
    This.Resolver res=(
      Void unused1=(
        Void unused2=(
          This.resolver() .isPresent() cond=that.resolver().isPresent()
          (
            Void unused4=cond.#checkTrue()
            catch exception unused5 (
              on Void void
              )
            return that.resolver()
            )
          )
        Void unused3=return this.resolver()
        void
        )
      catch return result0 (
        on This.Resolver result0
        )
      error {//@stringU
      //CurlyBlock-Should be unreachable code
      }
      )
    Void unused0=return This.#apply(resolver:res, myLibs:list)
    void
    )
  catch return result (
    on This result
    )
  error {//@stringU
  //CurlyBlock-Should be unreachable code
  }
  )}
Adapt:{
class method 
This #apply(Library^adapter//@consistent
) 
mut method //@consistent
Library #adapter() 
read method //@consistent
Library adapter() 
class method 
This #apply() This.#apply(adapter:{})
method 
This #add(Outer1.Name that, Outer1.Name into) (
  Void unused=(
    Void unused0=(
      Outer1.Name.isExternal() cond=that.isExternal()
      (
        Void unused3=cond.#checkTrue()
        catch exception unused4 (
          on Void void
          )
        error Outer2.S.#stringParser(that:{//@stringU
        //start name must be internal
        })
        )
      )
    Void unused1=(
      Outer1.Name.isInternalPath() .#bang() cond0=that.isInternalPath().#bang()
      (
        Void unused5=cond0.#checkTrue()
        catch exception unused6 (
          on Void void
          )
        return this.#add(that:that, of:Outer1.Name.#stringParser(that:{//@stringU
        //This
        }), into:into)
        )
      )
    Outer1.IntrospectionPlugin.adaptLib(l1 l2 ) map=Outer1.IntrospectionPlugin.adaptLib(l1:into.adapter(), l2:that.adapter())
    Outer1.IntrospectionPlugin.sumLib(l1 l2 ) lib=Outer1.IntrospectionPlugin.sumLib(l1:this.adapter(), l2:map)
    Void unused2=return This.#apply(adapter:lib)
    void
    )
  catch return result (
    on This result
    )
  error {//@stringU
  //CurlyBlock-Should be unreachable code
  }
  )
method 
This #add(Outer1.Name that, Outer1.Name of, Outer1.Name into) (
  Void unused=(
    Outer1.IntrospectionPlugin.adaptLib(l1 l2 ) map1=Outer1.IntrospectionPlugin.adaptLib(l1:into.adapter(), l2:that.adapter())
    Outer1.IntrospectionPlugin.adaptLib(l1 l2 ) map2=Outer1.IntrospectionPlugin.adaptLib(l1:map1, l2:of.adapter())
    Outer1.IntrospectionPlugin.sumLib(l1 l2 ) lib=Outer1.IntrospectionPlugin.sumLib(l1:this.adapter(), l2:map2)
    Void unused0=return This.#apply(adapter:lib)
    void
    )
  catch return result (
    on This result
    )
  error {//@stringU
  //CurlyBlock-Should be unreachable code
  }
  )
method 
This #add(Outer1.Name makePrivate) (
  Void unused=(
    Outer1.Name.#apply(isExternal adapter ) fName=Outer1.Name.#apply(isExternal:Outer2.Bool.false(), adapter:Outer1.IntrospectionPlugin.getFreshName(that:makePrivate.adapter()))
    Void unused0=return this.#add(that:makePrivate, into:fName)
    void
    )
  catch return result (
    on This result
    )
  error {//@stringU
  //CurlyBlock-Should be unreachable code
  }
  )
class method 
This #begin() This.#apply()
method 
This #end() this
method 
This #plusplus(This that) (
  Outer1.IntrospectionPlugin.sumLib(l1 l2 ) lib=Outer1.IntrospectionPlugin.sumLib(l1:this.adapter(), l2:that.adapter())
  This.#apply(adapter:lib)
  )
method 
Library #left(Library that) Outer1.IntrospectionPlugin.adaptLib(l1:that, l2:this.adapter())}
Data:{
Vardecorator:{
class method 
mut This #apply(Outer2.Use.#begin() .#end() ^inner//@consistent
) 
mut method //@consistent
Void inner(Outer2.Use.#begin() .#end() that) 
mut method //@consistent
Outer2.Use.#begin() .#end() #inner() }
Varaccumulator:{
class method 
mut This #apply(Outer2.Use.#begin() ^inner//@consistent
) 
mut method //@consistent
Void inner(Outer2.Use.#begin() that) 
mut method //@consistent
Outer2.Use.#begin() #inner() }
class method 
This #apply() 
class method 
This #begin() This.#apply()
method 
This #end() this
method 
Library #left(Library that) Outer1.Use.#begin().#add(that:this.addEquals(l:that)).#end().#left(that:that)
method 
Library equalsOnField(Outer1.Name c, Outer1.Name n) Outer1.Adapt.#begin().#add(that:Outer1.Name.#stringParser(that:{//@stringU
//T
}), into:c).#add(that:Outer1.Name.#stringParser(that:{//@stringU
//f
}), into:n).#end().#left(that:{
T:{
method 
This4.Bool #equalequal(Any that) }
read method 
This.T f() 
method 
Outer3.Bool current(This that) this.f().#equalequal(that:that.f())})
method 
Library addEquals(Library l) (
  Void unused=(
    Outer1.Use.#begin() .#end() decorator=(
      Outer1.Use.#begin() accumulator=Outer1.Use.#begin()
      mut This.Varaccumulator varaccumulator=This.Varaccumulator.#apply(inner:accumulator)
      Void unused2=(
        Outer1.Introspection.#apply(that ) .fields() .vals() field=Outer1.Introspection.#apply(that:l).fields().vals()
        (
          Void unused3=(
            Void unused4=(
              Void unused5=loop (
                Void unused6=field.#next()
                catch exception unused7 (
                  on Void (
                    Void unused8=(
                      Void unused9=field.#checkEnd()
                      catch exception unused10 (
                        on Void void
                        )
                      void
                      )
                    exception void
                    )
                  )
                varaccumulator.inner(that:varaccumulator.#inner().#add(that:this.equalsOnField(c:field.#inner().class(), n:Outer1.Name.#stringParser(that:field.#inner().name().binaryRepr()))))
                )
              catch exception unused11 (
                on Void void
                )
              void
              )
            catch exception propagated (
              on Any (
                Void unused12=field.#close()
                exception propagated
                )
              )
            void
            )
          catch return propagated0 (
            on Library (
              Void unused13=field.#close()
              return propagated0
              )
            )
          field.#close()
          )
        )
      varaccumulator.#inner().#end()
      )
    mut This.Vardecorator vardecorator=This.Vardecorator.#apply(inner:decorator)
    Void unused0=vardecorator.inner(that:vardecorator.#inner().#plusplus(that:Outer1.Use.#begin().#add(resolver:{
    method 
    Outer3.Bool current(This that) this.left(that:that).#and(that:this.right(that:that))
    method 
    Outer3.Bool left(This that) 
    method 
    Outer3.Bool right(This that) }).#end()))
    Outer1.Use.#begin() .#end() .#left(that ) result=vardecorator.#inner().#left(that:{
    method 
    Outer3.Bool current(This that) 
    method 
    Outer3.Bool #equalequal(Any that) (
      Void unused=(
        Void unused0=(
          This that0=(
            Void unused1=return that
            catch return casted (
              on This casted
              
              on Any exception void
              )
            error {//@stringU
            //CastT-Should be unreachable code
            }
            )
          catch exception unused2 (
            on Void return Outer3.Bool.false()
            )
          (
            Void unused3=return this.current(that:that0)
            void
            )
          )
        void
        )
      catch return result (
        on Outer3.Bool result
        )
      error {//@stringU
      //CurlyBlock-Should be unreachable code
      }
      )})
    Void unused1=return Outer1.Adapt.#begin().#add(makePrivate:Outer1.Name.#stringParser(that:{//@stringU
    //current(that)
    })).#end().#left(that:result)
    void
    )
  catch return result0 (
    on Library result0
    )
  error {//@stringU
  //CurlyBlock-Should be unreachable code
  }
  )}}
Bool:{<:Outer1.S.ToS
method 
Void #checkTrue() exception Void 
class method 
This true() 
class method 
This false() 
method 
This #and(This that) 
method 
This #or(This that) 
method 
This #bang() }
N:{<:Outer1.S.ToS
class method 
This #numberParser(Library that) 
method 
This #plus(This that) 
method 
This #less(This that) 
method 
This #times(This that) 
method 
This #divide(This that) 
method 
Outer1.Bool #equalequal(This that) 
method 
Outer1.Bool #left(This that) 
method 
Outer1.Bool #leftequal(This that) 
method 
Outer1.Bool #bangequal(This that) 
method 
Outer1.Bool #right(This that) 
method 
Outer1.Bool #rightequal(This that) 
method 
Library binaryRepr() }
S:{<:This.ToS
class method 
This #stringParser(Library that) 
ToS:{interface 
method 
Outer1 toS() }
method 
This #plusplus(This.ToS that) 
method 
Outer1.Bool #bangequal(This that) 
method 
Outer1.Bool #equalequal(This that) 
method 
This #apply(Outer1.N that) 
method 
Outer1.N size() 
class method 
This doubleQuote() 
method 
This replace(This that, This into) 
method 
Library binaryRepr() }
Debug:{
class method 
Void #apply(Outer1.S that) }}