{
Bool:{<:Outer1::S::ToS
mut method '@consistent
Library #binaryRepr3() 
read method '@consistent
Library binaryRepr3() 
type method '@private
Outer0 #apply(Library^binaryRepr3'@consistent
) 
method 
Void #checkTrue() exception Void using Outer1::Alu check ifInt32EqualDo(n1:this.binaryRepr3(), n2:Outer1::N.#numberParser(that:{'@stringU
'0
}).binaryRepr()) exception void
type method 
Outer0 true() Outer0.#apply(binaryRepr3:Outer1::N.#numberParser(that:{'@stringU
'1
}).binaryRepr())
type method 
Outer0 false() Outer0.#apply(binaryRepr3:Outer1::N.#numberParser(that:{'@stringU
'0
}).binaryRepr())
method 
Outer0 #and(Outer0 that) (
  Void unused=(
    Void unused0=(
      Void unused2=this.#checkTrue()
      catch exception unused3 (
        on Void void
        )
      return that
      )
    Void unused1=return this
    void
    )
  catch return result (
    on Outer0 result
    )
  error {'@stringU
  'CurlyBlock-Should be unreachable code
  }
  )
method 
Outer0 #or(Outer0 that) (
  Void unused=(
    Void unused0=(
      Void unused2=this.#checkTrue()
      catch exception unused3 (
        on Void void
        )
      return this
      )
    Void unused1=return that
    void
    )
  catch return result (
    on Outer0 result
    )
  error {'@stringU
  'CurlyBlock-Should be unreachable code
  }
  )
method 
Outer0 #bang() (
  Void unused=(
    Void unused0=(
      Void unused2=this.#checkTrue()
      catch exception unused3 (
        on Void void
        )
      return Outer0.false()
      )
    Void unused1=return Outer0.true()
    void
    )
  catch return result (
    on Outer0 result
    )
  error {'@stringU
  'CurlyBlock-Should be unreachable code
  }
  )
method toS() (
  Void unused=(
    Void unused0=(
      Void unused2=this.#checkTrue()
      catch exception unused3 (
        on Void void
        )
      return Outer1::S.#stringParser(that:{'@stringU
      'true
      })
      )
    Void unused1=return Outer1::S.#stringParser(that:{'@stringU
    'false
    })
    void
    )
  catch return result (
    on Outer0::toS() result
    )
  error {'@stringU
  'CurlyBlock-Should be unreachable code
  }
  )}
ExitCode:{
type method 
Library normal() {'@exitStatus
'0
}
type method 
Library failure() {'@exitStatus
'42000
}}
Alu:{'@plugin
'L42.is/connected/withAlu

type method '@private
Outer0 _private() }
N:{<:Outer1::S::ToS
type method 
Outer0 #apply(Library^binaryRepr'@consistent
) 
mut method '@consistent
Library #binaryRepr() 
read method '@consistent
Library binaryRepr() 
type method 
Outer1::N #numberParser(Library that) Outer1::N.#apply(binaryRepr:using Outer1::Alu check stringToInt32(that:that) error void)
method toS() Outer1::S.#stringParser(that:using Outer1::Alu check int32ToString(that:this.binaryRepr()) error void)
method 
Outer1::N #plus(Outer1::N that) Outer1::N.#apply(binaryRepr:using Outer1::Alu check sumInt32(n1:this.binaryRepr(), n2:that.binaryRepr()) error void)
method 
Outer1::N #less(Outer1::N that) Outer1::N.#apply(binaryRepr:using Outer1::Alu check subInt32(n1:this.binaryRepr(), n2:that.binaryRepr()) error void)
method 
Outer1::N #times(Outer1::N that) Outer1::N.#apply(binaryRepr:using Outer1::Alu check mulInt32(n1:this.binaryRepr(), n2:that.binaryRepr()) error void)
method 
Outer1::N #divide(Outer1::N that) Outer1::N.#apply(binaryRepr:using Outer1::Alu check divInt32(n1:this.binaryRepr(), n2:that.binaryRepr()) error void)
method 
Outer1::Bool #equalequal(Outer1::N that) (
  Void unused=(
    Void unused0=using Outer1::Alu check ifInt32EqualDo(n1:this.binaryRepr(), n2:that.binaryRepr()) return Outer1::Bool.true()
    Void unused1=return Outer1::Bool.false()
    void
    )
  catch return result (
    on Outer1::Bool result
    )
  error {'@stringU
  'CurlyBlock-Should be unreachable code
  }
  )
method 
Outer1::Bool #left(Outer1::N that) (
  Void unused=(
    Void unused0=using Outer1::Alu check ifInt32GrtDo(n1:this.binaryRepr(), n2:that.binaryRepr()) return Outer1::Bool.true()
    Void unused1=return Outer1::Bool.false()
    void
    )
  catch return result (
    on Outer1::Bool result
    )
  error {'@stringU
  'CurlyBlock-Should be unreachable code
  }
  )
method 
Outer1::Bool #leftequal(Outer1::N that) (
  Void unused=(
    Void unused0=using Outer1::Alu check ifInt32GEqDo(n1:this.binaryRepr(), n2:that.binaryRepr()) return Outer1::Bool.true()
    Void unused1=return Outer1::Bool.false()
    void
    )
  catch return result (
    on Outer1::Bool result
    )
  error {'@stringU
  'CurlyBlock-Should be unreachable code
  }
  )
method 
Outer1::Bool #bangequal(Outer1::N that) this.#equalequal(that:that).#bang()
method 
Outer1::Bool #right(Outer1::N that) this.#leftequal(that:that).#bang()
method 
Outer1::Bool #rightequal(Outer1::N that) this.#left(that:that).#bang()}
S:{<:Outer0::ToS
mut method '@consistent
Library #_binaryRepr3() 
read method '@consistent
Library _binaryRepr3() 
type method '@private
Outer0 _private(Library^_binaryRepr3'@consistent
) 
Varresult0:{
type method 
mut Outer0 #apply(Outer2::S^inner'@consistent
) 
mut method '@consistent
Void inner(Outer2::S that) 
mut method '@consistent
Outer2::S #inner() 
read method '@consistent
Outer2::S inner() }
Vari0:{
type method 
mut Outer0 #apply(Outer2::N^inner'@consistent
) 
mut method '@consistent
Void inner(Outer2::N that) 
mut method '@consistent
Outer2::N #inner() 
read method '@consistent
Outer2::N inner() }
type method 
Outer0 #stringParser(Library that) Outer0._private(_binaryRepr3:that)
method 
Library binaryRepr() this._binaryRepr3()
ToS:{interface 
method 
Outer2::S toS() }
method toS() this
method 
Outer1::S #plusplus(Outer0::ToS that) Outer1::S.#stringParser(that:using Outer1::Alu check stringConcat(s1:this.binaryRepr(), s2:that.toS().binaryRepr()) error void)
method 
Outer1::Bool #bangequal(Outer1::S that) this.#equalequal(that:that).#bang()
method 
Outer1::Bool #equalequal(Outer1::S that) (
  Void unused=(
    Void unused0=using Outer1::Alu check ifStringEqualDo(s1:this.binaryRepr(), s2:that.binaryRepr()) return Outer1::Bool.true()
    Void unused1=return Outer1::Bool.false()
    void
    )
  catch return result (
    on Outer1::Bool result
    )
  error {'@stringU
  'CurlyBlock-Should be unreachable code
  }
  )
method 
Outer1::S #apply(Outer1::N that) Outer1::S.#stringParser(that:using Outer1::Alu check stringCharAt(that:this.binaryRepr(), pos:that.binaryRepr()) error void)
method 
Outer1::N size() Outer1::N.#apply(binaryRepr:using Outer1::Alu check stringSize(that:this.binaryRepr()) error void)
type method 
Outer1::S doubleQuote() Outer1::S.#stringParser(that:{'@stringU
'"\u000a
}).#apply(that:Outer1::N.#numberParser(that:{'@stringU
'0
}))
method 
Outer1::S replace(Outer1::S that, Outer1::S into) (
  Void unused=('that must be of size 1
  
    Outer1::N i=Outer1::N.#numberParser(that:{'@stringU
    '0
    })
    Outer1::S result=Outer1::S.#stringParser(that:{'@stringU
    })
    mut Outer0::Vari0 vari=Outer0::Vari0.#apply(inner:i)
    mut Outer0::Varresult0 varresult=Outer0::Varresult0.#apply(inner:result)
    Void unused0=(
      Void unused2=loop (
        Void unused3=vari.#inner().#left(that:this.size()).#checkTrue()
        (
          Void unused4=(
            Outer0::#apply(that ) ::#equalequal(that ) cond=this.#apply(that:vari.#inner()).#equalequal(that:that)
            (
              Void unused5=cond.#checkTrue()
              catch exception unused6 (
                on Void varresult.inner(that:varresult.#inner().#plusplus(that:this.#apply(that:vari.#inner())))
                )
              varresult.inner(that:varresult.#inner().#plusplus(that:into))
              )
            )
          vari.inner(that:vari.#inner().#plus(that:Outer1::N.#numberParser(that:{'@stringU
          '1
          })))
          )
        )
      catch exception unused7 (
        on Void void
        )
      void
      )
    Void unused1=return varresult.#inner()
    void
    )
  catch return result0 (
    on Outer1::S result0
    )
  error {'@stringU
  'CurlyBlock-Should be unreachable code
  }
  )}
Debug:{
type method '@private
Outer0 _private() 
type method 
Void #apply(Outer1::S that) using Outer1::Alu check stringDebug(that:that.binaryRepr()) void
type method 
Void #apply(Outer1::S fileName, Outer1::S content) using Outer1::Alu check fileDebug(fileName:fileName.binaryRepr(), content:content.binaryRepr()) void}
IntrospectionPlugin:{'@plugin
'L42.is/connected/withItself

type method '@private
Outer0 _private() 
type method 
Library sumLib(Library l1, Library l2) using Outer0 check sumLib(l1:l1, l2:l2) error {
type method 
Outer0 sumLib() }
type method 
Library adaptLib(Library l1, Library l2) using Outer0 check adaptLib(l1:l1, l2:l2) error {
type method 
Outer0 adaptLib() }
type method 
Library nameToAdapter(Library that) using Outer0 check nameToAdapter(that:that) error {
type method 
Outer0 nameToAdapter() }
type method 
Library typeNameToAdapter(type Any that) using Outer0 check typeNameToAdapter(that:that) error {
type method 
Outer0 typeNameToAdapter() }
type method 
Library getFreshName(Library that) using Outer0 check getFreshName(that:that) error {
type method 
Outer0 getFreshName() }
type method 
Library adapter(type Any that, Outer1::S name) (
  Void unused=(
    Outer1::IntrospectionPlugin::typeNameToAdapter(that ) name1=Outer1::IntrospectionPlugin.typeNameToAdapter(that:that)
    Outer1::IntrospectionPlugin::nameToAdapter(that ) name2=Outer1::IntrospectionPlugin.nameToAdapter(that:name.binaryRepr())
    Void unused0=return Outer1::IntrospectionPlugin.adaptLib(l1:name1, l2:name2)
    void
    )
  catch return result (
    on Library result
    )
  error {'@stringU
  'CurlyBlock-Should be unreachable code
  }
  )
type method 
Library adapter(Outer1::S nameDest, Outer1::S nameSrc) (
  Void unused=(
    Outer1::IntrospectionPlugin::nameToAdapter(that ) name1=Outer1::IntrospectionPlugin.nameToAdapter(that:nameDest.binaryRepr())
    Outer1::IntrospectionPlugin::nameToAdapter(that ) name2=Outer1::IntrospectionPlugin.nameToAdapter(that:nameSrc.binaryRepr())
    Void unused0=return Outer1::IntrospectionPlugin.adaptLib(l1:name1, l2:name2)
    void
    )
  catch return result (
    on Library result
    )
  error {'@stringU
  'CurlyBlock-Should be unreachable code
  }
  )}
Collections:{
ListCode:{
type method 
Library #apply() {' generic linked list class, elements of type Elem

Varres1:{
type method 
mut Outer0 #apply(Outer1^inner'@consistent
) 
mut method '@consistent
Void inner(Outer1 that) 
mut method '@consistent
Outer1 #inner() 
read method '@consistent
Outer1 inner() }
Varres2:{
type method 
mut Outer0 #apply(Outer1::#apply() ^inner'@consistent
) 
mut method '@consistent
Void inner(Outer1::#apply() that) 
mut method '@consistent
Outer1::#apply() #inner() }
type method 
Outer0 _new(Outer0::Cell^head'@consistent
) 
mut method '@consistent
Outer0::Cell #head() 
read method '@consistent
Outer0::Cell head() 
type method 
Outer0 #apply() Outer0._new(head:Outer0::CellEnd.#apply())
method 
Outer3::Bool isEmpty() (
  Void unused=(
    Void unused0=(
      Outer0::head() x=this.head()
      (
        Outer0::CellEnd x0=(
          Void unused1=return x
          catch return casted (
            on Outer0::CellEnd casted
            
            on Any exception void
            )
          error {'@stringU
          'CastT-Should be unreachable code
          }
          )
        catch exception unused2 (
          on Void return Outer3::Bool.false()
          )
        (
          Void unused3=return Outer3::Bool.true()
          void
          )
        )
      )
    void
    )
  catch return result (
    on Outer3::Bool result
    )
  error {'@stringU
  'CurlyBlock-Should be unreachable code
  }
  )
method 
Outer0::Elem top() this.head().#inner()
method 
mut Outer0::Iterator vals() this.head().vals(terminate:Outer3::Bool.true())
method 
mut Outer0::Iterator valsCut() this.head().vals(terminate:Outer3::Bool.false())
method 
Outer0 pop() (
  Void unused=(
    Void unused0=return Outer0._new(head:this.head().#next())
    catch exception unused1 (
      on Void error Outer3::S.#stringParser(that:{'@stringU
      'PopOnEmpyList
      })
      )
    void
    )
  catch return result (
    on Outer0 result
    )
  error {'@stringU
  'CurlyBlock-Should be unreachable code
  }
  )
method 
Outer0 #plusplus(Outer0 that) (
  Void unused=(
    Outer0 res=this
    mut Outer0::Varres1 varres=Outer0::Varres1.#apply(inner:res)
    Void unused0=(
      Outer0::vals() e=that.vals()
      (
        Void unused2=(
          Void unused3=(
            Void unused4=loop (
              Void unused5=e.#next()
              catch exception unused6 (
                on Void (
                  Void unused7=(
                    Void unused8=e.#checkEnd()
                    catch exception unused9 (
                      on Void void
                      )
                    void
                    )
                  exception void
                  )
                )
              varres.inner(that:varres.#inner().#add(that:e.#inner()))
              )
            catch exception unused10 (
              on Void void
              )
            void
            )
          catch exception propagated (
            on Any (
              Void unused11=e.#close()
              exception propagated
              )
            )
          void
          )
        catch return propagated0 (
          on Outer0 (
            Void unused12=e.#close()
            return propagated0
            )
          )
        e.#close()
        )
      )
    Void unused1=return varres.#inner()
    void
    )
  catch return result (
    on Outer0 result
    )
  error {'@stringU
  'CurlyBlock-Should be unreachable code
  }
  )
type method 
Outer0 #begin() Outer0.#apply()
method 
Outer0 #add(Outer0::Elem that) Outer0._new(head:Outer0::CellNext.#apply(elem:that, nextCell:this.head()))
method 
Outer0 #end() (
  Outer0::#apply() res=Outer0.#apply()
  mut Outer0::Varres2 varres=Outer0::Varres2.#apply(inner:res)
  Void unused=(
    Outer0::vals() elem=this.vals()
    (
      Void unused0=(
        Void unused1=(
          Void unused2=loop (
            Void unused3=elem.#next()
            catch exception unused4 (
              on Void (
                Void unused5=(
                  Void unused6=elem.#checkEnd()
                  catch exception unused7 (
                    on Void void
                    )
                  void
                  )
                exception void
                )
              )
            varres.inner(that:varres.#inner().#add(that:elem.#inner()))
            )
          catch exception unused8 (
            on Void void
            )
          void
          )
        catch exception propagated (
          on Any (
            Void unused9=elem.#close()
            exception propagated
            )
          )
        void
        )
      catch return propagated0 (
        on Any (
          Void unused10=elem.#close()
          return propagated0
          )
        )
      elem.#close()
      )
    )
  varres.#inner()
  )
Elem:{}
Cell:{interface 
method 
mut Outer1::Iterator vals(Outer4::Bool terminate) 
method 
Outer1::Cell #next() exception Void 
method 
Outer1::Elem #inner() 
method 
Void #checkEnd() }
CellEnd:{<:Outer1::Cell
type method 
Outer0 #apply() 
method vals(terminate ) Outer1::Iterator.#apply(that:this, terminate:terminate)
method #next() exception void
method #inner() error Outer4::S.#stringParser(that:{'@stringU
'InnerOnCellEnd, should not happen
})
method #checkEnd() void}
CellNext:{<:Outer1::Cell
type method 
Outer0 #apply(Outer1::Elem^elem'@consistent
, Outer1::Cell^nextCell'@consistent
) 
mut method '@consistent
Outer1::Elem #elem() 
read method '@consistent
Outer1::Elem elem() 
mut method '@consistent
Outer1::Cell #nextCell() 
read method '@consistent
Outer1::Cell nextCell() 
method vals(terminate ) (
  Void unused=(
    Outer1::CellNext::#apply(elem nextCell ) startPoint=Outer1::CellNext.#apply(elem:this.elem(), nextCell:this)
    Void unused0=return Outer1::Iterator.#apply(that:startPoint, terminate:terminate)
    void
    )
  catch return result (
    on Outer0::vals(terminate ) result
    )
  error {'@stringU
  'CurlyBlock-Should be unreachable code
  }
  )
method #next() this.nextCell()
method #inner() this.elem()
method #checkEnd() (
  Outer0::#checkEnd() ::this::nextCell() cell=this.nextCell()
  (
    Outer1::CellNext cell0=(
      Void unused=return cell
      catch return casted (
        on Outer1::CellNext casted
        
        on Any exception void
        )
      error {'@stringU
      'CastT-Should be unreachable code
      }
      )
    catch exception unused0 (
      on Void void
      )
    (
      Void unused1=error Outer4::S.#stringParser(that:{'@stringU
      'IterationNotComplete,\u000a  use valsCut() to allows incomplete iterations\u000a
      })
      void
      )
    )
  )}
Iterator:{
type method 
mut Outer0 #apply(Outer1::Cell^that'@consistent
, Outer4::Bool^terminate'@consistent
) 
mut method '@consistent
Void that(Outer1::Cell that) 
mut method '@consistent
Outer1::Cell #that() 
read method '@consistent
Outer1::Cell that() 
mut method '@consistent
Outer4::Bool #terminate() 
read method '@consistent
Outer4::Bool terminate() 
mut method 
Void #next() exception Void (
  Void unused=(
    Outer0::that() ::#next() x=this.that().#next()
    Void unused0=(
      Outer1::CellEnd x0=(
        Void unused2=return x
        catch return casted (
          on Outer1::CellEnd casted
          
          on Any exception void
          )
        error {'@stringU
        'CastT-Should be unreachable code
        }
        )
      catch exception unused3 (
        on Void void
        )
      (
        Void unused4=exception void
        void
        )
      )
    Void unused1=return this.that(that:x)
    void
    )
  catch return result (
    on Void result
    )
  error {'@stringU
  'CurlyBlock-Should be unreachable code
  }
  )
read method 
Void #checkEnd() (
  Outer0::terminate() cond=this.terminate()
  (
    Void unused=cond.#checkTrue()
    catch exception unused0 (
      on Void void
      )
    this.that().#checkEnd()
    )
  )
read method 
Outer1::Elem #inner() this.that().#inner()
read method 
Void #close() void}}
type method '@private
Outer0 _private() }
type method '@private
Outer0 _private() 
type method 
Library list(type Any that) (
  Void unused=(
    Outer1::IntrospectionPlugin::typeNameToAdapter(that ) map=Outer1::IntrospectionPlugin.typeNameToAdapter(that:that)
    Outer1::IntrospectionPlugin::nameToAdapter(that ) tRen=Outer1::IntrospectionPlugin.nameToAdapter(that:Outer1::S.#stringParser(that:{'@stringU
    'Elem
    }).binaryRepr())
    Void unused0=return this.list(adapter:Outer1::IntrospectionPlugin.adaptLib(l1:map, l2:tRen))
    void
    )
  catch return result (
    on Library result
    )
  error {'@stringU
  'CurlyBlock-Should be unreachable code
  }
  )
type method 
Library list(Library adapter) Outer1::IntrospectionPlugin.adaptLib(l1:Outer0::ListCode.#apply(), l2:adapter)}
Name:{
type method 'external is "pointing out"
'internal is " A::B::C"
'not external and not internal is a method name
Outer0 #apply(Outer1::Bool^isExternal'@consistent
, Library^adapter'@consistent
) 
mut method '@consistent
Outer1::Bool #isExternal() 
read method '@consistent
Outer1::Bool isExternal() 
mut method '@consistent
Library #adapter() 
read method '@consistent
Library adapter() 
type method 
Outer1::Name #stringParser(Library that) Outer1::Name.#apply(isExternal:Outer1::Bool.false(), adapter:using Outer1::IntrospectionPlugin check nameToAdapter(that:that) error {
type method 
Outer0 nameToAdapter() })
type method 
Outer1::Name #apply(type Any that) Outer1::Name.#apply(isExternal:Outer1::Bool.true(), adapter:using Outer1::IntrospectionPlugin check typeNameToAdapter(that:that) error {
type method 
Outer0 typeNameToAdapter() })
method 
Outer1::Bool isInternalPath() (
  Void unused=(
    Outer1::Introspection::#apply(that node ) ::methods() ms=Outer1::Introspection.#apply(that:this.adapter(), node:Outer1::S.#stringParser(that:{'@stringU
    '%o_0%
    })).methods()
    Void unused0=return ms.isEmpty()
    void
    )
  catch return result (
    on Outer1::Bool result
    )
  error {'@stringU
  'CurlyBlock-Should be unreachable code
  }
  )}
Introspection:{
VarmNum:{
type method 
mut Outer0 #apply(Outer2::N^inner'@consistent
) 
mut method '@consistent
Void inner(Outer2::N that) 
mut method '@consistent
Outer2::N #inner() 
read method '@consistent
Outer2::N inner() }
Varms:{
type method 
mut Outer0 #apply(Outer1::Methods^inner'@consistent
) 
mut method '@consistent
Void inner(Outer1::Methods that) 
mut method '@consistent
Outer1::Methods #inner() 
read method '@consistent
Outer1::Methods inner() }
type method 
Outer0 #apply(Library^that'@consistent
, Outer1::S^node'@consistent
) 
mut method '@consistent
Library #that() 
read method '@consistent
Library that() 
mut method '@consistent
Outer1::S #node() 
read method '@consistent
Outer1::S node() 
type method 
Outer0 #apply(Library that) Outer0.#apply(that:that, node:Outer1::S.#stringParser(that:{'@stringU
'Outer0
}))
method 
Outer1::S get() Outer1::S.#stringParser(that:using Outer1::IntrospectionPlugin check get(that:this.that(), node:this.node().binaryRepr()) error {
type method 
Outer0 getThatNode() })
method 
Library getIfExists(Outer1::N interfaceNum) exception Void using Outer1::IntrospectionPlugin check getOrElse(that:this.that(), interfaceNum:interfaceNum.binaryRepr(), node:this.node().binaryRepr()) exception void
method 
Outer0::Method get(Outer1::N methodNum) exception Void (
  Void unused=(
    Library name=using Outer1::IntrospectionPlugin check getNameOrElse(that:this.that(), methodNum:methodNum.binaryRepr(), node:this.node().binaryRepr()) exception void
    Void unused0=return Outer0::Method.#apply(myClass:this, num:methodNum, name:Outer1::S.#stringParser(that:name))
    void
    )
  catch return result (
    on Outer0::Method result
    )
  error {'@stringU
  'CurlyBlock-Should be unreachable code
  }
  )
Method:{
VarpNum:{
type method 
mut Outer0 #apply(Outer3::N::#numberParser(that ) ^inner'@consistent
) 
mut method '@consistent
Void inner(Outer3::N::#numberParser(that ) that) 
mut method '@consistent
Outer3::N::#numberParser(that ) #inner() }
Varps:{
type method 
mut Outer0 #apply(Outer2::Parameters::#begin() ::#end() ^inner'@consistent
) 
mut method '@consistent
Void inner(Outer2::Parameters::#begin() ::#end() that) 
mut method '@consistent
Outer2::Parameters::#begin() ::#end() #inner() }
type method 
Outer0 #apply(Outer1^myClass'@consistent
, Outer2::N^num'@consistent
, Outer2::S^name'@consistent
) 
mut method '@consistent
Outer1 #myClass() 
read method '@consistent
Outer1 myClass() 
mut method '@consistent
Outer2::N #num() 
read method '@consistent
Outer2::N num() 
mut method '@consistent
Outer2::S #name() 
read method '@consistent
Outer2::S name() 
method 
Outer2::S get() Outer2::S.#stringParser(that:using Outer2::IntrospectionPlugin check getOrElse(that:this.myClass().that(), methodNum:this.num().binaryRepr(), node:this.myClass().node().binaryRepr()) error {
type method 
Outer0 invalidMethodNumber() })
method 
Outer2::S getMdf() Outer2::S.#stringParser(that:using Outer2::IntrospectionPlugin check getMdfOrElse(that:this.myClass().that(), methodNum:this.num().binaryRepr(), node:this.myClass().node().binaryRepr()) error {
type method 
Outer0 invalidMethodNumber() })
method 
Outer2::Name returnClass() Outer2::Name.#apply(isExternal:Outer2::Bool.true(), adapter:using Outer2::IntrospectionPlugin check getTypePathOrElse(that:this.myClass().that(), methodNum:this.num().binaryRepr(), node:this.myClass().node().binaryRepr()) error {
type method 
Outer0 invalidMethodNumber() })
method 
Outer2::Name getName() Outer2::Name.#stringParser('get name? unuseful!
that:using Outer2::IntrospectionPlugin check getNameOrElse(that:this.myClass().that(), methodNum:this.num().binaryRepr(), node:this.myClass().node().binaryRepr()) error {
type method 
Outer0 invalidMethodNumber() })
method 
Outer2::Bool isField() (
  Void unused=(
    Void unused0=using Outer2::IntrospectionPlugin check ifIsFieldDo(that:this.myClass().that(), methodNum:this.num().binaryRepr(), node:this.myClass().node().binaryRepr()) return Outer2::Bool.true()
    Void unused1=return Outer2::Bool.false()
    void
    )
  catch return result (
    on Outer2::Bool result
    )
  error {'@stringU
  'CurlyBlock-Should be unreachable code
  }
  )
method 
Outer1::Parameter get(Outer2::N parameterNum) exception Void (
  Void unused=(
    Library name=using Outer2::IntrospectionPlugin check getNameOrElse(that:this.myClass().that(), methodNum:this.num().binaryRepr(), parameterNum:parameterNum.binaryRepr(), node:this.myClass().node().binaryRepr()) exception void
    Void unused0=return Outer1::Parameter.#apply(myMethod:this, num:parameterNum, name:Outer2::S.#stringParser(that:name))
    void
    )
  catch return result (
    on Outer1::Parameter result
    )
  error {'@stringU
  'CurlyBlock-Should be unreachable code
  }
  )
method 
Outer1::Parameters parameters() (
  Void unused=(
    Outer1::Parameters::#begin() ::#end() ps=Outer1::Parameters.#begin().#end()
    Outer2::N::#numberParser(that ) pNum=Outer2::N.#numberParser(that:{'@stringU
    '0
    })
    mut Outer0::Varps varps=Outer0::Varps.#apply(inner:ps)
    mut Outer0::VarpNum varpNum=Outer0::VarpNum.#apply(inner:pNum)
    Void unused0=(
      Void unused2=loop (
        Void unused3=Outer2::Bool.true().#checkTrue()
        (
          Void unused4=varps.inner(that:varps.#inner().#add(that:this.get(parameterNum:varpNum.#inner())))
          varpNum.inner(that:varpNum.#inner().#plus(that:Outer2::N.#numberParser(that:{'@stringU
          '1
          })))
          )
        )
      catch exception unused5 (
        on Void void
        )
      void
      )
    Void unused1=return varps.#inner()
    void
    )
  catch return result (
    on Outer1::Parameters result
    )
  error {'@stringU
  'CurlyBlock-Should be unreachable code
  }
  )}
Parameter:{
type method 
Outer0 #apply(Outer1::Method^myMethod'@consistent
, Outer2::N^num'@consistent
, Outer2::S^name'@consistent
) 
mut method '@consistent
Outer1::Method #myMethod() 
read method '@consistent
Outer1::Method myMethod() 
mut method '@consistent
Outer2::N #num() 
read method '@consistent
Outer2::N num() 
mut method '@consistent
Outer2::S #name() 
read method '@consistent
Outer2::S name() 
method 
Outer2::Name class() Outer2::Name.#apply(isExternal:Outer2::Bool.true(), adapter:using Outer2::IntrospectionPlugin check getTypePathOrElse(that:this.myMethod().myClass().that(), methodNum:this.myMethod().num().binaryRepr(), parameterNum:this.num().binaryRepr(), node:this.myMethod().myClass().node().binaryRepr()) error {
type method 
Outer0 invalidMethodNumber() })}
Parameters:{' generic linked list class, elements of type Elem

Varres1:{
type method 
mut Outer0 #apply(Outer1^inner'@consistent
) 
mut method '@consistent
Void inner(Outer1 that) 
mut method '@consistent
Outer1 #inner() 
read method '@consistent
Outer1 inner() }
Varres2:{
type method 
mut Outer0 #apply(Outer1::#apply() ^inner'@consistent
) 
mut method '@consistent
Void inner(Outer1::#apply() that) 
mut method '@consistent
Outer1::#apply() #inner() }
type method 
Outer0 _new(Outer0::Cell^head'@consistent
) 
mut method '@consistent
Outer0::Cell #head() 
read method '@consistent
Outer0::Cell head() 
type method 
Outer0 #apply() Outer0._new(head:Outer0::CellEnd.#apply())
method 
Outer2::Bool isEmpty() (
  Void unused=(
    Void unused0=(
      Outer0::head() x=this.head()
      (
        Outer0::CellEnd x0=(
          Void unused1=return x
          catch return casted (
            on Outer0::CellEnd casted
            
            on Any exception void
            )
          error {'@stringU
          'CastT-Should be unreachable code
          }
          )
        catch exception unused2 (
          on Void return Outer2::Bool.false()
          )
        (
          Void unused3=return Outer2::Bool.true()
          void
          )
        )
      )
    void
    )
  catch return result (
    on Outer2::Bool result
    )
  error {'@stringU
  'CurlyBlock-Should be unreachable code
  }
  )
method 
Outer1::Parameter top() this.head().#inner()
method 
mut Outer0::Iterator vals() this.head().vals(terminate:Outer2::Bool.true())
method 
mut Outer0::Iterator valsCut() this.head().vals(terminate:Outer2::Bool.false())
method 
Outer0 pop() (
  Void unused=(
    Void unused0=return Outer0._new(head:this.head().#next())
    catch exception unused1 (
      on Void error Outer2::S.#stringParser(that:{'@stringU
      'PopOnEmpyList
      })
      )
    void
    )
  catch return result (
    on Outer0 result
    )
  error {'@stringU
  'CurlyBlock-Should be unreachable code
  }
  )
method 
Outer0 #plusplus(Outer0 that) (
  Void unused=(
    Outer0 res=this
    mut Outer0::Varres1 varres=Outer0::Varres1.#apply(inner:res)
    Void unused0=(
      Outer0::vals() e=that.vals()
      (
        Void unused2=(
          Void unused3=(
            Void unused4=loop (
              Void unused5=e.#next()
              catch exception unused6 (
                on Void (
                  Void unused7=(
                    Void unused8=e.#checkEnd()
                    catch exception unused9 (
                      on Void void
                      )
                    void
                    )
                  exception void
                  )
                )
              varres.inner(that:varres.#inner().#add(that:e.#inner()))
              )
            catch exception unused10 (
              on Void void
              )
            void
            )
          catch exception propagated (
            on Any (
              Void unused11=e.#close()
              exception propagated
              )
            )
          void
          )
        catch return propagated0 (
          on Outer0 (
            Void unused12=e.#close()
            return propagated0
            )
          )
        e.#close()
        )
      )
    Void unused1=return varres.#inner()
    void
    )
  catch return result (
    on Outer0 result
    )
  error {'@stringU
  'CurlyBlock-Should be unreachable code
  }
  )
type method 
Outer0 #begin() Outer0.#apply()
method 
Outer0 #add(Outer1::Parameter that) Outer0._new(head:Outer0::CellNext.#apply(elem:that, nextCell:this.head()))
method 
Outer0 #end() (
  Outer0::#apply() res=Outer0.#apply()
  mut Outer0::Varres2 varres=Outer0::Varres2.#apply(inner:res)
  Void unused=(
    Outer0::vals() elem=this.vals()
    (
      Void unused0=(
        Void unused1=(
          Void unused2=loop (
            Void unused3=elem.#next()
            catch exception unused4 (
              on Void (
                Void unused5=(
                  Void unused6=elem.#checkEnd()
                  catch exception unused7 (
                    on Void void
                    )
                  void
                  )
                exception void
                )
              )
            varres.inner(that:varres.#inner().#add(that:elem.#inner()))
            )
          catch exception unused8 (
            on Void void
            )
          void
          )
        catch exception propagated (
          on Any (
            Void unused9=elem.#close()
            exception propagated
            )
          )
        void
        )
      catch return propagated0 (
        on Any (
          Void unused10=elem.#close()
          return propagated0
          )
        )
      elem.#close()
      )
    )
  varres.#inner()
  )
Cell:{interface 
method 
mut Outer1::Iterator vals(Outer3::Bool terminate) 
method 
Outer1::Cell #next() exception Void 
method 
Outer2::Parameter #inner() 
method 
Void #checkEnd() }
CellEnd:{<:Outer1::Cell
type method 
Outer0 #apply() 
method vals(terminate ) Outer1::Iterator.#apply(that:this, terminate:terminate)
method #next() exception void
method #inner() error Outer3::S.#stringParser(that:{'@stringU
'InnerOnCellEnd, should not happen
})
method #checkEnd() void}
CellNext:{<:Outer1::Cell
type method 
Outer0 #apply(Outer2::Parameter^elem'@consistent
, Outer1::Cell^nextCell'@consistent
) 
mut method '@consistent
Outer2::Parameter #elem() 
read method '@consistent
Outer2::Parameter elem() 
mut method '@consistent
Outer1::Cell #nextCell() 
read method '@consistent
Outer1::Cell nextCell() 
method vals(terminate ) (
  Void unused=(
    Outer1::CellNext::#apply(elem nextCell ) startPoint=Outer1::CellNext.#apply(elem:this.elem(), nextCell:this)
    Void unused0=return Outer1::Iterator.#apply(that:startPoint, terminate:terminate)
    void
    )
  catch return result (
    on Outer0::vals(terminate ) result
    )
  error {'@stringU
  'CurlyBlock-Should be unreachable code
  }
  )
method #next() this.nextCell()
method #inner() this.elem()
method #checkEnd() (
  Outer0::#checkEnd() ::this::nextCell() cell=this.nextCell()
  (
    Outer1::CellNext cell0=(
      Void unused=return cell
      catch return casted (
        on Outer1::CellNext casted
        
        on Any exception void
        )
      error {'@stringU
      'CastT-Should be unreachable code
      }
      )
    catch exception unused0 (
      on Void void
      )
    (
      Void unused1=error Outer3::S.#stringParser(that:{'@stringU
      'IterationNotComplete,\u000a  use valsCut() to allows incomplete iterations\u000a
      })
      void
      )
    )
  )}
Iterator:{
type method 
mut Outer0 #apply(Outer1::Cell^that'@consistent
, Outer3::Bool^terminate'@consistent
) 
mut method '@consistent
Void that(Outer1::Cell that) 
mut method '@consistent
Outer1::Cell #that() 
read method '@consistent
Outer1::Cell that() 
mut method '@consistent
Outer3::Bool #terminate() 
read method '@consistent
Outer3::Bool terminate() 
mut method 
Void #next() exception Void (
  Void unused=(
    Outer0::that() ::#next() x=this.that().#next()
    Void unused0=(
      Outer1::CellEnd x0=(
        Void unused2=return x
        catch return casted (
          on Outer1::CellEnd casted
          
          on Any exception void
          )
        error {'@stringU
        'CastT-Should be unreachable code
        }
        )
      catch exception unused3 (
        on Void void
        )
      (
        Void unused4=exception void
        void
        )
      )
    Void unused1=return this.that(that:x)
    void
    )
  catch return result (
    on Void result
    )
  error {'@stringU
  'CurlyBlock-Should be unreachable code
  }
  )
read method 
Void #checkEnd() (
  Outer0::terminate() cond=this.terminate()
  (
    Void unused=cond.#checkTrue()
    catch exception unused0 (
      on Void void
      )
    this.that().#checkEnd()
    )
  )
read method 
Outer2::Parameter #inner() this.that().#inner()
read method 
Void #close() void}}
Methods:{' generic linked list class, elements of type Elem

Varres1:{
type method 
mut Outer0 #apply(Outer1^inner'@consistent
) 
mut method '@consistent
Void inner(Outer1 that) 
mut method '@consistent
Outer1 #inner() 
read method '@consistent
Outer1 inner() }
Varres2:{
type method 
mut Outer0 #apply(Outer1::#apply() ^inner'@consistent
) 
mut method '@consistent
Void inner(Outer1::#apply() that) 
mut method '@consistent
Outer1::#apply() #inner() }
type method 
Outer0 _new(Outer0::Cell^head'@consistent
) 
mut method '@consistent
Outer0::Cell #head() 
read method '@consistent
Outer0::Cell head() 
type method 
Outer0 #apply() Outer0._new(head:Outer0::CellEnd.#apply())
method 
Outer2::Bool isEmpty() (
  Void unused=(
    Void unused0=(
      Outer0::head() x=this.head()
      (
        Outer0::CellEnd x0=(
          Void unused1=return x
          catch return casted (
            on Outer0::CellEnd casted
            
            on Any exception void
            )
          error {'@stringU
          'CastT-Should be unreachable code
          }
          )
        catch exception unused2 (
          on Void return Outer2::Bool.false()
          )
        (
          Void unused3=return Outer2::Bool.true()
          void
          )
        )
      )
    void
    )
  catch return result (
    on Outer2::Bool result
    )
  error {'@stringU
  'CurlyBlock-Should be unreachable code
  }
  )
method 
Outer1::Method top() this.head().#inner()
method 
mut Outer0::Iterator vals() this.head().vals(terminate:Outer2::Bool.true())
method 
mut Outer0::Iterator valsCut() this.head().vals(terminate:Outer2::Bool.false())
method 
Outer0 pop() (
  Void unused=(
    Void unused0=return Outer0._new(head:this.head().#next())
    catch exception unused1 (
      on Void error Outer2::S.#stringParser(that:{'@stringU
      'PopOnEmpyList
      })
      )
    void
    )
  catch return result (
    on Outer0 result
    )
  error {'@stringU
  'CurlyBlock-Should be unreachable code
  }
  )
method 
Outer0 #plusplus(Outer0 that) (
  Void unused=(
    Outer0 res=this
    mut Outer0::Varres1 varres=Outer0::Varres1.#apply(inner:res)
    Void unused0=(
      Outer0::vals() e=that.vals()
      (
        Void unused2=(
          Void unused3=(
            Void unused4=loop (
              Void unused5=e.#next()
              catch exception unused6 (
                on Void (
                  Void unused7=(
                    Void unused8=e.#checkEnd()
                    catch exception unused9 (
                      on Void void
                      )
                    void
                    )
                  exception void
                  )
                )
              varres.inner(that:varres.#inner().#add(that:e.#inner()))
              )
            catch exception unused10 (
              on Void void
              )
            void
            )
          catch exception propagated (
            on Any (
              Void unused11=e.#close()
              exception propagated
              )
            )
          void
          )
        catch return propagated0 (
          on Outer0 (
            Void unused12=e.#close()
            return propagated0
            )
          )
        e.#close()
        )
      )
    Void unused1=return varres.#inner()
    void
    )
  catch return result (
    on Outer0 result
    )
  error {'@stringU
  'CurlyBlock-Should be unreachable code
  }
  )
type method 
Outer0 #begin() Outer0.#apply()
method 
Outer0 #add(Outer1::Method that) Outer0._new(head:Outer0::CellNext.#apply(elem:that, nextCell:this.head()))
method 
Outer0 #end() (
  Outer0::#apply() res=Outer0.#apply()
  mut Outer0::Varres2 varres=Outer0::Varres2.#apply(inner:res)
  Void unused=(
    Outer0::vals() elem=this.vals()
    (
      Void unused0=(
        Void unused1=(
          Void unused2=loop (
            Void unused3=elem.#next()
            catch exception unused4 (
              on Void (
                Void unused5=(
                  Void unused6=elem.#checkEnd()
                  catch exception unused7 (
                    on Void void
                    )
                  void
                  )
                exception void
                )
              )
            varres.inner(that:varres.#inner().#add(that:elem.#inner()))
            )
          catch exception unused8 (
            on Void void
            )
          void
          )
        catch exception propagated (
          on Any (
            Void unused9=elem.#close()
            exception propagated
            )
          )
        void
        )
      catch return propagated0 (
        on Any (
          Void unused10=elem.#close()
          return propagated0
          )
        )
      elem.#close()
      )
    )
  varres.#inner()
  )
Cell:{interface 
method 
mut Outer1::Iterator vals(Outer3::Bool terminate) 
method 
Outer1::Cell #next() exception Void 
method 
Outer2::Method #inner() 
method 
Void #checkEnd() }
CellEnd:{<:Outer1::Cell
type method 
Outer0 #apply() 
method vals(terminate ) Outer1::Iterator.#apply(that:this, terminate:terminate)
method #next() exception void
method #inner() error Outer3::S.#stringParser(that:{'@stringU
'InnerOnCellEnd, should not happen
})
method #checkEnd() void}
CellNext:{<:Outer1::Cell
type method 
Outer0 #apply(Outer2::Method^elem'@consistent
, Outer1::Cell^nextCell'@consistent
) 
mut method '@consistent
Outer2::Method #elem() 
read method '@consistent
Outer2::Method elem() 
mut method '@consistent
Outer1::Cell #nextCell() 
read method '@consistent
Outer1::Cell nextCell() 
method vals(terminate ) (
  Void unused=(
    Outer1::CellNext::#apply(elem nextCell ) startPoint=Outer1::CellNext.#apply(elem:this.elem(), nextCell:this)
    Void unused0=return Outer1::Iterator.#apply(that:startPoint, terminate:terminate)
    void
    )
  catch return result (
    on Outer0::vals(terminate ) result
    )
  error {'@stringU
  'CurlyBlock-Should be unreachable code
  }
  )
method #next() this.nextCell()
method #inner() this.elem()
method #checkEnd() (
  Outer0::#checkEnd() ::this::nextCell() cell=this.nextCell()
  (
    Outer1::CellNext cell0=(
      Void unused=return cell
      catch return casted (
        on Outer1::CellNext casted
        
        on Any exception void
        )
      error {'@stringU
      'CastT-Should be unreachable code
      }
      )
    catch exception unused0 (
      on Void void
      )
    (
      Void unused1=error Outer3::S.#stringParser(that:{'@stringU
      'IterationNotComplete,\u000a  use valsCut() to allows incomplete iterations\u000a
      })
      void
      )
    )
  )}
Iterator:{
type method 
mut Outer0 #apply(Outer1::Cell^that'@consistent
, Outer3::Bool^terminate'@consistent
) 
mut method '@consistent
Void that(Outer1::Cell that) 
mut method '@consistent
Outer1::Cell #that() 
read method '@consistent
Outer1::Cell that() 
mut method '@consistent
Outer3::Bool #terminate() 
read method '@consistent
Outer3::Bool terminate() 
mut method 
Void #next() exception Void (
  Void unused=(
    Outer0::that() ::#next() x=this.that().#next()
    Void unused0=(
      Outer1::CellEnd x0=(
        Void unused2=return x
        catch return casted (
          on Outer1::CellEnd casted
          
          on Any exception void
          )
        error {'@stringU
        'CastT-Should be unreachable code
        }
        )
      catch exception unused3 (
        on Void void
        )
      (
        Void unused4=exception void
        void
        )
      )
    Void unused1=return this.that(that:x)
    void
    )
  catch return result (
    on Void result
    )
  error {'@stringU
  'CurlyBlock-Should be unreachable code
  }
  )
read method 
Void #checkEnd() (
  Outer0::terminate() cond=this.terminate()
  (
    Void unused=cond.#checkTrue()
    catch exception unused0 (
      on Void void
      )
    this.that().#checkEnd()
    )
  )
read method 
Outer2::Method #inner() this.that().#inner()
read method 
Void #close() void}}
method 
Outer0::Methods methods() (
  Void unused=(
    Outer0::Methods ms=Outer0::Methods.#begin().#end()
    Outer1::N mNum=Outer1::N.#numberParser(that:{'@stringU
    '0
    })
    mut Outer0::Varms varms=Outer0::Varms.#apply(inner:ms)
    mut Outer0::VarmNum varmNum=Outer0::VarmNum.#apply(inner:mNum)
    Void unused0=(
      Void unused2=loop (
        Void unused3=Outer1::Bool.true().#checkTrue()
        (
          Void unused4=varms.inner(that:varms.#inner().#add(that:this.get(methodNum:varmNum.#inner())))
          varmNum.inner(that:varmNum.#inner().#plus(that:Outer1::N.#numberParser(that:{'@stringU
          '1
          })))
          )
        )
      catch exception unused5 (
        on Void void
        )
      void
      )
    Void unused1=return varms.#inner()
    void
    )
  catch return result (
    on Outer0::Methods result
    )
  error {'@stringU
  'CurlyBlock-Should be unreachable code
  }
  )
method 
Outer0::Parameters fields() (
  Void unused=(
    Outer0::methods() ms=this.methods()
    Outer0::Method ctor=(
      Void unused1=(
        Void unused2=(
          Outer0::methods() ::vals() m=ms.vals()
          (
            Void unused4=(
              Void unused5=(
                Void unused6=loop (
                  Void unused7=m.#next()
                  catch exception unused8 (
                    on Void (
                      Void unused9=(
                        Void unused10=m.#checkEnd()
                        catch exception unused11 (
                          on Void void
                          )
                        void
                        )
                      exception void
                      )
                    )
                  (
                    Outer0::methods() ::vals() ::#inner() ::isField() ::#and(that ) cond=m.#inner().isField().#and(that:m.#inner().getMdf().#equalequal(that:Outer1::S.#stringParser(that:{'@stringU
                    'Type
                    })))
                    (
                      Void unused12=cond.#checkTrue()
                      catch exception unused13 (
                        on Void void
                        )
                      return m.#inner()
                      )
                    )
                  )
                catch exception unused14 (
                  on Void void
                  )
                void
                )
              catch exception propagated (
                on Any (
                  Void unused15=m.#close()
                  exception propagated
                  )
                )
              void
              )
            catch return propagated0 (
              on Outer0::Method (
                Void unused16=m.#close()
                return propagated0
                )
              )
            m.#close()
            )
          )
        Void unused3=error Outer1::S.#stringParser(that:{'@stringU
        'Not a concrete class
        })
        void
        )
      catch return result0 (
        on Outer0::Method result0
        )
      error {'@stringU
      'CurlyBlock-Should be unreachable code
      }
      )
    Void unused0=return ctor.parameters()
    void
    )
  catch return result (
    on Outer0::Parameters result
    )
  error {'@stringU
  'CurlyBlock-Should be unreachable code
  }
  )}
Load:{
type method 
Outer0 #begin() 
method 
Outer0 #end() this
method 
Library #left(Library that) (
  Void unused=('assume that have abstract Bool N and S
  
    Void unused0=return Outer1::Adapt.#begin().#add(that:Outer1::Name.#stringParser(that:{'@stringU
    'N
    }), into:Outer1::Name.#apply(that:Outer1::N)).#add(that:Outer1::Name.#stringParser(that:{'@stringU
    'S
    }), into:Outer1::Name.#apply(that:Outer1::S)).#add(that:Outer1::Name.#stringParser(that:{'@stringU
    'S::ToS
    }), into:Outer1::Name.#apply(that:Outer1::S::ToS)).#add(that:Outer1::Name.#stringParser(that:{'@stringU
    'Bool
    }), into:Outer1::Name.#apply(that:Outer1::Bool)).#add(that:Outer1::Name.#stringParser(that:{'@stringU
    'Debug
    }), into:Outer1::Name.#apply(that:Outer1::Debug)).#end().#left(that:that)
    void
    )
  catch return result (
    on Library result
    )
  error {'@stringU
  'CurlyBlock-Should be unreachable code
  }
  )}
Opt:{
type method 
Outer0 unused() 
type method 
Library #apply(type Any that) Outer1::Adapt.#begin().#add(that:Outer1::Name.#stringParser(that:{'@stringU
'T
}), into:Outer1::Name.#apply(that:that)).#end().#left(that:{
type method 
Outer0 #new(Outer0::TOpt^that'@consistent
) 
mut method '@consistent
Outer0::TOpt #that() 
read method '@consistent
Outer0::TOpt that() 
T:{}
TOpt:{interface 
method 
Outer1::T get() }
TEmpty:{<:Outer1::TOpt
type method 
Outer0 #apply() 
method get() error Outer3::S.#stringParser(that:{'@stringU
'Value not present
})}
TOf:{<:Outer1::TOpt
type method 
Outer0 #apply(Outer1::T^that'@consistent
) 
mut method '@consistent
Outer1::T #that() 
read method '@consistent
Outer1::T that() 
method get() this.that()}
method 
Outer0::T #bang() this.that().get()
method 
Outer2::Bool isPresent() (
  Void unused=(
    Outer0::#bang() aux=this.#bang()
    Void unused0=return Outer2::Bool.true()
    catch error unused1 (
      on Any return Outer2::Bool.false()
      )
    void
    )
  catch return result (
    on Outer2::Bool result
    )
  error {'@stringU
  'CurlyBlock-Should be unreachable code
  }
  )
type method 
Outer0 #apply() Outer0.#new(that:Outer0::TEmpty.#apply())
type method 
Outer0 #apply(Outer0::T that) Outer0.#new(that:Outer0::TOf.#apply(that:that))})}
Use:{
Varresult1:{
type method 
mut Outer0 #apply(Outer1::myLibs() ::vals() ::#inner() ^inner'@consistent
) 
mut method '@consistent
Void inner(Outer1::myLibs() ::vals() ::#inner() that) 
mut method '@consistent
Outer1::myLibs() ::vals() ::#inner() #inner() }
type method 
Outer0 #apply(Outer0::Resolver^resolver'@consistent
, Outer0::Libs^myLibs'@consistent
) 
mut method '@consistent
Outer0::Resolver #resolver() 
read method '@consistent
Outer0::Resolver resolver() 
mut method '@consistent
Outer0::Libs #myLibs() 
read method '@consistent
Outer0::Libs myLibs() 
Resolver:{
type method 
Outer0 #new(Outer0::TOpt^that'@consistent
) 
mut method '@consistent
Outer0::TOpt #that() 
read method '@consistent
Outer0::TOpt that() 
TOpt:{interface 
method 
Library get() }
TEmpty:{<:Outer1::TOpt
type method 
Outer0 #apply() 
method get() error Outer3::S.#stringParser(that:{'@stringU
'Value not present
})}
TOf:{<:Outer1::TOpt
type method 
Outer0 #apply(Library^that'@consistent
) 
mut method '@consistent
Library #that() 
read method '@consistent
Library that() 
method get() this.that()}
method 
Library #bang() this.that().get()
method 
Outer2::Bool isPresent() (
  Void unused=(
    Outer0::#bang() aux=this.#bang()
    Void unused0=return Outer2::Bool.true()
    catch error unused1 (
      on Any return Outer2::Bool.false()
      )
    void
    )
  catch return result (
    on Outer2::Bool result
    )
  error {'@stringU
  'CurlyBlock-Should be unreachable code
  }
  )
type method 
Outer0 #apply() Outer0.#new(that:Outer0::TEmpty.#apply())
type method 
Outer0 #apply(Library that) Outer0.#new(that:Outer0::TOf.#apply(that:that))}
Libs:{' generic linked list class, elements of type Elem

Varres1:{
type method 
mut Outer0 #apply(Outer1^inner'@consistent
) 
mut method '@consistent
Void inner(Outer1 that) 
mut method '@consistent
Outer1 #inner() 
read method '@consistent
Outer1 inner() }
Varres2:{
type method 
mut Outer0 #apply(Outer1::#apply() ^inner'@consistent
) 
mut method '@consistent
Void inner(Outer1::#apply() that) 
mut method '@consistent
Outer1::#apply() #inner() }
type method 
Outer0 _new(Outer0::Cell^head'@consistent
) 
mut method '@consistent
Outer0::Cell #head() 
read method '@consistent
Outer0::Cell head() 
type method 
Outer0 #apply() Outer0._new(head:Outer0::CellEnd.#apply())
method 
Outer2::Bool isEmpty() (
  Void unused=(
    Void unused0=(
      Outer0::head() x=this.head()
      (
        Outer0::CellEnd x0=(
          Void unused1=return x
          catch return casted (
            on Outer0::CellEnd casted
            
            on Any exception void
            )
          error {'@stringU
          'CastT-Should be unreachable code
          }
          )
        catch exception unused2 (
          on Void return Outer2::Bool.false()
          )
        (
          Void unused3=return Outer2::Bool.true()
          void
          )
        )
      )
    void
    )
  catch return result (
    on Outer2::Bool result
    )
  error {'@stringU
  'CurlyBlock-Should be unreachable code
  }
  )
method 
Library top() this.head().#inner()
method 
mut Outer0::Iterator vals() this.head().vals(terminate:Outer2::Bool.true())
method 
mut Outer0::Iterator valsCut() this.head().vals(terminate:Outer2::Bool.false())
method 
Outer0 pop() (
  Void unused=(
    Void unused0=return Outer0._new(head:this.head().#next())
    catch exception unused1 (
      on Void error Outer2::S.#stringParser(that:{'@stringU
      'PopOnEmpyList
      })
      )
    void
    )
  catch return result (
    on Outer0 result
    )
  error {'@stringU
  'CurlyBlock-Should be unreachable code
  }
  )
method 
Outer0 #plusplus(Outer0 that) (
  Void unused=(
    Outer0 res=this
    mut Outer0::Varres1 varres=Outer0::Varres1.#apply(inner:res)
    Void unused0=(
      Outer0::vals() e=that.vals()
      (
        Void unused2=(
          Void unused3=(
            Void unused4=loop (
              Void unused5=e.#next()
              catch exception unused6 (
                on Void (
                  Void unused7=(
                    Void unused8=e.#checkEnd()
                    catch exception unused9 (
                      on Void void
                      )
                    void
                    )
                  exception void
                  )
                )
              varres.inner(that:varres.#inner().#add(that:e.#inner()))
              )
            catch exception unused10 (
              on Void void
              )
            void
            )
          catch exception propagated (
            on Any (
              Void unused11=e.#close()
              exception propagated
              )
            )
          void
          )
        catch return propagated0 (
          on Outer0 (
            Void unused12=e.#close()
            return propagated0
            )
          )
        e.#close()
        )
      )
    Void unused1=return varres.#inner()
    void
    )
  catch return result (
    on Outer0 result
    )
  error {'@stringU
  'CurlyBlock-Should be unreachable code
  }
  )
type method 
Outer0 #begin() Outer0.#apply()
method 
Outer0 #add(Library that) Outer0._new(head:Outer0::CellNext.#apply(elem:that, nextCell:this.head()))
method 
Outer0 #end() (
  Outer0::#apply() res=Outer0.#apply()
  mut Outer0::Varres2 varres=Outer0::Varres2.#apply(inner:res)
  Void unused=(
    Outer0::vals() elem=this.vals()
    (
      Void unused0=(
        Void unused1=(
          Void unused2=loop (
            Void unused3=elem.#next()
            catch exception unused4 (
              on Void (
                Void unused5=(
                  Void unused6=elem.#checkEnd()
                  catch exception unused7 (
                    on Void void
                    )
                  void
                  )
                exception void
                )
              )
            varres.inner(that:varres.#inner().#add(that:elem.#inner()))
            )
          catch exception unused8 (
            on Void void
            )
          void
          )
        catch exception propagated (
          on Any (
            Void unused9=elem.#close()
            exception propagated
            )
          )
        void
        )
      catch return propagated0 (
        on Any (
          Void unused10=elem.#close()
          return propagated0
          )
        )
      elem.#close()
      )
    )
  varres.#inner()
  )
Cell:{interface 
method 
mut Outer1::Iterator vals(Outer3::Bool terminate) 
method 
Outer1::Cell #next() exception Void 
method 
Library #inner() 
method 
Void #checkEnd() }
CellEnd:{<:Outer1::Cell
type method 
Outer0 #apply() 
method vals(terminate ) Outer1::Iterator.#apply(that:this, terminate:terminate)
method #next() exception void
method #inner() error Outer3::S.#stringParser(that:{'@stringU
'InnerOnCellEnd, should not happen
})
method #checkEnd() void}
CellNext:{<:Outer1::Cell
type method 
Outer0 #apply(Library^elem'@consistent
, Outer1::Cell^nextCell'@consistent
) 
mut method '@consistent
Library #elem() 
read method '@consistent
Library elem() 
mut method '@consistent
Outer1::Cell #nextCell() 
read method '@consistent
Outer1::Cell nextCell() 
method vals(terminate ) (
  Void unused=(
    Outer1::CellNext::#apply(elem nextCell ) startPoint=Outer1::CellNext.#apply(elem:this.elem(), nextCell:this)
    Void unused0=return Outer1::Iterator.#apply(that:startPoint, terminate:terminate)
    void
    )
  catch return result (
    on Outer0::vals(terminate ) result
    )
  error {'@stringU
  'CurlyBlock-Should be unreachable code
  }
  )
method #next() this.nextCell()
method #inner() this.elem()
method #checkEnd() (
  Outer0::#checkEnd() ::this::nextCell() cell=this.nextCell()
  (
    Outer1::CellNext cell0=(
      Void unused=return cell
      catch return casted (
        on Outer1::CellNext casted
        
        on Any exception void
        )
      error {'@stringU
      'CastT-Should be unreachable code
      }
      )
    catch exception unused0 (
      on Void void
      )
    (
      Void unused1=error Outer3::S.#stringParser(that:{'@stringU
      'IterationNotComplete,\u000a  use valsCut() to allows incomplete iterations\u000a
      })
      void
      )
    )
  )}
Iterator:{
type method 
mut Outer0 #apply(Outer1::Cell^that'@consistent
, Outer3::Bool^terminate'@consistent
) 
mut method '@consistent
Void that(Outer1::Cell that) 
mut method '@consistent
Outer1::Cell #that() 
read method '@consistent
Outer1::Cell that() 
mut method '@consistent
Outer3::Bool #terminate() 
read method '@consistent
Outer3::Bool terminate() 
mut method 
Void #next() exception Void (
  Void unused=(
    Outer0::that() ::#next() x=this.that().#next()
    Void unused0=(
      Outer1::CellEnd x0=(
        Void unused2=return x
        catch return casted (
          on Outer1::CellEnd casted
          
          on Any exception void
          )
        error {'@stringU
        'CastT-Should be unreachable code
        }
        )
      catch exception unused3 (
        on Void void
        )
      (
        Void unused4=exception void
        void
        )
      )
    Void unused1=return this.that(that:x)
    void
    )
  catch return result (
    on Void result
    )
  error {'@stringU
  'CurlyBlock-Should be unreachable code
  }
  )
read method 
Void #checkEnd() (
  Outer0::terminate() cond=this.terminate()
  (
    Void unused=cond.#checkTrue()
    catch exception unused0 (
      on Void void
      )
    this.that().#checkEnd()
    )
  )
read method 
Library #inner() this.that().#inner()
read method 
Void #close() void}}
type method 
Outer0 #apply() Outer0.#apply(resolver:Outer0::Resolver.#apply(), myLibs:Outer0::Libs.#begin().#end())
method 
Outer0 #add(Library that) (
  Outer0::myLibs() ::#add(that ) ls=this.myLibs().#add(that:that)
  Outer0.#apply(resolver:this.resolver(), myLibs:ls)
  )
method 
Outer0 #add(Library resolver) Outer0.#apply(resolver:Outer0::Resolver.#apply(that:resolver), myLibs:this.myLibs())
type method 
Outer0 #begin() Outer0.#apply()
method 
Outer0 #end() this
method 
Library #left(Library that) (
  Void unused=(
    Outer0::myLibs() ::vals() it=this.myLibs().vals()
    Void unused0=it.#next()
    catch exception unused1 (
      on Void return that
      )
    (
      Outer0::myLibs() ::vals() ::#inner() result=it.#inner()
      mut Outer0::Varresult1 varresult=Outer0::Varresult1.#apply(inner:result)
      Void unused2=(
        Outer0::myLibs() ::vals() libi=it
        (
          Void unused4=(
            Void unused5=(
              Void unused6=loop (
                Void unused7=libi.#next()
                catch exception unused8 (
                  on Void (
                    Void unused9=(
                      Void unused10=libi.#checkEnd()
                      catch exception unused11 (
                        on Void void
                        )
                      void
                      )
                    exception void
                    )
                  )
                varresult.inner(that:this.accumulate(l1:varresult.#inner(), l2:libi.#inner()))
                )
              catch exception unused12 (
                on Void void
                )
              void
              )
            catch exception propagated (
              on Any (
                Void unused13=libi.#close()
                exception propagated
                )
              )
            void
            )
          catch return propagated0 (
            on Library (
              Void unused14=libi.#close()
              return propagated0
              )
            )
          libi.#close()
          )
        )
      Void unused3=return this.accumulate(l1:varresult.#inner(), l2:that)
      void
      )
    )
  catch return result0 (
    on Library result0
    )
  error {'@stringU
  'CurlyBlock-Should be unreachable code
  }
  )
method 
Library accumulate(Library l1, Library l2) (
  Void unused=(
    Void unused0=return Outer1::IntrospectionPlugin.sumLib(l1:l1, l2:l2)
    catch error x (
      on Any (
        Void unused1=(
          Outer0::resolver() ::isPresent() ::#bang() cond=this.resolver().isPresent().#bang()
          (
            Void unused2=cond.#checkTrue()
            catch exception unused3 (
              on Void void
              )
            error x
            )
          )
        Outer1::Introspection::#apply(that ) ::methods() ms=Outer1::Introspection.#apply(that:this.resolver().#bang()).methods()
        Outer1::S _name=ms.pop().pop().top().name()
        Outer1::S _nameLeft=ms.pop().top().name()
        Outer1::S _nameRight=ms.top().name()
        Outer1::Name name=Outer1::Name.#stringParser(that:_name.binaryRepr())
        Outer1::Name nameLeft=Outer1::Name.#stringParser(that:_nameLeft.binaryRepr())
        Outer1::Name nameRight=Outer1::Name.#stringParser(that:_nameRight.binaryRepr())
        Outer1::Adapt::#begin() ::#add(that into ) ::#end() ::#left(that ) l1A=Outer1::Adapt.#begin().#add(that:name, into:nameLeft).#end().#left(that:l1)
        Outer1::Adapt::#begin() ::#add(that into ) ::#end() ::#left(that ) l2A=Outer1::Adapt.#begin().#add(that:name, into:nameRight).#end().#left(that:l2)
        Outer1::IntrospectionPlugin::sumLib(l1 l2 ) lRes=Outer1::IntrospectionPlugin.sumLib(l1:l1A, l2:l2A)
        return Outer1::Adapt.#begin().#add(makePrivate:nameLeft).#add(makePrivate:nameRight).#end().#left(that:Outer1::IntrospectionPlugin.sumLib(l1:this.resolver().#bang(), l2:lRes))
        )
      )
    void
    )
  catch return result (
    on Library result
    )
  error {'@stringU
  'CurlyBlock-Should be unreachable code
  }
  )
method 
Outer0 #plusplus(Outer0 that) (
  Void unused=(
    Outer0::myLibs() ::#plusplus(that ) list=this.myLibs().#plusplus(that:that.myLibs())
    Outer0::Resolver res=(
      Void unused1=(
        Void unused2=(
          Outer0::resolver() ::isPresent() cond=that.resolver().isPresent()
          (
            Void unused4=cond.#checkTrue()
            catch exception unused5 (
              on Void void
              )
            return that.resolver()
            )
          )
        Void unused3=return this.resolver()
        void
        )
      catch return result0 (
        on Outer0::Resolver result0
        )
      error {'@stringU
      'CurlyBlock-Should be unreachable code
      }
      )
    Void unused0=return Outer0.#apply(resolver:res, myLibs:list)
    void
    )
  catch return result (
    on Outer0 result
    )
  error {'@stringU
  'CurlyBlock-Should be unreachable code
  }
  )}
Adapt:{
type method 
Outer0 #apply(Library^adapter'@consistent
) 
mut method '@consistent
Library #adapter() 
read method '@consistent
Library adapter() 
type method 
Outer0 #apply() Outer0.#apply(adapter:{})
method 
Outer0 #add(Outer1::Name that, Outer1::Name into) (
  Void unused=(
    Void unused0=(
      Outer1::Name::isExternal() cond=that.isExternal()
      (
        Void unused3=cond.#checkTrue()
        catch exception unused4 (
          on Void void
          )
        error Outer1::S.#stringParser(that:{'@stringU
        'start name must be internal
        })
        )
      )
    Void unused1=(
      Outer1::Name::isInternalPath() ::#bang() cond0=that.isInternalPath().#bang()
      (
        Void unused5=cond0.#checkTrue()
        catch exception unused6 (
          on Void void
          )
        return this.#add(that:that, of:Outer1::Name.#stringParser(that:{'@stringU
        'Outer0
        }), into:into)
        )
      )
    Outer1::IntrospectionPlugin::adaptLib(l1 l2 ) map=Outer1::IntrospectionPlugin.adaptLib(l1:into.adapter(), l2:that.adapter())
    Outer1::IntrospectionPlugin::sumLib(l1 l2 ) lib=Outer1::IntrospectionPlugin.sumLib(l1:this.adapter(), l2:map)
    Void unused2=return Outer0.#apply(adapter:lib)
    void
    )
  catch return result (
    on Outer0 result
    )
  error {'@stringU
  'CurlyBlock-Should be unreachable code
  }
  )
method 
Outer0 #add(Outer1::Name that, Outer1::Name of, Outer1::Name into) (
  Void unused=(
    Outer1::IntrospectionPlugin::adaptLib(l1 l2 ) map1=Outer1::IntrospectionPlugin.adaptLib(l1:into.adapter(), l2:that.adapter())
    Outer1::IntrospectionPlugin::adaptLib(l1 l2 ) map2=Outer1::IntrospectionPlugin.adaptLib(l1:map1, l2:of.adapter())
    Outer1::IntrospectionPlugin::sumLib(l1 l2 ) lib=Outer1::IntrospectionPlugin.sumLib(l1:this.adapter(), l2:map2)
    Void unused0=return Outer0.#apply(adapter:lib)
    void
    )
  catch return result (
    on Outer0 result
    )
  error {'@stringU
  'CurlyBlock-Should be unreachable code
  }
  )
method 
Outer0 #add(Outer1::Name makePrivate) (
  Void unused=(
    Outer1::Name::#apply(isExternal adapter ) fName=Outer1::Name.#apply(isExternal:Outer1::Bool.false(), adapter:Outer1::IntrospectionPlugin.getFreshName(that:makePrivate.adapter()))
    Void unused0=return this.#add(that:makePrivate, into:fName)
    void
    )
  catch return result (
    on Outer0 result
    )
  error {'@stringU
  'CurlyBlock-Should be unreachable code
  }
  )
type method 
Outer0 #begin() Outer0.#apply()
method 
Outer0 #end() this
method 
Outer0 #plusplus(Outer0 that) (
  Outer1::IntrospectionPlugin::sumLib(l1 l2 ) lib=Outer1::IntrospectionPlugin.sumLib(l1:this.adapter(), l2:that.adapter())
  Outer0.#apply(adapter:lib)
  )
method 
Library #left(Library that) Outer1::IntrospectionPlugin.adaptLib(l1:that, l2:this.adapter())}
Data:{
Vardecorator:{
type method 
mut Outer0 #apply(Outer2::Use::#begin() ::#end() ^inner'@consistent
) 
mut method '@consistent
Void inner(Outer2::Use::#begin() ::#end() that) 
mut method '@consistent
Outer2::Use::#begin() ::#end() #inner() }
Varaccumulator:{
type method 
mut Outer0 #apply(Outer2::Use::#begin() ^inner'@consistent
) 
mut method '@consistent
Void inner(Outer2::Use::#begin() that) 
mut method '@consistent
Outer2::Use::#begin() #inner() }
type method 
Outer0 #apply() 
type method 
Outer0 #begin() Outer0.#apply()
method 
Outer0 #end() this
method 
Library #left(Library that) Outer1::Use.#begin().#add(that:this.addEquals(l:that)).#end().#left(that:that)
method 
Library equalsOnField(Outer1::Name c, Outer1::Name n) Outer1::Adapt.#begin().#add(that:Outer1::Name.#stringParser(that:{'@stringU
'T
}), into:c).#add(that:Outer1::Name.#stringParser(that:{'@stringU
'f
}), into:n).#end().#left(that:{
T:{
method 
Outer3::Bool #equalequal(Any that) }
read method 
Outer0::T f() 
method 
Outer2::Bool current(Outer0 that) this.f().#equalequal(that:that.f())})
method 
Library addEquals(Library l) (
  Void unused=(
    Outer1::Use::#begin() ::#end() decorator=(
      Outer1::Use::#begin() accumulator=Outer1::Use.#begin()
      mut Outer0::Varaccumulator varaccumulator=Outer0::Varaccumulator.#apply(inner:accumulator)
      Void unused2=(
        Outer1::Introspection::#apply(that ) ::fields() ::vals() field=Outer1::Introspection.#apply(that:l).fields().vals()
        (
          Void unused3=(
            Void unused4=(
              Void unused5=loop (
                Void unused6=field.#next()
                catch exception unused7 (
                  on Void (
                    Void unused8=(
                      Void unused9=field.#checkEnd()
                      catch exception unused10 (
                        on Void void
                        )
                      void
                      )
                    exception void
                    )
                  )
                varaccumulator.inner(that:varaccumulator.#inner().#add(that:this.equalsOnField(c:field.#inner().class(), n:Outer1::Name.#stringParser(that:field.#inner().name().binaryRepr()))))
                )
              catch exception unused11 (
                on Void void
                )
              void
              )
            catch exception propagated (
              on Any (
                Void unused12=field.#close()
                exception propagated
                )
              )
            void
            )
          catch return propagated0 (
            on Library (
              Void unused13=field.#close()
              return propagated0
              )
            )
          field.#close()
          )
        )
      varaccumulator.#inner().#end()
      )
    mut Outer0::Vardecorator vardecorator=Outer0::Vardecorator.#apply(inner:decorator)
    Void unused0=vardecorator.inner(that:vardecorator.#inner().#plusplus(that:Outer1::Use.#begin().#add(resolver:{
    method 
    Outer2::Bool current(Outer0 that) this.left(that:that).#and(that:this.right(that:that))
    method 
    Outer2::Bool left(Outer0 that) 
    method 
    Outer2::Bool right(Outer0 that) }).#end()))
    Outer1::Use::#begin() ::#end() ::#left(that ) result=vardecorator.#inner().#left(that:{
    method 
    Outer2::Bool current(Outer0 that) 
    method 
    Outer2::Bool #equalequal(Any that) (
      Void unused=(
        Void unused0=(
          Outer0 that0=(
            Void unused1=return that
            catch return casted (
              on Outer0 casted
              
              on Any exception void
              )
            error {'@stringU
            'CastT-Should be unreachable code
            }
            )
          catch exception unused2 (
            on Void return Outer2::Bool.false()
            )
          (
            Void unused3=return this.current(that:that0)
            void
            )
          )
        void
        )
      catch return result (
        on Outer2::Bool result
        )
      error {'@stringU
      'CurlyBlock-Should be unreachable code
      }
      )})
    Void unused1=return Outer1::Adapt.#begin().#add(makePrivate:Outer1::Name.#stringParser(that:{'@stringU
    'current(that)
    })).#end().#left(that:result)
    void
    )
  catch return result0 (
    on Library result0
    )
  error {'@stringU
  'CurlyBlock-Should be unreachable code
  }
  )}}