//Unit specific errors:
NotValidSupport=Message:{[Message.Guard]}
NotSameSupport=Message:{[Message.Guard]}
NotValidUnit=Message:{[Message.Guard]}
UnitCastError=Message:{[Message.Guard]}
//static methods, need to be compilable before top
N={class method Introspection.Nested (class Any that)
  =Introspection.Nested.from(classAny=that)}
  
ParRename={class method Library (class Any that, Trait trait,S.List names)={
  S parName=N(that).outerName()
  var acc=trait
  for name in names (
    acc:=acc[Name"%(name)(u_par)"=>Name"%(name)(u_%parName)"]
    )
  whoops Message.Guard
  return acc.code()
  }}
  
TraitAbstractSupport=Trait:{
  [HasToS]
  class method This #from(S.StringBuilder stringLiteral)
  method This +(This that)
  method This -(This that)
  method This *(This that)
  method This /(This that)
  read method Bool ==(read This that)
  read method Bool !=(read This that)
  read method Bool >(read This that)
  read method Bool <(read This that)
  read method Bool >=(read This that)
  read method Bool <=(read This that)
  }
  
TraitHasSupport=Trait:{
  Support={}
  method Support #inner() 
  class method This(Support that)
  }
  
TraitHasUnitCast=Trait:{class method This unitCast(Any that)}

TraitUnit=Trait:{...}

CompositUnit={...}

class method Library (class Any that)[NotValidSupport]={
  return Class:Data:TraitUnit['Support=>that]
  catch Message.Guard g exception NotValidSupport
    "The provided class is not a valid support class for a unit of measure"
    .with(cause=g)
  }