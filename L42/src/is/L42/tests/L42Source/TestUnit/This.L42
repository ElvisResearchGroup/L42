reuse [AdamTowel]
Base=Trait:{reuse [AdamTowel]
  Unit={...}
  TraitSI=Organize:Trait:{
    Support=Class:Unit.TraitAbstractSupport
    //the seven basic units
    Meter=Unit(Support)//meters
    Kg=Unit(Support)//kilograms
    Second=Unit(Support)//seconds
    Ampere=Unit(Support)//ampers
    Kelvin=Unit(Support)//kelvins
    Mole=Unit(Support)//moles
    Candel=Unit(Support)//candels

    Velocity=Meter.Per(Second)
//             Unit.CompositUnit(TraitUnit,Meter, per=Second)
    Meter2=Meter.Times(Meter)
    Meter$=Class:Meter2.FromLeft:Velocity.FromLeft
    
    Acceleration=Velocity.Per(Second)
    Velocity$=Class:Acceleration.FromLeft

    Meter3=Meter2.Times(Meter)
    Meter2$=Class:Meter3.FromLeft

    Hertz=Second.Inverse()  //hertz, 1/S
    Coulomb=Second.Times(Ampere)
    Becquerel=Second.Inverse()//use Becquerel(1Support per=mySeconds) to build
    Second$=Class:Hertz.FromUnit:Coulomb.FromLeft //can use myNum/24Second to get Hertz
    
    Newton=Kg.Times(Acceleration)
    Density=Kg.Per(Meter3)
    Kg$=Class:Newton.FromLeft:Density.FromLeft//optional other syntaxes:
    //Kg$=Class:Newton.FromKg:Density.FromKg 
    //Kg$=Class:Sum[Newton.FromKG, Density.FromKg]
    //Kg$=Class:(Newton.FromKg + Density.FromKg)
    //Kg$=(Newton.FromKg + Density.FromKg).code()

    Pascal=Newton.Per(Meter2)
    Joule=Newton.Times(Meter)
    Newton$=Class:Pascal.FromLeft:Joule.FromLeft
  
    Watt=Joule.Per(Second)
    Gray=Joule.Per(Kg)
    Sievert=Joule.Per(Kg)//use Sievert(myJ, per=myKg) to build
    Joule$=Class:Watt.FromLeft:Gray.FromLeft
    
    Volt=Watt.Per(Ampere)
    Watt$=Class:Volt.FromLeft
    
    Farad=Coulomb.Per(Volt)
    Coulomb$=Class:Farad.FromLeft
    
    Ohm=Volt.Times(Ampere)
    Weber=Volt.Times(Second)
    Volt$=Class:Ohm.FromLeft:Weber.FromLeft
    
    Siemens=Ohm.Inverse()
    Ohm$=Class:Siemens.FromUnit

    Tesla=Weber.Per(Meter2)
    Henry=Weber.Per(Ampere)
    Weber$=Class:Tesla.FromLeft:Henry.FromLeft
        
    Katal=Mole.Per(Second)
    Mole$=Class:Katal.FromLeft
    }
  }
  
DeployUnit=Deploy.module(
  url='Unit
  code=Base[deep='TraitSI=>'Unit.TraitSI].code()
  name='Unit
  )
  
UnitLib=Load:{reuse[#$Unit]}

SI=Class:UnitLib.TraitSI['Support=>Num]

Main=(
  Debug(S"Playing with units!")
  SI.Meter res1= (6SI.Meter +4SI.Meter)*2Num //20M
  Debug(res1)
  {}:Test"20Meter"(res1==20SI.Meter)
  Num res2=42SI.Meter / 2SI.Meter
  {}:Test"division"(res2==21Num)
  Num res3=(42SI.Meter).#inner()
  {}:Test"inner"(res3==42Num)
  SI.Velocity fast1= 42SI.Meter/0.1SI.Second
  Debug(fast1)
  {}:Test"division composite"(fast1==420SI.Velocity)
  fast2= SI.Velocity"420" //equivalent ways to initialize it
  fast3= SI.Velocity"840/2"
  distance1= 60SI.Second * fast1
  Debug(distance1)
  {}:Test"times component"(distance1==25200SI.Meter)
  g= 9.8SI.Acceleration
  speedAfter= 10SI.Second * g //98 m/s
  Debug(speedAfter)
  {}:Test"times compoment"(speedAfter==98SI.Velocity)
  t=10SI.Second
  //free fall distance d=(gt^2)/2
  distance2= (g*t*t)/2Num//490 m after 10s free fall
  Debug(distance2)
  {}:Test"free fall"(distance2==490SI.Meter)
  //Newton=Kg*m/s2 = Kg*Acceleration
  myRoket= 900SI.Newton
  gForceOnMe= 80SI.Kg*g //little less than 800
  myLift= myRoket-gForceOnMe
  {}:Test"can fly"(myLift>0SI.Newton)
  if myLift>0SI.Newton (Debug(S"I can fly"))
  myAcc= myLift / 80SI.Kg
  Debug(myAcc)
  {}:Test"acceleration up"(myAcc==1.45SI.Acceleration)
  reachedHeight= (myAcc*t*t) / 2Num //after 10 sec
  Debug(reachedHeight)
  {}:Test"reachedHeight"(reachedHeight==SI.Meter"145/2")
  )
