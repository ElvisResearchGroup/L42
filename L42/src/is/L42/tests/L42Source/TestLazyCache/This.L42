reuse[AdamTowel]

/*This test need to use the organizer decorator, in turn requiring full path rename.
Scope1 ={
  A = {
    mut Bs bs class method This(mut Bs bs)
    imm method Size ok()=native{trusted:eagerCachable} 3Size
    }
  B = {mut A a class method This(mut A a)}
  Bs = Class:ListT(B)
  LateCacheLoadingTask=(
    imm A ia=(
      mut Bs bs=Bs()
      mut A a=A(Bs)
      bs.add(a)
      )
    _=ia.ok()
    void
    )
  }
  */
Foo={Size inner,class method This of(Size inner)
  imm method Size times2()=
    native{trusted:cachable} (
      Log"Foo".write(S"2")//Discuss: how this scale when closed subexpressions can be cached?
      this.inner()*2Size
      )
  imm method Size times3Eager()=
    native{trusted:eagerCachable} (
      Log"Foo".write(S"3")
      this.inner()*3Size
      )
  }
TestCache=(
  Log"Foo".clear()
  Foo foo=Foo.of(inner=5Size)
//  {}:Test"pass"(Bool.true())
  {}:Test"cacheResult"(expected=10Size, actual=foo.times2())
/*  {}:Test"cacheResultAgain"(expected=10Size, actual=foo.times2())
  {}:Test"cacheResultEager"(expected=15Size, actual=foo.times3Eager())
  {}:Test"cacheResultEagerAgain"(expected=15Size, actual=foo.times3Eager())
  {}:Test"cacheAvoidRepeating"(expected=S"32",actual=Log"Foo".#$reader().read())*/
  )
/*  
A={
  Strings that
  class method This (Strings that)
  imm method S firstE()=
    native{trusted:cachable} (
      Log"Foo".write(S"firstEcalled")
      this.that().val(0\)
      )
  }
TestACache=(
  Log"Foo".clear()
  A a=A(Strings[S"Hello";S"Hi"])
  A b=A(Strings[S"Hello";S"Hi"])
  {}:Test"cacheAResult"(expected=S"Hello", actual=a.firstE())
  {}:Test"cacheAResultAgain"(expected=S"Hello", actual=a.firstE())
  {}:Test"cacheAvoidRepeating"(expected=S"firstEcalled",actual=Log"Foo".#$reader().read())
  {}:Test"cacheAResult"(expected=S"Hello", actual=b.firstE())
  {}:Test"cacheAResultAgain"(expected=S"Hello", actual=b.firstE())
  {}:Test"cacheAvoidRepeating"(expected=S"firstEcalled",actual=Log"Foo".#$reader().read())
  A c=A(Strings[S"Hello";S"Hi"])
  {}:Test"cacheAResult"(expected=S"Hello", actual=c.firstE())
  {}:Test"cacheAResultAgain"(expected=S"Hello", actual=c.firstE())
  {}:Test"cacheAvoidRepeating"(expected=S"firstEcalled",actual=Log"Foo".#$reader().read())
  A d=A(Strings[S"Hello";S"Hi";S"donut"])
  {}:Test"cacheDResult"(expected=S"Hello", actual=d.firstE())
  {}:Test"cacheDResultAgain"(expected=S"Hello", actual=d.firstE())
  {}:Test"cacheEnsureRepeatOnce"(expected=S"firstEcalledfirstEcalled",actual=Log"Foo".#$reader().read())
  )
  
 HasToSs = Class:ListT(HasToS)
 
 B={
  HasToSs that
  class method This (HasToSs that)
  imm method S firstE()=
    native{trusted:cachable} (
      Log"Foo".write(S"firstEcalled2")
      this.that().val(0\).toS()
      )
  }
  
BBox={
  B that
  class method This innerCon(B that)
  class method This (HasToSs that)=This.innerCon(B(that))
  imm method S firstE()=
    native{trusted:cachable} (
      this.that().firstE()
      )
  
}
  
TestBCache=(
  Log"Foo".clear()
  B b = B(HasToSs[S"Hello";S"Goodbye"])
  B b2 = B(HasToSs[S"Hello";S"Goodbye"])
  {}:Test"cacheBResult"(expected=S"Hello", actual=b.firstE())
  {}:Test"cacheBResultAgain"(expected=S"Hello", actual=b.firstE())
  {}:Test"cacheBvoidRepeating"(expected=S"firstEcalled2",actual=Log"Foo".#$reader().read())
  {}:Test"cacheBResult"(expected=S"Hello", actual=b2.firstE())
  {}:Test"cacheBResultAgain"(expected=S"Hello", actual=b2.firstE())
  {}:Test"cacheBvoidRepeating"(expected=S"firstEcalled2",actual=Log"Foo".#$reader().read())
  BBox b3 = BBox(HasToSs[S"Hello";S"Goodbye"])
  {}:Test"cacheBResult"(expected=S"Hello", actual=b3.firstE())
  {}:Test"cacheBResultAgain"(expected=S"Hello", actual=b3.firstE())
  {}:Test"cacheBvoidRepeating"(expected=S"firstEcalled2",actual=Log"Foo".#$reader().read())
  void
  )
  
AnyList = Class:ListT(Any)
VoidList = Class:ListT(Void)
LibList = Class:ListT(Library)

C={
  Strings that
  AnyList myList
  class method This (Strings that, AnyList myList)
  imm method S firstE()=
    native{trusted:cachable} (
      Log"Foo".write(S"firstEcalled3")
      this.that().val(0\)
      )
  }
  
MyTrait=Trait:{imm method Void foo()=void}
  
TestAnyVoidLibrary=(
  Log"Foo".clear()
  C c = C(that=Strings[S"Hello";S"Hi"], 
          myList=AnyList[MyTrait.code();void;S"bar"])
  C c2 = C(that=Strings[S"Hello";S"Hi"], 
          myList=AnyList[MyTrait.code();void;S"bar"])
  {}:Test"cacheCResult"(expected=S"Hello", actual=c.firstE())
  {}:Test"cacheCResultAgain"(expected=S"Hello", actual=c.firstE())
  {}:Test"cacheCvoidRepeating"(expected=S"firstEcalled3",actual=Log"Foo".#$reader().read())
  {}:Test"cacheCResult"(expected=S"Hello", actual=c2.firstE())
  {}:Test"cacheCResultAgain"(expected=S"Hello", actual=c2.firstE())
  {}:Test"cacheCvoidRepeating"(expected=S"firstEcalled3",actual=Log"Foo".#$reader().read())
  void
)
D={
  Strings that
  Any myAny
  class method This (Strings that,fwd imm Any myAny)
  imm method S firstE()=
    native{trusted:cachable} (
      Log"Foo".write(S"ACT.")
      this.that().val(0\)
      )
  }
TestCircular=(
  Log"Foo".clear()
  D d1 = D(Strings[S"Hello"],myAny=d2)
  D d2 = D(Strings[S"Goodbye"],myAny=d1)  
  {}:Test"cacheCResult"(expected=S"Hello", actual=d1.firstE())
  {}:Test"cacheCResultAgain"(expected=S"Hello", actual=d1.firstE())
  {}:Test"cacheCvoidRepeating"(expected=S"ACT.",actual=Log"Foo".#$reader().read())
  {}:Test"cacheCResult"(expected=S"Hello", actual=d2.firstE())
  {}:Test"cacheCResultAgain"(expected=S"Hello", actual=d2.firstE())
  {}:Test"cacheCvoidRepeating"(expected=S"ACT.",actual=Log"Foo".#$reader().read())
  )
*/
  /*
  MAKE A DEDICATED TEST FILE //follow TestList
  create b after using a
  
  test interfaces: A may have a HasToS and an Any
  and all permutations with NotQuiteStrings List of Any and List of HasToS
  
  test circular objects
  
  */