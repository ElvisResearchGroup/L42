read method Size combine(Size x,Size y, Size seed,Size oldCell)={
  if oldCell==0Size return seed   //unsetted is set
  if oldCell+1\==seed return seed //contaged
  if oldCell+6\ <seed return (oldCell+seed)/2Size //pulled up if it is so far below
  return 0Size //do nothing
  }
mut Points montainsTop=Points()
RiverMap=Class:Data:MapList(Size.List,base='zero())
mut RiverMap riverMap
class method mut RiverMap #default#riverMap(Size side)=\(side=side)
mut Random r
Size maxZ
Size side
read method Size (Point that)
read method Size (Size x,Size y)
mut method Void (Point that,Size val)
mut method Void (Size x,Size y,Size val)

mut method Size rand(Size that, Size to)=
  this.#r().nextInRange(start=that,end=to)
//For now, makes a maxZ tall diagonal line and
//6 other maxZ*0.65 peakes
mut method Void initTops()=(
  low=this.side()/6Size
  mid=this.side()/2Size
  high=5Size*(this.side()/6Size)
  midZ=(this.maxZ()*2Size)/3Size
  lowZ=(midZ*1Size)/3Size
  p1x=this.rand(low to=mid)
  p1y=this.rand(low to=mid)
  p2x=this.rand(mid to=high)
  p2y=this.rand(mid to=high)
  this.#montainsTop().add(Point(x=p1x,y=p1y, z=this.rand(midZ to=this.maxZ())))
  for w in Range(1\ to=6\) (
    x=((p1x*w)+(p2x*(6Size-w)))/6Size
    y=((p1y*w)+(p2y*(6Size-w)))/6Size
    this.#montainsTop().add(Point(x=x,y=y, z=this.rand(midZ to=this.maxZ())))
    )
  for w in Range(0\ to=6\) (//6 extra random lower tops
    x=this.rand(low to=high)
    y=this.rand(low to=high) 
    z=this.rand(lowZ to=midZ)
    this.#montainsTop().add(\(x=x,y=y,z=z))
    )
  )
mut method Void makeRivers(Size waterLevel)=(
  this.runWater(p=this.montainsTop().val(2\))
  this.runWater(p=this.montainsTop().val(3\))
  s=this.side()-1Size
  o=this.#order()//WHAT is the code below trying to do?
  ShufflePoint.shuffle(o,r=this.#r())
  for x in Range(1\ to=s) (
    for y in Range(1\ to=s) {
      if this.riverMap()(x=x,y=y) > 0Size return void
      var max=Size"-1"
      for (x1,y1) in o (
        r=this.riverMap()(x=x+x1,y=y+y1)
        if r>0Size (
          candidate=this(x=x+x1,y=y+y1)+r
          if candidate>max max:=candidate
          )
        )
      if max==Size"-1" return void
      m=this(x=x,y=y)
      if m < waterLevel-1Size return void
      if m <= max  this(x=x,y=y,val=max)
      else this(x=x,y=y,val=(m+max)/2Size)
      return void
      }
    )
  )
mut method Void add(mut Points river,Point p)=(
  this.#riverMap()(p, val=1\)
  this(p,val=this(p)-1\)
  river.add(p)
  )
mut method mut Points runWaterDown(Point start)={
  var p=start
  river=Points()
  loop (
    this.add(river=river,p=p)
    var min=this.maxZ()+1Size
    for pi in Points[p.with(y=\y-1\); p.with(x=\x-1\); p.with(x=\x+1\); p.with(y=\y+1\)] (
      candidate=this(pi)
      ok=this.riverMap()(pi) == 0Size && candidate<min //what happens if we remove the riverMap check?
      if ok (min:=candidate, p:=pi)
      )///crucially, min can be higher than the former this(p)
    if min==this.maxZ()+1Size || this(p)<=0Size (
      this.add(river=river,p=p)
      return river
      )
    )
  }
mut method Void runWater(Point p)=(
  x=this.#r().nextInRange(start=p.x()-2\,end=p.x()+2\)
  y=this.#r().nextInRange(start=p.y()-2\,end=p.y()+2\)
  river=this.runWaterDown(start=\(x=x,y=y))
  if river.size()>=2Size this.adjust(river=river)
  )
mut method Void riversGoDown(read Points river)=(
  var last=this(river.left())
  for p in river (
    current=this(p)
    if current>last this(p val=last)
    else last:=current
    )
  )
mut method Void adjust(read Points river)=(
  this.riversGoDown(river=river)
  preLastH=this.riverMap()(river.right())
    .max(this(river.val(\size()-2\))+1Size)
  this.#riverMap()(river.right() val=preLastH)
  var lastH=this(river.right())
  for i in Range(river.size()-2\).reverse() (
    pi=river.val(i)
    var currentH=this(pi)
    riverH=this.riverMap()(pi)
    if lastH>currentH (
      this.#riverMap()(pi val=(riverH+lastH)-currentH)
      currentH:=(riverH+lastH)-1Size
      )
    delta=(currentH-(lastH+1Size))
    if delta>0Size (//should make more water on waterfalls
      this.#riverMap()(pi val=this.riverMap()(pi)+delta)
      this(pi val=this(pi)-delta)
      )
    lastH:=currentH
    )
  )
mut method Void noUnderZero()=(
  for x in Range(this.side()) (
    for y in Range(this.side()) (
      if this(x=x,y=y)<0Size (
        reduced=(this.riverMap()(x=x,y=y)+this(x=x,y=y)).max(0\)
        this.#riverMap()(x=x,y=y,val=reduced)
        this(x=x,y=y,val=0\)
        )
      )
    )
  )