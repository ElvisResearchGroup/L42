reuse[AdamTowel]

TestClose={
  class method Void (Library that,S expected)=(
    _=Cache.Close:that
    catch error Cache.Close$Fail f (
      cut = expected.size()<f.toS().size()
      size =if cut expected.size()-1Size else f.toS().size()//remove the last \n on expected        
      S part=f.toS().subString(start=0\ end=size)
      that:Test"ExpectedExeption"(expected=expected actual=part)
      )
    that:Test"ExpectedExeptionMissed"(Bool.false())
    )
  }
TestClose1=(
  /*TestClose({
    Size n
    class method mut This(Size n)
    @Cache.Clear class method Size double(mut Size n)=error void
    },expected=S"""
      |Message toFix(toFix):
      |Invalid @This1.Cache.Now read method imm This1.Size double()=(..)
      |must be a class method
      |[file:
      """
    )*/
  TestClose({
    Size n
    class method mut This(Size n)
    @Cache.Now read method Size double()=this.n()+this.n()
    },expected=S"""
      |Message toFix(toFix):
      |Invalid @This1.Cache.Now read method imm This1.Size double()=(..)
      |must be a class method
      |[file:
      """
    )
  TestClose({
    read method Size n::0()
    class method mut This of::0(Size n)
    },expected=S"""
      |Message toFix(toFix):
      |Invalid class literal {}
      |Class is already close
      |[file:
      """
    )
  TestClose({
    capsule Strings that
    class method mut This(capsule Strings that)
    @Cache.Now class method Size size(read Strings that)=that.size()
    @Cache.Clear class method Size append1(mut Strings thaat)=(
      thaat.add(S"1")
      thaat.size()
      )
    },expected=S"""
      |Message toFix(toFix):
      |Invalid @This1.Cache.Clear class method imm This1.Size append1(mut This1.Strings thaat)=(..)
      |first parameter does not correspond to a capsule field: the parameter name is not a field
      |[file:
      """
    )
    /*
  TestClose({
    Size n
    class method mut This(Size n)
    @Cache.Now class method Size double(Size nn)=nn+nn
    },expected=S"""
      |Message toFix(toFix):
      |Invalid @This1.Cache.Now read method imm This1.Size double()=(..)
      |must be a class method
      |[file:
      """
    )
   
  CLOSE IS BROKEN like sum, works in some good cases.
  In particular, it needs to work for non coherent classes
  and needs to receive the names of the fields to identify the state.
  AddConstructor is adding the constructos, thus deciding the fields, and may pass the info...
  but how? can we use introspection to extract them from a constructor name?
    should it be Cache.Lazy, Cache.Eager(parallel) Cache.Now?
    and then Cache.Clear
    -error messages
    -make introspection print className/interface names, so we can print the right error
    -add sum and complete the last todo in Close!
    -standard code
    -multiline string %% support
    -add callSiteCache?
  */ 
  )

   