reuse[AdamTowel]

TestMsg={
  class method Void (Library that,Message msg,S expected)=(
    cut = expected.size()<msg.toS().size()
    size =if cut expected.size()-1Size else msg.toS().size()//remove the last \n on expected        
    S part=msg.toS().subString(start=0\ end=size)
    that:Test"ExpectedExeption"(expected=expected actual=part)
    )
  }
TestClose={
  class method Void (Library that,S expected)=(
    _=Cache.Close:that
    catch error Cache.Close$Fail f (TestMsg(that,msg=f,expected=expected))
    that:Test"ExpectedExeptionMissed"(Bool.false())
    )
  }
TestClose1=(
  TestClose({
    Size n
    class method mut This(Size n)
    @Cache.Clear class method Size double(mut Size n)=error void
    },expected=S"""
      |Message toFix(toFix):
      |method @This1.Cache.Clear class method imm This1.Size double(mut This1.Size n)=(..)
      |first parameter does not correspond to a capsule field; constructor class method mut This0 #apply(imm This1.Size n) initializes it as imm This1.Size
      |[file:
      """
    )
  TestClose({
    Size n
    class method mut This(Size n)
    @Cache.Now read method Size double()=this.n()+this.n()
    },expected=S"""
      |Message toFix(toFix):
      |method @This1.Cache.Now read method imm This1.Size double()=(..)
      |must be a class method
      |[file:
      """
    )
  TestClose({
    read method Size n::0()
    class method mut This of::0(Size n)
    },expected=S"""
      |Message toFix(toFix):
      |nested class { }
      |Class is already close
      |[file:
      """
    )
  TestClose({
    capsule Strings that
    class method mut This(capsule Strings that)
    @Cache.Now class method Size size(read Strings that)=that.size()
    @Cache.Clear class method Size append1(mut Strings thaat)=(
      thaat.add(S"1")
      thaat.size()
      )
    },expected=S"""
      |Message toFix(toFix):
      |method @This1.Cache.Clear class method imm This1.Size append1(mut This1.Strings thaat)=(..)
      |first parameter does not correspond to a capsule field: the parameter name is not a field
      |[file:
      """
    )
  TestClose({
    Size n
    class method mut This(Size n)
    @Cache.Now class method Size double(Size nn)=nn+nn
    },expected=S"""
      |Message toFix(toFix):
      |method @This1.Cache.Now class method imm This1.Size double(imm This1.Size nn)=(..)
      |No candidate getter/exposer with name nn and method modifier Immutable or Readable
      |[file:
      """
    )
  TestClose({
    Size n
    class method mut This(fwd imm Size n)
    @Cache.Now class method Size double(Size n)=n+n
    },expected=S"""
      |Message toFix(toFix):
      |method @This1.Cache.Now class method imm This1.Size double(imm This1.Size n)=(..)
      |parameter n is initialized with fwd in the constructor class method mut This0 #apply(fwd imm This1.Size n)
      |[file:
      """
    )
   /*
    -make introspection print className/interface names, so we can print the right error
    -standard code
    -add callSiteCache?
    -add lazyReadCache?
    -add multi args cache for imm/class?
  */ 
  )
TestSum={
  class method Void classClash(Library l1,Library l2,S expected)=(
    _=(Trait:l1)+l2
    catch error ClassClash f (TestMsg(l1,msg=f,expected=expected))
    l1:Test"ExpectedExeptionMissed"(Bool.false())
    )
  class method Void methodClash(Library l1,Library l2,S expected)=(
    _=(Trait:l1)+l2
    catch error MethodClash f (TestMsg(l1,msg=f,expected=expected))
    l1:Test"ExpectedExeptionMissed"(Bool.false())
    )
  }
TestSum1=(
  TestSum.methodClash(l1={
    method Void foo()=void
    },l2={
    method Void foo()=void
    },expected=S"""
    |Message toFix(toFix):
    |method imm method imm Void foo()=(..)
    |Conflicting implementation: the method is implemented on both side of the sum
    |[file:
    """)
  TestSum.classClash(l1={interface
    method Void foo()
    },l2={
    method Void foo()=void
    },expected=S"""
    |Message toFix(toFix):
    |nested class This0={ foo()=(..) }
    |The nested class can not be turned into an interface; some public methods are implemented
    |[file:
    """)
  )
//TODO: all errors, they should be exceptions?
TestError=Trait:{
  T={[Message]}
  class method This of()
  method Any()[Message]
  method S expected()
  class method Void :1(Library that)[Message]=(
    s=(This.of().expected()++Test.hole()).trim()
    (_=This.of()()
    catch error T f (that:Test"ErrorMessage"(expected=s,actual=f.toS()))
    that:Test"ErrorExpected"(Bool.false())
    ))
  }
Code=Trait:{
  A={method Void foo()=void}
  B={method Any foo()=void}
  }
TestMethodClash1={A=Class:TestError['T=>MethodClash]:{
  method Any()[Message]=
    Code['A.#equalgt0(other='B)]
  method S expected()=S"""
    |Message toFix(toFix):
    |method imm method imm Any foo()=(..)
    |Conflicting implementation: the method is implemented on both side of the sum
    |[file:[###]
    """  
  }B={}:A}
/*
TestMethodClash1={A=TestError>MethodClash>{
  method Any()[Message]=
    Code['A.#equalgt0(other='B)]
  method S expected()=S"""
    |Message toFix(toFix):
    |method imm method imm Any foo()=(..)
    |Conflicting implementation: the method is implemented on both side of the sum
    |[file:[###]
    """
  } B={}:A}
TestMethodClash1={}:TestError""(
  actual=MethodClash<:Code['A.#equalgt0(other='B)]
  expected=S"""
   |...
   """)
TestMethodClash1={}:Test""(
  actual=(_=Code['A.#equalgt0(other='B)]
    catch MethodClash x x X"")
  expected=S"""
   |...
   """)


Test
Action={interface class method read Any()[Message]}
Trigger={interface class method S (class Action that)[Message]}
ErrorToS=Trait:{[Trigger]
  T={[Message]}
  method(that)=(
    _=that()
    catch error T f (f.toS())
    S""
    )
  }
ClassClashToS=Class:ErrorToS['T=>ClassClash]
MethodClashToS=Class:ErrorToS['T=>MethodClash]
InvalidNameToS=Class:ErrorToS['T=>InvalidName]
InvalidMapToS=Class:ErrorToS['T=>InvalidMap]
//A=Data:{[Action] method()=Code['A=>'B]}
//TODO: somehow it fails to recognize the "other" method is the right to call

A={[Action] method()=Code['A.#equalgt0(other='B)]}
TestRename={
  TestMethodClash=(
    {}:Test""(expected=S"""
      |Message toFix(toFix):
      |method imm method imm Any foo()=(..)
      |Conflicting implementation: the method is implemented on both side of the sum
      |[file:[###]
      """.trim() actual=MethodClashToS(A))
    void
    )
    
  }*/