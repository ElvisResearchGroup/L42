reuse[AdamTowel]

TestMsg={
  class method Void (Library that,Message msg,S expected)=(
    cut = expected.size()<msg.toS().size()
    size =if cut expected.size()-1Size else msg.toS().size()//remove the last \n on expected        
    S part=msg.toS().subString(start=0\ end=size)
    that:Test"ExpectedExeption"(expected=expected actual=part)
    )
  }
TestClose={
  class method Void (Library that,S expected)=(
    _=Cache.Close:that
    catch error Cache.Close$Fail f (TestMsg(that,msg=f,expected=expected))
    that:Test"ExpectedExeptionMissed"(Bool.false())
    )
  }
TestClose1=(
  TestClose({
    Size n
    class method mut This(Size n)
    @Cache.Clear class method Size double(mut Size n)=error void
    },expected=S"""
      |Message toFix(toFix):
      |method @This1.Cache.Clear class method imm This1.Size double(mut This1.Size n)=(..)
      |first parameter does not correspond to a capsule field; constructor class method mut This0 #apply(imm This1.Size n) initializes it as imm This1.Size
      |[file:
      """
    )
  TestClose({
    Size n
    class method mut This(Size n)
    @Cache.Now read method Size double()=this.n()+this.n()
    },expected=S"""
      |Message toFix(toFix):
      |method @This1.Cache.Now read method imm This1.Size double()=(..)
      |must be a class method
      |[file:
      """
    )
  TestClose({
    read method Size n::0()
    class method mut This of::0(Size n)
    },expected=S"""
      |Message toFix(toFix):
      |nested class { }
      |Class is already close
      |[file:
      """
    )
  TestClose({
    capsule Strings that
    class method mut This(capsule Strings that)
    @Cache.Now class method Size size(read Strings that)=that.size()
    @Cache.Clear class method Size append1(mut Strings thaat)=(
      thaat.add(S"1")
      thaat.size()
      )
    },expected=S"""
      |Message toFix(toFix):
      |method @This1.Cache.Clear class method imm This1.Size append1(mut This1.Strings thaat)=(..)
      |first parameter does not correspond to a capsule field: the parameter name is not a field
      |[file:
      """
    )
  TestClose({
    Size n
    class method mut This(Size n)
    @Cache.Now class method Size double(Size nn)=nn+nn
    },expected=S"""
      |Message toFix(toFix):
      |method @This1.Cache.Now class method imm This1.Size double(imm This1.Size nn)=(..)
      |No candidate getter/exposer with name nn and method modifier Immutable or Readable
      |[file:
      """
    )
  TestClose({
    Size n
    class method mut This(fwd imm Size n)
    @Cache.Now class method Size double(Size n)=n+n
    },expected=S"""
      |Message toFix(toFix):
      |method @This1.Cache.Now class method imm This1.Size double(imm This1.Size n)=(..)
      |parameter n is initialized with fwd in the constructor class method mut This0 #apply(fwd imm This1.Size n)
      |[file:
      """
    )
   /*
    -make introspection print className/interface names, so we can print the right error
    -standard code
    -add callSiteCache?
    -add lazyReadCache?
    -add multi args cache for imm/class?
  */ 
  )
TestSum={
  class method Void classClash(Library l1,Library l2,S expected)[MethodClash]=(
    _=(Trait:l1)+l2
    catch ClassClash f (TestMsg(l1,msg=f,expected=expected))
    l1:Test"ExpectedExeptionMissed"(Bool.false())
    )
  class method Void methodClash(Library l1,Library l2,S expected)[ClassClash]=(
    _=(Trait:l1)+l2
    catch MethodClash f (TestMsg(l1,msg=f,expected=expected))
    l1:Test"ExpectedExeptionMissed"(Bool.false())
    )
  }
TestSum1=(
  TestSum.methodClash(l1={
    method Void foo()=void
    },l2={
    method Void foo()=void
    },expected=S"""
    |Message toFix(toFix):
    |method imm method imm Void foo()=(..)
    |Conflicting implementation: the method is implemented on both side of the sum
    |[file:
    """)
  TestSum.classClash(l1={interface
    method Void foo()
    },l2={
    method Void foo()=void
    },expected=S"""
    |Message toFix(toFix):
    |nested class This0={ foo()=(..) }
    |The nested class can not be turned into an interface; some public methods are implemented
    |[file:
    """)
  )
Code=Trait:{
  A={method Void foo()=void}
  B={method Any foo()=void}
  C={method Void a(A a)=a.foo()}
  method Void a(A a)=void
  }
TestRename=(
  {}:Test"MethodClash=>"(
    actual={error Code['A=>'B] catch MethodClash x return x}
    expected=S"""
      |Message toFix(toFix):
      |method imm method imm Any foo()=(..)
      |Conflicting implementation: the method is implemented on both side of the sum
      |[file:[###]
      """.trim())
  {}:Test"MethodClash->"(
    actual={error Code['A->'B] catch MethodClash x return x}
    expected=S"""
      |Message toFix(toFix):
      |method imm method imm Any foo()=(..)
      |Conflicting implementation: the method is implemented on both side of the sum
      |[file:[###]
      """.trim())
  )
TestRename2=(
  {}:Test"MethodClash->"(
    actual={error Code['C->'This] catch MethodClash x return x}
    expected=S"""
      |Message toFix(toFix):
      |method imm method imm Void a(imm This0.A a)=(..)
      |Conflicting implementation: the method is implemented on both side of the sum
      |[file:[###]
      """.trim())
  {}:Test"InvalidMap->"(
    actual={error Code['A.foo()=>Name""]['A->Name""] catch InvalidMap x return x}
    expected=S"""
      |Message toFix(toFix):
      |nested class { a(a)=(..) A={..} B={..} C={..} }
      |nested class A
      |The implementation can not be removed since the class is watched by nested class C
      |Full mapping:A-><empty>
      |[file:[###]
      """.trim())
  {}:Test"InvalidMap->"(
    actual={error Code[hide='A.foo()][clear='A] catch InvalidMap x return x}
    expected=S"""
      |Message toFix(toFix):
      |nested class { a(a)=(..) A={..} B={..} C={..} }
      |nested class A
      |The implementation can not be removed since the class is watched by nested class C
      |Full mapping:A-><empty>
      |[file:[###]
      """.trim())
  )
//TODO: now somehow the Info is always declassed to "norm" :-(
//TODO: Data & co must also throw exception instead of error 

//Testing a funkyer way to test
TestError=Trait:{
  T={[Message]}
  class method This of()
  method Any()[Message]
  method S expected()
  class method Void :1(Library that)[Message]=(
    s=(This.of().expected()++Test.hole()).trim()
    (_=This.of()()
    catch T f (that:Test"ErrorMessage"(expected=s,actual=f.toS()))
    that:Test"ErrorExpected"(Bool.false())
    ))
  }
TestMethodClashFunky={A=Class:TestError['T=>MethodClash]:{
  method Any()[Message]=
    Code['A=>'B]
    //Code['A.#equalgt0(other='B)]
  method S expected()=S"""
    |Message toFix(toFix):
    |method imm method imm Any foo()=(..)
    |Conflicting implementation: the method is implemented on both side of the sum
    |[file:[###]
    """  
  }B={}:A}