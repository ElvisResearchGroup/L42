reuse[AdamTowel]
Person=Data:{var S name}
OptP=Collection.opt(Person)
  ...
  //imm OptP o=OptP(\(name=S"bob"))
  mut Person p=Person(name=S"bob")
  mut OptP o=OptP(p)
  Person ip=Person(name=S"bob")
  OptP io=OptP(ip)
 
A={
  class method mut Person #foo(mut OptP that)=that.#get()
  class method read Person foo(read OptP that)=that.get()
  
    capsule        class 
  imm    mut                 fwd mut, fwd  imm       fwd%mut fwd%imm
        lent
     read
  }
  
  this.foo=fwd; if(fwd instanceof FWD){fwd.add(v->this.foo=v);}
  
  
  

TraitsAndNative={
  Base={class method mut This ()}
  HasOpt=Trait:{A=Collection.opt(Base)}
  }
/*
Collection.list(OptNum) may fail since list have optElem inside??
Should we allow opt(opt(t)) by generating better bytecode
toAbstract: abstracting a native is only possible if the dependencies are abstracted too
 == the classes using P as nativePar, watches P
redirect:
You may redirect a native** on another native** if the native pars are
  idenatically transferred in redirect
  //simpler? redirect on native is impossible?
You can not redirect a {} on an {.. #norm{nativeKind=Opt nativePar=S,Collections.ElemNotInOpt}}
//another nativeOpt may now be ill typed
You can not redirect a {nativeKind=Opt} on an {} or different native kind
//a map may now be ill typed
You can not redirect a {nativeKind=LazyMsg} on an {}  or different native kind
//a range of natives may now be ill typed

sum:
You may sum/sumrename a native** on another native** if the native pars are
  idenatically renamed
You can not sum a {} on an {nativeKind=Opt}
//another nativeOpt may now be ill typed
You can not sum a {nativeKind=Opt} on an {} or different native kind
//sum is simmetric, so look above
You can not sum a {nativeKind=LazyMsg} on an {}
//a range of natives may now be ill typed


*/
TestClose1=(
  code={
    Size n
    class method mut This(Size n)
    @Cache.Clear class method Size double(mut Size n)=error void
    }
  {}:Test"Close1"(
    actual={error Data.Close:code catch Data.Close.Fail x return x}
    expected=S"""
      |Message This.Data.Close.Fail([###]):
      |@This1.Cache.Clear class method This1.Size double(mut This1.Size n)=(..)
      |first parameter does not correspond to a capsule field; constructor class method mut This #apply(This1.Size n) initializes it as This1.Size
      |[file:[###]
      """.trim())
  code2={
    Size n
    class method mut This(Size n)
    @Cache.Now read method Size double()=this.n()+this.n()
    }
  {}:Test"Close2"(
    actual={error Data.Close:code2 catch Data.Close.Fail x return x}
    expected=S"""
      |Message This.Data.Close.Fail([###]):
      |@This1.Cache.Now read method This1.Size double()=(..)
      |can not be made into a cached read method; the receiver modifier must be class but it is read
      |[file:[###]
      """.trim())
  code3={
    read method Size n::0()
    class method mut This of::0(Size n)
    }
  {}:Test"Close3"(
    actual={error Data.Close:code3 catch Data.Close.Fail x return x}
    expected=S"""
      |Message This.Data.Close.Fail([###]):
      |nested class { }
      |Class is already close
      |[file:[###]
      """.trim())
  code4={
    capsule S.List that
    class method mut This(capsule S.List that)
    @Cache.Now class method Size size(read S.List that)=that.size()
    @Cache.Clear class method Size append1(mut S.List thaat)=(
      thaat.add(S"1")
      thaat.size()
      )
    }
  {}:Test"Close4"(
    actual={error Data.Close:code4 catch Data.Close.Fail x return x}
    expected=S"""
      |Message This.Data.Close.Fail([###]):
      |@This1.Cache.Clear class method This1.Size append1(mut This1.S.List thaat)=(..)
      |first parameter does not correspond to a capsule field: the parameter name is not a field
      |[file:[###]
      """.trim())
  code5={
    Size n
    class method mut This(Size n)
    @Cache.Now class method Size double(Size nn)=nn+nn
    }
  {}:Test"Close5"(
    actual={error Data.Close:code5 catch Data.Close.Fail x return x}
    expected=S"""
      |Message This.Data.Close.Fail([###]):
      |@This1.Cache.Now class method This1.Size double(This1.Size nn)=(..)
      |No candidate getter/exposer with name nn and method modifier imm or read
      |[file:[###]
      """.trim())
  code6={
    Size n
    class method mut This(fwd imm Size n)
    @Cache.Now class method Size double(Size n)=n+n
    }
  {}:Test"Close6"(
    actual={error Data.Close:code6 catch Data.Close.Fail x return x}
    expected=S"""
      |Message This.Data.Close.Fail([###]):
      |@This1.Cache.Now class method This1.Size double(This1.Size n)=(..)
      |parameter n is initialized with fwd in the constructor class method mut This #apply(fwd imm This1.Size n)
      |[file:[###]
      """.trim())
    )
TestSum1=(
  code1a={method Void foo()=void}
  code1b={method Void foo()=void}
  {}:Test"Sum1"(
    actual={error (Trait:code1a)+code1b catch Trait.MethodClash x return x}
    expected=S"""
    |Message This.Trait.MethodClash([###]):
    |method Void foo()=(..)
    |Conflicting implementation: the method is implemented on both side of the sum
    |[file:[###]
    """.trim())
  code2a={interface method Void foo()}
  code2b={method Void foo()=void }
  {}:Test"Sum2"(
    actual={error (Trait:code2a)+code2b catch Trait.ClassClash x return x}
    expected=S"""
    |Message This.Trait.ClassClash([###]):
    |nested class This={ foo()=(..) }
    |The nested class can not be turned into an interface; some public methods are implemented
    |[file:[###]
    """.trim())
  )
Code=Trait:{
  A={method Void foo()=void}
  B={method Any foo()=void}
  C={method Void a(A a)=a.foo()}
  method Void a(A a)=void
  }
TestRename=(
  {}:Test"MethodClash=>"(
    actual={error Code['A=>'B] catch Trait.MethodClash x return x}
    expected=S"""
      |Message This.Trait.MethodClash([###]):
      |method Any foo()=(..)
      |Conflicting implementation: the method is implemented on both side of the sum
      |[file:[###]
      """.trim())
  {}:Test"MethodClash->"(
    actual={error Code['A->'B] catch Trait.MethodClash x return x}
    expected=S"""
      |Message This.Trait.MethodClash([###]):
      |method Any foo()=(..)
      |Conflicting implementation: the method is implemented on both side of the sum
      |[file:[###]
      """.trim())
  )
TestRename2=(
  {}:Test"MethodClash->"(
    actual={error Code['C->'This] catch Trait.MethodClash x return x}
    expected=S"""
      |Message This.Trait.MethodClash([###]):
      |method Void a(This.A a)=(..)
      |Conflicting implementation: the method is implemented on both side of the sum
      |[file:[###]
      """.trim())
  {}:Test"InvalidMap->"(
    actual={error Code['A.foo()=>Name""][single='A->Name""] catch Trait.InvalidMap x return x}
    expected=S"""
      |Message This.Trait.InvalidMap([###]):
      |nested class { a(a)=(..) A={..} B={..} C={..} }
      |nested class A
      |The implementation can not be removed since the class is watched by nested class C
      |Full mapping:A-><empty>
      |[file:[###]
      """.trim())
  {}:Test"InvalidMap->"(
    actual={error Code[hide='A.foo()][clearSingle='A] catch Trait.InvalidMap x return x}
    expected=S"""
      |Message This.Trait.InvalidMap([###]):
      |nested class { a(a)=(..) A={..} B={..} C={..} }
      |nested class A
      |The implementation can not be removed since the class is watched by nested class C
      |Full mapping:A-><empty>
      |[file:[###]
      """.trim())
  )

//Testing a funkyer way to test
TestError=Trait:{
  T={[Message]}
  class method This of()
  method Any()[Message]
  method S expected()
  class method Void :1(Library that)[Message]=(
    s=(This.of().expected()++Test.hole()).trim()
    (_=This.of()()
    catch T f (that:Test"ErrorMessage"(expected=s,actual=f.toS()))
    that:Test"ErrorExpected"(Bool.false())
    ))
  }
TestMethodClashFunky={A=Class:TestError['T=>Trait.MethodClash]:{
  method Any()[Message]=
    Code['A=>'B]
    //Code['A.#equalgt0(other='B)]
  method S expected()=S"""
    |Message [###]
    |method Any foo()=(..)
    |Conflicting implementation: the method is implemented on both side of the sum
    |[file:[###]
    """  
  }B={}:A}