reuse [AdamTowel]
ONum=Collection.optional(Num)
//Need to check:
/*
trait it
make wrapper
support iteration
//what about removing some methods from lists?

redirect:
You may redirect a native** on another native** if the native pars are
  idenatically transferred in redirect
You can not redirect a {} on an {nativeKind=Opt}
//another nativeOpt may now be ill typed
You can not redirect a {nativeKind=Opt} on an {} or different native kind
//a map may now be ill typed
You can not redirect a {nativeKind=LazyMsg} on an {}  or different native kind
//a range of natives may now be ill typed

sum:
You may sum/sumrename a native** on another native** if the native pars are
  idenatically renamed
You can not sum a {} on an {nativeKind=Opt}
//another nativeOpt may now be ill typed
You can not sum a {nativeKind=Opt} on an {} or different native kind
//sum is simmetric, so look above
You can not sum a {nativeKind=LazyMsg} on an {}
//a range of natives may now be ill typed

*/
MapAll={
  TraitHIMap:{
    Key={}
    Val={}
    OVal={}
    class method mut This of()
    read method This2.Bool isEmpty()=native{trusted:isEmpty} error void
    read method This2.Size size()=native{trusted:size} error void
    read method This2.Num immVal(This2.Size that)=native{trusted:immVal} error void
    read method This2.S immKey(This2.Size that)=native{trusted:immKey} error void
    read method This2.ONum val(This2.S that)=native{trusted:val} error void
    mut method Void put(This2.S key, This2.Num val)=native{trusted:put} error void
    mut method Void remove(This2.S that)=native{trusted:removeKey} error void
    #norm{
      nativeKind=HIMap
      nativePar=This2.S,This2.Num,This2.ONum,This2.Collection.OutOfBounds
      typeDep=This,This2.Size,This2.Bool,This2.S,This2.Num,This2.ONum,This2.Collection.OutOfBounds
      coherentDep=This2.Size,This2.Bool,This2.S,This2.Num,This2.ONum,This2.Collection.OutOfBounds
      watched=This2.Size,This2.Bool,This2.S,This2.Num,This2.ONum,This2.Collection.OutOfBounds
      }
    }
  }
Main=(
  mut MapAll.IM m=MapAll.IM.of()
  Debug(S"Hello world %m.isEmpty() %m.size()")
  (_=m.immVal(3Size) catch error Collection.OutOfBounds oob (Debug(oob)) error X"")
  (_=m.immVal(Size"-2") catch error Collection.OutOfBounds oob (Debug(oob)) error X"")
  m.put(key=S"a" val=5Num)
  m.put(key=S"b" val=7Num)
  sa=S"a" sb=S"b"
  Debug(S"-- %m.val(sa).get() %m.size()")
  m.remove(sa)
  Debug(S"-- %m.val(sb).get() %m.size()")
  )
