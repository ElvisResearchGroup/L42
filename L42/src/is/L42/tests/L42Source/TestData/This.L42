reuse[AdamTowel]
TestDataCacheErrors={
  A={class method S (Library that)=(
    _=Data:that
    Debug(S"passed :(")
    catch Data.Fail f (f.toS())
    S""
    )}
  TestLazy=(
    {}:Test"with par"(expected=S"""
      |Message This1.Data.Close.Fail(This1.HasToS, This1.Message, This1.Message.Guard, This1.Data.Fail):
      |@This2.Cache.Lazy method This2.Num m(This2.Num x)=(..)
      |can not be made cached; it must have zero parameters[###]
      """.trim(),actual=A({
        @Cache.Lazy method Num m(Num x)=1Num
        }))
    {}:Test"with mut receiver"(expected=S"""
      |Message This1.Data.Close.Fail(This1.HasToS, This1.Message, This1.Message.Guard, This1.Data.Fail):
      |@This2.Cache.Lazy mut method This2.Num m()=(..)
      |can not be made cached; the receiver modifier must be imm or capsule but it is mut[###]
      """.trim(),actual=A({
        @Cache.Lazy mut method Num m()=1Num
        }))
    {}:Test"with mut return"(expected=S"""
      |Message This1.Data.Close.Fail(This1.HasToS, This1.Message, This1.Message.Guard, This1.Data.Fail):
      |@This2.Cache.Lazy method mut This2.S.List m()=(..)
      |can not be made cached; the return type modifier must be imm or capsule but it is mut[###]
      """.trim(),actual=A({
        @Cache.Lazy method mut S.List m()=S.List[]
        }))
    )
  TestEager=(
    {}:Test"with par"(expected=S"""
      |Message This1.Data.Close.Fail(This1.HasToS, This1.Message, This1.Message.Guard, This1.Data.Fail):
      |@This2.Cache.Eager method This2.Num m(This2.Num x)=(..)
      |can not be made cached; it must have zero parameters[###]
      """.trim(),actual=A({
        @Cache.Eager method Num m(Num x)=1Num
        }))
    {}:Test"with mut receiver"(expected=S"""
      |Message This1.Data.Close.Fail(This1.HasToS, This1.Message, This1.Message.Guard, This1.Data.Fail):
      |@This2.Cache.Eager mut method This2.Num m()=(..)
      |can not be made cached; the receiver modifier must be imm but it is mut[###]
      """.trim(),actual=A({
        @Cache.Eager mut method Num m()=1Num
        }))
    {}:Test"with class receiver"(expected=S"""
      |Message This1.Data.Close.Fail(This1.HasToS, This1.Message, This1.Message.Guard, This1.Data.Fail):
      |@This2.Cache.Eager class method This2.Num m()=(..)
      |can not be made cached; the receiver modifier must be imm but it is class[###]
      """.trim(),actual=A({
        @Cache.Eager class method Num m()=1Num
        }))
    {}:Test"with mut return"(expected=S"""
      |Message This1.Data.Close.Fail(This1.HasToS, This1.Message, This1.Message.Guard, This1.Data.Fail):
      |@This2.Cache.Eager method mut This2.S.List m()=(..)
      |can not be made cached; the return type modifier must be imm or capsule but it is mut[###]
      """.trim(),actual=A({
        @Cache.Eager method mut S.List m()=S.List[]
        }))
    )
  TestNow=(
    {}:Test"with par"(expected=S"""
      |Message This1.Data.Close.Fail(This1.HasToS, This1.Message, This1.Message.Guard, This1.Data.Fail):
      |@This2.Cache.Now class method mut This2.S.List m(This2.Num foo)=(..)
      |can not be made cached; the return type modifier must be imm or capsule but it is mut[###]
      """.trim(),actual=A({Num foo
        @Cache.Now class method mut S.List m(Num foo)=S.List[]
        }))
    {}:Test"with par"(expected=S"""
     |Message This1.Data.Close.Fail(This1.HasToS, This1.Message, This1.Message.Guard, This1.Data.Fail):
     |@This2.Cache.Now method This2.Num m(This2.Num foo)=(..)
     |can not be made into a cached read method; the receiver modifier must be class but it is imm[###]
      """.trim(),actual=A({Num foo
        @Cache.Now method Num m(Num foo)=foo
        }))
    {}:Test"with par"(expected=S"""
     |Message This1.Data.Close.Fail(This1.HasToS, This1.Message, This1.Message.Guard, This1.Data.Fail):
     |@This2.Cache.Now class method This2.Num m(This2.Num bar)=(..)
     |No candidate getter/exposer with name bar and method modifier imm or read[###]
      """.trim(),actual=A({Num foo
        @Cache.Now class method Num m(Num bar)=bar
        }))
    )
  TestLazyRead=(
    {}:Test"with par"(expected=S"""
      |Message This1.Data.Close.Fail(This1.HasToS, This1.Message, This1.Message.Guard, This1.Data.Fail):
      |@This2.Cache.LazyRead class method mut This2.S.List m(This2.Num foo)=(..)
      |can not be made cached; the return type modifier must be imm or capsule but it is mut[###]
      """.trim(),actual=A({Num foo
        @Cache.LazyRead class method mut S.List m(Num foo)=S.List[]
        }))
    {}:Test"with par"(expected=S"""
     |Message This1.Data.Close.Fail(This1.HasToS, This1.Message, This1.Message.Guard, This1.Data.Fail):
     |@This2.Cache.LazyRead method This2.Num m(This2.Num foo)=(..)
     |can not be made into a cached read method; the receiver modifier must be class but it is imm[###]
      """.trim(),actual=A({Num foo
        @Cache.LazyRead method Num m(Num foo)=foo
        }))
    {}:Test"with par"(expected=S"""
     |Message This1.Data.Close.Fail(This1.HasToS, This1.Message, This1.Message.Guard, This1.Data.Fail):
     |@This2.Cache.LazyRead class method This2.Num m(This2.Num bar)=(..)
     |No candidate getter/exposer with name bar and method modifier imm or read[###]
      """.trim(),actual=A({Num foo
        @Cache.LazyRead class method Num m(Num bar)=bar
        }))
    )
  }

TestDataInterface={
  Shape={interface [HasToS]
    S that
    class method This of(S that)
    }
  Square=Data:{[Shape]
    S that
    class method Shape of(S that)=This(that)
    }
  MainShape=(
    res=S"""
      |Square("square")
      """.trim()
    {}:Test"square direct"(
      expected=res
      actual=Square.of(S"square"))
    class Shape s=Square
    {}:Test"square by shape"(
      expected=res
      actual=s.of(S"square"))
    )
  }
TestDataRelax=(
  {}:Test"DataNoRelax"((
    _=Data:{method Void foo(S notAField)}
    catch Class.IncoherentClass x (Bool.true())
    Bool.false()
    ))
  {}:Test"DataRelax"((
    _=Data.Relax:{method Void foo(S notAField)}
    catch Class.IncoherentClass x (Bool.false())
    Bool.true()
    ))

  )
TestDataFwd={
  A=Data:{mut B b,var S name}
  B=Data:{mut A a,var S name}
  Task1=(
    mut A a=A(b=b,name=S"myA")
    mut B b=B(a=a,name=S"myB")
    {}:Test"name"(expected=S"myB",actual=a.b().name())
    //A(b=(a=(b=b1, name="myA"), name="myB"), name="myA")//current toS result (with undefined b1)
    //b1=B(a=(b=b1, name="myA"), name="myB") //possible desired outcome, still unsatisfactory
    //A(b=b1, name="myB"), name="myA")
    {}:Test"toS"(expected=S"""
      |b1=B(a=a1, name="myB")
      |a1=A(b=b1, name="myA")
      |a1
      """.trim(),actual=a)
    )
  }
TestDataBase={
  Point=Data:{Size x, Size y}
  TestPoint=(
    p1=Point(x=8\, y=42\)
    p2=Point(x=8\, y=42\)
    p3=Point(x=0\, y=0\)
    {}:Test"pointEq1"(p1==p2)
    {}:Test"pointEq2"(p1!=p3)
    {}:Test"pointEqWithy"(p1!=p2.with(y=0\))
    {}:Test"pointEqWithxy"(p1==p3.with(y=p1.y()).with(x=p1.x()))
    {}:Test"pointToS"(expected=p1, actual=p1)
    {}:Test"pointToS"(expected=S"Point(x=8, y=42)", actual=p1)
    )
  Person=Data:{S.List names}
  Box=Data:{Any f1,Any f2}
  Anys=Class:Collection.listTrait()['Elem=>Any]
  TestPerson=(
    p1=Person(names=\['Bob;'Alice;'Charles])
    {}:Test"personToS"(expected=S"""
      |Person(names=["Bob"; "Alice"; "Charles"])
      """, actual=p1.toS()++S.nl())
    b1=Box(f1=p1,f2=Box(f1=S"hi",f2=S.List()))
    {}:Test"personToS"(expected=S"""
      |Box(f1=Person(names=["Bob"; "Alice"; "Charles"]), f2=Box(f1=S"hi", f2=S.List[]))
      """, actual=b1.toS()++S.nl())
    Anys bs=Anys[3Size]
    HasToS interf=bs
    HasToS interfS=S"hi"
    HasToS interfP=Point(x=1\,y=2\)
    {}:Test"anys1"(expected=S"""
      |Anys[3Size]
      """, actual=bs.toS()++S.nl())
    {}:Test"anys2"(expected=S"""
      |Anys[3Size]
      """, actual=interf.toS()++S.nl())
    {}:Test"anys3"(expected=S"""
      |hi
      """, actual=interfS.toS()++S.nl())
    {}:Test"anys4"(expected=S"""
      |Point(x=1, y=2)
      """, actual=interfP.toS()++S.nl())    
    )}