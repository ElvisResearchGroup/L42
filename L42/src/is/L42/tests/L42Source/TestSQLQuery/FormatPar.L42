class method S(HasToS that)=(
  var S s=that.toS()
  var b=Bool.false()
  if HasToS.Raw r=that (b:=Bool.true())
  if b s:=S"'%this.escape(s)'"
  else s:=this.validate(s)
  s
  )
class method S validate(S that)={//properly propagate S.ParseError
  if that==S"true" || that==S"false" (return that)
  _=Size.from(string=that)
  return that
  }
class method S escape(S that)=(
  var res=that
  res:=res.replace(S.nl() with=S"\n")
  res:=res.replace(S.dq() with=S"\%S.dq()")
  res:=res.replace(S"'" with=S"\'")
  res:=res.replace(S"_" with=S"\_")
  res:=res.replace(S"\" with=S"\\")
  res:=res.replace(S.tab() with=S"\t")
  res:=res.replace(S.percent() with=S"\%S.percent()")
  //res:=res.replace(?? with=S"\b")
  //res:=res.replace(?? with=S"\r")
  //TODO: then check that all the characters are "valid", to avoid unicode surprises?
  res
  )
class method S (S that,S key,HasToS val)=
  that.replace(S"@%key" with=FormatPar(val))
class method S.List xs(S that)={
  acc=S.List()
  var res=that
  loop (
   i0=res.indexOf(S"@")
   if i0==Size"-1" return acc
   i=res.indexOf(S" ", from=i0)
   i1=(if i==Size"-1" res.size() else i)
   p=res.subString(start=i0+1Size,end=i1)
   res:=res.subString(start=i1, end=\size)
   _=Name"%(p)()"//will throw error if p is not a valid identifier
   if !acc.contains(p) acc.add(right=p)
   )
  }
