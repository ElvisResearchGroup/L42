Traits=Collection.list(Trait)

FormatPar={...}
Collecters={...}
Executers={...}
SquareBuilder={
  mut Introspection.Nested.List that
  class method mut This (mut Introspection.Nested.List that)
  class method mut This #query#squareBuilder()=This(\())
  class method Bool #shortCircutSquare()=Bool.true()
  mut method Void #squareAdd(class Any that)
    =this.#that().add(right=Introspection.Nested.from(classAny=that))
  method Library #from(S.StringBuilder stringLiteral)={
    return Class:This1(types=this.that(),sql=S.#from(stringLiteral=stringLiteral))()
    whoops Message.Guard
    }
  }
//----------
Introspection.Nested.List types
S sql
Introspection.Nested r
Introspection.Method k
S.List xs
class method This(Introspection.Nested.List types,S sql,Introspection.Nested r,Introspection.Method k,S.List xs)
class method This(Introspection.Nested.List types,S sql)=(
  r=types.left().meth(selector='left()).returnType().nested()
  ms=Introspection.Method.List()(for m in r.methods() (
    if m.selector().toS().startsWith(S"#immK(") \res<=m
    ))
  if ms.size()!=1Size error X"more then one canditate imm constructor"//TODO:
  This(types=types,sql=sql,r=r, k=ms.val(0\),xs=FormatPar.xs(sql))
  )
      
method Trait field(Trait that, Size i)={
  n=Name"p%(i)()"
  f_s=Trait.LiftS(this.k().nameFromRoot().xs().val(i))['#apply()=>n]
  tSrc=Name"T%(i)"
  tDest=this.k().parameters().val(i+1Size).nested().classAny()
  return (that+f_s)[tSrc=>tDest;hide=n]
  whoops Message.Guard
  }
method Trait makeCR()={
  n=this.k().parameters().size()-1Size
  if n==0Size error X"no zero fields"
  var res=Collecters.traits().val(n-1Size)//TODO: error X"too many fields"
  for i in n.range() ( res:=this.field(res,i=i) )//from 0 to n-1
  return res[Collecters.names().val(n-1Size)=>Name"R.%this.k().selector()"]
  whoops Message.Guard
  }
//--
method Trait par(Trait that,Size i)={
  n=Name"p%(i)()"
  tSrc=Name"T%(i)"
  tDest=this.types().val(i+1Size).classAny()
  p=this.xs().val(i)
  p_s=Trait.LiftS(p)['#apply()=>n]
  return (that+p_s)[tSrc=>tDest;hide=n]
  whoops Message.Guard
  }
method Trait makeExecuteQ()={
  n=this.xs().size() //ok for zero too
  var res=Executers.traits().val(n)//TODO: error X"too many parameters"
  for i in n.range() ( res:=this.par(res,i=i) ) //0 to n-1
  nameDest=Name"#apply()".with(xs=this.xs())
  sql=Trait.LiftS(this.sql())['#apply()=>'sql()]
  return res[Executers.names().val(n)=>nameDest]+sql
  whoops Message.Guard
  }
//---
TraitK=Trait:{
  class method mut This (mut DB db)
  class method mut This (mut DB that)=This(db=that)
  }
method Trait ()={
  makeCR=this.makeCR()
  executeQ=this.makeExecuteQ()
  //Debug(makeCR.nested().toFullS())
  //Debug(executeQ.nested().toFullS())
  return (TraitK+makeCR+executeQ)[
    'R=>this.r().classAny();
    'List=>this.types().left().classAny()
    ]
  whoops Message.Guard
  }