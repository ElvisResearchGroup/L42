ClassOperators={class method class This1 ()=This1}
Fail=Message:{[Message$Guard]}
class method Library:(Library that)[Fail]=(this:Trait(that)).code()
class method Trait :(Trait trait)[Fail]={
  var res=TraitEnumBase()
  for n in Introspection.Nested.from(library=trait.code()).nesteds() (//trait.nested().nesteds()
    step=TraitEnumStep['E=>n.nameFromRoot()]
    base=res['Vals.next()=>'Vals.prev()]
    res:=(step+base)[hide='Vals.prev()]
    )
  res:=res[hide='sealed()]
  res:=(res+TraitCacheVals)[hide='Vals.next()]
  return res+trait
  catch Message$Guard g exception Fail"".with(cause=g)
  catch Any g error X"trait exceptions should all become guards"
  }
TraitEnumBase=Trait({interface
  read method Bool readEquality(read This that)
  Top={interface read method Bool readEquality(read This that)}
  List=Collection.list(Top)
  Vals={ class method List next()=List() }
  })['Top=>'This]
TraitEnumStep=Trait:{interface
  class method Void sealed()
  read method Bool readEquality(read This that)
  read method Bool ==(read This that)
  read method Bool !=(read This that)
  E={[This1,HasToS]
    class method This()
    class method Void sealed()=void
    method readEquality(that)
      =System.immEquality(System.readClone(this) and=System.readClone(that))
    method ==(that)=this.readEquality(that)
    method !=(that)=!this.readEquality(that)
    method toS()=Introspection.Nested.from(classAny=This).outerName().toS()
    }
  List={method This withAlsoRight(This1 that)}
  Vals={
    class method List prev()
    class method List next()=this.prev().withAlsoRight(E())
    }
  }
TraitCacheVals=Trait:{
  List={}
  Vals=Data:{
    class method List next()
    @Cache.Lazy class method List ()=this.next()
    }
  }