reuse[#$AdamTowel]
TestNum=(
  {}:Test"zero"(0Num+0Num==0Num)
  {}:Test"one+"(1Num+1Num==2Num)
  {}:Test"one*"(1Num*1Num==1Num)
  {}:Test"two+"(2Num+2Num==4Num)
  {}:Test"two*"(2Num*2Num==4Num)
  {}:Test"zero"(Num"25/30"+Num"11/60"==Num"61/60")
  {}:Test"zero"(Num"25/30"+Num"-11/60"==Num"39/60")
  {}:Test"zero"(Num"25/30"*Num"11/10"==Num"275/300")
  {}:Test"zero"(Num"25/30"*Num"-11/10"==Num"-275/300")
  )
TestQuote=(
  ss=S.List['hi()]
  {}:Test"quote"(S"hi()"==ss.left())
  )
OptS=Collection.optional(S)
OptSize=Collection.optional(Size)
TestOptS=(
  OptS o1=OptS()
  OptS o2=OptS(S"hi")
  {}:Test"opt"(o2.val()==S"hi")
  {}:Test"optNope"(S"Optional value is empty"==(
    error o1.val() catch error Collection.NoElementInOpt e e.text()
    ))
  )
TestOptSize=(
  OptSize o1=OptSize()
  OptSize o2=OptSize(8Size)
  {}:Test"opt"(o2.val()==8Size)
  {}:Test"optNope"(S"Optional value is empty"==(
    error o1.val() catch error Collection.NoElementInOpt e e.text()
    ))
  )
TestSizeRange=(
  var sAcc=S""
  for i in (21Size).range() (sAcc++=S"a")
  {}:Test"range 21"(sAcc.size()==21Size)
  )
TestMatchReduce=((
  mut S.List ss=S.List[S"a";S"b";S"c"]
  {}:Test"reduceWithValue"(S"DDabc"==
    ss.reduce(S"DD")(for e in \vals \res<=\acc++e))
  ),,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,(
  lent S.List ss=S.List[S"a";S"b";S"c"]
  {}:Test"reduceWithValue"(S"DDabc"==
    ss.reduce(S"DD")(for e in \vals \res<=\acc++e))    
  ),,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,(
  read S.List ss=S.List[S"a";S"b";S"c"]
  {}:Test"reduceWithValue"(S"DDabc"==
    ss.reduce(S"DD")(for e in \vals \res<=\acc++e))    
  ),,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,(
  imm S.List ss=S.List[S"a";S"b";S"c"]
  {}:Test"reduceWithValue"(S"DDabc"==
    ss.reduce(S"DD")(for e in \vals \res<=\acc++e))    
  ))
TestMatchSome=(
  ss=S.List[S"a";S"b";S"c"]
  (    
    res=ss.matchAny()(for s in \vals \res<=(s==S"c"))
    {}:Test"MatchSome"(res)
    ),,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,(
    var sAcc=S""
    res=ss.matchAny()(for s in \vals (sAcc++=S"#" \res<=(s==S"b")))
    {}:Test"MatchSomeShortCircut"(sAcc.size()==2Size)
    )
  )
TestSizeInString=(
  half=21Size
  answer=half+half
  {}:Test"Sum"(answer==42Size)"Computed answer is %answer.toS()"
  //{}:Test"Failing test"(answer==8Size)"Computed answer is %answer.toS()"
  {}:Test"StringConcat"(S"Hello World "++answer.toS()++S"!" == S"Hello World 42!")
  {}:Test"StringSpliceConcat"(S"Hello World %answer!" == S"Hello World 42!")
  )
TestSizeParsing=(
  err=Size"oh NO!"//throws error
  {}:Test"InvalidParseInt"( Bool.false() )"Errors not thrown"
  catch error S.ParseError x 
    {}:Test"InvalidParseIntError"(
      x.text()==S"The string %S.dq()oh NO!%S.dq() is not a valid number"
      )"Error is %x"
  )
NotCoh={This field, class method This ()}
TestMakeNotCohList=Class.Relax:Collection.listTrait()['Elem=>NotCoh<:class Any]
TestSList=(
  s=S.List()
  s.add(\"hi")
  {}:Test"singleVal"(expected=S"hi", actual=s.val(0Size))
  {}:Test"size1"(s.size()==1Size)
  )
TestMap=(
  imm s=S.List[S"a";S"b";S"c"]
  res=S.List()(for e in s \res<=S"Q"++e)
  //Note: should the above be preferred wrt S.List[for e in s \res<=...] ??
  {}:Test"mapped"(res.val(1\)==S"Qb")
  )

TestWhile=(
  while Bool.true() (
    {}:Test"while runs"(Bool.true())
    exception void  
    )
  )
TestBoolRelOps=(
  {}:Test"Less then"(!(3Size<3Size))
  {}:Test"Less then and false"(!(3Size<3Size && Bool.false()))
  )
TestVectorOps=(
  ss1=S.List[S"a";S"b";S"c"]
  ss2=S.List[S"1";S"2";S"3"]
  (
    var sAcc=S""
    for imm si in ss1 (sAcc++=si)
    {}:Test"Simple for"(sAcc==S"abc")
    ),,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,(
    var sAcc=S""
    for s1 in ss1, imm s2 in ss2 (sAcc++=s1++s2)
    {}:Test"Simple for"(sAcc==S"a1b2c3")
    ),,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,(
    ss3=S.List[(\res<=S"hi")]
    {}:Test"justSlash"(ss3.size()==1Size)
    ),,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,(
    ss4=S.List[for s1 in ss1, imm s2 in ss2 (\res<=s1++s2)]
    for var imm si in ss4 (si:=S"pe"++si)
    for var si in ss4 (si:=S"No"++si)
    var sAcc=S""
    for imm si in ss4 (sAcc++=si)
    {}:Test"Simple for"(sAcc==S"Nopea1Nopeb2Nopec3")
    )
  )
TestLog=(
  Log iLog=Log(S"Foo")
  mut Log mLog=iLog.#$reader()
  iLog.write(S"Hello")
  iLog.write(S" ")
  iLog.write(S"World")
  {}:Test"logTest"(expected=S"Hello World", actual=mLog.read())
  iLog.clear()
  )

Person={
  var S name
  var Size age
  class method mut This(S name,Size age)
  read method capsule This clone()=This(name=this.name(),age=this.age())
  }
Couple={
  var Person p1
  var Person p2
  class method mut This(Person p1, Person p2)
  read method capsule This clone()=This(p1=this.p1(),p2=this.p2())
  imm method Void normMe()=native{trusted:lazyCache} (void)
  }
I={ class method mut This() }
TestEqualities=(
  Person immPerson = (
    mut Person p1=Person(name=S"bob",age=23Size)
    mut Person p2=Person(name=S"bob",age=23Size)
    {}:Test"RefEq1"(!System.mutReferenceEquality(p1 and=p2))
    {}:Test"RefEq2"(System.mutReferenceEquality(p1 and=p1))
    {}:Test"RefEq3"(System.mutReferenceEquality(p2 and=p2))
    {}:Test"StructEq1"(System.mutStructuralEquality(p1 and=p2))
    p1.age(24Size)
    {}:Test"StructEq2"(!System.mutStructuralEquality(p1 and=p2))
    mut Person p3 = p1.clone()
    {}:Test"StructEq3"(System.mutStructuralEquality(p1 and=p3))
    p1
    )
  Couple immCouple = (
    mut Couple c1 = Couple(p1=immPerson, p2=immPerson)
    mut Couple c2 = Couple(p1=immPerson, p2=immPerson.clone())
    {}:Test"StructEq4"(!System.mutStructuralEquality(c1 and=c2))
    c2
    )
  Couple immCouple2 = Couple(p1=immPerson, p2=immPerson)
  Couple immCouple3 = Couple(p1=immPerson.clone(), p2=immPerson.clone())
  Couple immCouple4 = Couple(p1=immPerson, p2=Person(name=S"Claire",age=20Size))
  {}:Test"ImmEq1"(System.immEquality(immCouple and=immCouple2))
  {}:Test"ImmEq2"(System.immEquality(immCouple2 and=immCouple3))
  {}:Test"ImmEq3"(!System.immEquality(immCouple3 and=immCouple4))
  I i1 = I()
  I i2 = I()
  {}:Test"ImmEq4"(System.immEquality(i1 and=i2))
  
  mut Couple mutCouple = Couple(p1=immPerson, p2=immPerson)
  {}:Test"MutClone1"(!System.mutReferenceEquality(mutCouple and=System.mutClone(mutCouple)))
  {}:Test"MutClone2"(System.mutStructuralEquality(mutCouple and=System.mutClone(mutCouple)))
  {}:Test"ReadClone1"(System.immEquality(System.readClone(mutCouple) and=System.readClone(mutCouple)))
  void
  )

TestNestedTraits={
  Trait2=Trait:{method Void foo()=void}
  A=Trait2:{
    class method Bool k()=Bool.true()
    B=Trait:{
      class method class This1 m()=This1
      }
    }
  AA=A.code()
  BB=AA.B.code()
  TestBB={}:Test"bb"(BB.m().k())
  }