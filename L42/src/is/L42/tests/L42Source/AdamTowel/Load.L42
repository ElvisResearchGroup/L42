ClassOperators={class method This1()=This1()}

Introspection.Nested$List deps
  
class method This(Introspection.Nested$List deps)
  
class method This()=\(deps=this.baseDeps())
  
N={//To shorten the creation of the list baseDeps
  ClassOperators={class method class This1()=This1}
  class method Introspection.Nested:(class Any a)=\.from(classAny=a)
  }
class method mut Introspection.Nested$List baseDeps()=\[
  N:Public;
  N:(HasToS<:class Any);
  N:Break;
  N:Bool;
  N:Size;
  N:Num;
  N:S;
  N:Debug;
  N:Url;
  N:Test;
  N:Log;
  N:Name;
  N:Trait;
  N:Class;
  N:Deploy;
  N:(Message<:class Any);
  N:X;
  N:Collection;
  N:Cache;
  N:Data;
  N:Introspection;
  N:Organize;
  N:Load$;
  ]
method Trait.Acc collect(Library that)=(
  atIn=Introspection.Nested.from(library=that).nested(name='AbstractTowel)
  atOut=Introspection.Nested.from(classAny=AbstractTowel)
  acc=Trait.Acc(Name$Mapping())
  for nci in atIn.nesteds() (
    src=nci.innerDoc().annotation(nested=atIn).get().texts().left()
    name=nci.nameFromRoot()
    for ncj in this.deps() (
      dest=ncj.innerDoc().annotation(nested=atOut).get().texts().left()
      matches=this.match(src=src,dest=dest)
      if matches (acc.#squareAdd(deep=name=>ncj.classAny()) Break())
      )
    )
  acc
  )
method Library :(Library that)
  [Trait$InvalidName,Trait$InvalidMap,Trait$MethodClash,Trait$ClassClash]
  =Class:Trait(that)(squareBuilder=this.collect(that))
  
method Bool match(S src,S dest)=src==dest//To be overridden
@AbstractTowel{load}