ClassOperators={class method This1()=This1()}

Introspection.Nesteds deps
  
class method This(Introspection.Nesteds deps)
  
class method This()=\(deps=this.baseDeps())
  
N={//To shorten the creation of the list baseDeps
  ClassOperators={class method class This1()=This1}
  class method Introspection.Nested:(class Any a)=\.from(classAny=a)
  }
class method mut Introspection.Nesteds baseDeps()=\[
  N:S;N:Size;N:Bool;N:Debug/*..*/
  ]
method Trait.Acc collect(Library that)=(
  at=Introspection.Nested.from(library=that).nested(name='AbstractTowel)
  acc=Trait.Acc(Meta())
  for nci in at.nesteds() (
    src=nci.outerDoc().annotation(nested=at).get().texts().left()
    name=nci.nameFromRoot()
    for ncj in this.deps() (
      dest=ncj.outerDoc().annotation(nested=at).get().texts().left()
      matches=this.match(src=src,dest=dest)
      if matches acc.#squareAdd(name=>ncj.classAny())
      )
    )
  acc
  )
method Library :(Library that)
  [Trait$InvalidName,Trait$InvalidMap,Trait$MethodClash,Trait$ClassClash]
  =Class:Trait(that)(squareBuilder=this.collect(that))
  
method Bool match(S src,S dest)=src==dest//To be overridden
/*
TODO:
- remove unused code
-Adam towel will have an empty AbstractTowel nested 
Load
  takes a Library with a nested AbstractTowel
    for every nested in abstract towel: there is a @AbstractTowel/This{id}
    in the outer Towel there are nesteds with @AbstractTowel{id'}
  for ni in input.AbstractTowel
    for nj in towel.annotated?? (simply a list of Nested, the user can add to?)
      if ni match nj redirect ni=>*nj
DeployLibrary
  takes a Library l and a Name n
  l=removeUnusedCode(l,n)
  forall nested !=n:
    if nested not labeled make it private
    else rename in AbstractTowel
  abstract* AbstractTowel
  rename n=>This 
  
  
Then caching top level

Then IDE
*/