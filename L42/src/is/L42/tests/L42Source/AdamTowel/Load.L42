AbstractTowel={}
Load={
  Introspection.Nesteds deps
  
  class method This(Introspection.Nesteds deps)
  
  class method This()=\(deps=this.baseDeps())
  
  class method mut Introspection.Nesteds baseDeps()=\[
    S;Size;Bool;Debug/*..*/
    ]
    
  Acc=Data:{
    Introspection.Nested i
    mut Trait.Acc acc
    
    method S id(Introspection.Nested that)=
      that.outerDoc().annotation(nested=this.i()).get().texts().left()

    method mut Trait.Acc ()=(
      for nci in i.nesteds() (this(nci))
      this.acc()
      )
    method Void (Introspection.Nested that)=
      for ncj in this.that()
        if this.match(src=this.id(that),dest=this.id(ncj))
          this.add().#squareAdd(that.nameFromRoot()=>this.classAny())
    }
    
  Library :(Library that)=(
    top=Introspection.Nested.from(library=that)
    i=top.nested(name='AbstractTowel)
    Class:Trait(that)(squareBuilder=Acc(i=i,acc=Meta())())
    )
  } 
/*
TODO:
- remove unused code
-Adam towel will have an empty AbstractTowel nested 
Load
  takes a Library with a nested AbstractTowel
    for every nested in abstract towel: there is a @AbstractTowel/This{id}
    in the outer Towel there are nesteds with @AbstractTowel{id'}
  for ni in input.AbstractTowel
    for nj in towel.annotated?? (simply a list of Nested, the user can add to?)
      if ni match nj redirect ni=>*nj
DeployLibrary
  takes a Library l and a Name n
  l=removeUnusedCode(l,n)
  forall nested !=n:
    if nested not labeled make it private
    else rename in AbstractTowel
  abstract* AbstractTowel
  rename n=>This 
  
  
Then caching top level

Then IDE
*/