ClassOperators={class method This1()=This1()}

Introspection.Nesteds deps
  
class method This(Introspection.Nesteds deps)
  
class method This()=\(deps=this.baseDeps())
  
N={//To shorten the creation of the list baseDeps
  ClassOperators={class method class This1()=This1}
  class method Introspection.Nested:(class Any a)=\.from(classAny=a)
  }
class method mut Introspection.Nesteds baseDeps()=\[
  N:Public;
  N:(HasToS<:class Any);
  N:Break;
  N:Bool;
  N:Size;
  N:Num;
  N:S;
  N:Debug;
  N:Url;
  N:Test;
  N:Log;
  N:Name;
  N:Trait;
  N:Class;
  N:Deploy;
  N:(Message<:class Any);
  N:X;
  N:Collection;
  N:Cache;
  N:Data;
  N:Introspection;
  N:Organize;
  N:Load$;
  ]
method Trait.Acc collect(Library that)=(
  at=Introspection.Nested.from(library=that).nested(name='AbstractTowel)
  acc=Trait.Acc(Name$Mapping())
  for nci in at.nesteds() (
    src=nci.outerDoc().annotation(nested=at).get().texts().left()
    name=nci.nameFromRoot()
    for ncj in this.deps() (
      dest=ncj.outerDoc().annotation(nested=at).get().texts().left()
      matches=this.match(src=src,dest=dest)
      if matches acc.#squareAdd(deep=name=>ncj.classAny())
      )
    )
  acc
  )
method Library :(Library that)
  [Trait$InvalidName,Trait$InvalidMap,Trait$MethodClash,Trait$ClassClash]
  =Class:Trait(that)(squareBuilder=this.collect(that))
  
method Bool match(S src,S dest)=src==dest//To be overridden