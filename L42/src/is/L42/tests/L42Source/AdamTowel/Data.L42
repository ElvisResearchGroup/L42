AddConstructors$Fail=Class:Message.Native:{[Guard]}      
AddConstructors$Meta={
  class method This #apply()
  method Library addConstructors(Library that,This2.S name,This2.S mutK,This2.S immK)=native{trusted:addConstructors} error void
  #norm{nativeKind=Meta,
    typeDep=This0 This1.AddConstructors$Fail,This2.S
    coherentDep=This1.AddConstructors$Fail,
    nativePar=This1.AddConstructors$Fail This1.AddConstructors$Fail This1.AddConstructors$Fail This1.AddConstructors$Fail This1.AddConstructors$Fail
    }}
AddConstructors={
  Name that
  class method This(Name that)
  class method This()=This('This0)
  ClassOperators={class method This1()=This1()}
  method Trait :(Trait t)=this:t.code()
  method Trait :(class Trait.Lifted l)=this:l.code()
  method Trait :(Library that)=Trait(AddConstructors$Meta().addConstructors(that,name=this.that().toS(),mutK=S"#apply",immK=S"#immK"))
  }

Wither$Fail=Class:Message.Native:{[Guard]}      
Wither$Meta={
  class method This #apply()
  method Library wither(Library that,This2.S name,This2.S immK)=native{trusted:wither} error void
  #norm{nativeKind=Meta,
    typeDep=This0 This1.Wither$Fail,This2.S
    coherentDep=This1.Wither$Fail,
    nativePar=This1.Wither$Fail This1.Wither$Fail This1.Wither$Fail This1.Wither$Fail This1.Wither$Fail
    }}
Wither={
  Name that
  class method This(Name that)
  class method This()=This('This0)
  ClassOperators={class method This1()=This1()}
  method Trait :(Trait t)=this:t.code()
  method Trait :(class Trait.Lifted l)=this:l.code()
  method Trait :(Library that)=Trait(Wither$Meta().wither(that,name=this.that().toS(),immK=S"#immK"))
  }

ClassOperators={class method This1()=This1()}
Operations=
  Class.MutReferenceEquality+
  Class.MutStructuralEquality+
  Class.ImmEquality+
  Class.ReadClone+
  Class.MutClone+
  Class.ReadEquality+
  Class.ImmToString+
  Class.ImmNorm
AddEqOp=Trait:{
    method Bool immEquality(This that)
    method Bool ==(This that)=this.immEquality(that)
    method Bool !=(This that)=!(this==that)
    }
AddHasToS=Class.ReadToString+{[HasToS]
    method toS()=this.readToString()
    }

class method This()
method Library :(Library lib)=this:Trait(lib)
method Library :(Trait that)=(
  var Trait acc=that
  acc:=AddConstructors:acc
  acc:=Wither:acc
  acc:=Cache.Close:acc
  acc:=Operations+acc
  catch MethodClash x error x
  catch ClassClash x error x
  //TODO: handle errors for Close,AddConstructors and so on
  //declare a common Data.Fail interface/wrapper and Data will throw exception Data.Fail
  //TODO: make some stuff private?
  //TODO: add toString and standard code to Operations, and wither!
  (acc:=AddHasToS:acc catch Any _ void)
  (acc:=AddEqOp:acc catch Any _ void)
  Class:acc
  )
  
/*
Data: adds
  //using Traits
  -read conventional structural equals//need a wrapper if the type of the argument is not This0?
  -read conventional structural toString
  -read niceToString
  -read hashCode from conventional string?
  -read lift toLibrary capsule val?
  //using field informations
  -imm wither
  -constructor with as many fwds as possible
  Do not close state, do not handle invariant
  Return a library, not a Trait

Class: check that the library is consistent (and may extract from a trait)
  Both Data subsume Class.

Do we need special treatement for classes with no fields?
in this case it would make an Imm constructor, but it would be deceiving to allow Data on no fields.
Would also add an operator == even if no fields... is this transparent with structural checks?

Action: on code with only 1 abs method named #apply, it mark them as interfaces
  on code implementing an Action method behave as Class and then close
all the state an make all but the interface methods private
Organize: will rename A$B in A.B and so on; will mark as private
methods not annotated as @Exported
Unit
Alphanumeric
*/