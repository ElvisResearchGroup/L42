@Public Close$Fail=Class:Message.Native:{[Message$Guard]}      
Close$Meta={
  class method This #apply()
  method Library close(Library that,This2.S name)=native{trusted:close} error void
  #norm{nativeKind=Meta,
    typeDep=This0 This1.Close$Fail,This2.S
    coherentDep=This1.Close$Fail,
    nativePar=This1.Close$Fail This1.Close$Fail This1.Close$Fail This1.Close$Fail This1.Close$Fail
    }}
@Public Close={
  Name that
  @Public class method This(Name that)
  @Public ClassOperators={class method This1()=This1('This)}
  @Public method Trait :(Trait t)=this:t.code()
  @Public method Trait :(class Trait.Lifted l)=this:l.code()
  @Public method Trait :(Library that)=Trait(Close$Meta().close(that,name=this.that().toS()))
  }
@Public AddConstructors$Fail=Class:Message.Native:{[Message$Guard]}      
AddConstructors$Meta={
  class method This #apply()
  method Library addConstructors(Library that,This2.S name,This2.S mutK,This2.S immK)=native{trusted:addConstructors} error void
  #norm{nativeKind=Meta,
    typeDep=This0 This1.AddConstructors$Fail,This2.S
    coherentDep=This1.AddConstructors$Fail,
    nativePar=This1.AddConstructors$Fail This1.AddConstructors$Fail This1.AddConstructors$Fail This1.AddConstructors$Fail This1.AddConstructors$Fail
    }}
@Public AddConstructors={
  Name that
  @Public class method This(Name that)
  @Public ClassOperators={class method This1()=This1('This)}
  @Public method Trait :(Trait t)=this:t.code()
  @Public method Trait :(class Trait.Lifted l)=this:l.code()
  @Public method Trait :(Library that)=Trait(AddConstructors$Meta().addConstructors(that,name=this.that().toS(),mutK=S"#apply",immK=S"#immK"))
  }

@Public Wither$Fail=Class:Message.Native:{[Message$Guard]}      
Wither$Meta={
  class method This #apply()
  method Library wither(Library that,This2.S name,This2.S immK)=native{trusted:wither} error void
  #norm{nativeKind=Meta,
    typeDep=This0 This1.Wither$Fail,This2.S
    coherentDep=This1.Wither$Fail,
    nativePar=This1.Wither$Fail This1.Wither$Fail This1.Wither$Fail This1.Wither$Fail This1.Wither$Fail
    }}
@Public Wither={
  Name that
  @Public class method This(Name that)
  @Public ClassOperators={class method This1()=This1('This)}
  @Public method Trait :(Trait t)=this:t.code()
  @Public method Trait :(class Trait.Lifted l)=this:l.code()
  @Public method Trait :(Library that)=Trait(Wither$Meta().wither(that,name=this.that().toS(),immK=S"#immK"))
  }
@Public ClassOperators={class method This1()=This1()}
Operations=
  Class.MutReferenceEquality+
  Class.MutStructuralEquality+
  Class.ImmEquality+
  Class.ReadClone+
  Class.MutClone+
  Class.ReadEquality+
  Class.ImmToString+
  Class.ImmNorm
AddEqOp=Trait:{
    method Bool immEquality(This that)
    method Bool ==(This that)=this.immEquality(that)
    method Bool !=(This that)=!(this==that)
    }
AddHasToS=Class.ReadToString+{[HasToS]
    method toS()=this.readToString()
    }
@Public class method This()
@Public method Library :(Library lib)=this:Trait(lib)
@Public method Library :(Trait that)=(
  var Trait acc=that
  acc:=AddConstructors:acc
  acc:=Wither:acc
  acc:=Close:acc
  acc:=Operations+acc
  catch Trait$MethodClash x error x
  catch Trait$ClassClash x error x
  //TODO: handle errors for Close,AddConstructors and so on
  //declare a common Data.Fail interface/wrapper and Data will throw exception Data.Fail
  //TODO: make some stuff private?
  //TODO: add toString and standard code to Operations, and wither!
  (acc:=AddHasToS:acc catch Any _ void)
  (acc:=AddEqOp:acc catch Any _ void)
  Class:acc
  )
  
/*
Data: adds
  //using Traits
  -read conventional structural equals//need a wrapper if the type of the argument is not This0?
  -read conventional structural toString
  -read niceToString
  -read hashCode from conventional string?
  -read lift toLibrary capsule val?
  //using field informations
  -imm wither
  -constructor with as many fwds as possible
  Do not close state, do not handle invariant
  Return a library, not a Trait

Class: check that the library is consistent (and may extract from a trait)
  Both Data subsume Class.

Do we need special treatement for classes with no fields?
in this case it would make an Imm constructor, but it would be deceiving to allow Data on no fields.
Would also add an operator == even if no fields... is this transparent with structural checks?

Action: on code with only 1 abs method named #apply, it mark them as interfaces
  on code implementing an Action method behave as Class and then close
all the state an make all but the interface methods private
Organize: will rename A$B in A.B and so on; will mark as private
methods not annotated as @Public
Unit
Alphanumeric
*/