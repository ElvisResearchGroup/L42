//Step 1: the minimal infrastructure to deploy a towel
S={
  class method This empty()
  #norm{nativeKind=String, nativePar=This1.ParseErr
    typeDep=This,This1.ParseErr
    coherentDep=This1.ParseErr
  }}
ParseErr={class method This empty() #norm{nativeKind=LazyMessage typeDep=This}}
Debug={
  class method This of()
  method Void deployLibrary(This1.S that,Library lib)=
    native{trusted:deployLibrary} error void
    #norm{typeDep=This, This1.S, nativeKind=TrustedIO}        
  }
S$StringBuilder={
  class method mut This of()
  mut method Void _a()=
    native{trusted:'a'} error void
  read method This1.S toS()=
    native{trusted:toS} error void
    #norm{nativeKind=StringBuilder
      typeDep=This0,This1.S
      coherentDep=This1.S 
      }
  }
//Step 2: Base towel, all the main functionalities are there
// but miss some details and do not have encapsulation
DeployAAA=(
  lib={
    Public={}
    @Public HasToS={interface read method S toS()}
    //HasEquals={ }//NOPE: == hava a base. A trait can add to a class extends any, and to an interface (as a new base) and to the ones implementing the base.
    //List can take a class method Boolean equals(Elem e1,Elem e2)
    @Public Break={class method Void ()[Void]=exception void}
    @Public Bool={...}
    @Public Size={...}
    @Public Num={...}
    @Public S={...}
    NativeName={...}
    S$ParseError={...}//can not use BaseErrorTrait() since circular dependence from S
    @Public Url={...}
    @Public Debug={...}
    S$StringBuilder={...}//end of circular dependency for S
    BaseErrorTrait={...}
    @Public Trait$MethodClash=BaseErrorTrait()
    @Public Trait$ClassClash=BaseErrorTrait()
    @Public Trait$InvalidName=BaseErrorTrait()
    @Public Trait$InvalidMap=BaseErrorTrait()
    @Public Test={...}
    @Public Log={...}
    Meta={...}
    @Public Name={...}
    @Public Trait={...}
    @Public Class={...}
    @Public Deploy={...}
    @Public Message={...}
      @Public Message$Guard={interface [Message]}
      @Public Message$Assertion={interface[Message]}
    ClassName={
      class method S (class Any that)=S"toFix"
      class method S superInterfaces(class Any that)=S"toFix"
      class method S excName(class Any that, S text)=S"Message %(This(that))(%This.superInterfaces(that)):%S.nl()%text"
      }
    MessageTrait=Trait:{...}
    LazyMessageTrait={...}
    @Public X=Class:Message:{...}
    @Public IterationIncomplete=Class:Message:{[Message$Guard]}
    @Public NoElementInOpt=Class:Message.Native:{[Message$Guard]}
    @Public OutOfBounds=Class:Message.Native:{[Message$Guard]}
    @Public ElementNotImm=Class:Message.Native:{[Message$Guard]}
    @Public ElementNotMut=Class:Message.Native:{[Message$Guard]}    
    @Public Opt={...}
    @Public Collection={...}
    @Public Strings=Class:Collection.listEqTrait()['Elem=>S]:{
      class method Bool equals(read S a,read S b)=a==b
      }
    @Public Cache={...}
    @Public Data={...}
    @Public Introspection=Class:Trait({...})[
      'Nested$=>'Nested;'Type$=>'Type;'Doc$=>'Doc;'Method$=>'Method
      ]
    DelayTyping={}
    @Public Organize={...}
    }
  mut S$StringBuilder sb=S$StringBuilder.of()
  sb._a() sb._a() sb._a()
  Debug.of().deployLibrary(sb.toS(),lib=lib)
  )
//Deploy step2:
DeployAdamTowel={reuse[#$aaa]
  AddOns=Deploy.towel(url='AdamTowel,
    code=Class:Organize:(Trait:{...}+{reuse[#$aaa]})
    ) 
  }
//Testing step2:
TestsAdamTowel={...}