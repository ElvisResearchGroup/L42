//Step 1: the minimal infrastructure to deploy a towel
S={
  class method This empty()
  #norm{nativeKind=String, nativePar=This1.ParseErr
    typeDep=This,This1.ParseErr
    coherentDep=This1.ParseErr
  }}
ParseErr={class method This empty() #norm{nativeKind=LazyMessage typeDep=This}}
Debug={
  class method This of()
  method Void deployLibrary(This1.S that,Library lib)=
    native{trusted:deployLibrary} error void
    #norm{typeDep=This, This1.S, nativeKind=TrustedIO}        
  }
S$StringBuilder={
  class method mut This of()
  mut method Void _a()=
    native{trusted:'a'} error void
  read method This1.S toS()=
    native{trusted:toS} error void
    #norm{nativeKind=StringBuilder
      typeDep=This0,This1.S
      coherentDep=This1.S 
      }
  }
//Step 2: Base towel, all the main functionalities are there
// but miss some details and do not have encapsulation
DeployAAA=(
  lib={
    Public$={}
    @Public$ AbstractTowel={}
    @Public$ Public={@AbstractTowel{public}}    
    @Public HasToS={interface read method S toS() @AbstractTowel{hasToS}}
    //HasEquals={ }//NOPE: == hava a base. A trait can add to a class extends any, and to an interface (as a new base) and to the ones implementing the base.
    //List can take a class method Boolean equals(Elem e1,Elem e2)
    @Public Break={class method Void ()[Void]=exception void @AbstractTowel{break}}
    @Public Bool={...}
    @Public Size={...}
    @Public Num={...}
    @Public S={...}
    NativeName={...}
    @Public S$ParseError={...}//can not use BaseErrorTrait() since circular dependence from S
    @Public Debug={...}
    @Public S$StringBuilder={...}//end of circular dependency for S
    Introspection$Nested={
      class method This from(Library library)=error void
      class method This from(class Any classAny)=error void
      method S excName(S text)=error void
      }
    @Public Url={...}
    BaseErrorTrait={...}
    @Public Trait$MethodClash=BaseErrorTrait()
    @Public Trait$ClassClash=BaseErrorTrait()
    @Public Trait$InvalidName=BaseErrorTrait()
    @Public Trait$InvalidMap=BaseErrorTrait()
    @Public Test={...}
    @Public Log={...}
    @Public Name$Mapping={...}
    @Public Name={...}
    @Public Trait={...}
    @Public Class={...}
    @Public Deploy={...}
    @Public Message={...}
    @Public Message$Guard={interface [Message]}
    @Public Message$Assertion={interface[Message]}
    MessageTrait=Trait:{...}
    LazyMessageTrait={...}
    @Public X=Class:Message:{...}
    @Public Collection$IterationIncomplete=Class:Message:{[Message$Guard]}
    @Public Collection$NoElementInOpt=Class:Message.Native:{[Message$Guard]}
    @Public Collection$OutOfBounds=Class:Message.Native:{[Message$Guard]}
    @Public Collection$ElementNotImm=Class:Message.Native:{[Message$Guard]}
    @Public Collection$ElementNotMut=Class:Message.Native:{[Message$Guard]}    
    @Public Collection={...}
    @Public S$List=Class:Collection.listEqTrait()['Elem=>S]:{
      class method Bool equals(read S a,read S b)=a==b
      }
    @Public Name$List=Class:Collection.listEqTrait()['Elem=>Name]:{
      class method Bool equals(read Name a,read Name b)=a==b
      }
    Size$List=Class:Collection.listEqTrait()['Elem=>Size]:{
      class method Bool equals(read Size a,read Size b)=a==b
      }
    Num$List=Class:Collection.listEqTrait()['Elem=>Num]:{
      class method Bool equals(read Num a,read Num b)=a==b
      }    
    @Public Cache={...}
    @Public Data={...}
    @Public Introspection=Class:Trait({...})[
      'Nested$=>'Nested;'Type$=>'Type;'Doc$=>'Doc;'Method$=>'Method
      ]
    DelayTyping={}
    @Public Organize={...}
    Deploy$={...}
    Load$={}
    @Public Load={...}    
    }
  mut S$StringBuilder sb=S$StringBuilder.of()
  sb._a() sb._a() sb._a()
  Debug.of().deployLibrary(sb.toS(),lib=lib)
  )
//Deploy step2:
DeployAdamTowel={reuse[#$aaa]
  AddOns=(
    base=Trait({reuse[#$aaa]})[clear='Introspection$Nested]
    added=Trait:{...}
    tot=base+added
    organize=Organize(public='Public)
    toDeploy=Class:(organize:tot)['This=>'AbstractTowel.Top][hide='AbstractTowel.Top]
    Debug(Introspection.Nested.from(library=toDeploy).toFullS())
    Deploy.towel(url='AdamTowel,code=toDeploy)
    )
  }
//Testing step2:
TestsAdamTowel={...}