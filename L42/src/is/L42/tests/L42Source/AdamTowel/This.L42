//Step 1: the minimal infrastructure to deploy a towel
S={
  class method This empty()
  #norm{nativeKind=String, nativePar=This1.ParseErr
    typeDep=This,This1.ParseErr
    coherentDep=This1.ParseErr
  }}
ParseErr={class method This empty() #norm{nativeKind=LazyMessage typeDep=This}}
Debug={
  class method This of()
  method Void deployLibrary(This1.S that,Library lib)=
    native{trusted:deployLibrary} error void
    #norm{typeDep=This, This1.S, nativeKind=TrustedIO}        
  }
S$StringBuilder={
  class method mut This of()
  mut method Void _a()=
    native{trusted:'a'} error void
  read method This1.S toS()=
    native{trusted:toS} error void
    #norm{nativeKind=StringBuilder
      typeDep=This0,This1.S
      coherentDep=This1.S 
      }
  }
//Step 2: Base towel, all the main functionalities are there
// but miss some details and do not have encapsulation
DeployAAA=(
  lib={
    Public$={}
    @Public$ AbstractTowel={}
    @Public$ @AbstractTowel{public}Public={}    
    @Public @AbstractTowel{hasToS}HasToS={interface read method S toS()}
    //HasEquals={ }//NOPE: == hava a base. A trait can add to a class extends any, and to an interface (as a new base) and to the ones implementing the base.
    //List can take a class method Boolean equals(Elem e1,Elem e2)
    @Public @AbstractTowel{break}Break={class method Void ()[Void]=exception void}
    @Public @AbstractTowel{bool}Bool={...}
    @Public @AbstractTowel{size}Size={...}
    @Public @AbstractTowel{num}Num={...}
    @Public @AbstractTowel{s}S={...}
    NativeName={...}
    S$ParseError={...}//can not use BaseErrorTrait() since circular dependence from S
    @Public @AbstractTowel{debug}Debug={...}
    S$StringBuilder={...}//end of circular dependency for S
    Introspection$Nested={
      class method This from(Library library)=error void
      class method This from(class Any classAny)=error void
      method S excName(S text)=error void
      }
    @Public @AbstractTowel{url}Url={...}
    BaseErrorTrait={...}
    @Public Trait$MethodClash=BaseErrorTrait()
    @Public Trait$ClassClash=BaseErrorTrait()
    @Public Trait$InvalidName=BaseErrorTrait()
    @Public Trait$InvalidMap=BaseErrorTrait()
    @Public @AbstractTowel{test}Test={...}
    @Public @AbstractTowel{log}Log={...}
    @Public Meta={...} //TODO: will be private later, but then
    //trait[] need to take NOT A META, and NAME=>NAME need to return NOT A META
    @Public @AbstractTowel{name}Name={...}
    @Public @AbstractTowel{trait}Trait={...}
    @Public @AbstractTowel{class}Class={...}
    @Public @AbstractTowel{deploy}Deploy={...}
    @Public @AbstractTowel{message}Message={...}
    @Public Message$Guard={interface [Message]}
    @Public Message$Assertion={interface[Message]}
    MessageTrait=Trait:{...}
    LazyMessageTrait={...}
    @Public @AbstractTowel{x}X=Class:Message:{...}
    @Public Collection$IterationIncomplete=Class:Message:{[Message$Guard]}
    @Public Collection$NoElementInOpt=Class:Message.Native:{[Message$Guard]}
    @Public Collection$OutOfBounds=Class:Message.Native:{[Message$Guard]}
    @Public Collection$ElementNotImm=Class:Message.Native:{[Message$Guard]}
    @Public Collection$ElementNotMut=Class:Message.Native:{[Message$Guard]}    
    @Public @AbstractTowel{collection}Collection={...}
    S$List=Class:Collection.listEqTrait()['Elem=>S]:{
      class method Bool equals(read S a,read S b)=a==b
      }
    Name$List=Class:Collection.listEqTrait()['Elem=>Name]:{
      class method Bool equals(read Name a,read Name b)=a==b
      }
    Size$List=Class:Collection.listEqTrait()['Elem=>Size]:{
      class method Bool equals(read Size a,read Size b)=a==b
      }
    Num$List=Class:Collection.listEqTrait()['Elem=>Num]:{
      class method Bool equals(read Num a,read Num b)=a==b
      }    
    @Public @AbstractTowel{cache}Cache={...}
    @Public @AbstractTowel{data}Data={...}
    @Public @AbstractTowel{introspection}Introspection=Class:Trait({...})[
      'Nested$=>'Nested;'Type$=>'Type;'Doc$=>'Doc;'Method$=>'Method
      ]
    DelayTyping={}
    @Public @AbstractTowel{organize}Organize={...}
    Deploy$={...}
    Load$={}
    @Public @AbstractTowel{load} Load={...}    
    }
  mut S$StringBuilder sb=S$StringBuilder.of()
  sb._a() sb._a() sb._a()
  Debug.of().deployLibrary(sb.toS(),lib=lib)
  )
//Deploy step2:
DeployAdamTowel={reuse[#$aaa]
  AddOns=(
    base=Trait({reuse[#$aaa]})[clear='Introspection$Nested]
    added=Trait:{...}
    tot=base+added
    organize=Organize(public='Public)
    toDeploy=Class:(organize:tot)['This=>'AbstractTowel.Top]//[hide='AbstractTowel.Top]
    //Debug(Introspection.Nested.from(library=toDeploy).toFullS())
    //organize=Organize()
    Deploy.towel(url='AdamTowel,code=toDeploy)
    )
  }
//Testing step2:
TestsAdamTowel={...}