//Step 1: the minimal infrastructure to deploy a towel
S={#norm{nativeKind=String}}
Debug={
  class method This of()
  method Void deployLibrary(This1.S that,Library lib)=
    native{trusted:deployLibrary} error void
    #norm{declaresClassMethods, typeDep=This, This1.S, nativeKind=TrustedIO}        
  }
StringBuilder={
  class method mut This of()
  mut method Void _a()=
    native{trusted:'a'} error void
  read method This1.S toS()=
    native{trusted:toS} error void
    #norm{declaresClassMethods, typeDep=This0, This1.S, nativeKind=StringBuilder}
  }
//Step 2: barely usable Strings, booleans and Size
DeployAAA=(
  mut StringBuilder sb=StringBuilder.of()
  sb._a()sb._a()sb._a()
  lib={//now, deploying aaa: Strings, booleans and Size
    HasToS={interface read method S toS()}
    //HasEquals={ }//NOPE: == hava a base. A trait can add to a class extends any, and to an interface (as a new base) and to the ones implementing the base.
    //List can take a class method Boolean equals(Elem e1,Elem e2)
    Break={class method Void ()[Void]=exception void}
    Bool={...}
    Size={...}
    S={...}
    Message={...}
    Guard={interface [Message]}
    Assertion={interface[Message]}
    Url={...}
    Debug={...}
    StringBuilder={...}
    Test={...}
    Meta={...}
    Name={...}
    Trait={...}
    Class={...}
    PrivateOps={...}
    X=Class:Message:{...}
    NoElementInOpt=Class:(Message.NativeTrait()+{[Guard]})
    Deploy={...}
    Opt={...}
    ListT={
      ListNative=Trait:{...}
      ListOps=Trait:{...}
      ListEqOps=Trait:{...}
      class method Trait(class Any that)=(ListOps+ListNative)['Elem>that]
      class method Trait(class Any withEq)=(ListOps+ListNative+ListEqOps)['Elem>withEq]
      }
    Strings=Class:(ListT(withEq=S)+{
      class method Bool equals(read S a,read S b)=a==b})
    }
  Debug.of().deployLibrary(sb.toS(),lib=lib)
  )
//Deploy step2:
DeployAdamTowel={reuse[#$aaa]
  AddOns=Deploy.towel(url='AdamTowel,
    code=Class:(Trait:{...}+{reuse[#$aaa]})
    ) 
  }
//Testing step2:
TestsAdamTowel={reuse[#$AdamTowel]
  OptS=Class:Opt(S)
  TestOpt=(
    OptS o1=OptS()
    OptS o2=OptS(S"hi")
    {}:Test"opt"(o2.get()==S"hi")
    )
  TestSizeRange=(
    var sAcc=S""
    for i in (21Size).range() (sAcc++=S"a")
    {}:Test"range 21"(sAcc.size()==21Size)
    )
  TestMatchReduce=((
    mut Strings ss=Strings[S"a";S"b";S"c"]
    {}:Test"reduceWithValue"(S"DDabc"==
      ss.reduce(S"DD")(for e in \vals \res<=\acc++e))
    )(
    lent Strings ss=Strings[S"a";S"b";S"c"]
    {}:Test"reduceWithValue"(S"DDabc"==
      ss.reduce(S"DD")(for e in \vals \res<=\acc++e))    
    )(
    read Strings ss=Strings[S"a";S"b";S"c"]
    {}:Test"reduceWithValue"(S"DDabc"==
      ss.reduce(S"DD")(for e in \vals \res<=\acc++e))    
    )(
    imm Strings ss=Strings[S"a";S"b";S"c"]
    {}:Test"reduceWithValue"(S"DDabc"==
      ss.reduce(S"DD")(for e in \vals \res<=\acc++e))    
    ))

  TestMatchSome=(
    ss=Strings[S"a";S"b";S"c"]
    (    
      res=ss.matchAny()(for s in \vals \res<=(s==S"c"))
      {}:Test"MatchSome"(res)
      )(
      var sAcc=S""
      res=ss.matchAny()(for s in \vals (sAcc++=S"#" \res<=(s==S"b")))
      {}:Test"MatchSomeShortCircut"(sAcc.size()==2Size)
      )
    )
  TestSizeInString=(
    half=21Size
    answer=half+half
    {}:Test"Sum"(answer==42Size)"Computed answer is %answer.toS()"
    //{}:Test"Failing test"(answer==8Size)"Computed answer is %answer.toS()"
    {}:Test"StringConcat"(S"Hello World "++answer.toS()++S"!" == S"Hello World 42!")
    {}:Test"StringSpliceConcat"(S"Hello World %answer!" == S"Hello World 42!")
    )
  TestSizeParsing=(
    err=Size"oh NO!"//throws error
    {}:Test"InvalidParseInt"( Bool.false() )"Errors not thrown"
    catch error S x 
      {}:Test"InvalidParseIntError"(x==S"The string %S.dq()oh NO!%S.dq() is not a valid number")"Error is %x" 
    )
  NotCoh={This field, class method This ()}
  TestMakeNotCohList=ListT(NotCoh)
  TestStrings=(
    s=Strings.empty()
    s.add(\"hi")
    {}:Test"singleVal"(s.val(0Size)==S"hi")
    {}:Test"size1"(s.size()==1Size)
    )
  TestWhile=(
    while Bool.true() (
      {}:Test"while runs"(Bool.true())
      exception void  
      )
    )
  TestBoolRelOps=(
    {}:Test"Less then"(!(3Size<3Size))
    {}:Test"Less then and false"(!(3Size<3Size && Bool.false()))
    )
  TestVectorOps=(
    ss1=Strings[S"a";S"b";S"c"]
    ss2=Strings[S"1";S"2";S"3"]
    (
      var sAcc=S""
      for imm si in ss1 (sAcc++=si)
      {}:Test"Simple for"(sAcc==S"abc")
      )(
      var sAcc=S""
      for s1 in ss1, imm s2 in ss2 (sAcc++=s1++s2)
      {}:Test"Simple for"(sAcc==S"a1b2c3")
      )(
      ss3=Strings[(\res<=S"hi")]
      {}:Test"justSlash"(ss3.size()==1Size)
      )(
      ss4=Strings[for s1 in ss1, imm s2 in ss2 (\res<=s1++s2)]
      for var imm si in ss4 (si:=S"pe"++si)
      for var si in ss4 (si:=S"No"++si)
      var sAcc=S""
      for imm si in ss4 (sAcc++=si)
      {}:Test"Simple for"(sAcc==S"Nopea1Nopeb2Nopec3")
      )
    )
  TestMeta=(
    _=Meta().simpleRedirect(
      innerPath=S"A.B"
      l42Lib={A={B={method Void m()}} method Void (A.B that)=void}
      classAny=Debug)
    _=Meta().simpleRedirect(
      innerPath=S"A.B"
      l42Lib={A={B={method Void m()}} method Void (A.B that)=void}
      classAny=NotCoh)
    {}:Test"Meta does not crash"(Bool.true())
    //TODO:could be improved after introspection is reimplemented 
    )
  }