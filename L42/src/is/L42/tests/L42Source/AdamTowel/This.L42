//Step 1: the minimal infrastructure to deploy a towel
S={#norm{nativeKind=String}}
Debug={
  class method This0 of()        
  method Void deployLibrary(This1.S that,Library lib)=
    native{trusted:deployLibrary} error void
    #norm{declaresClassMethods, typeDep=This0, This1.S, nativeKind=TrustedIO}        
  }
StringBuilder={
  class method mut This0 of()
  mut method Void _a()=
    native{trusted:'a'} error void
  read method This1.S toS()=
    native{trusted:toS} error void
    #norm{declaresClassMethods, typeDep=This0, This1.S, nativeKind=StringBuilder}
  }
//Step 2: barely usable Strings, booleans and Size
DeployAAA=(
  mut StringBuilder sb=StringBuilder.of()
  sb._a()sb._a()sb._a()
  lib={//now, deploying aaa: Strings, booleans and Size
    Bool={...}
    Size={...}
    S={...}
    Debug={...}
    StringBuilder={...}
    Meta={...}
    }
  Debug.of().deployLibrary(sb.toS(),lib=lib)
  )
//Testing step2
Test1={reuse[#$aaa]
  Task=(
    half=21Size
    answer=half+half
    Debug(answer.toS())
    Debug(S"Hello World "++answer.toS()++S"!")
    err=Size"oh NO!"
    Debug(S"this should not be printed")
    catch error S x Debug(x) 
    )
  NotCoh={This field, class method This ()}
  ListT=Meta().simpleSum(a={...},b={
    class method Library (class Any that)=Meta().simpleRedirect(
      innerPath=S"Elem"
      l42Lib=this.code()
      classAny=that)
    })
  Strings=ListT(S)
  TestListT=(//If ListT code write This1.Size instead of This2.Size, no type error happens.
    Strings s=S.empty()//Here, no type error happens even if
    s.add(immVal=S"hi")//we add on an immutable Strings!!
    Debug(s.val(0\))
    )
  TestMeta=(
    _=Meta().simpleRedirect(
      innerPath=S"A.B"
      l42Lib={A={B={method Void m()}} method Void (A.B that)=void}
      classAny=Debug)
    _=Meta().simpleRedirect(
      innerPath=S"A.B"
      l42Lib={A={B={method Void m()}} method Void (A.B that)=void}
      classAny=NotCoh)
    void
    )
  }