//Step 1: the minimal infrastructure to deploy a towel
S={#norm{nativeKind=String}}
Debug={
  class method This0 of()        
  method Void deployLibrary(This1.S that,Library lib)=
    native{trusted:deployLibrary} error void
    #norm{declaresClassMethods, typeDep=This0, This1.S, nativeKind=TrustedIO}        
  }
StringBuilder={
  class method mut This0 of()
  mut method Void _a()=
    native{trusted:'a'} error void
  read method This1.S toS()=
    native{trusted:toS} error void
    #norm{declaresClassMethods, typeDep=This0, This1.S, nativeKind=StringBuilder}
  }
//Step 2: barely usable Strings, booleans and Size
DeployAAA=(
  mut StringBuilder sb=StringBuilder.of()
  sb._a()sb._a()sb._a()
  lib={//now, deploying aaa: Strings, booleans and Size
    HasToS={interface read method S toS()}
    //HasEquals={ }//NOPE: == hava a base. A trait can add to a class extends any, and to an interface (as a new base) and to the ones implementing the base.
    //List can take a class method Boolean equals(Elem e1,Elem e2)
    Bool={...}
    Size={...}
    S={...}
    X={...}
    Url={...}
    Debug={...}
    StringBuilder={...}
    Test={...}
    Meta={...}
    Name={...}
    Trait={...}
    Class={...}
    Deploy={...}   
    ListT={
      ListNative=Trait:{...}
      ListOps=Trait:{...}
      class method Trait(class Any that)=(ListOps+ListNative)['Elem>that]
      }
    Strings=Class:ListT(S)
    }
  Debug.of().deployLibrary(sb.toS(),lib=lib)
  )
//Deploy step2:
DeployAdamTowel={reuse[#$aaa]
  Task=Deploy.towel(url='AdamTowel, code={reuse[#$aaa]})
  }

//Testing step2:
Test1={reuse[#$AdamTowel]
  Task=(
    half=21Size
    answer=half+half
    {}:Test"Answer is 42"(answer==42Size)"Computed answer is %answer.toS()"
    {}:Test"Failing test"(answer==8Size)"Computed answer is %answer.toS()"
    Debug(S"Hello World "++answer.toS()++S"!")
    err=Size"oh NO!"
    Debug(S"this should not be printed")
    catch error S x Debug(x) 
    )
  NotCoh={This field, class method This ()}
  TestListT=(//If ListT code write This1.Size instead of This2.Size, no type error happens.
    mut Strings s=Strings.empty()
    s.add(immVal=S"hi")
    Debug(s.val(0\).toS())
    Debug(s.size().toS())
    )
  TestWhile=
    while Bool.false() void
  TestBoolOps=(
    Debug((3Size<3Size).toS())
    Debug((3Size<3Size && Bool.false()).toS())
    )
  TestVectorOps=(
    mut Strings ss1=Strings[S"a";S"b";S"c"]
    mut Strings ss2=Strings[S"1";S"2";S"3"]
    for imm si in ss1 (Debug(si))
    for s1 in ss1, imm s2 in ss2 (Debug(s1++s2))
    mut Strings ss3=Strings[(\list.add(immVal=S"hi"))]
    mut Strings ss4=Strings[for imm s1 in ss1, imm s2 in ss2 (\list.add(immVal=s1++s2))]
    Debug(ss3.size().toS())
    for var imm si in ss4 (si:=S"pe"++si)
    for var si in ss4 (si:=S"No"++si)
    for imm si in ss4 (Debug(si))
    )
  TestMeta=(
    _=Meta().simpleRedirect(
      innerPath=S"A.B"
      l42Lib={A={B={method Void m()}} method Void (A.B that)=void}
      classAny=Debug)
    _=Meta().simpleRedirect(
      innerPath=S"A.B"
      l42Lib={A={B={method Void m()}} method Void (A.B that)=void}
      classAny=NotCoh)
    void
    )
  }