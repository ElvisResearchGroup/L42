CloseAll={
  class method Trait (Trait that)=(
    n=Introspection.Nested.from(library=that.code())
    This(that,n=n)  
    )
  class method Trait (Trait that,Introspection.Nested n)=(
    var res=that
    for ni in n.nesteds() (res:=This(res,n=ni))
    if !n.isInterface() && !n.isClose() (res:=Data.Close(n.nameFromRoot()):res)
    res
    )
  }
ClassOperators={class method This1()=This1()}
Introspection.Nested public
class method This (Introspection.Nested public)
class method This()=\(public=\.from(classAny=Public)) 

method Size maxLev(Introspection.Nested that)=(
  var res=0Size
  for ni in that.nesteds() (
    tmp=this.maxLev(ni)
    if res<tmp res:=tmp
    )
  res+1Size
  )
method Trait :(Library that)[Trait$InvalidName,Trait$InvalidMap,Trait$ClassClash,Trait$MethodClash]=
  this:Trait(that)
  
method Trait :(Trait trait)[Trait$InvalidName,Trait$InvalidMap,Trait$ClassClash,Trait$MethodClash]=(
  max=this.maxLev(Introspection.Nested.from(library=trait.code()))
  var res=trait
  (var lev=0Size while lev<max (//range will come later
    lev+=1Size
    i=Introspection.Nested.from(library=res.code())//trait.introspection() will come later
    res:=res(squareBuilder=this.mapRename$(Trait.Acc(Meta()),n=i,level=max-lev))
    ))
  res:=CloseAll(res)
  (var lev=0Size while lev<max (//range will come later
    lev+=1Size
    i=Introspection.Nested.from(library=res.code())//trait.introspection() will come later
    res:=res(squareBuilder=this.mapHide(Trait.Acc(Meta()),n=i,level=max-lev))
    ))
  res
  )

EmptyOnThis={class method S (S that)=if that==S"This" S"" else that}

method Bool isPrivate(Introspection.Doc that)=!that.annotatedAs(nested=this.public())

method mut Trait.Acc mapHide(mut Trait.Acc that, Introspection.Nested n, Size level)={
  ncs=n.nesteds()
  if level!=0Size (
    for ni in ncs (_=this.mapHide(that,n=ni,level=level-1\) void)
    return that
    )
  ms=n.methods()
  privates=Name$List()((
    for e in ncs (if this.isPrivate(e.outerDoc()) \res<=e.nameFromRoot())
    for e in ms (if this.isPrivate(e.doc()) \res<=e.nameFromRoot())
    ))
  somePublic=privates.size()!=ms.size()+ncs.size()
  if somePublic (for name in privates that.#squareAdd(hide=name))
  return that
  }
method mut Trait.Acc mapRename$(mut Trait.Acc that, Introspection.Nested n, Size level)={
  ncs=n.nesteds()
  if level!=0Size (
    for ni in ncs (_=this.mapRename$(that,n=ni,level=level-1\) void)
    return that
    )
  outName=EmptyOnThis(n.nameFromRoot().toS())
  outSize=outName.size()
  for ni in ncs {
    inName=ni.nameFromRoot().toS() //A.B$C$   A.$
    var inC=if outSize==0Size inName 
      else inName.subString(start=outSize+1\,end=\size) //"B$C$"   "$"
    if inC.contains(\"$$") return void
    if !inC.contains(\"$") return void
    if inC.endsWith(\"$") (inC:=inC.subString(start=0\, end=\size-1\)) //"B$C"    ""
    if inC.startsWith(\"$") return void
    inC:=inC.replace(\"$" with=\".") //"B.C"    ""
    if inC.size()==0Size return that.#squareAdd(Name(inName)=>n.nameFromRoot())
    return that.#squareAdd(Name(inName)=>Name(n.nameFromRoot().toS()++S"."++inC))  //A.B$C$ =>A.B.C
    }
  return that
  }