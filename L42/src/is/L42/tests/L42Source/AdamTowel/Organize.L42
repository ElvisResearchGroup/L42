CloseAll={
  class method Trait (Trait that)=(
    n=Introspection.Nested.from(library=that.code())
    This(that,n=n)  
    )
  class method Trait (Trait that,Introspection.Nested n)=(
    var res=that
    for ni in n.nesteds() (res:=This(res,n=ni))
    if !n.isInterface() && !n.isClose() (res:=Cache.Close(n.nameFromRoot()):res)
    res
    )
  }
ClassOperators={class method class This1()=This1}
class method Size maxLev(Introspection.Nested that)=(
  var res=0Size
  for ni in that.nesteds() (
    tmp=this.maxLev(ni)
    if res<tmp res:=tmp
    )
  res+1Size
  )
class method Trait :(Library that)[InvalidName,InvalidMap,ClassClash,MethodClash]=
  This:Trait(that)
class method Trait :(Trait trait)[InvalidName,InvalidMap,ClassClash,MethodClash]=(
  max=this.maxLev(Introspection.Nested.from(library=trait.code()))
  var res=trait
  (var lev=0Size while lev<max (//range will come later
    lev+=1Size
    i=Introspection.Nested.from(library=res.code())
    res:=res(squareBuilder=this.mapRename$(Trait.Acc(Meta()),n=i,level=max-lev))
    ))
  res:=CloseAll(res)
  (var lev=0Size while lev<max (//range will come later
    lev+=1Size
    i=Introspection.Nested.from(library=res.code())
    res:=res(squareBuilder=this.mapHide(Trait.Acc(Meta()),n=i,level=max-lev))
    ))
  res
  )
IsPublicNC={class method Bool (Introspection.Nested that)=that.outerDoc().annotatedAs(Public)}
IsPublicM={class method Bool (Introspection.Method that)=that.doc().annotatedAs(Public)}
EmptyOnThis={class method S (S that)=if that==S"This" S"" else that}
class method mut Trait.Acc mapHide(mut Trait.Acc that, Introspection.Nested n, Size level)={
  ncs=n.nesteds()
  if level!=0Size (
    for ni in ncs (_=this.mapHide(that,n=ni,level=level-1\) void)
    return that
    )
  ms=n.methods()
  var isHiding=Bool.false()
  for ni in ncs (isHiding:= isHiding || IsPublicNC(ni))
  for mi in ms (isHiding:= isHiding || IsPublicM(mi))
  if !isHiding return that
  for ni in ncs (if !IsPublicNC(ni) (that.#squareAdd(hide=ni.nameFromRoot())))
  for mi in ms (if !IsPublicM(mi) (that.#squareAdd(hide=mi.nameFromRoot())))
  return that
  }
class method mut Trait.Acc mapRename$(mut Trait.Acc that, Introspection.Nested n, Size level)={
  ncs=n.nesteds()
  if level!=0Size (
    for ni in ncs (_=this.mapRename$(that,n=ni,level=level-1\) void)
    return that
    )
  outName=EmptyOnThis(n.nameFromRoot().toS())
  outSize=outName.size()
  for ni in ncs {
    inName=ni.nameFromRoot().toS() //A.B$C$   A.$
    var inC=if outSize==0Size inName 
      else inName.subString(start=outSize+1\,end=\size) //"B$C$"   "$"
    if inC.contains(\"$$") return void
    if !inC.contains(\"$") return void
    if inC.endsWith(\"$") (inC:=inC.subString(start=0\, end=\size-1\)) //"B$C"    ""
    if inC.startsWith(\"$") return void
    inC:=inC.replace(\"$" with=\".") //"B.C"    ""
    if inC.size()==0Size return that.#squareAdd(Name(inName)=>n.nameFromRoot())
    return that.#squareAdd(Name(inName)=>Name(n.nameFromRoot().toS()++S"."++inC))  //A.B$C$ =>A.B.C
    }
  return that
  }