CloseAll={
  class method Trait (Trait that)=(
    n=Introspection.Nested.from(library=that.code())
    This(that,n=n)  
    )
  class method Trait (Trait that,Introspection.Nested n)=(
    var res=that
    for ni in n.nesteds() (res:=This(res,n=ni))
    if !n.isInterface() && !n.isClose() (res:=Data.Close(n.nameFromRoot()):res)
    res
    )
  }
ClassOperators={class method This1()=This1()}
Name public
class method This (Name public)
class method This()=\(public=Name"") 

method Size maxLev(Introspection.Nested that)=(
  var res=0Size
  for ni in that.nesteds() (
    tmp=this.maxLev(ni)
    if res<tmp res:=tmp
    )
  res+1Size
  )
method Trait :(Library that)[Trait$InvalidName,Trait$InvalidMap,Trait$ClassClash,Trait$MethodClash]=
  this:Trait(that)
  
method Trait :(Trait trait)[Trait$InvalidName,Trait$InvalidMap,Trait$ClassClash,Trait$MethodClash]=(
  max=this.maxLev(Introspection.Nested.from(library=trait.code()))
  var res=trait
  (var lev=0Size while lev<max (//range will come later
    lev+=1Size
    i=Introspection.Nested.from(library=res.code())//trait.introspection() will come later
    res:=res(squareBuilder=this.mapRename$(Trait.Acc(Name$Mapping()),n=i,level=max-lev))
    ))
  res:=CloseAll(res)
  (var lev=0Size while lev<max (//range will come later
    lev+=1Size
    i=Introspection.Nested.from(library=res.code())//trait.introspection() will come later
    res:=res(squareBuilder=this.mapHide(Trait.Acc(Name$Mapping()),n=i,level=max-lev))
    ))
  res
  )

EmptyOnThis={class method S (S that)=if that==S"This" S"" else that}

method Bool isPrivate(Introspection.Doc that)={
  if this.public()==Name"" return !that.annotatedAs(Public)
  return !that.annotatedAs(nested=that.root().nested(name=this.public()))
  }
  
method mut Trait.Acc mapHide(mut Trait.Acc that, Introspection.Nested n, Size level)={
  ncs=n.nesteds()
  if level!=0Size (
    for ni in ncs (_=this.mapHide(that,n=ni,level=level-1\) void)
    return that
    )
  ms=n.methods()
  var hasPublic=Bool.false()
  privates=Name$List()((
    for e in ncs (
      //Debug(S" names: %e.nameFromRoot()  %this.public().nameFromRoot()")
      //Debug(S" eq %(e==this.public())")
      if this.isPrivate(e.outerDoc()) \res<=e.nameFromRoot()
      else hasPublic:=Bool.true()
        )
    for e in ms (
      if this.isPrivate(e.doc()) (
        if !e.isRefined() \res<=e.nameFromRoot()
        )
      else hasPublic:=Bool.true()
      )
    ))
  if hasPublic (for name in privates that.#squareAdd(hide=name))
  return that
  }
method mut Trait.Acc mapRename$(mut Trait.Acc that, Introspection.Nested n, Size level)={
  ncs=n.nesteds()
  if level!=0Size (
    for ni in ncs (_=this.mapRename$(that,n=ni,level=level-1\) void)
    return that
    )
  outName=EmptyOnThis(n.nameFromRoot().toS())
  outSize=outName.size()
  for ni in ncs {
    inName=ni.nameFromRoot().toS() //A.B$C$   A.$
    var inC=if outSize==0Size inName 
      else inName.subString(start=outSize+1\,end=\size) //"B$C$"   "$"
    if inC.contains(\"$$") return void
    if !inC.contains(\"$") return void
    if inC.endsWith(\"$") (inC:=inC.subString(start=0\, end=\size-1\)) //"B$C"    ""
    if inC.startsWith(\"$") return void
    inC:=inC.replace(\"$" with=\".") //"B.C"    ""
    if inC.size()==0Size return that.#squareAdd(deep=Name(inName)=>n.nameFromRoot())
    return that.#squareAdd(deep=Name(inName)=>Name(n.nameFromRoot().toS()++S"."++inC))  //A.B$C$ =>A.B.C
    }
  return that
  }
@AbstractTowel{organize}