Counter=Data:{var Size emails}
MetaData=Data:{
  var Size encryptionKey
  var Bool isEncrypted
  var Size signKey
  var Bool isSigned
  var Bool isSignatureVerified
  }
AddressBookEntry=Data:{
  S alias
  mut S.List receivers
  mut method Void add(S receiver)=this.#receivers().add(receiver)
  }
AddressBook=Collection.list(AddressBookEntry)
KeyringEntry=Data:{
 mut Client keyOwner
 Size publicKey
 }
Keyring=Collection.list(KeyringEntry)
$Client={mut method mut $Client self()=this}
Clients=Collection.list($Client)
OptClient=Collection.optional($Client)
Client={
  Size id
  S name
  mut Keyring keyring
  @Top Size privateKey
  var Bool autoResponse
  mut AddressBook addressBook
  var mut OptClient forwardReceiver
  mut method mut $Client self()
  class method mut This(Size id,S name,mut Keyring keyring,@Top Size privateKey,Bool autoResponse,
    mut AddressBook addressBook,mut Client forwardReceiver)
  class method mut This(Size id,S name,@Top Size privateKey,Bool autoResponse)=This(
    id=id, name=name, keyring=\[], privateKey=privateKey,autoResponse=autoResponse,
    addressBook=\[], forwardReceiver=\())

  class method This create(mut Clients clients,S name, @Top Size privateKey, Bool autoResponse)=(
    mut This client = This(clients.size(), name=name, privateKey=privateKey, autoResponse=autoResponse)
    clients.#add(right=client)
    client
    )
  class method Void deliver(mut Client client, mut Email msg)=
  Debug(S"mail delivered\n")
  class method Void incomingWrappeeAutoResponder(mut Client client, mut Email msg)=(
    This.deliver(client=client, msg=msg)
    if client.autoResponse() This.autoRespond(client=client, msg=msg)
    )
  class method Void incomingWrappeeForward(mut Client client, mut Email msg)=(
    This.incomingWrappeeAutoResponder(client=client, msg=msg)
    mut OptClient receiverOpt = client.forwardReceiver()
    Client receiver = receiverOpt.val()
    if (receiver "!= null") (
      msg.to(receiver.name())
      This.forward(client=client, msg=msg)
      This.incoming(receiver=receiver, msg=msg)
      )
    )
  class method Void incomingWrappeeVerify(mut Client client, mut Email msg)=(
    This.verify(client=client, msg=msg)
    This.incomingWrappeeForward(client=client, msg=msg)
    )
  class method Void incoming(mut Client client, mut Email msg)=(
    @Top Size privkey = client.privateKey()
    var @Top Bool intermediateBool = msg.metadata().isEncrypted()
    var @Top Size intermediateInt = msg.metadata().encryptionKey()
    if privkey != 0Size (
      @Top Bool valid = This.isKeyPairValid(publicKey=intermediateInt, privateKey=privkey)
      if intermediateBool && valid ( //high context, only assignments to high
        intermediateBool := false
        intermediateInt := 0
        )
      )
    msg.#metadata().isEncrypted(intermediateBool)
    msg.#metadata().encryptionKey(intermediateInt)
    This.incomingWrappeeVerify(client=client, msg=msg)
    void
    )
  class method Void mail(mut Client client, mut Email msg)=Debug(S"mail sent")
  class method Void outgoingWrappeeBase(mut Client client, mut Email msg)=(
    msg.from(client)
    This.mail(client=client, msg=msg)
    )
  class method Void outgoingWrappeeEncrypt(mut Client client, mut Email msg)=(
    mut Client receiver = This.getClientByAdress(address=msg.to())
    Size pubkey = client.getKeyringPublicKeyByClient(client=receiver)
    if (pubkey != 0Size) ( // low
      msg.#metadata().encryptionKey(pubkey) //pubkey promoted to high
      msg.#metadata().isEncrypted(Bool.true())
      Debug(S"Encrypted Mail " ++ msg.getId())
      )
    This.outgoingWrappeeBase(client=client, msg=msg)
    )
  class method Void outgoingWrappeeAddressbook(mut Client client, mut Email msg)=(
    mut S.List aliasReceivers = client.getAddressBookReceiversForAlias(msg.to())
    if !aliasReceivers.isEmpty() (
      for (Size i = 1Size, i < aliasReceivers.size(), i++) (
        var S receiverAddress := aliasReceivers.val(i)
        msg.to(receiverAddress)
        This.outgoing(client=client, msg=msg)
        This.incoming(Client.getClientByAdress(receiverAddress), msg)
        )
      msg.to(aliasReceivers.val(0))
      This.outgoingWrappeeEncrypt(client=client, msg=msg)
      ) 
    else This.outgoingWrappeeEncrypt(client=client, msg=msg)
    )
  class method Void outgoing(mut Client client, mut Email msg)=(
    This.sign(client=client, msg=msg)
    This.outgoingWrappeeAddressbook(client=client, msg=msg)
    )
  class method Void sendEmail(mut Client sender, S receiverAddress, S subject, @Top S body)=(
    mut Email email = Email.create(counter=Counter.this(), subject=subject, body=body, from=sender, to=receiverAdress)
    Debug(S"sending Mail " ++ email.id())
    This.outgoing(client=sender, msg=email)
    mut OptClient receiver = Client.getClientByAdress(email.to())
    if (receiver.val() "!= null") (
      This.incoming(receiver.val(), email)
      ) else (
        //throw new IllegalArgumentException("Receiver " + receiverAddress + " Unknown")
      )
   )
  class method mut Client getClientById(Clients clients, Size id)=(
    clients.#val(id)
    )
  mut OptClient getClientByAdress(S address)={
    for (Size i = 0Size, i < clients.size(), i++) (
      if (clients.val(i) != null && clients.val(i).name().equals(address)) (
        return clients.val(i)
        )
      )
  return null
  //throw new IllegalArgumentException("Receiver " + address + " Unknown")
  }
  mut method Void resetClients(Clients clients)=("empty the list")

  mut method Void addKeyringEntry(mut Client client, Size publicKey)=(
   this.#keyring().#add(KeyringEntry(keyOwner=client, publicKey=publicKey))
   )
  read method Size getKeyringPublicKeyByClient(read Client client)={
    for mut KeyringEntry e : this.keyring() {
      if e.keyOwner().equals(client) return e.publicKey()
      }
    return 0Size
    }
  class method @Top Bool isKeyPairValid(@Top Size publicKey, @Top Size privateKey)={
//Util.prompt("keypair valid " + publicKey + " " + privateKey)
    if (publicKey == 0Size || privateKey == 0Size) return Bool.false()
    return privateKey == publicKey //should be a secure validation. This is just an example.
    }
  class method Void autoRespond(mut Client client, mut Email msg)=(
    Debug(S"sending autoresponse\n")
    mut Client sender = msg.from()
    msg.to(sender.name())
    This.outgoing(client=client, msg=msg)
    This.incoming(client=sender, msg=msg)
    )
  mut method mut S.List getAddressBookReceiversForAlias(S alias)={
    for (mmut AddressBookEntry e : this.addressBook()) {
      if (e.alias().equals(alias)) return e.receivers()
      }
    return Collections.emptyList()
    }
  mut method Void addAddressbookEntry(S alias, S receiver)={
    for (mut AddressBookEntry e : this.addressBook()) { 
      if (e.alias().equals(alias)) (
        e.add(receiver=receiver) 
        return void
        )
      }
    mut AddressBookEntry newEntry = AddressBookEntry(alias=alias, receivers=S.List())
    newEntry.add(receiver)
    this.addressBook().#add(newEntry)
    }
  class method Void sign(mut Client client, mut Email msg)={
    @Top Size privkey = client.privateKey()
    if (privkey == 0Size) return void
    msg.#metadata().isSigned(Bool.true())
    msg.#metadata()signKey(privkey)
    return void
    }
  class method Void verify(mut Client client, mut Email msg)0=( //receiver of message
  Size pubkey = client.getKeyringPublicKeyByClient(msg.from())
  var @Top Bool intermediateBool = msg.#metadata().isSignatureVerified()
  if (pubkey != 0Size && This.isKeyPairValid(publicKey=pubkey, privateKey=msg.getEmailSignKey())) 
    intermediateBool := Bool.true()
  msg.#metadata().isSignatureVerified(intermediateBool)
  )

  class method Void forward(mut Client client, mut Email msg)=(
    Debug(S"Forwarding message.\n")
    This.printMail(msg=msg)
    This.outgoing(client=client, msg=msg)
    )
}

Email={
  Size id
  S subject
  @Top S body
  mut Client from
  var S to
  mut @Top MetaData metaData
  class method mut This (Size id,S subject,@Top S body,mut Client from,S to,@Top MetaData metaData)
  class method This create(mut Counter counter,S subject,@Top S body,mut Client from,S to)=(
    id=counter.emails()
    counter.emails(\emails+1\)
    metaData=MetaData(
      encryptionKey=0Size
      isEncrypted=Bool.false()
      signKey=0Size
      isSigned=Bool.false()
      isSignatureVerified=Bool.true()
      )
    This(id=id,subject=subject,body=body,from=from,to=to,metaData=metaData)
    )
  mut method @Top Bool isReadable() = !this.metaData().isEncrypted()
  class method Void printMailWrappeeBase(mut Email that)=(
    Debug(S"ID:  " ++ that.id())
    Debug(S"FROM: " ++ that.from())
    Debug(S"TO: " ++ that.to())
    Debug(S"SUBJECT: " ++ that.subject())
    //Debug(S"IS_READABLE " ++ that.isReadable())//high
    //Debug(S"BODY: " ++ that.body())//high
    //Debug(S"ENCRYPTED " ++ that.metaData().isEncrypted())//high
    //Debug(S"SIGNED " ++ that.metaData().isSigned()) //high
    //Debug(S"SIGNATURE " ++ that.metaData().SignKey())//high
    //Debug(S"SIGNATURE VERIFIED " ++ that.metaData().isSignatureVerified()) //high
    )
  read method mut Email clone() = Email(
    id=this.id()
    subject=this.subject()
    body=this.body()
    from=this.from().clone()
    to=this.to()
    metaData=this.metaData().clone()
    )
  }
    