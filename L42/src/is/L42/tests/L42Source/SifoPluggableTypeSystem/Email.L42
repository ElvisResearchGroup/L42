Counter=Data:{var Size emails}
MetaData=Data:{
  var Size encryptionKey
  var Bool isEncrypted
  var Size signKey
  var Bool isSigned
  var Bool isSignatureVerified
  }
AddressBookEntry=Data:{
  S alias
  mut S.List receivers
  mut method Void add(S receiver)=this.#receivers().add(receiver)
  }
AddressBook=Collection.list(AddressBookEntry)
$Keyring={ class method mut This () }
$Clients={
  class method mut This ()
  mut method mut This outSelf()=this
  }
$OptClient={ class method mut This () }
$Client={
  S name
  class method mut This(Size id,S name,mut $Keyring keyring,
    @Top Size privateKey,Bool autoResponse,mut AddressBook addressBook,
    mut $OptClient forwardReceiver,mut $Clients clients)
  mut method mut This self()=this  
  }
OptClient=Collection.optional($Client)
Clients=Organize:{
  $=Class:Trait(Collection.list($Client)):{mut method mut This self()=this}
  mut method mut $ self()
  mut method mut $Clients outSelf()
  mut method mut $Client client(Size id)=this.self().#val(id)//note: unused also in the original example
  mut method mut $Client client(S address)={
    for mut c in this.self().#vals() ( if c.name()==address return c )
    error X"Receiver %address Unknown"
    }
  mut method Void resetClients()=while !this.self().isEmpty() this.removeRight()
  mut method $Client create(S name, @Top Size privateKey, Bool autoResponse)=(
    client = $Client(id=this.size(), name=name,keyring=\(), privateKey=privateKey,
      autoResponse=autoResponse,addressBook=\(), forwardReceiver=\(),clients=this.outSelf())
    this.self().#add(right=client)
    client
    )
  }
KeyringEntry=Data:{
 mut $Client keyOwner
 Size publicKey
 }
Keyring=Collection.list(KeyringEntry)
Client={
  Size id
  S name
  mut Keyring keyring
  @Top Size privateKey
  var Bool autoResponse
  mut AddressBook addressBook
  var mut OptClient forwardReceiver
  mut Clients clients
  mut method mut $Client self()
  mut method Void deliver(mut Email msg)=Debug(S"mail delivered%S.nl()")//represents the real sending of the email
  mut method Void incomingWrappeeAutoResponder(mut Email msg)=(
    this.deliver(msg=msg)
    if this.autoResponse() this.autoRespond(msg=msg)
    )
  mut method Void incomingWrappeeForward(mut Email msg)=(
    this.incomingWrappeeAutoResponder(msg=msg)
    receiverOpt = this.forwardReceiver()
    if receiverOpt (
      msg.to(receiverOpt.val().name())
      this.forward(msg=msg)
      receiverOpt.val().incoming(msg=msg)
      )
    )
  mut method Void incomingWrappeeVerify(mut Email msg)=(
    this.verify(msg=msg)
    this.incomingWrappeeForward(msg=msg)
    )
  mut method Void incoming(mut Email msg)=(
    @Top Size privkey = this.privateKey()
    @Top MetaData m=msg.#metadata()
    if privkey != 0Size (
      @Top Bool valid = This.isKeyPairValid(publicKey=m.encriptionKey(), privateKey=privkey)
      if m.isEncripted() && valid ( //high context, only assignments to high
        m.isEncrypted(Bool.false())
        m.encryptionKey(0Size)
        )
      )
    this.incomingWrappeeVerify(msg=msg)
    void
    )
  mut method Void mail(mut Email msg)=Debug(S"mail sent")
  mut method Void outgoingWrappeeBase(mut Email msg)=(
    msg.from(this)
    this.mail(msg=msg)
    )
  mut method Void outgoingWrappeeEncrypt(mut Email msg)=(
    mut Client receiver = This.getClientByAdress(address=msg.to())
    Size pubkey = this.getKeyringPublicKeyByClient(client=receiver)
    if pubkey != 0Size ( // low
      msg.#metadata().encryptionKey(pubkey) //pubkey promoted to high
      msg.#metadata().isEncrypted(Bool.true())
      Debug(S"Encrypted Mail %msg.id()")
      )
    this.outgoingWrappeeBase(msg=msg)
    )
  mut method Void outgoingWrappeeAddressbook(mut Email msg)=(
    mut S.List aliasReceivers = this.getAddressBookReceiversForAlias(msg.to())
    if aliasReceivers.isEmpty() return this.outgoingWrappeeEncrypt(msg=msg)
    for i in (aliasReceivers.size()-1Size).range() (//TODO: check range docs
      S receiverAddress = aliasReceivers.val(i+1\)
      msg.to(receiverAddress)
      this.outgoing(msg=msg)
      this.clients().getClientByAdress(receiverAddress).#val().incoming(msg=msg)
      )
    msg.to(aliasReceivers.val(0\))
    this.outgoingWrappeeEncrypt(msg=msg)
    )
  mut method Void outgoing(mut Email msg)=(
    this.sign(msg=msg)
    this.outgoingWrappeeAddressbook(msg=msg)
    )
  mut method Void sendEmail(S receiverAddress, S subject, @Top S body)=(//TODO: counter must have the create method
    email = Email.create(counter=this.emailCounter(), subject=subject, body=body, from=this, to=receiverAddress)
    Debug(S"sending Mail %email.id()")
    this.outgoing(msg=email)
    receiver = this.clients().getClientByAdress(email.to())
    if !receiver.val().isPresent() error X"Receiver %receiverAddress Unknown"
    receiver.val().incoming(msg=email)
    )
  mut method Void addKeyringEntry(mut Client client, Size publicKey)=(
   this.#keyring().#add(KeyringEntry(keyOwner=client, publicKey=publicKey))
   )
  read method Size getKeyringPublicKeyByClient(read Client client)={
    for e in this.keyring() (
      if e.keyOwner().equals(client) return e.publicKey()
      )
    return 0Size
    }
  class method @Top Bool isKeyPairValid(@Top Size publicKey, @Top Size privateKey)={
    //Debug(S"keypair valid %publicKey %privateKey")//correctly fails verification
    if publicKey == 0Size || privateKey == 0Size return Bool.false()
    return privateKey == publicKey //should be a secure validation. This is just an example.
    }
  mut method Void autoRespond(mut Email msg)=(
    Debug(S"sending autoresponse%S.nl()")
    mut Client sender = msg.from()
    msg.to(sender.name())
    this.outgoing(msg=msg)
    sender.incoming(msg=msg)
    )
  mut method mut S.List getAddressBookReceiversForAlias(S alias)={
    for e in this.addressBook() (
      if e.alias().equals(alias) return e.receivers()
      )
    return S.List()
    }
  mut method Void addAddressbookEntry(S alias, S receiver)={
    for e in this.addressBook() (
      if e.alias().equals(alias) return e.add(receiver=receiver)
      )
    newEntry = AddressBookEntry(alias=alias, receivers=S.List[receiver])
    return this.addressBook().#add(newEntry)
    }
  mut method Void sign(mut Email msg)={
    @Top Size privkey = this.privateKey()
    if privkey == 0Size return void
    msg.#metadata().isSigned(Bool.true())
    msg.#metadata().signKey(privkey)
    return void
    }
  mut method Void verify(mut Email msg)=( //receiver of message
    Size pubkey = this.getKeyringPublicKeyByClient(msg.from())//TODO: name more 42
    @Top Bool keyValid = This.isKeyPairValid(publicKey=pubkey, privateKey=msg.getEmailSignKey())
    if pubkey != 0Size && keyValid  msg.#metadata().isSignatureVerified(Bool.true()) 
    )
  mut method Void forward(mut Email msg)=(
    Debug(S"Forwarding message.%S.nl()")
    this.printMail(msg=msg)
    this.outgoing(msg=msg)
    )
  }

Email={
  Size id
  S subject
  @Top S body
  mut Client from
  var S to
  mut @Top MetaData metaData
  class method mut This (Size id,S subject,@Top S body,mut Client from,S to,@Top MetaData metaData)
  class method This create(mut Counter counter,S subject,@Top S body,mut Client from,S to)=(
    id=counter.emails()
    counter.emails(\emails+1\)
    metaData=MetaData(
      encryptionKey=0Size
      isEncrypted=Bool.false()
      signKey=0Size
      isSigned=Bool.false()
      isSignatureVerified=Bool.true()
      )
    This(id=id,subject=subject,body=body,from=from,to=to,metaData=metaData)
    )
  mut method @Top Bool isReadable() = !this.metaData().isEncrypted()
  class method Void printMailWrappeeBase(mut Email that)=(
    Debug(S"ID:  " ++ that.id())
    Debug(S"FROM: " ++ that.from())
    Debug(S"TO: " ++ that.to())
    Debug(S"SUBJECT: " ++ that.subject())
    //Debug(S"IS_READABLE " ++ that.isReadable())//high
    //Debug(S"BODY: " ++ that.body())//high
    //Debug(S"ENCRYPTED " ++ that.metaData().isEncrypted())//high
    //Debug(S"SIGNED " ++ that.metaData().isSigned()) //high
    //Debug(S"SIGNATURE " ++ that.metaData().SignKey())//high
    //Debug(S"SIGNATURE VERIFIED " ++ that.metaData().isSignatureVerified()) //high
    )
  read method mut Email clone() = Email(
    id=this.id()
    subject=this.subject()
    body=this.body()
    from=this.from().clone()
    to=this.to()
    metaData=this.metaData().clone()
    )
  }
    