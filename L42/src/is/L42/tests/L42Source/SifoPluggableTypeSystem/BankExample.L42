Account={  
  class method Size interestRate()=2Size
  class method Size overdraftLimit()=Size"-5000"
  class method Size dailyLimit()=Size"-1000"
  var @Top Size interest
  mut @Top State state
  var Bool lock
  class method mut This (@Top Size interest, mut @Top State state, Bool lock)
  class method mut This() = This(
    interest=0Size,
    state=State(balance=0Size, withdraw=0Size)
    lock=Bool.false()
    )
  
  read method @Top Size calculateInterest()=(
    @Top Size balance = this.state().balance()
    @Top Size totInterests = balance * This.interestRate()
    totInterests / 36500Size
    )
  read method @Top Size estimatedInterest(Size daysLeft)=(
    @Top Size moreInterest = daysLeft * this.calculateInterest()
    this.interest() + moreInterest
    )
  read method @Top Bool creditWorthy(Size amount)=(
    @Top Size balance = this.state().balance()
    balance >= amount
    )
  mut method Void doLock()=this.lock(Bool.true())
  mut method Void unLock()=this.lock(Bool.false())
  }
State=Data:{
  var Size balance,var Size withdraw
  mut method Bool updateBalance(Size that)={
    Size newBalance = this.balance() + that
    if newBalance < Account.overdraftLimit() return Bool.false()
    this.balance(newBalance)
    return Bool.true()
    }
  mut method Bool undoUpdateBalance(Size that)={
    Size newBalance = this.balance() - that
    if newBalance < Account.overdraftLimit() return Bool.false()
    this.balance(newBalance)
    return Bool.true()
    }
  mut method Bool update(Size that)={
    var newWithdraw = this.withdraw()
    if that < 0Size (
      newWithdraw += that
      if newWithdraw < Account.dailyLimit() return Bool.false()
      )
    overdraw = newWithdraw >= Account.dailyLimit() && !this.updateBalance(that) 
    if overdraw return Bool.false()
    this.withdraw(newWithdraw)
    return Bool.true()
    }
  mut method Bool undoUpdate(Size that)={
    var newWithdraw = this.withdraw()
    if that < 0Size (
      newWithdraw -= that
      if newWithdraw < Account.dailyLimit() return Bool.false()
      )
    overdraw = newWithdraw >= Account.dailyLimit() && !this.undoUpdateBalance(that) 
    if overdraw return Bool.false()
    this.withdraw(newWithdraw)
    return Bool.true()
    }
  }

Application={
  mut Account account
  class method mut This (mut Account account)
  class method mut This ()=(
    mut Account acc=Account()
    This(account=acc)
    )
  mut method Void nextDay()=(
    mut @Top State state = this.#account().#state()
    state.withdraw(0Size)
    this.#account().interest(\interest + \calculateInterest)
    )
   mut method Void nextYear()=(
    mut @Top State state = this.#account().#state()
    @Top Size interest = this.account().interest()
    @Top Size newBalance = state.balance() + interest
    state.balance(newBalance)
    this.#account().interest(0Size)
    )
  }
Transaction={
  read method @Top Bool transfer(mut Account source, mut Account destination, Size amount)={
    if !This.lockForTransfer(source=source, destination=destination) return Bool.false()
    mut @Top State sourceState = source.#state()
    mut @Top State destinationState = destination.#state()
    if (amount <= Size"0") return Bool.false() 
    @Top Bool sourceKo = !sourceState.update(amount * Size"-1")
    if sourceKo return Bool.false()
    @Top Bool destinationKo = !destinationState.update(amount)
    if destinationKo (
      _=sourceState.undoUpdate(amount * Size"-1")
      return Bool.false()
      )
    source.unLock()
    destination.unLock()
    return Bool.true()
    }
  class method Bool lockForTransfer(mut Account source, mut Account destination)={
    if source.lock() return Bool.false()
    if destination.lock() return Bool.false()
    source.doLock()
    destination.doLock()
    return Bool.true()
    }
  }