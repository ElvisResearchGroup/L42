Account={  
  class method Size interestRate()=2Size
  class method Size overdraftLimit()=Size"-5000"
  class method Size dailyLimit()=Size"-1000"
  var @Top Size interest
  @Top mut State state
  var Bool lock
  class method mut This (@Top Size interest, mut @Top State state, Bool lock)
  class method mut This() = This(
    interest=0Size,
    state=State(balance=0Size, withdraw=0Size)
    lock=Bool.false()
    )
  
  read method @Top Size calculateInterest()=
    (this.state().balance()<:Size * This.interestRate()) / 36500Size
  read method @Top Size estimatedInterest(Size daysLeft)=(
    @Top Size moreInterest = daysLeft * this.calculateInterest()
    this.interest() + moreInterest
    )
  read method @Top Bool creditWorthy(Size amount)=
    this.state().balance()<:Size >= amount
  mut method Void doLock()=this.lock(Bool.true())
  mut method Void unLock()=this.lock(Bool.false())
  }
State=Data:{
  var Size balance,var Size withdraw
  mut method Bool updateBalance(Size that)={
    var Size newBalance = this.balance() + that
    if newBalance < Account.overdraftLimit() return Bool.false()
    this.balance(newBalance)
    return Bool.true()
    }
  mut @Top method @Top Bool undoUpdateBalance(Size that)={
    var Size newBalance = this.balance() - that
    if newBalance < Account.overdraftLimit() return Bool.false()
    this.balance(newBalance)
    return Bool.true()
    }
  mut method Bool update(Size that)={
    var newWithdraw = this.withdraw()
    if that < 0Size (
      newWithdraw += that
      if newWithdraw < Account.dailyLimit() return Bool.false()
      )
    overdraw = newWithdraw >= Account.dailyLimit() && !this.updateBalance(that) 
    if overdraw return Bool.false()
    this.withdraw(newWithdraw)
    return Bool.true()
    }
  mut method Bool undoUpdate(Size that)={
    var newWithdraw = this.withdraw()
    if that < 0Size (
      newWithdraw -= that
      if newWithdraw < Account.dailyLimit() return Bool.false()
      )
    overdraw = newWithdraw >= Account.dailyLimit() && !this.undoUpdateBalance(that) 
    if overdraw return Bool.false()
    this.withdraw(newWithdraw)
    return Bool.true()
    }
  }
Application={
  mut Account account
  class method mut This (mut Account account)
  class method mut This ()=(
    mut Account acc=Account()
    This(account=acc)
    )
  mut method Void nextDay()=(
    this.#account().#state().withdraw(0Size)
    this.#account().interest(\interest + \calculateInterest)
    )
   mut method Void nextYear()=(
    this.#account().#state().balance(\balance + this.account().interest())
    this.#account().interest(0Size)
    )
  }
Transaction={
  read method @Top Bool transfer(mut Account source, mut Account destination, Size amount)={
    if !This.lockForTransfer(source=source, destination=destination) return Bool.false()
    mut @Top State sourceState = source.#state()
    mut @Top State destinationState = destination.#state()
    if (amount <= Size"0") return Bool.false() 
    if !sourceState.update(amount * Size"-1") return Bool.false()
    if !destinationState.update(amount) (
      _=sourceState.undoUpdate(amount * Size"-1")
      return Bool.false()
      )
    source.unLock()
    destination.unLock()
    return Bool.true()
    }
  class method Bool lockForTransfer(mut Account source, mut Account destination)={
    if source.lock() return Bool.false()
    if destination.lock() return Bool.false()
    source.doLock()
    destination.doLock()
    return Bool.true()
    }
  }