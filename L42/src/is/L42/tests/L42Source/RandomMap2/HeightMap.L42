read method Size combine(Size x,Size y, Size seed,Size oldCell)={
  if oldCell==0Size return seed   //unsetted is set
  if oldCell+1\==seed return seed //contaged
  if oldCell+6\ <seed return (oldCell+seed)/2Size //pulled up if it is so far below
  return 0Size //do nothing
  }
mut Points montainsTop=Points()
RiverMap=Class:Data:MapList(Size.List,base='zero())
mut RiverMap riverMap
class method mut RiverMap #default#riverMap(Size side)=\(side=side)
mut Math.Random r
Size maxZ
Size side
read method Size (Point that)
read method Size (Size x,Size y)
mut method Void (Point that,Size val)
mut method Void (Size x,Size y,Size val)

mut method Size rand(Size that, Size to)=
  this.#r().nextInRange(start=that,end=to)
//For now, makes a maxZ tall diagonal line and
//6 other maxZ*0.65 peakes

mut method Void makeRivers(Size waterLevel)=(
  this.runWater(p=this.montainsTop().val(2\))
  this.runWater(p=this.montainsTop().val(3\))
  s=this.side()-1Size
  o=this.#order()
  for x in Range(1\ to=s) (
    for y in Range(1\ to=s) {
      if this.riverMap()(x=x,y=y) > 0Size return void
      h=this(x=x,y=y)
      if h <= waterLevel return void
      var max=Size"-1"//for all non water points
      for (x1,y1) in o (//for all surrunding spots, find the max with water
        r=this.riverMap()(x=x+x1,y=y+y1)
        candidate=this(x=x+x1,y=y+y1)+r
        if r>0Size ( max:=candidate.max(max) )
        )
      if max==Size"-1" return void
      if h <= max  this(x=x,y=y,val=max)
      else this(x=x,y=y,val=(h+max)/2Size)
      return void
      }
    )
  )
mut method Void add(mut Points river,Point p)=(
  this.#riverMap()(p, val=1\)
  this(p,val=this(p)-1\)
  river.add(p)
  )
mut method mut Points runWaterDown(Point start)={
  var p=start
  river=Points()
  loop (
    this.add(river=river,p=p)
    var min=this.maxZ()+1Size
    for pi in Points[p.with(y=\y-1\); p.with(x=\x-1\); p.with(x=\x+1\); p.with(y=\y+1\)] (
      candidate=this(pi)
      ok=this.riverMap()(pi) == 0Size && candidate<min //what happens if we remove the riverMap check?
      if ok (min:=candidate, p:=pi)
      )///crucially, min can be higher than the former this(p)
    if min==this.maxZ()+1Size || this(p)<=0Size (
      this.add(river=river,p=p)
      return river
      )
    )
  }
mut method Void runWater(Point p)=(
  x=this.#r().nextInRange(start=p.x()-2\,end=p.x()+2\)
  y=this.#r().nextInRange(start=p.y()-2\,end=p.y()+2\)
  river=this.runWaterDown(start=\(x=x,y=y))
  if river.size()>=2Size this.adjust(river=river)
  )
mut method Void riversGoDown(read Points river)=(
  var last=this(river.left())
  for p in river (
    current=this(p)
    if current>last this(p val=last)
    else last:=current
    )
  )
mut method Void adjust(read Points river)=(
  this.riversGoDown(river=river)
  endH=this(river.val(\size()-2\))+1Size//the earth + 1 water
  preLastH=this.riverMap()(river.right()).max(endH)
  this.#riverMap()(river.right() val=preLastH)
  this(river.right() val=0\)
  var lastH=this(river.right())
  for i in Range(river.size()-2\).reverse() (
    pi=river.val(i)
    var currentH=this(pi)
    riverH=this.riverMap()(pi)
    if lastH>currentH (
      this.#riverMap()(pi val=(riverH+lastH)-currentH)
      currentH:=(riverH+lastH)-1Size
      )
    delta=(currentH-(lastH+1Size))
    if delta>0Size (//should make more water on waterfalls
      this.#riverMap()(pi val=this.riverMap()(pi)+delta)
      this(pi val=this(pi)-delta)
      )
    lastH:=currentH
    )
  )
mut method Void noUnderZero()=(
  for x in Range(this.side()) (
    for y in Range(this.side()) (
      if this(x=x,y=y)<0Size (
        reduced=(this.riverMap()(x=x,y=y)+this(x=x,y=y)).max(0\)
        this.#riverMap()(x=x,y=y,val=reduced)
        this(x=x,y=y,val=0\)
        )
      )
    )
  )