reuse[AdamTowel]


Public={}
CloseAll={
  class method Trait (Library that)=(
    n=Introspection.Nested.from(library=that)
    This(Trait(that),n=n)  
    )
  class method Trait (Trait that,Introspection.Nested n)=(
    var res=that
    for ni in n.nesteds() (res:=This(res,n=ni))
    if !n.isInterface() && !n.isClose() (res:=Cache.Close(n.nameFromRoot()):res)
    res
    )
  }
Organize={
  ClassOperators={class method class This1()=This1}
  class method Size maxLev(Introspection.Nested that)=(
    var res=0Size
    for ni in that.nesteds() (
      tmp=this.maxLev(ni)
      if res<tmp res:=tmp
      )
    res+1Size
    )
  class method Trait :(Trait trait)=This:trait.code()
  class method Trait :(Library that)=(
    var res=CloseAll(that)
    max=this.maxLev(Introspection.Nested.from(library=that))
    for lev in max.range() (
      i=Introspection.Nested.from(library=res.code())
      res:=res(squareBuilder=this.mapRename$(Trait.Acc(Meta()),n=i,level=max-lev))
      j=Introspection.Nested.from(library=res.code())
      res:=res(squareBuilder=this.mapHide(Trait.Acc(Meta()),n=j,level=max-lev))
      whoops Guard
      )
    res
    )
  IsPublicNC={class method Bool (Introspection.Nested that)=that.outerDoc().annotatedAs(Public)}
  IsPublicM={class method Bool (Introspection.Method that)=that.doc().annotatedAs(Public)}
  class method mut Trait.Acc mapHide(mut Trait.Acc that, Introspection.Nested n, Size level)={
    ncs=n.nesteds()
    if level!=0Size (
      for ni in ncs (_=this.mapHide(that,n=ni,level=level-1\) void)
      return that
      )
    ms=n.methods()
    var isHiding=Bool.false()
    for ni in ncs (isHiding:= isHiding || IsPublicNC(ni))
    for mi in ms (isHiding:= isHiding || IsPublicM(mi))
    if !isHiding return that
    for ni in ncs (if !IsPublicNC(ni) (that.#squareAdd(hide=ni.nameFromRoot())))
    for mi in ms (if !IsPublicM(mi) (that.#squareAdd(hide=mi.nameFromRoot())))
    return that
    }
  class method mut Trait.Acc mapRename$(mut Trait.Acc that, Introspection.Nested n, Size level)={
    ncs=n.nesteds()
    if level!=0Size (
      for ni in ncs (_=this.mapRename$(that,n=ni,level=level-1\) void)
      return that
      )
    outName=n.nameFromRoot().toS()
    outSize=outName.size()
    for ni in ncs {
      inName=n.nameFromRoot().toS() //A.B$C$   A.$
      var inC=inName.subString(start=outSize,end=\size) //.B$C$   .$
      if inC.contains(\"$$") return void
      if !inC.contains(\"$") return void
      if inC.endsWith(\"$") (inC:=inC.subString(start=0\, end=\size-1\)) //.B$C   . 
      inC:=inC.replace(\"$" with=\".") //.B.C    .
      if inC==S"." (inC:=S"")
      return that.#squareAdd(Name(inName)=>Name(outName++inC))  //A.B$C$ =>A.B.C
      }
    return that
    }
  }

//---------------------------
Full={class method S (Trait that)=
  Introspection.Nested.from(library=that.code()).toFullS()
  }
TestFullS=(
  {}:Test"fullS"(actual=Full(Trait:{ method Void foo(S that)=void  method B bar() B={}})
  expected=S"""
    |{
    |  method Void foo(This1.S that)=(..)
    |  method This.B bar()
    |  B={#typed{}}
    |  #norm{}
    |  }
    """)
  {}:Test"sum"(actual=Full(
    Trait:{ method Void foo(S that)=void  method B bar() B={}}
    +{B={method Void beer()}}
    )
  expected=S"""
    |{
    |  method Void foo(This1.S that)=(..)
    |  method This.B bar()
    |  B={method Void beer()#typed{}}
    |  #norm{}
    |  }
    """)
  {}:Test"renameDeep"(actual=Full(
    Trait({ B={method Any b() C={method Any c()}}})
    [deep='B=>'A.C])
  expected=S"""
    |{A={C={method Any b()C={method Any c()#typed{}}#typed{}}#typed{}}#norm{}}
    """)

  )

ExampleAnn={@{exampleAnn}}

TestMeth=(
  lib={ method Void foo(S that)=void  method B bar() B={}}
  n=Introspection.Nested.from(library=lib)
  b=n.nesteds().val(0Size)
  foo=n.methods().val(0\)
  bar=n.methods().val(1\)
  b2=bar.returnType().nested()
  {}:Test"self1String"(expected=b actual=b2)
  //{}:Test"self1"(b.nameFromRoot()==b2.nameFromRoot())
  {}:Test"self1"(b==b2)
  {}:Test"self2"(n!=b2)
  )
TestAnn=(
  lib={ @ExampleAnn B={method Void foo(S that)=void}}
  n=Introspection.Nested.from(library=lib).nesteds().val(0Size)
  clazz=n.outerDoc().docs().left().nested()
  s=clazz.innerDoc().docs().left().texts().left()
  {}:Test"0"(expected=S"exampleAnn", actual=s)
  )
TestFromLib=(
  lib={method Void foo(S that)=void @{hi} B={method Void foo(S that)=void}}
  {}:Test"1"(
    actual=Introspection.Nested.from(library=lib)
    expected=S"""
      |{ foo(that)=(..) B={..} }
      |
      |File name:[###]/TestIntrospection/This.L42
      |Line:[###]
      |Column:[###]
      """.trim())
  n=Introspection.Nested.from(library=lib).nesteds().val(0Size)      
  {}:Test"2"(actual=n
    expected=S"""
      |{ foo(that)=(..) }
      |
      |File name:[###]/TestIntrospection/This.L42
      |Line:[###]
      |Column:[###]
      """.trim())
  {}:Test"3"(actual=Introspection.Nested.from(library=lib).nesteds(),
    expected=S"""
      |Introspection.Nesteds[(i="{ foo(that)=(..) }\n\nFile name:[###]")]
      """.trim())
  {}:Test"4"(actual=n.outerName(), expected=S"B")
  {}:Test"5"(actual=n.outerDoc(), expected=S"@{@{hi}}")
  )