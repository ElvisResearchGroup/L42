reuse[AdamTowel]


Public={}
CloseAll={
  class method Trait (Library that)=(
    n=Introspection.Nested.from(library=that)
    This(Trait(that),n=n)  
    )
  class method Trait (Trait that,Introspection.Nested n)=(
    var res=that
    for ni in n.nesteds() (res:=This(res,ni))
    if !n.isInterface() && !n.isClose()
      Cache.Close(n.nameFromRoot()):res
    )
  }
Organize={
  class Size maxLev(Introspection.Nested n)=(
    var res=0Size
    for ni in n.nesteds() (
      tmp=maxLev(ni)+1Size
      if res<tmp res:=tmp
      )
    res
    )
  class method Library :(Library that)=(
    var res=CloseAll(that)
    max=this.maxLev(n=Introspection.Nested.from(library=that))
    for lev in max.range() (
      i=Introspection.Nested.from(library=res.code())
      res:=res(squareBuilder=this.mapRename$(Trait.Acc[],n=i,level=max-lev))
      j=Introspection.Nested.from(library=res.code())
      res:=res(squareBuilder=this.mapHide(Trait.Acc[],n=j,level=max-lev))
      )
    res
    )
  class method Trait.Acc mapHide(mut Trait.Acc that, Introspection.Nested n, Size level,Bool mustHide)={
    if level==0 return this.mapHide(that,mustHide=mustHide,n=n)
    isHiding=(there is some member annotate @Public)
    for ni in n.nesteds() (
      if mustHide (
        _=this.mapRename$(that,n=ni,mustHide=mustHideNow,level=level-1\)
        void
        )
      else(
        mustHideNow=isHiding && !ni.outerDoc().annotatedAs(Public)
        _=this.mapRename$(that,n=ni,mustHide=mustHideNow,level=level-1\)
        void
        )
      )
    return that
    }
  class method Trait.Acc mapHide(mut Trait.Acc that, Introspection.Nested n,Bool mustHide)={
    assert nested content should have been hidden already
    if any member is annotated @Public, hide the ones not annotated public    
    return that
    }
  class method Trait.Acc mapRename$(mut Trait.Acc that, Introspection.Nested n, Size level)={
    if level==0 return this.mapRename$(that,n=n)
    for ni in n.nesteds() (
      _=this.mapRename$(that,n=ni,level=level-1\)
      )
    return that
    }
  class method Trait.Acc mapRename$(mut Trait.Acc that, Introspection.Nested n)=(
    outName=n.nameFromRoot().toS()
    outSize=outName.size()
    for ni in n.nesteds() {
      inName=n.nameFromRoot().toS()
      var inC=inName.substring(outSize,\size)
      if inC.contains("$$") return void
      if !inC.contains("$") return void
      if inC.endsWith("$") (inc:=inC.substring(0\, \size-1\)
      inC:=inC.replace("$",".")
      if inC.startsWith(".") return void
      return that.add(inName=>outName+inC)
      }
    that
    )
  }
//---------------------------

ExampleAnn={@{exampleAnn}}

TestMeth=(
  lib={ method Void foo(S that)=void  method B bar() B={}}
  n=Introspection.Nested.from(library=lib)
  b=n.nesteds().val(0Size)
  foo=n.methods().val(0\)
  bar=n.methods().val(1\)
  b2=bar.returnType().nested()
  {}:Test"self1String"(expected=b actual=b2)
  //{}:Test"self1"(b.nameFromRoot()==b2.nameFromRoot())
  {}:Test"self1"(b==b2)
  {}:Test"self2"(n!=b2)
  )
TestAnn=(
  lib={ @ExampleAnn B={method Void foo(S that)=void}}
  n=Introspection.Nested.from(library=lib).nesteds().val(0Size)
  clazz=n.outerDoc().docs().left().nested()
  s=clazz.innerDoc().docs().left().texts().left()
  {}:Test"0"(expected=S"exampleAnn", actual=s)
  )
TestFromLib=(
  lib={method Void foo(S that)=void @{hi} B={method Void foo(S that)=void}}
  {}:Test"1"(
    actual=Introspection.Nested.from(library=lib)
    expected=S"""
      |{ foo(that)=(..) B={..} }
      |
      |File name:[###]/TestIntrospection/This.L42
      |Line:[###]
      |Column:[###]
      """.trim())
  n=Introspection.Nested.from(library=lib).nesteds().val(0Size)      
  {}:Test"2"(actual=n
    expected=S"""
      |{ foo(that)=(..) }
      |
      |File name:[###]/TestIntrospection/This.L42
      |Line:[###]
      |Column:[###]
      """.trim())
  {}:Test"3"(actual=Introspection.Nested.from(library=lib).nesteds(),
    expected=S"""
      |Introspection.Nesteds[Introspection.Nested(i="{ foo(that)=(..) }\n\nFile name:[###]")]
      """.trim())
  {}:Test"4"(actual=n.outerName(), expected=S"B")
  {}:Test"5"(actual=n.outerDoc(), expected=S"@{@{hi}}")
  )