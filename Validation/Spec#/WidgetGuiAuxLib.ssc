using System;
using System.Collections.Generic;
using Microsoft.Contracts;

internal sealed partial class Gui
{
	[Immutable] internal sealed class Event 
	{
		internal readonly string targetId, eventId;
		internal readonly string[] all;

		internal Event(string that)
		{
			string[] s = that.Split(new string[]{"::"}, StringSplitOptions.None);
			
			// To shut up boogiees array bounds checks
			assume s.Length >= 2;

			this.targetId = s[0];
			this.eventId = s[1];
			this.all = s;
		}
	}

	internal interface Widget 
	{
		string id { get; }
		int left { get; }
		int top { get; }
		int width { get; }
		int height { get; }
		string colour { get; }
		
		// Note: I have created these two functions instead of a simple List<Widget> children { get; }
		// Since the latter does not imply that the returned elements thesmelves are peer valid (just that the list is)
		[Pure] int children_count();
		// I have to make this return a nullable, since boogie tries to verify the consistency of the contracts with a dummy 'return null' implementation
		// But null is not peer valid, if I use Widget? it only requires the result to be peer valid if it is not null.
		[Pure] Widget? children(int i);

		bool dispatch(Event that) modifies this.**;
	}

	internal interface Action 
	{ 
		void apply(Event event_) modifies this.**; 
	}

	internal sealed class Button: Widget 
	{
		[Peer] internal readonly Action action;
		internal readonly string imgName;

		public string colour { get { return "gray"; } }
		[Pure] public override string ToString() { return this.id; }
		public bool dispatch(Event that)
		{
			if (this.id == that.targetId)
			{
				this.action.apply(that);
				return true;
			}
			return false;
		}

		int    Gui.Widget.left   { get { return this.left;   } }
		int    Gui.Widget.top    { get { return this.top;    } }
		int    Gui.Widget.width  { get { return this.width;  } }
		int    Gui.Widget.height { get { return this.height; } }
		string Gui.Widget.id     { get { return this.id;     } }

		[Pure] public int children_count() { return 0; }
		[Pure] public Widget? children(int i) { assume false; }

		internal readonly int left, top, width, height;
		internal readonly string id;

		[Captured] internal Button(string id, int left, int top, int width, int height, Action action, string imgName) 
			ensures Owner.Same(this, action); 
		{
			Owner.AssignSame(this, action);
			this.id = id;
			this.left = left;
			this.top = top;
			this.width = width;
			this.action = action;
			this.imgName = imgName;
		}
	}
}
