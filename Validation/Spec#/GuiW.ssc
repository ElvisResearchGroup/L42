using System;
using Microsoft.Contracts;
using System.Collections.Generic;


internal sealed class Box: Gui.DispatchTrait 
{
	internal int left;
	internal int top;

	[Pure] internal bool invariant_(int width, int height) 
	{
		Gui.Debug("Invariant #");
		for (int i = 0; i < this.children.Count; i++)
		{
			Gui.Widget w1 = this.children[i]; //! Read-effect this.children[.] is not admitted for Confined method invariant_.
			if (!Inside(w1, width, height)) return false; //! Read-effect this.children[.] is not admitted for Confined method invariant_.
			for (int j = 0; j < this.children.Count; j++)
			{
				Gui.Widget w2 = this.children[j];
				if (w1.id != w2.id && Overlap(w1, w2)) return false;
			}
		}
		return true;
	}

	[Pure] private static bool Overlap(/*read*/ Gui.Widget w1, /*read*/ Gui.Widget w2) 
	{
		if (w1.left > w2.left + w2.width || w2.left > w1.left + w1.width)
			return false;
		if (w1.top > w2.top + w2.height || w2.top > w1.top + w1.height)
			return false;

		return true;
	}

	[Pure] private static bool Inside(Gui.Widget that, int width, int height)
	{
		if (that.left < 0) return false;
		if (that.left + that.width > width) return false;
		if (that.top < 0) return false;
		if (that.top + that.height > height) return false;
		return true;
	}


	public override void process(Gui.Event event_) /*mut*/ {} 

	#region boilerplate
		[Captured] internal Box(string id, List<Gui.Widget> children, int left, int top)
			requires Owner.Same(Owner.ElementProxy(children), children);
			ensures Owner.Same(this, children);
		{
			this.left = left;
			this.top = top;
			base(id, children);
		}
	#endregion
}


internal sealed class ButtonW: Gui.DispatchTrait, Gui.Widget 
{
	[Peer] internal Box outer; /*mut*/
	internal int leftDelta;
	internal int topDelta;

	[Pure] public override string ToString() { return this.id; }

	public override void process(Gui.Event event_) /*mut*/
	{
		Gui.Debug("Button pressed: " + this.id);
		this.outer.left = this.outer.left + this.leftDelta;
		this.outer.top = this.outer.top + this.topDelta;
	}

	internal static ButtonW Left(/*mut*/ Box outer, int scale)
		ensures Owner.Same(result, outer);
	{
		return new ButtonW(outer, scale, "_Left", 0, 13, 6, 6, -5, 0);
	}
	internal static ButtonW Right(Box outer, int scale) 
		ensures Owner.Same(result, outer); 
	{ 
		return new ButtonW(outer, scale, "_Right", 26, 13, 6, 6, 5, 0); 
	}
	internal static ButtonW Up(Box outer, int scale)
		ensures Owner.Same(result, outer); 
	{
		return new ButtonW(outer, scale, "_Up", 13, 0, 6, 6, 0, -5);
	}
	internal static ButtonW Down(Box outer, int scale)
		ensures Owner.Same(result, outer); 
	{
		return new ButtonW(outer, scale, "_Down", 13, 26, 6, 6, 0, 5);
	}

	[Captured] ButtonW(/*mut*/ Box outer, int scale, string suffix, int left, int top, int width, int height, int leftDelta, int topDelta)
		ensures Owner.Same(this, outer);
	{
		List<Gui.Widget> children = new List<Gui.Widget>();
		Owner.AssignSame(Owner.ElementProxy(children), outer);
		Owner.AssignSame(children, outer);

		base(outer.id + suffix, children);
		this._top = top*scale;
		this._left = left*scale;
		this._width = width*scale;
		this._height = height*scale;

		this.outer = outer;
		this.leftDelta = leftDelta;
		this.topDelta = topDelta;
	}

	public int left { get { return this._left; } }
	public int top { get { return this._top; } }
	public int width { get { return this._width; } }
	public int height { get { return this._height; } }
	public string colour { get { return "grey"; } }

	#region boilerplate
		// Spec# (unlike C#) does not have auto implemented properties
		readonly int _left, _top, _width, _height;

		// Can't inherit Gui.Widget.left.get from DispatchTrait since it dosn't implement Gui.Widget
		string Gui.Widget.id { get { return this.id; } }
		List<Gui.Widget> Gui.Widget.children { [Peer] get { return this.children; } }
	#endregion
}

internal sealed class SafeMovable: Gui.Widget 
{
	[Rep] private readonly Box box;

	internal SafeMovable(int width, int height, string colour, [Captured] Box box) 
	{
		this._width = width;
		this._height = height;
		this._colour = colour;
		this.box = box;
	} //! Object invariant possibly does not hold
	
	internal SafeMovable(string id, int left, int top, int width, int height, string colour, [Captured] List<Gui.Widget> children) 
		modifies children.**;
		requires Owner.Same(Owner.ElementProxy(children), children);
	{
		Box box = new Box(id, children, left, top);

		ButtonW bl = ButtonW.Left(box, height/32);
		ButtonW br = ButtonW.Right(box, height/32);
		ButtonW bu = ButtonW.Up(box, height/32);
		ButtonW bd = ButtonW.Down(box, height/32);

		box.children.Add(bl);
		box.children.Add(br);
		box.children.Add(bu);
		box.children.Add(bd);

		this(width, height, colour, box);
	}


	public string id { get { return this.box.id; } }
	
	public List<Gui.Widget> children { get { return this.box.children; } }
	public int left { get { return this.box.left; } }
	public int top { get { return this.box.top; } }

	public bool dispatch(Gui.Event that) /*mut*/ 
	{ 
		expose (this) return this.box.dispatch(that);
	} //! Object invariant possibly does not hold

	public int width     { get { return this._width;  } }
	public int height    { get { return this._height; } }
	public string colour { get { return this._colour; } }

	invariant this.box.invariant_(this._width, this._height);

	#region boilerplate
		// Spec# (unlike neweer versions of C#) does not have auto implemented properties
		readonly int _width, _height;
		readonly string _colour;
	#endregion
}