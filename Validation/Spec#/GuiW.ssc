using System;
using Microsoft.Contracts;
using System.Collections.Generic;

internal sealed class Box: Gui.DispatchTrait 
{
	internal int left;
	internal int top;

	public override void process(Gui.Event event_) { } 

	[Captured] internal Box(string id, List<Gui.Widget> children, int left, int top)
		requires Owner.Same(Owner.ElementProxy(children), children);
		ensures Owner.Same(this, children);
	{
		this.left = left;
		this.top = top;
		base(id, children);
	}
}

internal sealed class SafeMovable: Gui.Widget 
{
	[Rep] private readonly Box box;

	internal static Gui.Button Left(Box outer, int scale)
		ensures Owner.Same(result, outer);
	{
		return MakeButton(outer, scale, "_Left", 0, 13, 6, 6, -5, 0);
	}
	internal static Gui.Button Right(Box outer, int scale) 
		ensures Owner.Same(result, outer); 
	{ 
		return MakeButton(outer, scale, "_Right", 26, 13, 6, 6, 5, 0); 
	}
	internal static Gui.Button Up(Box outer, int scale)
		ensures Owner.Same(result, outer); 
	{
		return MakeButton(outer, scale, "_Up", 13, 0, 6, 6, 0, -5);
	}
	internal static Gui.Button Down(Box outer, int scale)
		ensures Owner.Same(result, outer); 
	{
		return MakeButton(outer, scale, "_Down", 13, 26, 6, 6, 0, 5);
	}

	internal class MoveAction: Gui.Action {
		[Peer] Box outer;
		int leftDelta, topDelta;
		[Captured] internal MoveAction(Box outer, int leftDelta, int topDelta) 
			ensures Owner.Same(this, outer);
		{ 
			Owner.AssignSame(this, outer);
			this.outer = outer;
			this.leftDelta = leftDelta;
			this.topDelta = topDelta;
		}
		public void apply(Gui.Event event_) 
		{
			Debug.Print("Button pressed");
			outer.left = outer.left + leftDelta;
			outer.top  = outer.top + topDelta;
		}
	}

	internal static Gui.Button MakeButton(Box outer, int scale, string suffix, int left, int top, int width, int height, int leftDelta, int topDelta)
		ensures Owner.Same(result, outer);
	{
		return new Gui.Button(outer.id + suffix, left*scale, top*scale, width*scale, height*scale, new MoveAction(outer, leftDelta, topDelta));
	}

	internal SafeMovable(int width, int height, string colour, [Captured] Box box) 
	{
		this._width = width;
		this._height = height;
		this._colour = colour;
		this.box = box;
	} // Verification error: Object invariant possibly does not hold
	
	internal SafeMovable(string id, int left, int top, int width, int height, string colour, [Captured] List<Gui.Widget> children) 
		modifies children.**;
		requires Owner.Same(Owner.ElementProxy(children), children);
	{
		Box box = new Box(id, children, left, top);

		// I have to put these in variables (and not pass them directly to box.children.Add) otherwise boogie complains
		Gui.Button bl = Left(box, height/32);
		Gui.Button br = Right(box, height/32);
		Gui.Button bu = Up(box, height/32);
		Gui.Button bd = Down(box, height/32);

		box.children.Add(bl);
		box.children.Add(br);
		box.children.Add(bu);
		box.children.Add(bd);

		this(width, height, colour, box);
	}

	public string id { get { return this.box.id; } }
	public List<Gui.Widget> children { get { return this.box.children; } }
	public int left { get { return this.box.left; } }
	public int top { get { return this.box.top; } }

	public bool dispatch(Gui.Event that)
	{ 
		expose (this) return this.box.dispatch(that);
	} // Verification error: Object invariant possibly does not hold

	public int width     { get { return this._width;  } }
	public int height    { get { return this._height; } }
	public string colour { get { return this._colour; } }

	invariant Debug.IncrementCounter("Invariant") && forall {int i in (0: this.box.children.Count);
		   Inside(this.box.children[i], this._width, this._height) 
		&& forall {int j in (0: this.box.children.Count);
			// WTF? Without this I get a verification error: '
			//     all of System.Collections.Generic.List<Gui.Widget!>.this[int].get, unsatisfied precondition: index < Count' 
			   i < this.box.children.Count
			&& (!this.box.children[i].id.Equals(this.box.children[j].id) ==> !Overlap(this.box.children[i], this.box.children[j]))
		}
	};

	[Pure] private static bool Overlap(Gui.Widget w1, Gui.Widget w2) 
	{
		if (w1.left > w2.left + w2.width || w2.left > w1.left + w1.width)
			return false;
		if (w1.top > w2.top + w2.height || w2.top > w1.top + w1.height)
			return false;

		return true;
	}
	// Since this method is only called in the invariant,
	// Its significantly easier to just pass the width and height, as opposed to trying to make it an instance method.
	[Pure] private static bool Inside(Gui.Widget that, int width, int height)
	{
		if (that.left < 0) return false;
		if (that.left + that.width > width) return false;
		if (that.top < 0) return false;
		if (that.top + that.height > height) return false;
		return true;
	}

	// Spec# (unlike neweer versions of C#) does not have auto implemented properties
	readonly int _width, _height;
	readonly string _colour;
}