using System;
using Microsoft.Contracts;
using System.Collections.Generic;

// I need to define this class since the constructor for System.Object is not declared as 'Pure'
// This means that the static analayser thinks calls to 'base()' on a class deriving from Object could mutate memory.
// This particularlly means that after that call (which is implicitly the first thing in a constructor)
// A constructors precondition can no longer be assumed
internal class PureObject { [Pure] internal PureObject() {} }

internal class MoveAction: Gui.Action 
{
	[Peer] SafeMovable outer;

	int leftDelta, topDelta;
	[Captured] internal MoveAction(SafeMovable outer, int leftDelta, int topDelta) 
		ensures Owner.Same(this, outer);
	{ 
		Owner.AssignSame(this, outer);
		this.outer = outer;
		this.leftDelta = leftDelta;
		this.topDelta = topDelta;
	}
	public void apply(Gui.Event event_) 
	{
		Debug.Print("Button pressed");
		outer.left = outer.left + leftDelta;
		outer.top  = outer.top + topDelta;
	}
}
internal sealed class SafeMovable: PureObject, Gui.Widget 
{
	private static Gui.Button MakeButton(SafeMovable outer, int scale, string suffix, int left, int top, int width, int height, int leftDelta, int topDelta)
		ensures Owner.Same(result, outer);
	{
		return new Gui.Button(outer.id + suffix, left*scale, top*scale, width*scale, height*scale, new MoveAction(outer, leftDelta, topDelta));
	}

	// Box(string id, List<Gui.Widget> children, int left, int top)
	[Captured] internal SafeMovable(int width, int height, string colour, string id, List<Gui.Widget> children, int left, int top) 
		modifies children.**;
		requires Owner.Same(Owner.ElementProxy(children), children);
	{
		this.width = width;
		this.height = height;
		this.colour = colour;
		this.left = left;
		this.top = top;

		Owner.AssignSame(this, children);
		this.children = children;
		this.id = id; 
	} // Verification error: Object invariant possibly does not hold

	internal static SafeMovable Make(string id, int left, int top, int width, int height, string colour, List<Gui.Widget> children)
		modifies children.**;
		requires Owner.Same(Owner.ElementProxy(children), children);
		ensures Owner.Same(result, children);
	{
		SafeMovable res = new SafeMovable(width, height, colour, id, children, left, top);

		expose (res) 
		{
			// I have to put these in variables (and not pass them directly to box.children.Add) otherwise boogie complains
			Gui.Button bl = MakeButton(res, height/32, "_Left", 0, 13, 6, 6, -5, 0);
			Gui.Button br = MakeButton(res, height/32, "_Right", 26, 13, 6, 6, 5, 0);
			Gui.Button bu = MakeButton(res, height/32, "_Up", 13, 0, 6, 6, 0, -5);
			Gui.Button bd = MakeButton(res, height/32, "_Down", 13, 26, 6, 6, 0, 5);
		
			res.children.Add(bl);
			res.children.Add(br);
			res.children.Add(bu);
			res.children.Add(bd);
		}
		return res;
	}

	public bool dispatch(Gui.Event that)
	{
		expose (this) 
		{
			if (this.id == that.targetId)
				return true;

			for (int i = 0; i < this.children.Count; i++)
				if (this.children[i].dispatch(that)) return true;

			return false;
		} // Verification error: Object invariant possibly does not hold
	}

	invariant Debug.IncrementCounter("Invariant") && forall {int i in (0: this.children.Count);
		   Inside(this.children[i], this.width, this.height) 
		&& forall {int j in (0: this.children.Count);
			// WTF? Without this I get a verification error: '
			//     all of System.Collections.Generic.List<Gui.Widget!>.this[int].get, unsatisfied precondition: index < Count' 
			   i < this.children.Count
			//&& (!this.children[i].id.Equals(this.box.children[j].id) ==> !Overlap(this.children[i], this.children[j]))
		}
	};

	[Pure] private static bool Overlap(Gui.Widget w1, Gui.Widget w2) 
	{
		if (w1.left > w2.left + w2.width || w2.left > w1.left + w1.width)
			return false;
		if (w1.top > w2.top + w2.height || w2.top > w1.top + w1.height)
			return false;

		return true;
	}
	// Since this method is only called in the invariant,
	// Its significantly easier to just pass the width and height, as opposed to trying to make it an instance method.
	[Pure] private static bool Inside(Gui.Widget that, int width, int height)
	{
		if (that.left < 0) return false;
		if (that.left + that.width > width) return false;
		if (that.top < 0) return false;
		if (that.top + that.height > height) return false;
		return true;
	}

	/*
		Changes to make:  make Box.id readonly (and move it outside of the box?), put properties next to fields
			make TRIVIAL property implementations explicit (so we don't need to use _'s for field names)
	*/

	readonly int width, height;
	internal int left, top;
	readonly string colour, id;
	[Rep] [ElementsRep] internal List<Gui.Widget> children;

	// Boilerplate widget implementation
	// Spec# (unlike neweer versions of C#) does not have auto implemented properties
	int Gui.Widget.width                 { get { return this.width;    } }
	int Gui.Widget.height                { get { return this.height;   } }
	string Gui.Widget.colour             { get { return this.colour;   } }
	string Gui.Widget.id                 { get { return this.id;       } }
	List<Gui.Widget> Gui.Widget.children { get { return this.children; } }
	int Gui.Widget.left		             { get { return this.left;     } }
	int Gui.Widget.top	            	 { get { return this.top;      } }
}