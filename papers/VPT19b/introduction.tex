\section{Introduction}
Meta-programming is a very useful technique for writing code, as it can automatically generate large chunks of code following arbitrary patterns. If we want to ensure our meta-programming produces `correct' code, we could try and statically verify the meta-programming itself, though we are unaware of any work that actually enables this. 

Just like static verification, meta-programming is often executed during compilation (or at `meta-time'), before the program is actually run. So instead of statically verifying the program \emph{before} we compile it, we could do so afterwards, on the result of the meta-programming. However, static verification can be slow, in addition it is often hard to predicate when it will fail to verify correct code. Instead we propose a technique by which only the \emph{input} to the meta-programming needs to be statically verified. Our technique works by ensuring, through a simple and predictable meta-time check, that the result of primitive meta-operations is always `correct' whenever their inputs are.

The meta-programming technique of \emph{iterative trait composition}~\cite{Servetto:2013:MLA:2426890.2426913} makes this possible, as its primitive operations (in particular \emph{trait composition} work on entire pieces of self-contained code//classes (`traits'). Though prior work does look at verifying the structure of the result of trait composition~\cite{Damiani:2011:VTP:2076674.2076682}, such work does not consider the correctness of the \emph{behaviour} of the result's methods. Trait composition differs significantly from other meta-programming techniques that work on incomplete code chunks, such as quasi-quotation~\cite{sheard2002template} which operates directly on (partial) abstract syntax trees. We do not believe it would be simple or easy to verify the correctness of AST operations, it is not even clear to us what it should mean for an (incomplete) AST to be `correct'.

An alternative way of generating code is to use higher order functions, which can also generate arbitrary behaviour. However, unlike iterative trait composition and quasi-quotation, they cannot generate classes or declarations. One can statically verify higher order functions to ensure they return code with certain contracts~\cite{Xu:2009:SCC:1480881.1480889}. A potential avenue for future work would be to combine higher order functions with iterative trait composition: where one would use higher order functions to generate behaviour, and iterative trait composition to generate declarations.

In \sref{bac} we discuss prior work in specifying OO code, and explain the concept of iterative trait composition. In \sref{combining} we present and explain our contribution. In \sref{ex} we show how our approach works with two examples. \sref{conc} discusses conclusions (including limitations of our work) as well as directions for future research.