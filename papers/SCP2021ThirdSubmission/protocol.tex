%-----------------------------------------------------------
%define simple objects
%show solution  for simple person: requires 3 properties
%show solution is sound --> proof in appendix
%naive is unsound - person 3 bugs
\section{Our Invariant Protocol}
\label{s:protocol}
All classes contain a \Q@read method Bool invariant() {..}@, if no \Q!invariant()! method is explicitly present, a trivial one returning \Q!true! is assumed.

Our protocol guarantees that the whole reachable object graph of any object involved in execution (formally, in a redex) is \emph{valid}: if you can use an object, \emph{manually} calling \Q@invariant()@ on it is guaranteed to return \Q@true@ in a finite number of steps.\footnote{
  We will show later how we satisfy this constraint without 
  solving the halting problem or requiring all \Q@invariant()@ methods to be total.
  }

%Our protocol is designed only to verify invariants over immutable and encapsulated state.
As the \Q!invariant()! is used to determine whether \Q!this! is broken, it may receive a broken \Q@this@; however this will only occur for calls to \Q!invariant()! inserted by our approach. User written calls to \Q!invariant()! are guaranteed to receive a valid \Q!this!.

We restrict \Q@invariant()@ methods so that they represent a predicate over the receiver's \Q!imm! and \Q!rep! fields. To ensure that \Q!invariant()! methods do not expose a potentially broken \Q!this! to the other objects, we require that all occurrences of \Q!this!\footnote{Some languages allow the \Q@this@ receiver to be implicit. For clarity in this work we require \Q@this@ to be always used explicit.}%
%(as a sub-expression)
in the \Q!invariant()!'s body are the receiver of a field access (\Q!this.f!) of an \Q!imm!/\Q!rep! field, or the receivers of a method call (\Q!this.m(..)!) of a final (non-virtual) method that in turn satisfies these restrictions. No other uses of \Q!this! are allowed, such as as the right hand side of a variable declaration, or an argument to a method.
An equivalent alternative design could instead rely on static \Q@invariant(..)@ methods taking each \Q!imm!/\Q!rep! field as an \Q!imm!/\Q!read! parameter.

Invariants can only refer to immutable and encapsulated state. Thus while we can easily verify that a doubly linked list of immutable elements
is correctly linked up,
we can not do the same for a doubly linked lists of \IO[4.1]{unencapsulated} mutable elements.
\IO[4.2]{In particular, as the nodes of the list must be mutable (since they reference the mutable elements), for these to be referenced in the \Q!invariant! method, they must be reacheable from a \Q!rep! field, but then the elements of the list cannot be made accesible as \Q!mut! from outside the list.\footnote{\IO[4.3]{If our protocol were extended to support polymorphic reference capabilities (as in Gordon \etal's work~\cite{GordonEtAl12}), we could allow a reference with a polymorphic reference capability to be reachable from a \Q!rep! field, provided that the state reachable from such a reference cannot be read from the \Q!invariant! method. This could be done by supporting a reference capability that prevents reading state (such as the \Q!tag! capability of Pony~\cite{clebsch2015deny}), and requiring that such a polymorphic reference capability be type checked as if it were \Q!tag!.
Outside the list however, if the polymorphic reference capability is known to be \Q!mut!, the elements could then be freely accessed and aliased, as the \Q!invariant! would be guaranteed to not depend on them.}} We do not make it harder to correctly implement lists of mutable elements, we only limit what invariants can be expressed in our protocol. Note that we could use the transform pattern presented in \autoref{s:patterns} to mutate the elements of such a list, in a way that does not allow aliases to be saved outside.}

There is a line of work~\cite{DBLP:conf/mpc/BarnettN04} striving to allow invariants over other forms of state.
%It would not be technically difficult to 
%integrate the solutions of those works, but 
We have not tried to integrate such solutions into our work, as we believe it would make our system more complex and ad hoc, probably requiring numerous specialised kinds of reference capabilities.
Thus we have traded some expressive power in order to preserve safety and simplicity.

\subheading{Purity}\label{s:purity}
L42's enforcement of reference and object capabilities statically guarantees that any method with only \Q!read! or \Q!imm! parameters (including the receiver) is \emph{pure}; we define pure
as being deterministic and not mutating existing memory. This holds because
(1) the reachable object graph of the parameters (including \Q!this!) is only accessible as \Q@read@ (or \Q@imm@), thus it cannot be mutated
%\footnote{This holds also in concurrent environments ensuring no other thread/actor has access to a \Q@mut@/\Q@capsule@ alias of \Q@this@. 
%%	Thus, since such methods do not write to memory accessible by another thread, nor read memory that could be mutated by another thread, they are atomic.
%};
(2) if a capability object is in the reachable object graph of any of the arguments (including the receiver), then it can only be accessed as \Q@read@, preventing calling any 
non-deterministic (capability) methods;
(3) no other pre-existing objects are accessible (as L42 does not have global variables). 
In particular, this means that our \Q!invariant()! methods are pure, since 
their only parameter (the receiver) is \Q!read!.
%\footnote{%
%		If L42 did have static variables, getters and setters for them would need to be capability methods.
%		Even allowing unrestricted access to \Q@imm@
%		static variables would prevent reasoning over
%		determinism, due to the possibility of global %variable
%		updates; however constant/final globals of an 
%		\Q@imm@ type would not cause such problems.%
%}
%We are unsure about the exact details of Gordon \etal's and Pony's object capabilities style, and if they can be used to enforce purity.

%Methods that perform non-deterministic \emph{input} shouldn't be white-listed.%, including methods that read information passed to white-listed output methods.


%Here we combine Reference capabilities with reference and object capabilities to guarantee 
%\MS{determinism of} any method that can not access a \Q@mut@ reference to a capability object:
%all non deterministic primitive operations are instance methods requiring a \Q@mut@ receiver, and
%	\item all non-deterministic primitives (like native calls) require a \Q@mut@ receiver,
%instances of capability classes containing such methods can only be created by a \Q@mut@ method of another capability class
%	\begin{itemize}
%		\item the runtime-system\footnote{as 42 has no standard-library, we treat meta-code as the runtime-system} before main begins,
%		\item within a \Q@mut@ method on such a class
%	\end{itemize}
%	\item all non-deterministic operations require a \Q@mut@ receiver,
%	\item all classes 
%	\item there are no global variables\footnote{Note: even just allowing \Q@imm@
%global variables would prevent reasoning over determinism due to the possibility of global variable updates; however constant/final globals of an \Q@imm@ type would not cause such problems.},
% \item user code cannot directly create a capability object: they can only indirectly do so through an existing \Q@mut@ capability object reference.

% NOTE: SOMEWHERE MAKE IT CLEAR THAT NON-DETERMINISM CAN ONLY OCCUR THROUGH A CAPABILITY OBJECT
%\end{itemize}



% However, the \Q!invariant()! method itself needs to be able to operate on a potentially invalid \Q!this!, this will only happen when it is automatically called by the language itself, not by explicit calls present in the source code.
% Clearly the \Q@invariant()@ method must be able to take an invalid \Q@this@, since the purpose of such method is to distinguish valid and invalid objects. On a first look this may seem an open contradiction
% with the aim of this work, however only calls to \Q@invariant()@ inserted by the language semantics can take an invalid \Q@this@. As for any other method, when the application code can call \Q@invariant()@, \Q@this@ is guaranteed to be valid.
%

%Logically, there are two reasons to access a field: we may wish to read the information stored in such object or we wish to mutate the object contained in the field.
%For the first case, we can type the field access as \Q@read@, but in the second case we
%need to type it as \Q@mut@. 
%We call `rep mutators' a method accessing as \Q@mut@ a \Q!capsule! field referenced in the invariant.
%We will show how rep mutators are analogous of the pack/unpack/expose~\cite{???}.
%In order for a class to have an invariant under our protocol,
%\Q@invariant()@ method the form 
% Can  a program write say mut method invariant or is it syntactically [???]

%We will later explain how these and other restrictions can be partially relaxed, as in the code examples.

% In order to prevent passing an invalid \Q@this@ to other methods.
%and unrelated code cannot break the invariant
%s of arbitrary objects,
%since a \Q!read! or \Q!mut! field could be modified through arbitrary aliases 
%(see \autoref{s:immutable}). 

%To ensure that invariants cannot be broken by unrelated code (see \autoref{s:immutable})  %
\subheading{Rep Fields}
%As we discussed before, while most approaches agree on the exact properties of a capsule reference,
%capsule fields are handled in different ways in different approaches. 
Former work on L42 discusses ``depending on how we expose the owned data, we can closely model both \emph{owners-as-dominators}[...] and \emph{owners-as-qualifiers}[...]''\cite{GIANNINI2019145}, and  ``\Q!lent! getter[s], a third variant''\cite{GIANNINI2019145}.%Flexible recovery of uniqueness and immutability

Those informal considerations have then influenced the L42 language design,
bringing to the creation of syntactic sugar and programming patterns to represent various kinds of \Q@capsule@ fields aimed to model various forms of ownership. Under the hood, all those forms of \Q@capsule@ fields are just private \Q@mut@ fields with some extra restrictions. Describing in the details those restrictions would be outside of the scope of this paper.

Here we present a novel kind of encapsulated field, that we call a  \Q!rep! field.
As for the various kinds of L42 \Q@capsule@ fields, our new kind of field is also just 
a private \Q@mut@ fields with extra restrictions,
enforcing the following key property:
the reachable object graph of a \Q!rep! field $o.f$ can only be mutated under the control of a \Q@mut@ method of $o$, and during such mutation, $o$ itself cannot be seen.
This is similar to owner-as-modifier~\cite{Dietl05universes:lightweight,10.1007/978-3-540-92188-2_4}, 
where we could consider an object to be the `owner' of all the mutable objects in the reachable object graph of its \Q!rep! fields, but with the extra restriction that the owner is unobservable during mutation of those objects.

More preciselly, if a reference to an object in the reachable object graph of a \Q!rep! field $o.f$ is involved in execution as \Q!mut!, then:
(1) no reference to $o$ is involved in execution,
(2) a call to a \Q!mut! method for $o$ is present in a previous stack frame, and
(3) mutable references to the reachable object graph of $o.f$ are not leaked out of such method execution, either as return values, exception values, or stored in the reachable object graph of any parameter or any other field of the method's receiver.


To show how our \Q@rep@ fields ensure these properties, we first define some terminology:
\Q@x.f@ is a \emph{field access}, \Q@x.f=e@ is a \emph {field update},\footnote{Thus a field update \Q@x.f=e@ is not a field access followed by an assignment.}
a \Q@mut@ method with a field access on a \Q!rep! field of \Q!this! is a \emph{rep mutator}.
\footnote{
We could relax our protocol,
so that a \Q!mut! method that reads a \Q!rep! field is not considered a rep mutator if the method only needs to use the field's value as \Q!read!.
This relaxation would merely be for convenience; it does not change expressivity as one can write a getter of form
\Q@read method read C m()\{return this.f;\}@
for a \Q@rep C f@ field,
%$\method{\Kw{read}\,}{\,\Kw{read}\,C}{m}{}{\Kw{this}\D f}$, where $C.f = \field{\Kw{rep}}{C}{f}$,
and then call \Q@this.m()@ on a \Q!mut! \Q!this!.%
} 
Note that a method performing a field \emph{update} of a \Q@rep@ field (instead of a field access) is not called a rep mutator, but it is just a normal method performing a field update.
Rep mutators handle the more subtle case where the fields of an object with invariant are not updated, but a mutation deep within their reachable object graph may potentially break the invariant.

The following rules define our novel \Q!rep! fields:
\begin{itemize}
\item A \Q!rep! field can only be initialised/updated using the result of an expression with  \Q!capsule! type.
\item A \Q!rep! field access will return a:
\begin{itemize}
\item \Q!mut! reference, when accessed on \Q!this! within a rep mutator,
\item \Q!read! reference, when accessed on any other \Q!mut! receiver,
\item \Q!imm! if the receiver is \Q!imm!, \Q!read! if the receiver is \Q!read!, or \Q@capsule@ if the receiver is
\Q!capsule!. This last case is safe since a \Q@capsule@ receiver object will then be garbage collectable, so we do not need to preserve its invariant.
\end{itemize}
\item A rep mutator must:
\begin{itemize}
\item use \Q!this! exactly once: to access the \Q!rep! field,
\item have no \Q!mut! or \Q!read! parameters (except the \Q!mut! receiver),
\item not have a \Q!mut! return type,
\item not throw any checked exceptions\footnote{To allow rep mutators to leak checked exceptions, we would need to check the invariant when such exceptions are leaked. However, this would make the runtime semantics of checked exceptions inconsistent with unchecked ones.}.
\end{itemize}
\end{itemize}	

	
\noindent The above rules ensure that rep mutators control the mutation of the reachable object graph of \Q!rep! fields, and 
 ensures our points (1), (2), and (3):
$o$ will not be in the reachable object graph of $o.f$ and
only a rep mutator on $o$ can see $o.f$ as \Q!mut!; this means that the only way to mutate the reachable object graph of $o.f$ is through such methods. \IO[5]{The restriction on the paramater types of a rep mutator ensure that $o$ will not be reacheable from any of the method's arguments, nor can these arguments be made reacheable through $o.f$, which would violate our point (3).}
%When a rep mutator is not executing, no object in the reachable object graph of $o.f$ can be seen as \Q!mut! or \Q!capsule!. 
%(using any sequence of field accesses on a local variable).
If execution is (indirectly) in a rep mutator, then $o$ is only used as the receiver of the \Q!this.f! expression in the rep mutator.
Thus we can be sure that the reachable object graph of $o.f$ will only be mutated within a rep mutator, and only after the single use of $o$ to access $o.f$.
Since such mutation could invalidate the invariant of $o$, we call the \Q@invariant()@ method at the end of the rep mutator body; before $o$ can be used again. Provided that the invariant is re-established before a rep mutator returns, no invariant failure will be thrown, even if the invariant was temporarily broken \emph{during} the body of the method.%
\footnote{
That is, rep mutators pretend
  that \Q@this@ is linear by requiring it to be used exactly once to read the \Q@rep@ field. By burying the
  only current access point to the \Q@rep@ field we can read it as \Q@mut@ and mutate it.
  The restrictions on parameter types and return types ensure that when such reference goes out of
  scope, the only remaining reference allowing mutation is in the \Q@rep@ field again.
  This is similar to the ideas of the Focus operation~\cite{DBLP:journals/jot/BarnettDFLS04}
 and View-point adaptation~\cite{DietlEtAl07}.
}

\IO[17]{The following example illustrates these properties of rep mutators:}
\begin{lstlisting}
class Foo {
	imm Int n; rep Point p;

	read method Bool invariant() {
		return this.p.x + this.p.y < this.n;
	}
	mut method read Point bar() {
		return new Point(this.p.x, this.p.y); // ok, not a rep mutator
	}
	mut method read Point baz(capsule Qux q) {
		mut Qux my_q = q; // Ok, q is used exactly once
		mut Point my_p = this.p; // ok, single use of `this'
		my_p.x = my_q.compute_x(my_p); // may break the invariant
		// it is ok if th invariant doesn't hold, as `this' cannot be reachable
		// from `my_q' or `my_p', this holds since `q' is capsule, and so cannot
		// alias `this'; if `q' were instead mut or read, this would not be guaranteed.
		my_p.y = my_q.compute_y(my_p);
		return my_p; // invariant check here
	}
}
\end{lstlisting}
%INTERESTING, the commented text down here looks a lot like the rev suggestion above...
%As the expression is \Q!capsule!, we can be sure that the object being initialised/updated will have the only external alias to the reachable object graph of the field's new value. In addition, since the reference was \Q!capsule!, the initialised/updated object could not already alias it, thus after the initialisation/update, the initilised/updated \Q!capsule! field will not alias the object.

In contrast, L42's pre-existing \Q!capsule! fields do not have our rep mutator restrictions, in particular, other objects can mutate them, although storing references to them on the heap is highly restricted.
These properties are also \emph{weaker} than those of \Q!capsule! \emph{references}: we do not need to prevent arbitrary \Q!read! aliases to the reachable object graph of a \Q!rep! field, and we do allow arbitrary \Q!mut! aliases to exist during the execution of a rep mutator. In particular, our rules allow unrestricted read only access to our \Q!rep! fields.

%In particular, unrestricted readonly access to \Q!capsule! fields can be allowed by writing getters of the form \Q!read method read C f() { return this.f; }!. Such getters are already fundamental in L42~\cite{DBLP:journals/programming/AroraSO19}. Such a method can be called on a \Q!mut! \Q!this!, without making the method a rep mutator. % ISAAC: WRong since you've now made capsule fields non-instance private

%Note that methods with a \Q@capsule@ \Q@this@
%which perform a \Q@capsule@ field access are not rep mutators: since \Q!capsule! variables can only be used once, \Q!this! will be garbage collectable immediately after the single use of \Q!this! to read the \Q!capsule! field.
% ISAAC: Redundent, I say this allready in a footnote above

%\subheading{Rep mutators}
%In order to allow complex mutations of objects with invariants we, introduce the notion of \emph{rep mutator}. A \emph{rep mutator} can perform an arbitrarily complex mutation of the reachable object graph of a \Q!capsule! field. We use TMs to ensure that the object containing the \Q!capsule! field is not usable whilst the field's reachable object graph is mutated, and its invariant is checked immediately afterwards. 
%Formally, \emph{rep mutators} are \Q@mut@ methods whose body accesses a \Q@capsule@ field. 


%\end{itemize}
%Our type system will ensure that such methods are \Q!mut method!s, and the \Q!capsule! field will be seen as \Q!mut!.
%As \Q@capsule@ mutators use \Q!this! only once, and have no \Q!read! or \Q!mut! parameters, \Q!this! will not be accessible during execution, this is important as mutating the reachable object graph of the \Q@capsule@ field may violate the invariant of \Q!this!.  Preventing \Q!mut! return types ensures that such methods cannot \REV{leak out a mutable alias to the \Q!capsule! field}{D}{why would it otherwise be possible ... Even doing this locally violates the soundness semantics for every reference immutability system I've see}, which could then be used to break the invariant.

%\footnote{This is sound provided \Q!this! can be used only once. This is already enforced by L42, since \Q!this! will be a \Q!capsule! variable, which L42 only allows to be used once.}. By the the properties of \Q!capsule!}




\subheading{Runtime Monitoring}
The language runtime will automatically perform calls to \Q!invariant()!, if such a call returns \Q!false!, an unchecked exception will be thrown. Such calls are performed at the following points:
\begin{itemize}
	\item After a constructor call, on the newly created object.
	\item After a field update, on the receiver.
	\item After a rep mutator method returns, on the receiver of the method\footnote{The invariant is not checked if the call was terminated via an an unchecked exception, since strong exception safety guarantees the object will be unreachable.}.
\end{itemize}
\noindent In \autoref{s:formalism}, we show that these checks, together with our aforementioned restrictions, are sufficient to ensure our guarantee that the invariants of all objects involved in execution hold. %(except the invariant of \Q!this! when used to access fields in a runtime-generated call to the \Q!invariant()! method itself).

\subheading{Traditional Constructors and Subclassing}
L42 constructors directly initialise all the fields using the parameters, and L42 does not provide traditional subclassing \IO[6]{(it provides other forms of code reuse), it does however provide subtyping similar to Java 7's interfaces.}
This works naturally with our invariant protocol.
We can support traditional constructors as in Pony and Gordon \etal's language, 
by requiring that constructors only use \Q@this@ as the receiver of a field initialisation.
%L42 does not support user-written constructors but allows static factory methods with equivalent behaviour.
Subclassing can be supported by forcing that a subclass invariant method implicitly starts with a check that \Q@super.invariant()@ returns \Q@true@. We would also perform invariant checks at the end of \Q@new@ expressions, as happens in~\cite{feldman2006jose}, and not at the end of \Q@super(..)@ constructor calls.
