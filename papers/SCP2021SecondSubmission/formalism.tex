\section{Formal Language Model}
\lstset{language=FortyFour} % Make all code bold
\IOComm{REMBER TO TALK ABOUT READ FIELDS WITH MARCO!!!!}
\IOComm{Note i'm using ``$\square$'' instead of ``$[]$'' for the ``hole''s as it's more standard}
\label{s:formalism}
To model our system we need to formalise an imperative OO language
with exceptions, object capabilities, and type system
support for reference capabilities and strong exception safety.
Formal models of the runtime semantics of such languages are simple, but
defining and proving the correctness of such a type system 
is quite complex, and indeed many such papers exist that have already done this~\cite{ServettoEtAl13a,ServettoZucca15,GordonEtAl12,clebsch2015deny,JOT:issue_2011_01/article1}.
Thus we parametrise our language formalism, and assume we already have an expressive and sound type system enforcing the properties we need, so
that we can separate our novel invariant protocol, from the non-novel reference capabilities.
We clearly list in \ref{s:proof} the requirements we make on such a type system, so that any language satisfying them can soundly support our invariant protocol.
In \ref{s:typesystem} we show an example type system, a restricted subset of L42, and prove that it satisfies our requirements. Conceptually our approach can parametrically be applied to any type system supporting these requirements, for example you could extend our type system with additional promotions or generic.
To keep our small step reduction semantics as conventional as possible, we base our formalism on Pierce~\cite{pierce2002types} and Featherweight Java~\cite{IgarashiEtAl01}, which is a turing complete minimalistic subset of Java. \IOComm{check this is in the citation}. \IOComm{What's the relavence of "Pierce" here?}
As such, we model an OO language where receivers are always specified explicitly, and the receivers of field accesses and updates in method bodies are always \Q!this!; that is, all fields are instance-private.
Constructor declarations are not present explicitly, instead we assume they are all of the form $C\oR \trange{\fmdf}{C}{x} \cR\oC \drange[\semicolon]{\Kw{this}\singleDot f}{\Kw{=}\,x} \cC$, where the fields of $C$ are $\trange{\fmdf}{C}{f}$, and $\derep{\fmdf_i}$ gives the reference capability required for the field kind $\fmdf_i$, see below for the definition.
Note that we do not model variable updates or traditional subclassing, since this would make the proofs more involved without adding any additional insight.

\subheading{Notational Conventions}
We use the following notational conventions:
\begin{itemize}
	\item Class, method, parameter, and field names are denoted by $C$, $m$, $x$, and $f$, respectively.
	\item We use ``$\vs$'' as a metavariable denoting a sequence of form $\range{v}$, and ``$v?$'' to denote an optional $v$, similarly with other metavariables.
	\item We use ``$\_$'' to stand for any piece of syntax, including the empty string.
	\item Memory locations are denoted by $l$.
	\item We assume an implicit program/class table; we use the notation $C.m$ to get the method declaration for $m$ within class $C$, similarly we use $C.f$ to get the declaration of field $f$, and $C.i$ to get the declaration of the $i$\textsuperscript{th} field.
	\item Memory, denoted by $\s : l\rightarrow C\{\vs\}$, is a finite map from locations, $l$, to annotated tuples, $C\{\vs\}$, representing objects; here $C$ is the class name and $\vs$ are the 
	field values, without any reference capabilities.
	We use the notation $\C{l}$ get the class name of $l$, $\s[l.f=v]$ to update a field of $l$, $\s[l.f]$ to access one, and $\s \setminus l$ to delete $l$ (
this is only used in our proofs since our small step reduction does not need to delete individual locations). The notation $\s,\s'$ combines the two memories, and requires that $\dom(\s)$ is disjoint from $\dom(\s')$.
	\item We assume a typing judgment of form $\ty{e}{T}$, this says that the expression $e$ has type $T$,
	where the classes of any locations are stored in $\s$ and the types of variables are stored in the environment $\G : x\rightarrow T$.
\end{itemize}

\noindent To encode object capabilities and I/O, we assume a special location  $c$ of class \Q@Cap@. This location can be used in the main expression and would refer to an object with methods that behave non-deterministically, such methods would model operations such as file reading/writing. In order to simplify our proof, we assume that:
\begin{itemize}
	\item \Q@Cap@ has no fields,
	\item instances of \Q@Cap@ cannot be created with a \Q@new@ expression,
	\item \Q@Cap@'s \Q@invariant()@ method is defined to have a body of `\Q!imm true!', and
	\item all other methods in the \Q@Cap@ class must require a \Q@mut@ receiver; such methods can be declared with the same signature multiple times, thus a call to them will non-deterministically chose one of the implementations.
\end{itemize}
We only model a single \Q@Cap@ capability class for simplicity, as modelling user-definable capability classes as described in \ref{s:OCs} is unnecessary for the soundness of our invariant protocol.

For simplicity, we do not formalise actual exception objects, rather we have \error{}s, which correspond to expressions which are currently  `throwing' an exception;
in this way there is no value associated with an \error.
Our L42 implementation instead allows arbitrary \Q!imm! values to be thrown as (unchecked) exceptions, formalising exceptions in such way would not cause any interesting variation of our proofs.

\begin{figure}
	\begin{grammatica}
		\produzione{e}{
			\x
			\mid \mdf\,\Kw{true}
			\mid \mdf\,\Kw{false}
			\mid \new{C}{\es}
			\mid \Kw{this}\singleDot f
			\mid \Kw{this}\singleDot f\equals e
			\mid \call{e}{m}{\es}
		}{expression}\\
		\seguitoProduzione{
			\mid \prom{\mdf}{e}
			\mid \try{e}{e'}
		}{}\\
		\seguitoProduzione{
    		\mid \mdf\,l
			\mid \mdf\,l\singleDot f
    		\mid \mdf\,l\singleDot f\equals e
			\mid \trys{\s}{e}{e'}
			\mid \M{l}{e}{e'}
		}{runtime expr.}\\
		
		\produzione{v}{
			l
			\mid \Kw{true}
			\mid \Kw{false}
		}{raw value}\\

		\produzione{w}{
			\mdf\,v
		}{value}\\

		\produzione{\EV}{
			\hole
			\mid \new{C}{\ws,\EV,\es}
			\mid \mdf\,l\singleDot f\equals\EV
			\mid \call{\EV}{m}{\es}
			\mid \call{w}{m}{\ws,\EV,\es}
		}{eval. context}\\
		\seguitoProduzione{
			\mid \prom{\mdf}{\EV}
			\mid \trys{\s}{\EV}{e}
			\mid \M{l}{\EV}{e}
			\mid \M{l}{w}{\EV}
		}{}\\
		
		\produzione{\E}{
			\hole
			\mid \new{C}{\es,\E,\es'}
			\mid \E\singleDot f
			\mid \E\singleDot f\equals e
			\mid e\singleDot f\equals\E
			\mid \call{\E}{m}{\es}
		}{full context}\\
		\seguitoProduzione{
			\mid \call{e}{m}{\es,\E,\es'}
			\mid \prom{\mdf}{\E}
			\mid \trys{\s?}{\E}{e}
		}{}\\
		\seguitoProduzione{
			\mid \trys{\s?}{e}{\E}
			\mid \M{l}{\E}{e}
			\mid \M{l}{e}{\E}
		}{}\\
		
		%\produzione{M_l}{\E[M\oR l,e\cR]}{}\\
		%\produzione{\EG_l}{
		%  M_l\singleDot m\oR\es_1,\E,\es_2\cR
		% |e\singleDot m\oR\es_1, M_l, \es_2, \E, \es_3\cR
		% |M_l\singleDot f\equals\E
		% |\Kw{new}\ C\oR\es_1,M_l,\es_2,\E,\es_3\cR
		% |\Kw{try}\oC\E\cC\ \Kw{catch}\ \oC e\cC
		% |\E[\EG_l]}{}\\
		\produzione{\CD}{
			\clazz{C}{\Cs}{\Fs}{\Ms}
			\mid \iclazz{C}{\Cs}{\As}
		}{class decl.}\\

		\produzione{F}{
			\field{\mdf}{C}{f}
		}{field}\\

		\produzione{A}{
			\amethod{\mdf}{T}{m}{\Ps}
		}{abs. method}\\

		\produzione{M}{
			\method{\mdf}{T}{m}{\Ps}{e}
		}{method}\\

		\produzione{P}{
			T\,x
		}{parameter}\\

		\produzione{T}{
			\mdf\,C}{type}\\

		\produzione{\mdf}{
			\Kw{mut}
			\mid \Kw{imm}
			\mid \Kw{read}
			\mid \Kw{capsule}
		}{reference capability}\\

		\produzione{\fmdf}{
			\Kw{mut}
			\mid \Kw{imm}
			\mid \Kw{read}
			\mid \Kw{rep}
		}{field kind}\\

		\produzione{\ER}{
			\EV[\new{C}{\ws,\hole,\ws'}]
			\mid \EV[\hole\singleDot f]
			\mid \EV[\hole\singleDot f\equals v]
			\mid \EV[v\singleDot f\equals\hole]
		}{redex context}\\
		\seguitoProduzione{
			\mid \EV[\call{\hole}{m}{\ws}]
			\mid \EV[\call{w}{m}{\ws,\hole,\ws'}]
			\mid \EV[\prom{\mdf}{\hole}]
		}{}\\

		\produzione{\error}{
			\EV[\M{l}{w}{\Kw{imm}\,\Kw{false}}]
			\text{, where }
			\EV \text{ not of form } \EV'[\trys{\s?}{\EV''}{\_}]
		}{validation error}
	\end{grammatica}%\vspace{-1em}
\caption{Grammar}\label{f:grammar}
\end{figure}


\subheading{Grammar}
The grammar is defined in Figure \ref{f:grammar}.

We use $\mdf$ for our reference capabilities, and $\fmdf$ for field kinds. Recall that we don't model traditional $\Kw{capsule}$ fields, but instead model our novel $\Kw{rep}$ fields, which can only be initialised/updated with $\Kw{capsule}$ references.

We use $v$ to represent a raw value, either a location or a boolean.
We use $w$, of form $\mdf\,v$, to keep track of the reference capabilities in the runtime, as it allows multiple references to the same location to co-exist with different reference capabilities; however $\mdf$'s are not stored in memory.
The reduction rules do not change behaviour based on these $\mdf$'s, they are merely used by our proofs to keep track of the guarantees enforced by the typesystem.
For simplicity, the boolean literals \Q!true! and \Q!false! have a reference capability, but these imposes no constraints (e.g. you can have two ``$\Kw{capsule}\,\Kw{true}$''s simultaneously).

Our expressions ($e$), include variables ($x$), boolean literals ($\mdf\,\Kw{true}$ and $\mdf\,\Kw{false}$), object creations ($\new{C}{\es})$, field accesses ($\Kw{this}.f$ and $\mdf\,l.f$), field updates ($\Kw{this}.f \equals e$ and $\mdf\,l.f \equals e$), and method calls $\call{e}{m}{\es}$. Note that these are sufficient to model standard constructs like sequencing and let-expressions \IOComm{give a citation}.
The expressions with $\Kw{this}$ will only occur in method bodies, at runtime $\Kw{this}$ will be substituted for a $\mdf\,l$.

The three other expressions are:
\begin{itemize}
	\item Promote expressions ($\prom{\mdf}{e}$), these evaluate $e$ and change the reference capability of the result to $\mdf$. This is similar to Pony's promote expressions. It is up to the typesystem what promotions it accepts as valid, provided they cannot be used to violate our requirements in \ref{s:proof}. Using an explicit promotion makes the proofs much simpler, but a typesystem could simply wrap expressions with a $\prom{\mdf}{\_}$ when necessary.
	\item Monitor expressions ($\M{l}{e}{e'}$) represent our runtime injected invariant checks. The location $l$ refers to the object whose invariant is being checked, $e$ represents the behaviour of the expression, and $e'$ is the invariant check, which will initially be $\invariant{l}$. The body of the monitor, $e$, is evaluated first, then the invariant check in $e'$ is evaluated. If $e'$ evaluates to $\Kw{imm}\,\Kw{true}$ (i.e. $l$ is valid), then the whole monitor expression will return the value fo $e$, otherwise if it evaluates to $\Kw{imm}\,\Kw{false}$, the monitor expression is an $\error$, and evaluation will proceed with to nearest enclosing $\Kw{catch}$ block, if any.
	\item Standard try-catch expressions ($\try{e}{e'}$) evaluate $e$, and if successful return its result, otherwise if $e$ is an $\error$, $e'$ will be evaluated and returned.
	This differs from Java's try-catch \emph{statements} as they do not return a value; our expression-based form can be emulated by using
		``\Q/$T$ $x$; try {$x$ = $e$;} catch(Throwable $t$) {$x$ = $e'$;}/'',
		for an appropriate type $T$ and fresh variable names $t$ and $x$, $x$ can then be used in place of the \Q!try!-\Q!catch! expression.
	\IOComm{alternatively, put the \Q!try!-\Q!catch! in a method so you can $\Kw{return}\,e$?}
	%\Q!try {return $e$;} catch(Throwable t) {return $e'$;}!
	During reduction, \Q!try!-\Q!catch! expressions will be annotated as $\trys{\s}{e}{e'}$, where $\s$ is the state of the memory before the body of the \Q!try! block begins execution. This annotation has no effect on the runtime, but is used by the proofs to model strong exception safety: objects in $\s$ are not mutated by the body of the \Q!try!. Note that as mentioned before, this strong limitation is only needed for unchecked exceptions, in particular, invariant failures. Our calculus only models unchecked exceptions/errors, however L42 also supports checked exceptions, and \Q@try-catch@es over them impose no limits on object mutation during the \Q@try@.
\end{itemize}

An $\error$ represents an uncaught invariant failure, i.e. a runtime-injected invariant check that has failed and is not enclosed in a \Q!try! block; this ensures that a \Q!try! block will only contain an $\error$ if there is no inner \Q!try!-\Q!catch! that should catch it instead.

Locations ($l$), annotated tries ($\trys{\s}{e}{e'}$), and monitors $\M{l}{e}{e'}$ are runtime expressions: they are not meant to be written by the programmer, instead they are introduced internally by our reduction rules.

We provide several expression contexts \IOComm{give a citation that describes them}, $\E$, $\EV$, and $\ER$. As is standard, an $\E$ represents an expression with a single \emph{hole} ($\hole$) in place of a sub-expression. We use the notation $\E[e]$ to fill in the hole, i.e. $\E[e]$ returns $\E$ but with the single occurrence of '$\hole$ replaced by $e$.
For example, if $\E = \call{\hole}{m}{}$ then $\E[\new{C}{}]$ = $\call{\new{C}{}}{m}{}$.

An evaluation context, $\EV$, represents the standard left-to-right evaluation order, an $\EV$ is like an $\E$, but all the expression to the left of the hole will be fully evaluated. This is used to model the standard left to right evaluation order: the hole denotes the location of the next expression to be evaluated.

The context $\ER$ instead has a hole in an argument to a \emph{redex} (i.e. an expression that is about to be reduced). Thus $\ER[w]$ represents an expression whose very next reduction step involves the value $w$.


The rest of our grammar is standard and follows Java, except that types ($T$) contain a reference capability ($\mdf$), and fields ($F$) contain a field kind ($\fmdf$).

\subheading{Reference Capability Operations}
We define the following properties of our reference capabilities and field kinds
\begin{itemize}
	\item $\mdf \leq \mdf'$ indicates that a reference of capability $\mdf$ can be be used whenever one of kind $\mdf'$ is expected. This defines a partial order:
	\begin{itemize}
	\item $\mdf \leq \mdf$, for any $\mdf$
	\item $\Kw{imm} \leq \Kw{read}$
	\item $\Kw{mut} \leq \Kw{read}$
	\item $\Kw{capsule} \leq \Kw{mut}$, $\Kw{capsule} \leq \Kw{imm}$, and $\Kw{capsule} \leq \Kw{read}$
	\end{itemize}
	
	\item $\derep{\fmdf}$ denotes the reference capability that a field with kind $\fmdf$ requires when initialised/updated:
	\begin{itemize}
	\item $\derep{\Kw{rep}} = \Kw{capsule}$
	\item $\derep{\fmdf} = \fmdf$, otherwise (in which case $\fmdf$ is also of form $\mdf$)
	\end{itemize}
	
	\item $\mread{\fmdf}{\mdf}$ denotes the reference capability that is returned when accessing a field with kind $\fmdf$, on a receiver with capability $\mdf$:
	\begin{itemize}
	\item $\mread{\fmdf}{\Kw{imm}} = \Kw{imm}$
	\item $\mread{\fmdf}{\Kw{read}} = \Kw{read}$, if $\fmdf \neq \Kw{imm}$
	\item $\mread{\Kw{rep}}{\Kw{capsule}} = \mread{\Kw{rep}}{\Kw{mut}} = \Kw{mut}$
	\item $\mread{\fmdf}{\Kw{capsule}} = \mread{\fmdf}{\Kw{mut}} = \fmdf$, when $\fmdf \neq \Kw{rep}$ (in which case $\fmdf$ is also of form $\mdf$)
	\end{itemize}
\end{itemize}

\IOComm{is this right? Or should a $\mread{\Kw{rep}}{\Kw{capsule}}$ and $\mread{\Kw{mut}}{\Kw{capsule}}$ return $\Kw{capsule}$?}

The $\leq$ notation and $\derep{\fmdf}$ notations are used latter in \ref{s:proof} and \ref{s:typesystem}.

\subheading{Well-Formedness Criteria}
%\subheading{Reduction Rules}
We additionally restrict the grammar with the following well-formedness criteria:
\begin{itemize}
	\item \Q@invariant()@ methods must follow the requirements of Section \ref{s:protocol}, except that for simplicity method calls on \Q!this! are not allowed.\footnote{Such method calls could be inlined or rewritten to take the field values themselves as parameters.}. This means that for every non-interface class $C$, $C.\Kw{invariant} = \method{\Kw{read}}{\Kw{imm}\,\Kw{Bool}}{\Kw{invariant}}{}e$, where $e$ can only use \Q!this! as the receiver o a \Q!imm! or \Q!rep! field access. Formally, this means that if forall $\E$ where $e = \E[\Kw{this}]$, we have:
	\begin{itemize}
		\item $\E = \E'[\hole.f]$, for some $\E'$
		\item $C.f = \field{\fmdf}{\_}{f}$
		\item $\fmdf \in \{\Kw{imm},\Kw{rep}\}$
	\end{itemize}
	
	\item Rep mutators must also follow the requirements in \ref{s:protocol}, except that a \Q!mut! method that reads a \Q!rep! field is \emph{always} considered a rep mutator, even if it only needs to use the field value as \Q!read!\footnote{
		This restriction is merely for simplicity, as you could simply write a getter of form $\method{\Kw{read}}{\Kw{read}\,C}{m}{}{\Kw{this}.f}$, where $C.f = \field{\Kw{rep}}{C}{f}$, and then call the getter on a \Q!mut! \Q!this!.}
		Such methods must must not use \Q!this!, except for the single access to the \Q!rep! field, and they must not have \Q!mut! or \Q!read! parameters, or a \Q!mut! return type.
		Formally, this means that for any $C$, $m$, and $f$, if $C.f = \field{\Kw{rep}{f}$ and $C.m = \method{\Kw{mut}}{\mdf'\,\_}{m}{\drangex{\mdf}{\_\,\_}}{\E[\Kw{this}.f]}$:
	\begin{itemize}
		\item $\Kw{this} \notin \E$
		\item $\drangex[\text{, }]{\mdf}{\!\notin \{\Kw{mut},\Kw{read}\}}$
		\item $\mdf' \neq \Kw{mut}$
	\end{itemize}

	\item We require that the method bodies are type checked against their declared return type, under the assumption that their parameters and receiver have the appropriate type' we also require that they do not contain runtime expressions. Formally, for all $C_0$ and $m$ with 
	$C_0.m = \method{\mdf_0}{T}{m}{\trange{\mdf}{C}{x}}{e}$, we have:
	\begin{itemize}
		\item $\ty[\emptyset][\Kw{this} \mapsto \mdf_0\,C_0, \trange{x}{\!\mapsto \mdf}{C}]{e}{T}$
		\item $e$ contains no $l$, $\M{\_}{\_}{\_}$, or $\trys{\s'}{\_}{\_}$ expressions
	\end{itemize}

	\item We also assume some general sanity requirements:
	every $C$ mentioned in the program or any well typed expression has a single corresponding \Q!class!/\Q!interface! definition; the $C$s in an \Q!implements! are all names of \Q!interface!s; the $C$ in a $\new{C}{\es}$ expression denotes a \Q!class!; the \Q!implements! relationship is acyclic; the fields of a \Q!class! have unique names; 
	methods within a \Q!class!/\Q!interface! (other than \Q!mut! methods in \Q!Cap!) have unique names; and parameters of a method have unique names and are not named \Q!this!.

	\item For simplicity of the type-system and associated proof, we require that every method in the (indirect) super-interfaces of a class be implemented with exactly the same signature, i.e. if we have a $\clazz{C}{\_}{\_}{\Ms}$, and $\iclazz{C'}{\_}{\As}$, where $C'$ is reachable through the \Q!implements! clauses starting from $C$,
	then for all $\amethod{\mdf}{m}{T}{\Ps} \in \As$, there is some $e$ with $\method{\mdf}{m}{T}{\Ps}{e} \in \Ms$.
\end{itemize}

\subheading{Reduction Rules}
\newcommand{\rowSpace}{\\\vspace{2.5ex}}
\begin{figure}
	\!\!$\!\!\!\!\!\begin{array}{l}\smash{
		\rrule{new}
		{\s}{\new{C}{\range{\_\,v}}}
		{\s,l\mapsto C\{\range{v}\}}{\M{l}{\Kw{mut}\,l}{\invariant{l}}}}

	\\\rowSpace\smash{
		\rrule{access}
		{\s}{\mdf\,l.f}
		{\s}{\mread{\fmdf}{\mdf}\,\s[l.f]}}
		\text{, where }\C{l}.f = \field{\fmdf}{\_}{f}}

	\rowSpace\smash{
		\rrule{update}
		{\s}{\_\,l.f\equals{}\_\,v}
		{\s[l.f=v]}{\M{l}{\Kw{mut}\,l}{\invariant{l}}}}

	\\[0ex]\smash{
		\rrule{call}
		{\s}{\call{\_\,l}{m}{\range{\_\,v}}}
		{\s}{e'[\Kw{this}\coloneqq\mdf_0\,l,\trange{x}{\!\coloneqq\mdf}{v}]}
		\text{, where:}}
	\\\qquad\begin{array}{l}
		\C{l}.m = \method{\mdf_0}{\_}{m}{\drange{\mdf}{\_\,x}}{e}\\*
		\text{if } \mdf_0 = \Kw{mut}\text{ and }\exists f\text{ such that } \C{l}.f = \field{\Kw{rep}}{\_}{f}\text{ and } e = \E[\Kw{this}\singleDot f],\\*
		\text{then } e' = \M{l}{e}{\invariant{l}},\\*
		\text{otherwise }e' = e
	\end{array}\vspace{-0.5ex} % because otherwise there seems to be too much space between this and promote

	\\\rowSpace\smash{
		\rrule{promote}
		{\s}{\prom{\mdf}{\_\,v}}
		{\s}{\mdf\,v}}

	\\\smash{
		\rrule{try enter}
		{\s}{\try{e}{e'}}
		{\s}{\trys{\s}{e}{e'}}}

	\\\rowSpace\smash{
		\rrule{try ok}
		{\s}{\trys{\s'}{w}{\_}}
		{\s}{w}}
	\quad\smash{
		\rrule{try error}
		{\s}{\trys{\s'}{\error}{e}}
		{\s}{e}}

	\\\smash{
		\rrule{monitor exit}
		{\s}{\M{l}{w}{\Kw{imm}\,\Kw{true}}}
		{\s}{w}}
	%\vspace{-2.5ex}
	\end{array}$
\caption{Reduction rules}\label{f:reductions}
\end{figure}

Our reduction rules are defined in Figure \ref{f:reductions}.
\IOComm{Note: I've decided to try and not make substiutition behave specially for promote expressions as it breaks part of the invariant protocol proof}
The rules use $\EV$ to ensure that the sub-expression to be reduced is the left-most unevaluated one:
\begin{itemize}
\item \textsc{new} creates a new object, and returns a monitor expression that will check the new object's invariant, and if that succeeds, return a \Q!mut! reference to the object. Note the use of $\s,l \mapsto C\{\_\}$ implies that $l \notin \dom(\s)$, since $\s,l\mapsto C\{\_\}$ would be undefined otherwise.

\item \textsc{access} looks up the value of a field in the memory and returns it, annotated with the appropriate reference capability (see above for the definition of $\mread{\fmdf}{\mdf}$).
\item \textsc{update} updates the value of a field, returning a monitor that re-checks the invariant of the receiver, and if successful, will return the receiver of the update as \Q!mut!. Note that this does \emph{not} check that the receiver of a the field update has an appropriate reference capability, it is the responsibility of the type-system to ensure that this rule is only applied to a \Q!mut! or \Q!capsule! receiver. For soundness, we return a \Q!mut! reference even when the receiver is \Q!capsule!, promotion can then be used to convert the result to a \Q!capsule!, provided the new field value is appropriately encapsulated.
\item \textsc{call} looks for a corresponding method definition in the receiver's class, and reduces to its body with parameters appropriately substituted. The parameters are substituted with the reference capabilities of the method's signature, not the capabilities at the call-site, this is used by the proofs to show that further reductions will respect the capabilities in the method signature.
In the case of a rep mutator (a \Q!mut! method that accesses a \Q!rep! field), the method body is wrapped in a monitor expression that will re-check the invariant of the receiver once the body of the method has finished reducing.
Note that as \Q!Cap! can have multiple definitions of the same method, this reduction rule allows for non-determinism, but only if the receiver is of class \Q!Cap! and the method is a \Q!mut! method.

\item \textsc{promote} simply changes the reference capability to the one indicated. Note that our requirements on the type-system, given in \ref{s:proof}, ensure that inappropriate promotions (e.g. \Q!imm! to \Q!mut!) will be ill-typed.

\item \textsc{try enter} will annotate a \Q!try!-\Q!catch! with the current memory state, before any reduction occurs within the \Q!try! part. In \ref{s:proof}, we require the type system to ensure strogn exception safety: that the objects in the saved $\s$ are never modified. Note that the grammar for $\EV$ prevents the body of an \emph{unannotated} \Q!try! block from being reduced, thus ensuring that this rule is applied first.

\item \textsc{try ok} simply returns the body of a \Q!try! block once it has successfully reduced to a value. \textsc{try error} on the other hand reduces to the body of the \Q!catch! block if its \Q!try! block is an $\error$ (an invariant failure that is \emph{not} enclosed by an inner \Q!try! block). Note that the grammar for $\EV$ prevents the body of a \Q!catch! block from being reduced, instead \textsc{try error} must be applied first;this ensures that the body of a \Q!catch! is only reduced if the \Q!try! part has reduced to an $\error$.

\item \textsc{monitor exit} reduces a successful invariant check to the body of the monitor. If the invariant check on the other hand has failed, i.e. has returned $\Kw{imm}\,\Kw{false}$, it will be an $\error$, and \textsc{try error} will proceed to the nearest enclosing $\Kw{catch}$ block.
\end{itemize}

Note that as with most OO languages, an expression $e$ can always be reduced, unless: $e$ is already a value, $e$ contains an uncaught invariant failure, or $e$ attempts to perform an ill-defined operation (e.g. calling a method that doesn't exist). The latter case can be prevented by any standard sound OO typesystem, in particular, our proofs say nothing about such ill-defined operations.
However, invalid use of reference capabilities (e.g. having both an \Q!imm! and \Q!mut! reference to the same location) does \emph{not} cause reduction to get stuck, instead, in \ref{s:proof} we explicitly require that the typesystem prevents such things from happening, which our example type system in \ref{s:typesytem} proves to be the case.

Note that the monitor expressions are only a proof device, they need not be implemented directly as presented.
For example, in L42 we implement them by statically injecting calls to \Q!invariant()! at the end of setters (for \Q@imm@ and \Q@rep@ fields), factory methods, and capsule mutators; this works as L42 follows the uniform access principle, so it does not have primitive expression forms for field updates and constructors, rather they are uniformly represented as method calls.

\subheading{Statement of Soundness}
We define a deterministic reduction arrow to mean that exactly one reduction is possible:\\*
\indent$\ \s|e \Rightarrow \s'|e'$ iff $\{\s'|e'\}=\{\s''|e'' \text{, where } \s|e \rightarrow \s'|e'\}$

\noindent We say that an object is \valid when calling its \Q@invariant()@ method would
deterministically produce $\Kw{imm}\,\Kw{true}$ in a finite number of steps, i.e. assuming the typesystem is sound, this means it does not evaluate to $\Kw{imm}\,Kw{false}$, fail to terminate, or produce an \error.
We also require that evaluating \Q@invariant()@ preserves existing memory, however new objects can be freely created and mutated:

\indent$\valid(\s,l)$ iff $\s | \invariant{l} \Rightarrow^+ \s,\s' | \Kw{imm}\,\Kw{true}$.%\loseSpace

\noindent
To allow the \Q!invariant()! method to be called on an invalid object, and access fields on such an objects, we define the set of trusted execution steps as the call to \Q@invariant()@ itself, and any field accesses inside its evaluation:

%\loseSpace
\indent $\trusted(\ER, l)$ iff, either:
\begin{iitemize}
\item $\ER=\EV[\M{l}{\_}{\call{\hole}{\Kw{invariant}}{}}]$, or
\item $\ER=\EV[\M{l}{\_}{\EV'[\hole\singleDot f]}]$.
\end{iitemize}

The idea being that the $\ER$ is like an $\EV$ but it has a hole where a reference can be, thus $\trusted(\ER, l)$ holds when the very next reduction we are about to perform is $\call{\mdf\,l}{\Kw{invariant}}{}$ or $\mdf\,l\singleDot f$.
As we discuss in our proof of $\thm{Soundness}$, any such $\mdf\,l\singleDot f$ expression came from the body of the \Q!invariant()! method itself, since $l$ can not occur in the $\rog$ of any of its fields mentioned in the \Q!invariant()! method.\footnote{Invariants only see \Q@imm@ and \Q@rep@ fields (as \Q@read@), neither of which can alias the current object.}

We define a \VS as one that was obtained by any number of reductions from a well typed initial main expression and memory:\\
\indent $\VS(\s, e)$ iff $c\mapsto\Kw{Cap}\{\}|e_0\rightarrow^* \s|e$, for some $e_0$ such that:
\begin{iitemize}
\item $\tyr[c\mapsto\Kw{Cap}\{\}]{e_0}{T}$, for some $T$
\item $e_0$ contains no $\M{\_}{\_}{\_}$, $\trys{\s'}{\_}{\_}$, or $\prom{\mdf}{\_}$ expressions
\item $\forall\mdf\,l \in e_0$, $\mdf\,l = \Kw{mut}\,c$.
\end{iitemize}
By restricting which initial expressions are well-typed, the type-system (such as the one presented in \ref{s:typesystem}) can ensure the required properties of our reference-capabilities (see \ref{s:proof}); any standard OO type system can also be used to reject expressions that might try to perform an ill-defined reduction (like reading a field that does not exist).

The initial expression cannot contain any runtime expressions, except for \Q!mut! references to the single pre-existing \Q!Cap! object.
To make the type system and proofs presented in \ref{s:typesystem} simpler, we require that $c$ can only be referenced as \Q!mut! and that there are no promote expressions. This restriction does not effect expressivity, as you can pass $c$ to a method whose parameters have the desired reference capability, and whose body contains the desired promote expressions.
%\loseSpace

Finally, we define what it means to soundly enforce our invariant protocol:
\SS\begin{restatable}[Soundness]{theorem}{THMSoundness} %Creates a \THMSoundness macro that restates the theorem with the correct number
If $\VS(\s, \ER[\_\,l])$, then either $\valid(\s,l)$ or $\trusted(\ER,l)$.
\end{restatable}
%Every object referenced by any untrusted redex, within a \VS, is valid.
Except for the injected invariant checks (and fields they directly access),
any redex in the execution of a well typed program takes as input only valid objects.
In particular, no method call (other than \emph{injected} invariant checks themselves) can see an object which is being checked for validity.

This is a very strong statement because $\valid(\s,l)$ requires
the invariant of $l$ to deterministically terminate.
Our setting does ensure termination of the invariant of any $l$ that is now within a redex (as opposed to an $l$ that is on the heap, or is being monitored).
This works because non terminating \Q@invariant()@ methods would cause the monitor expression to never terminate. Thus, an
$l$ with a non terminating \Q@invariant()@ is never involved in an untrusted redex.
Thus works as invariants are deterministic computations that depend only on the state reachable from $l$.
In particular, if $l$ is in a redex, a monitor expression must have terminated after the object instantiation
and after any updates to the state of $l$.

%We believe this property captures very precisely our statements in section~\ref{s:protocol}.

\lstset{language=FortyThree} % Back to default