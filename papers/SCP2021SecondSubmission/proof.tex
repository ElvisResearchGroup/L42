\section{Invariant Protocol Proof and Type System Requirements}
\IOComm{
VERIFY substitution properties with mcall;
explain how requirements restrict valid promotions;
REMOVE ctxv reduction rule;
use RRULE macro and make sure the rules are as identical as reasonable with formalism part
}

\lstset{language=FortyFour} % Make all code bold
\label{s:proof}
As previously discussed, we provide a set of requirements that the type system needs to ensure, and then present such a type system in \ref{s:typesystem}, in this way the soundness of our invariant protocol is paramateric over the conrete typesystem.
We will express such requirements using type judgements of the standard form $\ty{e}{T}$.

\subheading{Auxiliary Definitions}

\IOComm{define \rog}
To express our type system assumptions, we first need some auxiliary definitions. We define what it means for an $l$ to be \reach from an expression or context:\\
\indent $\reach(\s, e, l)$ iff $\exists l' \in e$ such that $l \in \rog(\s, l')$,\\
\indent $\reach(\s, \E, l)$ iff $\exists l' \in \E$ such that $l \in \rog(\s, l')$.

\noindent We now define what it means for an object to be \immut: it is in the \rog of an \Q!imm! reference or a \reach \Q!imm! field:\\*
\indent $\immut(\s, e, l)$ iff $\exists \E, l'$ such that:
\begin{iitemize}
\item $\Kw{imm}\,l' \in e$, and $l \in \rog(\s, l')$, or
\item $\reach(\s, e, l')$, $\exists f$ such that $\C{l'}.f = \field{\Kw{imm}}{\_}{f}$, and $l \in \rog(\s, \s[l'.f])$.
\end{iitemize}

\noindent We define the \mrog of an $l$ to be the locations reachable from $l$ by traversing through any number of \Q!mut! and \Q!rep! fields:\\
\indent $l' \in \mrog(\s, l)$ iff:%
\begin{iitemize}
	\item $l' = l$; or
	\item $\exists f$ such that $\C{l}.f = \field{\fmdf}{\_}{f}$, $\fmdf \in \{\Kw{mut},\Kw{rep}\}$, and $l' \in \mrog(\s, \s[l.f])$
\end{iitemize}

\noindent Now we can define what it means for an $l$ to be \muty\footnote{We use the term \muty and not `\emph{mutable}' as an object might be neither \muty nor im\emph{mutable}, e.g. if there are only \Q!read! references to it.} by an expression $e$: something in $l$ is reachable from a \Q!mut! reference in $e$, by passing through any number of \Q!mut! or \Q!rep! fields:\\
\indent $\muty(\s, e, l)$ iff $\exists l', l''$ such that:
\begin{iitemize}
	\item $l' \in \rog(\s,l)$
	\item $\mdf\,l'' \in e$ with $\mdf \in \{\Kw{mut}, \Kw{capsule}\}$, and
	\item $l' \in \mrog(\s,l'')$.
\end{iitemize}

\noindent Finally, we model the \encap property of \Q!capsule! references:\\
\indent $\encap(\s, \E, l)$ iff $\forall l' \in \rog(\s, l)$, if $\muty(\s, \E[\Kw{capsule}\,l], l')$, then
not $\reach(\s, \E, l')$.

That is, a location $l$ found in a context $\E$ is encapsulated if all $\muty$ objects in its $\rog$ would be unreachable with that single use of $l$ removed.
That single use of $l$ is the connection preventing those $\muty$ objects from being garbage collectable.

\subheading{Type System Requirements}
%Here we assume a slight variation of the usual \thm{Subject Reduction}\cite{pierce2002types}: a (sub) expression obtained using any number of reductions, from a well-typed and well-formed initial $\s_0|e_0$, is also well-typed:
%\SS\begin{Requirement}[Subject Reduction]
%	If $\VS(\s, \E[e])$, then $\WT{e}$.
%\end{Requirement}
%We do not explicitly invoke this requirement, rather it allows us to use any of the other type-system requirements on any sub-expression we obtained from a $\VS$.

As we do not have a concrete type system, we need to assume some properties about the expressions it accepts.
First we require that the values in the field initilisers of \Q!new! expressions, the RHS of an update expression, the receiver, and paramaters of a method call, and the result of a method have the appropriate reference capabilites.
\SS\begin{Requirement}[Type Consistency]\
\begin{ienumerate}
	\item If $\VS(\E[\new{C}{\drange{\mdf}{v}}])$ then:
	\begin{itemize}
		\item $C.(n + 1)$ is undefined,
		\item $C.1 = \field{\fmdf}{\_}{\_}$, \ldots, $C.n = \field{\fmdf}{\_}{\_}$, and
		\item $\drange[\text{, }]{\mdf}{\!\leq \derep{\fmdf}}$.
	\end{itemize}

	\item If $\VS(\E[\_\,l\singleDot f \equals \mdf\,v])$, then:
	\begin{itemize}
		\item $\C{l}.f = \field{\fmdf}{\_}{f}$, and
		\item $\mdf \leq \derep{\fmdf}$.
	\end{itemize}

	\item If $\VS(\E[\call{\mdf_0\,l}{m}{\drange{\mdf}{v}}])$, then:
	\begin{itemize}
		\item $\C{l}.m = \method{\mdf'_0}{\mdf''_1\,\_}{m}{\drangex{\mdf'}{\_\,\_}}{\_}$, with
		\item $\drange[\text{, }]{\mdf}{\!\leq\mdf'}$, and
		\item if $\s|\call{\mdf_0\,l}{m}{\drange{\mdf}{v}} \rightarrow^* \s'|\mdf''_2\,v'$, then $\mdf''_2 \leq \mdf''_1$.
	\end{itemize}
\end{ienumerate}
\end{Requirement}%

\noindent Now we define formal properties about our RCs, thus giving them meaning. First we require that
an \immut object can not also be \muty: i.e. an object reachable from an \Q!imm! reference/field cannot also be reached from a \Q!mut!/\Q!capsule! reference and through \Q!mut!/\Q!rep! fields:%
\SS\begin{Requirement}[Imm Consistency]\ \\
\indent If $\VS(\s, e)$ and $\immut(\s, e, l)$, then not $\muty(\s, e, l)$.
\end{Requirement}
\noindent Note that this does not prevent \emph{promotion} from a \Q!mut! to an \Q!imm!: reduction of a \Q!promote! expression may change the modifiers of an $l$ from \Q!mut! to \Q!imm!, provided that in the new state there are no longer any \Q!mut! references to the $\rog$ of $l$.

We require that if something was not \muty, that it remains that way; this prevents, for example, \Q!promote! expressions from \Q!read! to \Q!mut!, as well as field accesses returning a \Q!mut! from a receiver that was not \Q!mut!:%
\SS\begin{Requirement}[Mut Consistency] If $\VS(\s, \EV[e])$, \\
\indent not $\muty(\s, e, l)$, and $\s|\EV[e] \rightarrow^{+} \s'|\EV[e']$, then not $\muty(\s', e', l)$.
\end{Requirement}

\vspace{2pt} % Without this, the next line clashes with a footnote
\noindent We require that a \Q!capsule! reference be \encap:%
\SS\begin{Requirement}[Capsule Consistency]\ \\
\indent If $\VS(\s,\E[\Kw{capsule}\,l])$, then $\encap(\s, \E, l)$.
\end{Requirement}%
Note that the type-system's idea of ``capsuleness'' may in fact be stronger then \encap, but \encap is sufficient for our invariant protocol.

\noindent We require that field updates only be performed on \Q!mut!/\Q!capsule! receivers:%
\SS\begin{Requirement}[Mut Update] If $\VS(\E[\mdf\_.\_ \equals \_])$, then $\mdf \leq \Kw{mut}$.
\end{Requirement}

\subheading{Strong Exception Safety}
Finally we assume strong exception safety: the memory preserved by each \Q@try@--\Q@catch@ execution is not \muty within the \Q!try!:%
\SS\begin{Requirement}[Strong Exception Safety]
If $\VS(\s', \E[\trys{\s}{e}{\_}])$, then\\
\indent $\forall l \in \dom(\s)$, not $\muty(\s', e, l)$.
\end{Requirement}
As a corollary of this and \thm{Mut Update}, we have that $\s' = \s,\_$, i.e. $\s'$ is the same as $\s$, except it may have newly created objects.
Note that this \emph{only} needs to hold because our \Q@try@--\Q@catch@ can catch invariant failures: in L42, \Q@try@--\Q@catch@'s that catch \emph{checked} exceptions do not need this restriction.

We use strong exception safety to prove that locations preserved by \Q@try@ blocks are never monitored (this is important as it means that a \Q!catch! that catches a monitor failure will not be able to see the responsible object),%
\SS\begin{Lemma}[Unmonitored Try]
	%If $\VS(\s, e)$, then $\forall \E$, $e = \E[\trys{\s_0}{\E'[\M{l}{\_}{\_}]}{\_}]$ implies $l\notin\s_0$
	If $\VS(\s, e)$ and $e = \E[\trys{\s_0}{\E'[\M{l}{\_}{\_}]}{\_}]$, then $l \notin \s$
\end{Lemma}\SS
\begin{proof}
By $\VS$ we have $c\mapsto\Kw{Cap}\{\}|e_0\rightarrow^+ \s|e$, so we proceed by induction on the number of ``$\rightarrow$''s: in the base case, $e = e_0$ and so it cannot contain a monitor expression by the definition of \VS. If this property holds for $\VS(\s, e)$ but not for $\s'|e'$ with $\s|e\rightarrow \s'|e'$, we must have applied the \textsc{new}, \textsc{update}, or \textsc{call} rules; since no other reduction steps introduce a monitor expression. If the reduction was a \textsc{new}, $l$ will be fresh, so it could not have been in $\s_0$. If the reduction was an \textsc{update}, by \thm{Mut Update}, $\Kw{mut}\,l \in e$, similarly (by our well-formedness rules on method bodies) \textsc{call} will only introduce a monitor over a call to a \Q!mut! method, so by \thm{Type Consistency}, $\Kw{mut}\,l \in e$; either way we have that $l$ was \muty, since our reductions never change the $\s_0$ annotation, by \thm{Strong Exception Safety}, we have that $l \notin \s_0$.
\end{proof}

\subheading{Determinism}
We can use our object capability discipline (described in Section \ref{s:formalism}) to prove that the \Q!invariant()! method is deterministic and does not mutate existing memory:%
\SS\begin{Lemma}[Determinism] If $\VS(\s, \EV[\invariant{l}])$ and
\begin{iitemize}
\item[] $\s|\EV[\invariant{l}] \rightarrow \s'|\EV[e'] \rightarrow^{+} \s''|\EV[e'']$,
\end{iitemize}

\indent then $\s'' = \s,\_$, $\s|\EV[\invariant{l}] \Rightarrow^+ \s''|\EV[e'']$, and $\forall l' \in \dom(\s)$, not $\muty(\s'', e'', l')$.
\end{Lemma}\SS
\begin{proof}
To prove this, we will use induction on the number of ``$\rightarrow$''s, and additionally prove that $\forall l' \in \dom(\s)$, not $\muty(\s', e', l')$, i.e. no part of the original $\s$ will become $\muty$ from the body of the call $\invariant{l}$.

\emph{Base case}: If $\s|\EV[\invariant{l}] \rightarrow \s'|\EV[e']$, then the reduction was performed by \textsc{call}.
By our well-formedness rules, the \Q!invariant()! method takes a \Q!read! \Q!this!, so by our \textsc{call} reduction rule we have that $l$ is not \muty in $e'$ (since any $\mdf\,l\in e'$ will have $\mdf = \Kw{read}$). By our well-formedness rules on method bodies and \textsc{call}, we have that no other $l'$ was introduced in $e'$, thus nothing is $\muty$ in $e'$.

The only non-deterministic single reduction steps are for calls to \Q!mut! methods on a \Q!Cap!; however \Q!invariant()! is a \Q!read! method, so even if $l$ = $c$, we have $\s|\EV[\invariant{l}] \Rightarrow \s'|\EV[e']$. Since \textsc{call} does not mutate $\s'$, we also have $\s' = \s$.
Additionally, since $l'$ is the only location mentioned in the expression $\invariant{l}$ and it is not $\muty$, we additionally have $\forall l' \in \dom(\s)$, not $\muty(\s', e', l')$.

\emph{Inductive case}: We inductively assume that $\s|\EV[\invariant{l}] \Rightarrow^+ \s'|\EV[e'] \rightarrow \s''|\EV[e'']$, $\s' = \s,\_$, and $\forall l' \in \dom(\s)$, not $\muty(\s', e', l')$. Thus by \thm{Mut Consistency}, we have that each such $l' \in \dom(\s)$ is not \muty in $e''$. Since nothing in $\s$ was \muty: by \thm{Mut Update}, our reduction can't have modified anything in \s, i.e. $\s'' = \s',\_ = \s,\_$. As our reduction rules never remove things from memory, $c \in \dom(\s)$, so it can't be $\muty$ in $e'$. By definition of \Q!Cap!, no other instances of \Q!Cap! exist, thus by \thm{Type Consistency}, no \Q!mut! methods of \Q!Cap! can be called; since calling such a method is the only way to get a non-deterministic reduction, we have $\s'|\EV[e'] \Rightarrow \s''|\EV[e'']$.
\end{proof}

%Thanks to how our reduction rules are designed, especially \textsc{try error},
%@Progress will need to rely on @StrongExceptionSafety internally.

\subheading{Rep Field Soundness}
Now we define and prove important properties about our novel \Q!rep! fields. We first start with a few core auxiliary definitions. We define a notation to easily get the \Q!rep! field declarations for an $l$:\\
\indent $f \in \rf(\s, l)$ iff $\C{l}.f = \field{\Kw{rep}}{\_}{f}$.

\noindent An $l$ is \RNC if it is not reachable from its \Q!rep! fields:\\
\indent $\RNC(\s, l)$ iff $\forall f \in \rf(\s, l)$, $l \notin \rog(\s, \s[l.f])$.

\noindent We say that an $l$ is \ENR if none of its \Q!rep! fields is \muty without passing through $l$:\\
\indent $\ENR(\s, e, l)$ iff $\forall f \in \rf(\s, l)$, not $\muty(\s\setminus l, e, \s[l.f])$.

\noindent We say that an $l$ is \NRM if we aren't in a monitor for $l$ which must have been introduced by \textsc{call}, and we don't access any of its \Q!rep! fields as \Q!mut!:\\
\indent $\NRM(\s, e, l)$ iff $\forall \E$:
\begin{iitemize}
\item if $e = \E[\M{l}{e'}{\_}]$, then $e' = \Kw{mut}\,l$, and
\item if $e = \E[\mdf\,l.f]$, $f \in \rf(\s, l)$, and $\mdf\neq\Kw{mut}$.
\end{iitemize}

\noindent Finally we say that $l$ is \HNO if we are in a monitor introduced for a call to a rep mutator, and $l$ is not reachable from inside this monitor, except perhaps through a single \Q!rep! field access.\\
\indent $\HNO(\s, e, l)$ iff $e = \EV[\M{l}{e'}{\_}]$, and either:
\begin{iitemize}
\item $e' = \E[\mdf\,l.f]$, $f \in \rf(\s, l)$, and not $\reach(\s, \E, l)$ or
\item not $\reach(\s, e', l)$.
\end{iitemize}

\noindent Now we formally state the core properties of our \Q!rep! fields (informally described in Section \ref{s:protocol}):%
\SS\begin{theorem}[Rep Field Soundness]
If $\VS(\s, e)$ then $\forall l$, if $\reach(\s, e, l)$, then:\\
\indent $\RNC(\s, l)$ and either:
\begin{iitemize}
\item $\ENR(\s, e, l)$ and $\NRM(\s, e, l)$, or
\item $\HNO(\s, e, l)$.
\end{iitemize}
\end{theorem}\SS
\begin{proof}
By $\VS$ we have $c\mapsto\Kw{Cap}\{\}|e_0\rightarrow^+ \s|e$, so we proceed by induction on the number of ``$\rightarrow$''s. The base case is trivial, since \Q!Cap! has no \Q!rep! fields and the initial main expression $e_0$ cannot contain monitors.

In the inductive case, we assume our theorem holds for a $\VS$ and \reach $l$, and prove it for the next $\VS$. We then proceed by cases on the non-\textsc{ctxv} reduction rule applied:
\IOComm{make this non-ctxv thing more explicit}

% \RNC: No other reduction rule modifies memory, so they trivially preserve \RNC for all $l$s.
% \HNO: No other rules remove monitors or field accesses, or make something \reach that wasn't before; thus they preserve \HNO for all $l$s.
% \NRM: Since no other rule can introduce a monitor expression over an $e \neq l$, nor introduce field access, by \thm{Mut Consistency} and \thm{Mut Access}, we can't have broken \NRM for any $l$.
% \ENR: Since none of the other reduction rules modify memory, by \thm{Mut Consistency}, they can't violate \ENR.
\begin{ienumerate}

\item (\textsc{new}) $\s|\EV[\new{C}{\drange{\mdf}{v}}]\rightarrow \s'| \EV[\M{l}{\Kw{mut}\,l}{\invariant{l}}]$, where $\s' = \s,l\mapsto C\{\range{v}\}$:
\begin{enumerate}
	\item Since the pre-existing \s was not modified, by \VS, $l \notin \rog(\s, v_i) = \rog(\s', \s'[l.f])$; thus \RNC holds for $l$. In addition, since this reduction didn't modify the fields of any pre-existing $l'$, by the inductive hypothesis, we have \RNC for $l$ and each such $l'$.
	\item Consider any $l'$ in $\dom(\s')$:
	\begin{itemize}
		\item Suppose $l' \neq l$ and was \ENR and \NRM. Suppose we have made it so that it is no longer \ENR, then we must have made some $f' \in \rf(\s, l')$ \muty. Since the \rog of $l'$ can't have been modified, nor could the \rog of any other pre-existing $l''$, Since we didn't modify the \rog of $l'$ nor the \rog of any other pre-existing $l''$, 	we must have that $\s[l'.f']$ is now \muty through some $l.f$. This requires that $v_i$ is an initialiser for a \Q!mut! or \Q!rep! field, which by \thm{Type Consistency} means that $\mdf_i \leq \Kw{mut}$. But then the $\s[l'.f']$ was already \muty through $\mdf_i\,v_i$, so $l'$ can't have already been \ENR, a contradiction.
		\item We can't have broken \NRM either since we haven't introduced any monitor expressions or field accesses, nor modified any existing ones.
		\item Now suppose $l' = l$ and consider each $i$ with $C.i = \field{\Kw{rep}}{\_}{f}$. By \thm{Type Consistency} and \thm{Capsule Consistency}, $v_i$ was \encap and $\rog(\s, v_i)$ is not \muty from \EV, and so we don't have $\muty(\s'\setminus l, \EV[\M{l}{\Kw{mut}\,l}{\invariant{l}}], v_i)$; thus \ENR holds for $l$ and each of its \Q!rep! fields.
		\item We trivially have that $l$ is \NRM since $l$ was fresh, there can't be any monitor expressions or field accesses for it in $\EV$.
	\end{itemize}
	\item By the inductive hypothesis, any other pre-existing $l'$ must be \HNO, but we haven't removed any monitor expression or field-accesses (because the arguments to the constructor are all of form $\mdf\,v$), in addition, we haven't made any pre-existing object \reach (everything reachable through $l$ was already reachable through some $v_i$ anyway). Thus each such $l'$ is still \HNO.
\end{enumerate}

\item (\textsc{access}) $\s|\EV[\mdf\,l.f]\rightarrow \s|\EV[\mread{\fmdf}{\mdf}\,\s[l.f]]$, where $\C{l}.f = \field{\fmdf}{C}{f}$:
\begin{enumerate}
	\item As this rule doesn't mutate memory, by the inductive hypothesis, every $l'$ must be \RNC.
	\item Consider any $l'$ that was \ENR and \NRM:
	\begin{itemize}
		\item Suppose $l' = l$ and $\fmdf = \Kw{rep}$, either $\mread{\fmdf}{\mdf} \neq \Kw{mut}$ or $\mdf = \Kw{capsule}$. If $\mdf = \Kw{capsule}$, then by \thm{Capsule Consistency} and \RNC, $l$ is not \reach from $\EV[\mread{\fmdf}{\mdf}\,\s[l.f]]$, so it is irrelevant if $l$ is no longer \ENR. Otherwise, if $\mdf \neq \Kw{capsule}$, $\mread{\fmdf}{\mdf} \neq \Kw{mut}$, so \ENR is preserved for $l$.
		\item Since this reduction doesn't modify memory, and $\mread{\fmdf}{\mdf} \leq \Kw{mut}$ only if $\mdf \leq \Kw{mut}$, we can't have made the \rog of any other \Q!rep! field $f'$ of any $l'$ \muty without going through $l'$, so \ENR is preserved.
		\item As in the above \textsc{new} case, \NRM is preserved as we haven't introduced any monitor expressions or field accesses.
	\end{itemize}
	\item Consider any $l'$ that was not \ENR and \NRM, then by the inductive hypothesis it was \HNO and:
	\begin{itemize}
		\item If $l' = l$, then $\EV = \EV'[\M{l}{\E[\mdf\,l.f]}{\_}]$, with $l$ not \reach from $\E$, and $\fmdf = \Kw{rep}$. By \RNC, $l$ is not in the \rog of $\s[l.f]$, and so $l$ is not \reach from $\E[\mread{\fmdf}{\mdf}\,\s[l.f]]$, and so it is still \HNO.
		\item If $l' \neq l$, it is still \HNO l is as this reduction dosen't make anything \reach that wasn't already \reach through $l$ or $\EV$.
	\end{itemize}
\end{enumerate}

\item (\textsc{update}) $\s|\EV[\mdf\,l.f\equals{}\mdf'\,v]\rightarrow \s[l.f=v]|\EV[\M{l}{\Kw{mut}\,l}{\invariant{l}}]$:
\begin{enumerate}
	\item By the inductive hypothesis we have that \RNC holds for $l$. If $f \in \rf(\s, l)$, by \thm{Mut Update}, we have that $l$ is \muty, so by \thm{Type Consistency} and \thm{Capsule Consistency}, $\encap(\s, \EV[\mdf\,l.f = \hole], v)$, hence $l$ is not \reach from $v$, and so after the update, \RNC still holds for $l$. In addition, if $f \notin \rf(\s, l)$ we obviously must still have \RNC. 	\item Otherwise, by the inductive hypothesis, $l'$ was \HNO, and so $l' \notin \rog(\s, v)$, so we can't have added $l'$ to the \rog of anything, thus \RNC still holds.
	\item By the inductive hypothesis we have that \RNC holds for each $l'$:
	\begin{itemize}
		\item If $f \in \rf(\s, l)$: by \thm{Mut Update}, we have that $l$ is \muty, so by \thm{Type Consistency} and \thm{Capsule Consistency}, $\encap(\s, \EV[\mdf\,l.f = \hole], v)$, hence $l$ is not \reach from $v$, and so after the update, \RNC still holds for $l$.
		\item Now consider any $l'$ and $f' \in \rf(\s, l')$, with $l'.f' \neq l.f$:
		\begin{itemize}
			\item If $l'$ was \ENR, by \thm{Mut Update}, $\mdf = \Kw{mut}$. By \ENR, the \rog of $l'.f'$ is not \muty (except through a field \emph{access} on $l'$), thus we have that $l \notin \rog(\s, \s[l'.f'])$, in addition, since $l'.f' \neq l.f$, we can't have modified the $\rog$ of $l'.f'$, hence $l'$ is still \RNC.
			\item Otherwise, by the inductive hypothesis, $l'$ was \HNO, and so $l' \notin \rog(\s, v)$, so we can't have added $l'$ to the \rog of anything, thus $l'$ is still \RNC.
		\end{itemize}
	\end{itemize}
	\item Consider any $l'$ that was \ENR and \NRM:
	\begin{itemize}
		\item Suppose $l' = l$ and $f \in \rf(\s, l)$. If $v$ is a boolean than clearly we couldn't have broken \ENR. If $v$ is a memory location, then by \thm{Type Consistency} and \thm{Capsule Consistency}, $v$ is \encap, thus $v$ is not \muty from \EV, and $l$ is not \reach from $v$, thus $v$ is still \encap, and so \ENR still holds for $l$ and $f$.
		\item Now consider any $f' \in \rf(\s, l')$, with $l'.f' \neq l.f$; by the above, $l$ is \RNC and so $l \notin \rog(\s, \s[l'.f'])$. If $f$ was a \Q!mut! or \Q!rep! field, by \thm{Type Consistency}, $\mdf' = \Kw{mut}$, so by \ENR, $v \notin \rog(\s, \s[l'.f'])$; thus we can't have made $\rog(\s, \s[l'.f'])$ \muty through $l.f$; so $l'.f'$ can't now be \muty through $\Kw{mut}\,l$. By \thm{Mut Consitency}, we couldn't have have made $l'.f'$ \muty some other way, so $l'$ is still \ENR.
		\item As in the above cases, \NRM is preserved as we haven't introduced any monitor expressions or field accesses.
	\end{itemize}
	\item By the inductive hypothesis, any $l'$ which was not \ENR and \NRM, was \HNO. We haven't removed any monitor expression or field-accesses, nor have we made anything \reach that wasn't before, so each such $l'$ is still \HNO.
\end{enumerate}
\IOComm{for consistency, reorder the next three cases in call, try-error, then monitor-exit?}
\item (\textsc{monitor exit}) $\s|\EV[\M{l}{\mdf\,v}{\Kw{imm}\,\Kw{true}}]\rightarrow \s|\EV[\mdf\,v]$:
\begin{enumerate}
	\item As this rule doesn't mutate memory, by the inductive hypothesis, every $l'$ must be \RNC.
	\item Any $l'$ that was \ENR, still is by \thm{Mut Consistency}, since we haven't modified memory; and as with the above cases, if $l'$ was \NRM it still is, since we haven't introduced any monitor expressions or field accesses.
	\item Now consider any $l'$ that was not \ENR and \NRM, then by the inductive hypothesis it was \HNO:
	\begin{itemize}
		\item If $l' \neq l$, then as with the \textsc{access} case above, we can't have broken \HNO.
		\item Otherwise, suppose $l' = l$. If this monitor was introduced by \textsc{new} or \textsc{update}, then $\mdf\,v = \Kw{mut}\,l$. And so \HNO can't have held for $l$ since $l = v$, and $\mdf\,v$ was not the receiver of a field access.
		\item Thus this monitor must have been introduced by \textsc{call}, due to a call to a rep mutator on $l$. Consider the state $\s_0|\EV[e_0]$ immediately before that \textsc{call}:
		\begin{itemize}
			\item We must not have had that $l$ was \HNO, since $e_0$ would contain $l$ as the receiver of a method call. Thus, by our inductive hypothesis, $l$ was originally \ENR and \NRM.
			\item Because \NRM held in $s_0|\EV[e_0]$, and $\mdf\,v$ contains no field accesses or monitor, it also holds in $\EV[\mdf\,v]$.
			\item Since a rep mutator cannot have any \Q!mut! parameters, by \thm{Type Consistency}, \thm{Mut Consistency}, and \thm{Mut Update}, the body of the method can't have modified $\s_0$: thus $\s = \s_0, \_$. Since no pre-existing memory has changed since the \textsc{call}, and a rep mutator cannot have a \Q!mut! return type, by \thm{Type Consistency}, we must have $\mdf\neq\Kw{mut}$:
			\begin{itemize}
				\item If $\mdf = \Kw{capsule}$, by \thm{Capsule Consistency}, the value of any \Q!rep! field of $l$ can't be in the \rog of $v$ (unless $l$ is no longer \reach), so we haven't made such a field \muty.
				\item Otherwise, $\mdf \in \{\Kw{read}, \Kw{imm}\}$, by \thm{Read Consistency}, \thm{Imm Consistency}, and \thm{Mut Consistency}, we have that $v$ is not \muty. \IOComm{WTF? not \muty in $EV$? Also $v$ could be a boolean and so \muty doesn't make sense, or does it?}
			\end{itemize}
			Either way, the \textsc{monitor exit} reduction has restored $\ENR(\s_0, \EV[e_0], l)$.
		\end{itemize}
	\end{itemize}
\end{enumerate}

\item (\textsc{try error}) $\s|\EV[\trys{\s_0}{\error}{e}] \rightarrow \s|\EV[e]$, where $\error = \EV'[\M{l}{\_}{\_}]$:
\begin{enumerate}
	\item As above, since this rule doesn't mutate memory, by the inductive hypothesis, every $l'$ must still be \RNC.
	\item As above, since we didn't modify memory, or introduce any monitor expressions or field accesses, any $l'$ that was \ENR and \NRM is still \ENR and \NRM.
	\item Consider any $l'$ that was not \ENR and \NRM, by the inductive hypothesis it must have been \HNO:
	\begin{itemize}
		\item If $l' \neq l$. If $l'$ was in $\s_0$, then by \thm{Strong Exception Safety} we haven't modified $\s_0$, and so \HNO is preserved. Otherwise, by \thm{Strong Exception Safety}, $l'$ is no longer \reach, and so this theorem imposes no requirements on it.
		\item If $l' = l$, then by our reduction rules, we were previously in state $\s_0|\EV[\try{e_0}{e}]$. By \thm{Unmonitored Try}, $l \notin \dom(\s_0)$, and so $l$ was not \reach from $\EV[\try{e_0}{e}]$. By \thm{Strong Exception Safety}, we have that nothing in $\s_0$  has changed, so we must still have that $l$ is not \reach from $\EV[e]$: thus its status is irrelevant.
	\end{itemize}
\end{enumerate}

\item (\textsc{call}) $\s|\EV[\call{\mdf\,l}{m}{\drange{\mdf}{v}}]\rightarrow \s|\EV[e]$:
\begin{enumerate}
	\item As above, since this rule doesn't mutate memory, by the inductive hypothesis, every $l'$ must still be \RNC.
	\item Consider any $l'$ that was \ENR and \NRM:
	\begin{itemize}
		\item Suppose $m$ is not a rep mutator, by our well-formedness rules for method bodies, $e$ doesn't contain a monitor.
		\begin{itemize}
			\item Suppose $l' = l$. Since $m$ is not a rep mutator, if $e = \E[\mdf'\,l.f]$, for some $f \in \rf(\s, l)$, we must have that $m$ was not a \Q!mut! method. Since fields are instance-private, we must have $\mdf' \neq \Kw{mut}$, so we can't have broken \NRM for $l$.
			\item Otherwise, $l' \neq l$, and since fields are instance-private, we must have $\mdf'\,l.f \notin e$. As $e$ doesn't contain monitors either, we haven't broken \NRM for $l'$.
		\end{itemize}
		\item Otherwise, $e = \M{l}{e'}{\invariant{l}}$, and suppose $l' = l$. By our rules for rep mutators, $m$ must be a \Q!mut! method with only \Q!imm! and \Q!capsule! parameters, thus by \thm{Type Consistency}, $\mdf \leq \Kw{mut}$, and each $\mdf_i \in \{\Kw{imm},\Kw{capsule}\}$. By \thm{Imm Consistency} and \thm{Capsule Consistency}, $l$ can't be reachable from any $v_i$. Since rep mutators use \Q!this! only once, to access a \Q!rep! field, $e' = \E[\Kw{mut}\,l.f]$, for some $f \in \rf(\s, l)$. Since $l$ is not \reach from any $v_i$, $l \notin \E$, and by our well-formedness rules for method bodies, $l$ is not \reach from any $l' \in \E$, thus \HNO now holds for $l$.
		\item If $l' = l$ then we haven't introduced a monitor expression, and as above, we haven't introduce a field access on it either, we can't have broken \ENR.
		\item Finally, since we didn't modify memory, $l'$ is still \NRM.
	\end{itemize}
	\item As above since we haven't removed any monitor expression or field-accesses, nor have we made anything \reach, by the inductive hypothesis, every other $l'$ is still \HNO.
\end{enumerate}

\item (\textsc{try enter}, \textsc{try ok}, and \textsc{promote}) these are trivial, since as used in the above cases:
\begin{enumerate}
	\item These rules don't mutate memory, thus by the inductive hypothesis, every $l'$ must still be \RNC.
	\item These rules don't modify memory, or introduce any monitor expressions or field accesses, so any $l'$ that was \ENR and \NRM is still \ENR and \NRM.
	\item As these rules don't remove any monitor expression or field-accesses, nor do they make anything \reach, by the inductive hypothesis, every other $l'$ is still \HNO.
\end{enumerate}

\end{ienumerate}
\end{proof}

\subheading{Stronger Soundness}
It is hard to prove \thm{Soundness} directly,
so we first define a stronger property,
called \thm{Stronger Soundness}.

An object is \mony if execution
is currently inside of a monitor for that object, and
the monitored expression $e_1$ does not
contain $l$ as a \emph{proper} sub-expression:

\indent $\mony(e,l)$ iff
$e=\EV[\M{l}{e'}{\_}]$ and either $e'=\_\,l$ or $l \notin e'$.%\loseSpace

\noindent A monitored object is associated with an expression that cannot observe it, but may
reference its internal representation directly.
In this way, we can safely modify its representation before checking its invariant.
The idea is that at the start the object will be valid and $e'$ will reference $l$;
but during reduction, $l$ will be used to
modify the object; only after that moment, the object may become invalid.

\thm{Stronger Soundness} says that starting from a well-typed and well-formed $\s_0|e_0$, and performing any number of reductions, every \reach object is either \valid or \mony:%
\SS\begin{theorem}[Stronger Soundness]
If $\VS(\s, e)$ then $\forall l$, if $\reach(\s, e, l)$ then $\valid(\s, l)$ or $\mony(e, l)$.
\end{theorem}\SS
\begin{proof}
We will prove this inductively on the number of ``$\rightarrow$''s, in a similar way to how we proved \thm{Rep Field Soundness}.
In the base case, we have $\s = c\mapsto\Kw{Cap}\{\}$, since \Q!Cap! is defined to have the trivial invariant, we have that $c$ (the only thing in \s), is \valid.

Now we assume that everything reachable from the previous \VS was \valid or \mony, and proceed by cases on the non-\textsc{ctxv} rule that gets us to the next \VS.
\IOComm{dittot with non-ctxv rule}
\IOComm{Reorder cases: new/update/try-error/monitor exit}
\begin{ienumerate}
	\item (\textsc{update}) $\s|\EV[\mdf\,l.f\equals w]\rightarrow \s'|\EV[e']$, where  $e'=\M{l}{\Kw{mut}\,l}{\invariant{l}}$:
	\begin{itemize}
		\item Clearly $l$ is now $\mony$.
		\item Consider any other $l'$, where $l \in \rog(\s,l')$ and $l'$ was \valid; now suppose we just made $l'$ not \valid. By our well-formedness criteria, \Q@invariant()@ can only accesses \Q@imm@ and \Q@rep@ fields, thus by \thm{Imm Consistency} and \thm{Mut Update}, we must have that $l$ was in the \rog of $l'.f'$, for some $f' \in \rf(\s, l')$. Since $l \neq l'$, $l'$ can't have been \ENR. Thus, by \thm{Rep Field Soundness}, $l'$ was \HNO, and $\EV = \EV'[\M{l'}{\EV''}{\_}]$:
		\begin{itemize}
			\item If $\EV''[\mdf\,l.f \equals w] = \E[\mdf'\,l'.f']$, then by \HNO, $l'$ is not reachable from \E. The monitor must have been introduced by a \textsc{call}, on a rep mutator for $l'$. Since a rep mutator can take only \Q!imm! and \Q!capsule! parameters, by \thm{Type Consistency}, \thm{Imm Consistency}, and \thm{Capsule Consistency}, $l$ cannot be in their \rog{}s (since $l$ was in the \rog of $l'$, and the main expression contained a $\Kw{mut}\,l$). Thus the only way for the body of the monitor to access $l$ is by accessing $l'.f'$.
			Since rep mutators can access \Q!this! only once, and by the proof of \thm{Rep Field Soundness}, there is no other $l'.f'$ in $\E[\mdf'\,l'.f']$, nor was there one in a previous stage of reduction: hence $l$ is not \reach from $\E$. This is in contradiction with us having just updated $l$.
			\item Thus, by \HNO, we must have $\EV''[\mdf\,l.f \equals w] = e$, with $l'$ not \reach from $e$; so $l'$ was, and still is, \mony. \IOComm{TODO: WTF is e???}
		\end{itemize}
		\item Since we don't remove any monitors, we can't have violated \mony. In addition, if an $l$ was not in the \rog of a \valid $l'$, by \thm{Determinism}, $l'$ is still \valid.
	\end{itemize}

	\item (\textsc{monitor exit}) $\s|\EV[\M{l}{w}{\Kw{imm}\,\Kw{true}}]\rightarrow \s|\EV[w]$:
	\begin{itemize}
	\item[] By \VS and our well-formedness requirements on method bodies, the monitor expression must have been introduced by \textsc{update}, \textsc{call}, or \textsc{new}. In each case the third expression started off as $\invariant{l}$, and it has now (eventually) been reduced to $\Kw{imm}\,\Kw{true}$, thus by \thm{Determinism} $l$ is \valid. This rule does not modify pre-existing memory, introduce pre-existing $l$s into the main expression, nor remove monitors on other $l$s, thus every other pre-existing $l'$ is still \valid (due to \thm{Determinism}), or \mony.
	\end{itemize}

		\item (\textsc{new}) $\s|\EV[\new{C}{\range{\_\,v}}]\rightarrow \s,l\mapsto C\{\range{v}\}|\EV[ \M{l}{\Kw{mut}\,l}{\invariant{l}}]$:
		\begin{itemize}
			\item[] Clearly the newly created object, $l$, is \mony. As with the case for \textsc{monitor exit} above, every other \reach $l$ is still \valid or \mony.
		\end{itemize}
			
		\item (\textsc{try error}) $\s|\EV[\trys{\s'}{\error}{e}] \rightarrow \s|\EV[e]$, where $\error = \EV'[\M{l}{\_}{\_}]$:
		\begin{itemize}
			\item[] By the proof of \thm{Rep Field Soundness}, we must have that $l$ is no longer \reach, it is ok that it is now no longer \valid or \mony. As with the case for \textsc{monitor exit} above, every other \reach $l$ is still \valid or \mony.
		\end{itemize}
\end{ienumerate}

\noindent None of the other reduction rules (\textsc{access}, \textsc{call}, \textsc{promote}, \textsc{try enter}, and \textsc{try ok}) modify memory, the memory locations reachable inside of the main expression, or any pre-existing monitor expressions; thus regardless of the reduction performed, we have that each \reach $l$ is \valid or \mony.
\end{proof}

\subheading{Proof of Soundness}
First we need to prove that an object is not reachable from one of its \Q!imm! fields; if it were, \Q!invariant()! could access such a field and observe a potentially broken object:\SS
\begin{Lemma}[Imm Not Circular]\ \\
\indent If $\VS(\s, e)$, $\forall f,l$, if $\reach(\s, e, l)$, $\C{l}.f = \field{\Kw{imm}}{\_}{f}$, then $l \notin \rog(\s, \s[l.f])$.
\end{Lemma}\SS
\begin{proof}
The proof is by induction; obviously the property holds in the initial $\s|e$, since $\s = c\mapsto \Kw{Cap}\{\}$. Now suppose it holds in a $\VS(\s, e)$ and consider $\s|e \rightarrow \s'|e'$.
\begin{ienumerate}
	\item Consider any pre-existing \reach $l$ and $f$ with $\C{l}.f = \field{\Kw{imm}}{\_}{f}$, by \thm{Imm Consistency} and \thm{Mut Update}, the only way $\rog(\s, \s[l.f])$ could have changed is if $e = \EV[\mdf\,l.f = \mdf'v]$, where $\mdf \leq \Kw{mut}$, i.e. we just applied the \textsc{update} rule. By \thm{Type Consistency}, $\mdf' \leq \Kw{imm}$, so by \thm{Imm Consistency}, $l \notin \rog(\s, v)$. Since $v = \s'[l.f]$, we now have $l \notin \rog(\s', \s'[l.f])$.
	\item The only rule that makes an $l$ \reach is \textsc{new}. So consider $e =\EV[\new{C}{\range{\_\,v}}]$, and each $i$ with $C.i = \field{\Kw{imm}}{\_}{f}$. But each of $\range{v}$ existed in the previous state and $l \notin \dom(\s)$; so by \VS and our reduction rules, $l \notin \rog(\s, v_i) = \rog(\s', \s'[l.f])$.
\end{ienumerate}
\end{proof}

Note that the above only applies to \Q!imm! \emph{fields}: \Q!imm! \emph{references} to cyclic objects can be created by promoting a \Q!mut! reference, however the cycle must pass through a \emph{field} declared as \Q!read! or \Q!mut!, but such fields cannot be referenced in the invariant method.

We can now finally prove the soundness of our invariant protocol:
\SS\THMSoundness\SS

\begin{proof}
\noindent Suppose $\VS(\s, e)$, and $e = \ER[\_\,l]$. Suppose $l$ is not $\valid$; since $l$ is \reach, by \thm{Stronger Soundness}, $\mony(e,l)$, $e = \E[\M{l}{e_1}{e_2}]$, and either:
\begin{iitemize}
	\item $\ER = \E[\M{l}{\E'}{e_2}]$, that is $l$ was found inside of $e_1$, but by definition of $\ER$, we can't have $e_1 = l$, this contradicts the definition of \mony, or
	\item $\ER = \E[\M{l}{e_1}{\E'}]$, and thus $l$ was found inside $e_2$. By our reduction rules, all monitor expressions start with $e_2=\invariant{l}$; if this has yet to be reduced, then $\E' = \E''[\call{\hole}{\Kw{invariant}}{}]$, thus $\trusted(\ER, l)$. The next execution step will be a \textsc{call}, so by our well-formedness rules for \Q!invariant()!, $e_2$ will only contain $l$ as the receiver of a field access; so if we just performed said \textsc{call}, $\E' = \E''[\hole.f]$: hence $\trusted(\ER, l)$. Otherwise, by \thm{Imm Not Circular}, \thm{Rep Field Soundness}, and \RNC, no further reductions of $e_2$ could have introduced an occurrence of $l$, so we must have that $l$ was introduced by the \textsc{call} to \Q!invariant()!, and so $\trusted(\ER, l)$.
\end{iitemize}
Thus either $l$ is $\valid$ or $\trusted(\ER, l)$.
\end{proof}

\lstset{language=FortyThree} % Back to default