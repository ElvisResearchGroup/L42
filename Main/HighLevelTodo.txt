Per fare lo wither: 
e' lo stesso che fare valori di default per metodi:
prendi il metodo con tutti i parametri, usa una versione di SumMethod con un metodo
che produce quel valore.
Serve che sum method prenda anche il nome del parametro da rimpiazzare
Lib, Path, meth1 meth2, methRes, nome(contenuto in meth2)?
Dove vanno i parametri di meth1? all'inizio? alla fine? al posto del nome?

syntax stuff:
use use[psMany] for [with..], Done? now support separedBy in strings, make Debug stringable.
make error/exception on Path1... Pathn (e) 
==catch exception fresh (
  on Path1 error/exception (e)(fresh) ...on Pathn error/exception (e)(fresh)
  )
  add # for defaults: logic is
    on addition methods, is a constructor
    on set is the old value
    on stuff in a numericalish range 0..n, is the max range.
make comments with // /**/
make @id == /*@id*/

new desugaring for string and number literals!!
x:e in ps becomes x=e
:: becomes .


'caching is getting out of control
'a save version, operators refresh all the cache?
'still good, many operators do lots of internal stuff?


'@NonNull ast.Ast.Stage stage=Stage.None;//fix point for typing
'final java.util.List<ClassB>dependencies=-//if not empty, just to provide a better error, is sort of connected with stage? check!
'java.util.List<PathMwt> inherited=null;//fix point for interface implementation
'List<InvalidMwtAsState> coherent=-
'String givenName="";
'boolean verified=false;//to avoid re typechecking, should be safe for all operators?
'boolean privateNormalized=false;//to avoid re normalization - if operators remove cache, is not usefull.
'Would it disappear in the new idea? replaced with min-max with -1 default?
'final java.util.List<Integer> families=- //to merge two classes easier with sum, again same problem as before//Would disappear
	
prviati: 
method selector contiene un long int. -1 per non privato
@private non ha semantica nel linguaggio,
una library compilata e' ben formata se tutti i nomi dichiarati con forma a__n sono dichiarati una volta sola al suo interno, e non ridichiara nomi dichiarati fuori. (quindi hiding is ok)
operatori che prendono cose ben formate (in un certo programa)producono cose ben formate (nello stesso programma).
su chiamata di metodo(small step) o su resource.get() on compiled i nomi sono rimpiazzati.

una classB e' normalizata (non solo ben formata) se
ha nomi privati consegutivi e ordinati nei sottoalberi, 
e ogni classB cachia min e max (non solo le normalizzate).
Per efficiacia di implementazione, normalizziamo tutte le librerie del programma iniziale (reused).

all operators except sum and addprivate do not need further attention?
sum a,b if interval disoint, just sum and make union of interval
if not disjoint, normalize both starting from higer number ever committed (different from higher reached).
On commit, set up a new max committed
On add private, just extend the interval by 1 and use such index.

' make multiple normalization not insert multiple %$ stuff
' method Bool isConcrete() true iff all non state methods are implemented and
' all the interface methods are implemented.

'add a printableOutline() to nested class
' all public methods lv1,
' for all public nc lv*, if not annotated '@importanceX with x 1-*, with indented methods
' otherwise with all methods inline, nested after?

'Patch:{'no, remove metaguard entirelly, make methClash and co as 
'nested in Refactor, and specific errors as nested in the operator?
'remove also the general DecorationUnfeasable?
'or on the opposite, have DecorationUnfeasable take a class, and print itself in a fancy way to look like a nested?
'  MetaGuard:{interface
'    DecorationUnfeasable:Message::$[]<<{<:MetaGuard}
'    }
'throws shortcuts: return { return }  exception errorOn/exceptionOn
    ' on Metaguard, Guard error e
    ' exceptionOn Metaguard InvalidAction"YEP"  
' method Bool isConcrete() true iff all non state methods are implemented and
' all the interface methods are implemented.

'add a printableOutline() to nested class
' all public methods lv1,
' for all public nc lv*, if not annotated '@importanceX with x 1-*, with indented methods
' otherwise with all methods inline, nested after?

Obsolete(
  AddDocumentation for private state?
  -constructor must be first?
  -error if you was going to create a incoherent private state.
  -- no seams like addDocumentation must be called on the constructor, and make private all the potential state
  -to prevent capture of unwanted state methods, you can rename or implement them and then revert.
)
Adam Towel
 -adam towel 2 or 3 must:
   -inject ParseErrors in Bool, N
   -inject better error in Message::Opt
  -Message generate Foo"bla" :Foo
  and Foo"bla"(cause) :Foo, Foo(cause) should not work any more
 
  -test introspection more 
  -in deploy library, check that is closed code
  -test if from is applied when reading method types?
    -on literal, it should be frommed before passed to plugin
    -on external?
    -is it coherent that on external is frommed from the specific node, while from internal
    is frommed from the root?
  -we need to reorganize the errors, we need to add the ambigus redirect.
  -make opt have checktrue, ! & and | ? 
  //complex: what should & second parameter be? boolable would prevent optimizations or not?
   -for collections, error S" still report stuff that should be done better.
  -opt and iterator: version generic, version to sum with outer0 and get a nested.
  -method from interfaces? just all interfaces - this will miss from? 
Caching
   -desugaring import library, assume verified//done?
   -how it interact with trusted plugins?
    -is private normalized
    -get the set of used families
    -if runaway abstractness/incoherence causes plus, plus should keep track of why it exists.
       
    
    
    -Sum and interfaces: sum can make interfaces circular. I think I will make this OK
    -sum must give error if sum class implementing interface with class directly defining an 
    interface method of the first one. check this case
    
 Other plugins
    -db plugin
      design of resources: make connection string "is" resource handler?
 
 Composition operators:
   method composition path ms0, ms1
    T0 m0(arg0) eOpt0+ T1 m1(T0 x arg1) eOpt1=
    T0 m0(arg0) eOpt0 T1  m1(T0 x arg1) eOpt1    T1 m0m1(arg0 arg1) this.m1(this.m0(arg0),arg1)  
 
 Language
  - method of interfaces can be refined, method refine T m(xs) eOpt
  -yeld? [with .... yeld(e) or yeld(v, separator:S", ")
  this would allow S"["[with n in names.vals() ( yeld(n,separator:S"; "))]"]"
 Syntax
    -concrete header have doc ('here fs)'and here  -- one of the two must be the place for @private?
    -all implemented interface names have docs, also simpler @ann syntax no new line
    
    -put Outer without number in the sugar,outer keyword, to skip the first in scope
    - put << normalization in the sugar
    -put keywords/behaviour for circular and entangled. ?? no? fwd in constructor solved?
    -use @as default? instead of #?
     so Map[   @[a;b;c];       @[a;b;c];       ]
    options[isVisible:@]   vs  options[isVisible:Bool.true()]
    Car(weels:@[....] doors:@[])
    RenamePath[@"Bar" to:@"Beer"]
    -operators <-  ->   \/ /\ ?? may be not?
    -usually ~ is give me internal, so rename all .binary repr?
Parsing errors:
  variable declare multiple times do not give any info, not even the file
 -'Add that a file can be also a commented class? but then this comment would be lost.
   on the other side, is ok that can not have comments at the start? -just do {' ? 
  

Well formedness
  -well formedness, state must be all private or all public.
  -well formedness, no outer level bigger than max possible.
  -in Type system on T must check that T exists BEFORE checking the expr in the on
  - varName={if ... (return.. ) return ..} now give horrible error if type for varName is omitted.
    is ok to have error, but need a better one
well formedness: implemented or exceptions must be with no repetition, and with no Any.
Operators should preserve this
interfaces can be circular, check that no bug happens
  

------------------
   Check if what is under is done
    -private rename normalization
    collect privates: 
     MethodLocator:{List<Member> mTail; List<Integer> mPos; Ms that, Ms newName}
     NestedLocator:{List<Member> mTail; List<Integer> mPos; String that, String newName}
     collectPrivates(cb)->set of MethodLocator,NestedLocator
     since no sum will be triggered, we can do all the rename together
     collectPrivates(cb) first collect the names, then compute the rename, keeping in account private state consistency
       that is, constructors get the same pedex appended to name AND fields, and field get the same pedex
     renamePrivates(collectPrivates(cb))
       clone with path:
         on nested, if collected rename
         on mwt if collected rename
         on mi nothing, never private
         on path, if collected rename, will need to explore only a "pure nested" part of the tail
         on meth call, same idea. Reuse guess receiver type from rename method.
    reuse of lower case, trust private normalized and desugared.
       replace all the name__N_0 in name__N'_redirectIndex
    normalizePrivates(newIndex) rename all the name__N_K in name__N'_index
    reuse on Uppercase, do desugar and do not do private renaming at all.// just for testing
         
   