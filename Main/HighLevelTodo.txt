Adam Towel
  -test introspection more 
  -we need to reorganize the errors, we need to add the ambigus redirect.
  -make opt have checktrue, ! & and | ? 
  //complex: what should & second parameter be? boolable would prevent optimizations or not?
   -for collections, error S" still report stuff that should be done better.
  -opt and iterator: version generic, version to sum with outer0 and get a nested.
   
Caching
   -desugaring import library, assume verified//done?
   -how it interact with trusted plugins?
    -is private normalized
    -get the set of used families
    -if runaway abstractness/incoherence causes plus, plus should keep track of why it exists.
       
    
    
    -Sum and interfaces: sum can make interfaces circular. I think I will make this OK
    
 Other plugins
    -db plugin
      design of resources: make connection string "is" resource handler?
 
 Syntax
    -put Outer without number in the sugar,outer keyword, to skip the first in scope
    - put << normalization in the sugar
    -put keywords/behaviour for circular and entangled. 
    -put partial, mut partial and so on instead of ^ in parser
    -use @as default? instead of #?
     so Map[   @[a;b;c];       @[a;b;c];       ]
    options[isVisible:@]   vs  options[isVisible:Bool.true()]
    Car(weels:@[....] doors:@[])
    RenamePath[@"Bar" to:@"Beer"]
    -operators <-  ->   \/ /\ ?? may be not?
    -usually ~ is give me internal, so rename all .binary repr?

Well formedness
  -well formedness, state must be all private or all public.
well formedness: implemented or exceptions must be with no repetition, and with no Any.
Operators should preserve this
interfaces can be circular, check that no bug happens
  

------------------
   Check if what is under is done
    -private rename normalization
    collect privates: 
     MethodLocator:{List<Member> mTail; List<Integer> mPos; Ms that, Ms newName}
     NestedLocator:{List<Member> mTail; List<Integer> mPos; String that, String newName}
     collectPrivates(cb)->set of MethodLocator,NestedLocator
     since no sum will be triggered, we can do all the rename together
     collectPrivates(cb) first collect the names, then compute the rename, keeping in account private state consistency
       that is, constructors get the same pedex appended to name AND fields, and field get the same pedex
     renamePrivates(collectPrivates(cb))
       clone with path:
         on nested, if collected rename
         on mwt if collected rename
         on mi nothing, never private
         on path, if collected rename, will need to explore only a "pure nested" part of the tail
         on meth call, same idea. Reuse guess receiver type from rename method.
    reuse of lower case, trust private normalized and desugared.
       replace all the name__N_0 in name__N'_redirectIndex
    normalizePrivates(newIndex) rename all the name__N_K in name__N'_index
    reuse on Uppercase, do desugar and do not do private renaming at all.// just for testing
         
   