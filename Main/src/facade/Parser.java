package facade;

import java.io.FilterOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.io.PrintStream;
import java.lang.reflect.Field;
import java.util.Stack;

import org.antlr.v4.runtime.ANTLRInputStream;
import org.antlr.v4.runtime.BailErrorStrategy;
import org.antlr.v4.runtime.CommonTokenStream;
import org.antlr.v4.runtime.LexerNoViableAltException;
import org.antlr.v4.runtime.RecognitionException;
import org.antlr.v4.runtime.misc.ParseCancellationException;

import sugarVisitors.ToAst;
import tools.Assertions;
import antlrGenerated.L42Lexer;
import antlrGenerated.L42Parser;
import antlrGenerated.L42Parser.NudeEContext;
import ast.ErrorMessage;
import ast.ErrorMessage.ParsingError;
import ast.Expression;
/*
 **NOT WHAT I'm doing**
Implement the interface ANTLRErrorListener. You may extend BaseErrorListener for that. Collect the errors and append them to a list.
Call parser.removeErrorListeners() to remove the default listeners
Call parser.addErrorListener(yourListenerInstance) to add your own listener
Parse your input
Now, for the lexer, you may either do the same thing removeErrorListeners/addErrorListener, or add the following rule at the end:

UNKNOWN_CHAR : . ;
With this rule, the lexer will never fail (it will generate UNKNOWN_CHAR tokens when it can't do anything else) and all errors will be generated by the parser (because it won't know what to do with these UNKNOWN_CHAR tokens). I recommend this approach.

http://stackoverflow.com/questions/25832429/how-get-error-messages-of-antlr-parsing/25838580#25838580

 You should get a ParseCancellationException, which wraps a RecognitionException with the error message. Also, this answer of mine could be related.

 * */
public class Parser {
  private static NudeEContext parseCtx(String s){
    LoggedPrintStream lpsErr = LoggedPrintStream.create(System.err);
    System.setErr(lpsErr);
    try{
      NudeEContext ctxResult = getParser(s).nudeE();
      if(lpsErr.buf.length()!=0){
        throw new ParseCancellationException("\n\n------------------------------------\nCurrent file: "+Parser.fileName+"\nParsing error:\n"+lpsErr.buf.toString());
        }
      return ctxResult;
      }
    finally{System.setErr(lpsErr.underlying);}
    }
  private static String fileName=null;
  public static String getFileName(){
    return fileName;
    }
  public static Expression parse(String fileName,String s){
    String old=Parser.fileName;
    Parser.fileName=fileName;
    try{
      checkForTab(s);
      checkForBalancedParenthesis(s);
      s = replaceORoundWithTab(s);
      NudeEContext ctxResult=parseCtx(s);
      Expression result=ctxResult.accept(new ToAst());
      return result;
      }
    finally{Parser.fileName=old;}
  }
  private static void checkForTab(String s) {
    if(s.contains("\t")){throw new ErrorMessage.InvalidCharacter(getFileName(),
        "Tab ('\\t') is an invalid character in 42");}
  }
  public static antlrGenerated.L42Parser getParser(String s){
    ANTLRInputStream in = new ANTLRInputStream(s);
    antlrGenerated.L42Lexer l=new antlrGenerated.L42Lexer(in);/*{
      @Override public void recover(LexerNoViableAltException e) {
        throw new IllegalArgumentException(e); // Bail out
      }
    @Override public void recover(RecognitionException re) {
        throw new IllegalArgumentException(re); // Bail out
      }};*/
    CommonTokenStream t = new CommonTokenStream(l);
    antlrGenerated.L42Parser p=new antlrGenerated.L42Parser(t);
//    p.setErrorHandler(new BailErrorStrategy());
    return p;
  }

  private static class ParData{
    int currentLine=1;
    int currentPos=0;
    boolean inComment=false;
    int inStringSize=-1;
    boolean inStringMultiL=false;
    Stack<ErrorMessage.ParsingError>lastPar=new Stack<ErrorMessage.ParsingError>();
    void push(String s){
      if(this.inStringSize>=0){increaseStrLen();return;}
      if(this.inComment){return;}
      lastPar.push(new ErrorMessage.ParsingError(currentLine,currentPos,s));
    }
    void newLine(){
      currentLine+=1;
      currentPos=0;
      if(this.inStringSize==0){
        this.inStringMultiL=true;
        inComment=false;
        return;
        }
      if(this.inStringSize==-1){inComment=false;return;}
      if(!inComment){
        throw new ErrorMessage.UnclosedStringLiteral(Parser.fileName,currentLine,currentPos,"\"");
        }
      inComment=false;
      }
    void startComment(){
      if(this.inStringSize>=0 && !this.inStringMultiL){
        increaseStrLen();
        return;
        }
      this.inComment=true;
      increaseStrLen();
      }
    void nextPos(){currentPos+=1;}
    public void commit(String s,String token2) {
      if(this.inStringSize>=0){increaseStrLen();return;}
      if(this.inComment){return;}
      if(this.lastPar.isEmpty()){
        throw new ErrorMessage.UnopenedParenthesis(Parser.fileName,currentLine,currentPos,token2);
      }
      ErrorMessage.ParsingError last=this.lastPar.peek();
      if (last.getToken().equals(s)){this.lastPar.pop();}
      else{
        throw new ErrorMessage.ParenthesisMismatchRange(Parser.fileName,
            last.getLine(),last.getPos(),last.getToken(),
            currentLine,currentPos,token2);
      }
    }
    private void increaseStrLen(){
      if(this.inStringSize==-1){return;}
      this.inStringSize+=1;
      }
    public void stringSign() {
      if(inComment){increaseStrLen();return;}
      this.inStringMultiL=false;
      if(this.inStringSize==-1){this.inStringSize=0;}
      else{this.inStringSize=-1;}
    }
  }
  private static void checkForBalancedParenthesis(String s) {
    ParData d=new ParData();
    for(char c:s.toCharArray()){
      d.nextPos();
      switch (c){
              case '\n':d.newLine();
        break;case '\"':d.stringSign();
        break;case '\'':d.startComment();
        break;case '{':d.push("{");
        break;case '[':d.push("[");
        break;case '(':d.push("(");
        break;case '}':d.commit("{","}");
        break;case ']':d.commit("[","]");
        break;case ')':d.commit("(",")");
      }
    }
    if(!d.lastPar.isEmpty()){
      ParsingError m = d.lastPar.get(0);
      throw new ErrorMessage.UnclosedParenthesis(Parser.fileName,m.getLine(),m.getPos(),m.getToken());
    }
  }

  private static String replaceORoundWithTab(String s) {
    char[] toReplace=" ,\n+-*/({[<>=!~:".toCharArray();
    char[] source=s.toCharArray();
    char[] result=s.toCharArray();
    boolean inComment=false;
    for(char c:toReplace){
      for(int i=1;i<source.length;i++){
        if(source[i]=='\''){inComment=true;}
        if(source[i]=='\n'){inComment=false;}
        if (inComment){continue;}
        if (source[i]!='('){continue;}
        if (source[i-1]==c){result[i]='\t';}
      }
    }
    s=String.copyValueOf(result);
    return s;
  }
  static class LoggedPrintStream extends PrintStream {
    final StringBuilder buf;
    final PrintStream underlying;
    LoggedPrintStream(StringBuilder sb, OutputStream os, PrintStream ul) {
        super(os);
        this.buf = sb;
        this.underlying = ul;
    }
  private static LoggedPrintStream create(PrintStream toLog) {//from http://stackoverflow.com/questions/4334808/how-could-i-read-java-console-output-into-a-string-buffer
    try {
      final StringBuilder sb = new StringBuilder();
      Field f = FilterOutputStream.class.getDeclaredField("out");
      f.setAccessible(true);
      OutputStream psout = (OutputStream) f.get(toLog);
      return new LoggedPrintStream(sb, new FilterOutputStream(psout) {
        boolean lastIsSlash=false;
        public void write(int b) throws IOException {
          //TODO: hack to put back the "(" that was replaced with tab
          if(lastIsSlash && b=='\\'){
            lastIsSlash=false;
            super.write(b);
            sb.append((char) b);
            return;
          }
          if(lastIsSlash && b=='t'){
            lastIsSlash=false;
            super.write('(');
            sb.append((char) '(');
            return;}
          if(lastIsSlash){
            super.write('\\');
            sb.append((char) '\\');
            }
          lastIsSlash=b=='\\';
          if(!lastIsSlash){
            super.write(b);
            sb.append((char) b);
            }
          }
        }, toLog);
      }
    catch (NoSuchFieldException|IllegalArgumentException |IllegalAccessException e) {
      throw Assertions.codeNotReachable();
      }}}
}
