-----------------------------
Structure of this document:

0 Objectives

1 Grammar

2 L42N into L42F

3 L42F into Java

4 execution dynamics

5 Optimization

-----------------------------
0 Objectives
-----------------------------

Challenges:
Generated Java should be
-incremental
-fast to compile
-fast to execute//the less important now
-executable in parallel
-the generated class files should be cachable on remote server

key ideas:
-every L has a unique generated name added during normalization
-binding process will generate new names for binded (top level and nested)libraries //james suggests: old names may be marked as orphans
-every 42 execution generate a Resource class that have
  -current program // current program do not appear in map, current.top() always not LC
  -map from generate names to program view in that point//programs in map,p.top() always LC
   (no need to be the most updated program view?)
 Thus, multiple independent 42 executions can run in parallel, but
 multiple C:e in an execution needs to be sequential.


Starting point:
  L42N: L42 core, compiled, well typed and normalized, with some types annotated.

Intermediate; only for expressions in meth bodies:
  L42X: L42N with all subexpressions are xs, and L are replaced with their unique name CN

Destinaton1:
  L42F: a flattened version where every *executable*
  class/interface have a top level name
  this language also contains null, if, bool and so on..
   -design a process to optimize L42F using those features.
    Should be so that
    optimize(optimize(program))=optimize(program)

Destination 2:
  Java, C++, Javascript,..
  -design process to convert L42F programs into stuff.


Main Differences between 42 and Java/C#/C++ etc

All classes final (dynamic dispatch only for interfaces)
Expression based
Exception on local bindings
Fwd/placeholders
No primitive types



-----------------------------
1 Grammar
-----------------------------

L42N //should denote a super language with respect to the one in NotationsAndGrammar

e::=x|void|P|L|throw[T1,T2] e|loop e|(ds ks e[T])| e.m[P]((x:e)s)| use P check m((x:e)s) e
throw::= exception | error | return
k::=catch throw T x e
d::= T x=e

L42F
CT::= CN->p,CD,Javabytecode
CD::=kind CN implements CNs{ Mxs }
Mx::=refine? method T mxs((T x)s) body?//first is this
//note: no exceptions declared, body empty only if kind=interface
body::=ex | setter|getter|new|newWithFwd|newFwd |nativeIntSum|nativeIntMul|...|nativeVectorAdd
kind::=class |interface | nativeInt |nativeString| nativeFloat|nativeVector<CN> | nativeOpt<T>| ...
ex::= (dxs kxs ex [TX]) | x|void|CN|null| throw[TX1,TX2] x |loop ex
  |CN.mxs(ys)| use CN check mxs(ys) ex
  |if x then ex1 else ex2 |breakLoop | x1:=x2 |(mdf CN)x
kx::=catch throw TX x ex
dx::=TX x=ex
TX::=mdf CN//TODO: try to understand if we can leave mdf only in certain points

----
note: method calling/method dispatch in L42F:
methods with refine or with no body are dynamically dispatched
and must have a 'this' parameter
others are statically dispatched.
others still can have a 'this' parameter

CN is just an instance of class/interface CN.
Some native bodies would fail if the 'this' parameter is the CN instance.
The translation L42N to L42F will work in the following way:
-42 class methods declared in classes behave like static methods with no 'this'
-42 non class methods declared in classes behave line static method with first 'this' parameter
-42 class methods declared in interfaces, with dynamic dispatch
  behave like python class methods with first 'this class' parameter
-42 non class methods declared in interfaces, with dynamic dispatch
  behave like java method with first 'this' parameter

In addition, L42F can support implemented interface methods with no 'this' parameter (we use them for some predefined behavior)
  they behave java interface static methods (no equivalent in 42)

We assume the presence of some Prefefined classes/methods in L42F:
  Void, Any and Library, all offering only
  method CN NewFwd() newFwd //also Any have it!//yes, statically binded
//uppercase names to avoid conflicts

We also assume a class
nativeResource Resource{

  method Library LoadLib(class Any that)nativeLoadLib
  //return the Library denoted by the provided CN

  method Void Fix(Any a,Any b)nativeFix //hoping a is a Fwd
  //replace a with b in all the places a was stored.
  //every newFwd edits a list inside of Fwds to remember where they are stored.
  }

---------------
some classes can be implemented in 42, but it would be
inefficient and boring.
let be lInt32 an implementation for int 32 bits.
It uses implmentations for strings and bools, and can have creative names
for its methods. More methods could be defined there.
We can represent this family of int representations as
{native(Int32,1,This,Bool,S)
method This +(This that) this.sum_$_1(that)
}
Syntactically writing 'native(Int32,1,This,Bool,S)'
is a shortcut for a longer code that we do not actualy need to ever write.
similar to reuse, but is parametric and not desugared
is just a representation optimization.
Can a native lib have implements? nope?


It is not so easy for a case with 2 Concepts.Equal
and native java HashSets.
how should I implement java equals?
the one of the 2 that is implemented? what if both?
I may have to use http://trove.starlight-systems.com/
or
http://commons.apache.org/proper/commons-collections/javadocs/api-release/org/apache/commons/collections4/map/AbstractHashedMap.html#isEqualKey(java.lang.Object,%20java.lang.Object)
In this case, in the generate code
we can have
MyMap factory(){
  return new HashedMap(){
    isEqualKey(Object key1, Object key2){
      return ((LocalEqualityClazz)key1).localEqMethod(key2);
      }//etcetera
    }
}
collection plg can be generic in the same way
{//@plugin nativeVector
 // @Bar @Size @S @Bool
 method Bar get(Size that) use This check
   nativeVectorGet(_this:this,that:that)
}
could be a vector of bar, and the plgType can discover it and type properly

-----------------------------
2 L42N into L42F
-----------------------------
//for compactness ignore use, treated the same as mcall
//also, assume all local variables alpharenamed to be different
//and all newly introduced variables are fresh


################## libToCDs(p)
translate p.top() into a set of class declarations CD for L42F.
---

libToCDs(p)=//return a list of pairs <p,CD> continue in many lines
  libToCDs(p,ncs);   //recursively computed list elements
  p,class/interface? CN implements p*P1..p*Pn { //list element for p
    method CN NewFwd() newFwd
    libToCD(interface?,p,mwts)
    };
  pi, nullKind pi.CN implements empty{}//with pi in ps collected
  //for all L inside weakly deep methods.

  where p.top()={interface? implements P1..Pn mwts ncs Phase CN}

libToCDs(p,C:L)=libToCDs(p.navigate(C)) //assert p.navigate(C).top()==L

//cases for various kinds of mwt

Note, in 42, a call on this or P is always statically
dispatched; this never have an interface type.

Using header and body, cases for mwts
0//interface
libToCD(interface,p,mwt)=header(p,mwt)

1//class method into static method
libToCD(empty,p,mwt)=header(p,mwt) body(p,mwt[with e=e[this=This])
  where mwt.mt.mdf=class and mwt.e?!=empty

2//instance method
libToCD(empty,p,mwt)=header(p,mwt) body(p,mwt)
  where mwt.mt.mdf!=class and mwt.e?!=empty

3//get/set
libToCD(empty,p,mwt)=header(p,mwt) body
  where
  mdf!=class
  body =setter if mwt.ms.xs not empty, otherwise body=getter

4//constructor with FWD, note, we return 2 methods
libToCD(empty,p,mwt )= //we could have  p.top().CN instead of T, but T should be good enough
  header(p,mwt) newFwd
  header(p,noFwd(mwt))[with ms='New_'++mwt.ms] new
//  if noFwd(mwt)!=mwt, otherwise
//  header(p,mwt) fwd
//  header(p,mwt)[with ms='New_'++mwt.ms] new

  header(p,refine? class method T mxs(T1 x1..Tn xn) e?)=
    refine? method p*T mxs(p*T1 x1..p*Tn xn)
  otherwise
  header(p,refine? mdf method T mxs(T1 x1..Tn xn) e?)=
    refine? method p*T mxs(mdf p*This, p*T1 x1..p*Tn xn)
  body(p,refine? mdf method T m(T1 x1..Tn xn)exception Ps e)=p;(mdf This0 this,T1 x1..Tn xn)[e]


################## PG[ e0]= e1 with e0 in L42N and e1 in L42F
translate an expression. Needs a program and a gamma
---

###PG grammar and auxiliary operations
---
PG::=p;(x:T)s //p;G
p;(x:T)s + (x:T)s'=p;(x:T)s (x:T)s' //Thus I can write PG+x:T
PG + T1 x1=e1..Tn xn=en=PG+x1:T1..xn:Tn

PG*T=PG.p*T  //myPG.translate(T) in code?
PG*P=PG.p*P

p*P=p(P).CN

p*(mdf P) =mdf p*P

###PG[e] definition
---

PG[x]=x
PG[void]=void
PG[P]=PG*P
PG[L]=Resource.LoadLib_'L.CN'()//will be translate as Resource.LoadLib(someInt) in Java
  //yes, ok even if not compiled as for Collections.vector(of:P)
  //TODO: ok in code, hard to update formalism: collect p.evilPush(L) in a list ps,
  //so that we can add them to the CT with kind==null
PG[loop e]=loop PG[e]

PG[throw[T1,T2] x]=throw[PG*T1,PG*T2] x
otherwise
PG[throw[T1,T2] e]=PG[( T2 x=e throw[T1,T2] x)]

PG[x1:=x2]=x1:=x2
otherwise
PG[x1:=e]=PG[( T x=e x1:=x)]
  where T=PG.g(x1)

//Translation method call
//-normalizing es into xs
In the following, whith e!=x //use y for x receiver?
and xs is the list of xs of the method call

PG[e.m[P]( (x:e)s)]= PG[( mdf0 P x=e x.m[P]((x:e)s))]
where mdf0=PG.p(P)(m(xs)).mh.mdf

PG[y0.m[P]( (x:y)s xi:e (x:e)s)]= PG[( Ti y=e y0.m[P]( (x:y)s xi:y (x:e)s))]
where PG.p(P)(m(xs))= refine? mdf method T0 m(T1 x1..Tn xn)exceptions Ps e?

//-3 cases for y.m[P]((x:y)s)
//--case 1: interface or non class method-->trad normal
if PG.p(P) is interface or PG.p(P)(m(x1..xn)) non class method
PG[y0.m[P](x1:y1..xn:yn)]=PG*P.m`x1..xn`(y0..yn)

//--case 2:class method body  -->trad no this
otherwise
PG[y0.m[P](x1:y1..xn:yn)]=PG*P.m`x1..xn`(y1..yn)
if PG.p(P)(m(x1..xn))=refine? class method T m(T1 x1..Tn xn) exception Ps e?
and either e?=e or fwd_or_fwd%_in(PG.g(x1)..PG.g(xn))

//--case 3:class method constr no Fwd  --> trad no this, New_
otherwise //we have optimized new
PG[y0.m[P](x1:y1..xn:yn)]=PG*P.New_m`x1..xn`(y1..yn)

//block
PG[(ds ks e[T])]=(fwdFix(PG+ds[ds]) PG+ds[ks] PG+ds[e] [PG*T])
  PG[T x=e]=PG*T x=PG[e]
  PG[catch throw T x e]=catch throw PG*T x PG+x:T[e]

  fwdFix(dxs)=dxs if dxs.xs not in FV(dxs.es)
  otherwise //a block actually using placeholders
  fwdFix(mdf1 CN1 x1=ex1..mdfn CNn xn=exn)=
    fwdGen(mdf1 CN1 x'1,xs)..fwdGen(mdfn CNn x'n,xs)
    mdf1 CN1 x1=ex'1, imm Void z1=Resource.Fix(x1',x1)
                      if x'1 in xs else empty
    ..
    mdfn CNn xn=ex'n, imm Void zn=Resource.Fix(xn',xn)
                      if x'n in xs else empty
    with ex'i=exi[xi..xn=x'i..x'n], xs=FV(ex'1..ex'n)
    //in code, while computing ex'i, collect set of x'i that has been inserted
    // if x'i in such set then x'i in xs

  fwdGen(mdf CN x,xs)=empty if x not in xs
  otherwise fwdGen(mdf CN x,xs)=mdf CN x=CN.NewFwd()



################## CT.growWith(p,paths)
take an existing CT, create a bigger one where paths from p are added
we assume CT empty to exists
---

CT.growWith(p,paths)=CT+p1+..+pn
  where p1,..,pn=programsOf(p,paths)

###auxiliary programsOf
---
programsOf(p,empty)=empty
programsOf(p,Cs1..Csn paths)=
    p.navigate(Cs1),..,p.navigate(Csn),programsOf(p.pop(),paths)
  where p.pop() is defined, otherwise
programsOf(p,Cs1..Csn paths)=
    p.navigate(Cs1),..,p.navigate(Csn)
    where paths=empty

###auxiliary CT+p
---
CT+p=CT+p1,CD1+..+pn,CDn
  where p1,CD1..pn,CDn=libToCDs(p),

CT+p,CD=CT if CD.CN in dom(CT)
otherwise
CT+p,CD=CT,CD.CN->p,CD,empty,empty







-----------------------------
3 L42F into Java
-----------------------------
CT*mdf CN=CN if CT(CN)=kind _ and kind in {class,interface}
CT*mdf CN=int if CT(CN)=nativeInt _
...
CT*mdf CN=float if CT(CN)=nativeFloat _
CT*mdf CN=T if CT(CN)=nativeOpt<T> _

Java------------------
statement st::=
   T x;
  |x=ej;
  |if(x) b1 (else b2)?
  |while(true) b
  |b
  |break label
  |return x
  |throw new 'throw'(x)
  |try b catch(T x)b //more catch for catching return/exception/error
  |CN.m(xs)
  |useCall(xs)

block b::=label:{sts}

ej::=x|CN.m(xs)|useCall(xs)
??? | (CN') CN.m(xs) | CN'.m(xs) instanceof CN | !(CN'.m(xs) instanceof CN)

--------

c::=x?;label?

c+ej
emptyC+ej= return ej
x0;_+ej= x0=ej
empty;label+ej= ej

#######In the following * function, a global CT is assumed
emptyC*breakLoop= ??
_;label*breakLoop= break label;

c*x= c+x
c*CN= c+CN.instance()
c*void= return Void.instance()
c*null= c+null
c*CN.mxs(ys)= c+CT*CN.mxs(ys)//keep a look for native classes
//note, be careful with optimizations, we can not break a loop here
c*use CN check mxs(ys) ex= c+use(?,ys,(?)->{'emptyC*ex'})
c*'throw'[TX1,TX2] x= throw new 'throw'(x)
c*loop ex=label:{while(true){ 'empty;label*ex' }}
c*(mdf CN)x= c+(CT*CN)x
c*x1:=x2= x1=x2
c*if x then ex1 else ex2= if x {'c*ex1'} else{'c*ex2'}
c*(dxs ex [TX])= {tx(dxs) xe(c.label,dxs) c*ex}
c*(dxs ex [TX])= label0:{tx(dxs) try{ xe(c.label,dxs)} c;label0*kxs c*ex}

//reorder them for throw kind, and then for each kind
c;label0*catch throw1 TX1 x1 ex1..catch thrown TXn xn exn =
  catch([throw] y){ifT[y x1 TX1 c*ex1] else ...
    else ifT[y xn TXn c*exn] else throw y;s?}
s?=empty if c=emptyC
s?=break label; otherwise

tx(T x e)= CT*T x;

xe(label?,T x e)= x;label?*e;

//Note: we disallow capturing a 'return class Any'
//in the type system. If we allow it,
//we need to check for coherence!


### CT[CD]=JClass
---
CT[interface CN implements CNs {Mxs}]=
public interface CN implements CNs{CT,CN[Mxs]}
otherwise
CT[kind CN implements CNs {Mxs}]=
public class CN implements CNs{CT,CN[Mxs]}

CT,CN[refine method TX mxs(TX' this,(TX x)s) e]=
  public static CT*TX mxs(CT*TX' £this,CT*(TX x)s) CT[e[£this=this]]
  public CT*TX £mxs(CT*(TX x)s) {return CN.mxs(this,xs);}

//case with no "this"
CT,CN[refine method TX mxs((TX x)s) e]=
  public static CT*TX mxs(CT*(TX x)s) CT;empty;empty*e
  public CT*TX £mxs(CT*(TX x)s) {return CN.mxs(xs);}

CT,CN[refine method T mxs(TX' this,(T x)s)] //no body
  CT*TX £mxs(CT*(TX x)s);//is going to be in an interface
  static CT*TX mxs(CT*TX' £this,CT*(TX x)s){£this.£mxs(xs);}

CT,CN[method T mxs((T x)s) e] //no refine, note, work both with and without 'this' parameter
  public static CT*TX mxs(CT*(TX x)s[£this=this])CT[e[£this=this]]


//never happens CT[method T mxs((T x)s)]

CT,CN[refine? method T mxs((T x)s) new] //there can be many new/newFwd
  public static CT*TX mxs(CT*(TX x)s){
    CN res=new CN();
    res.x1=x1;..;res.xn=xn;
    return res;
    }
  public CT*TX £mxs(CT*(TX x)s) CN.mxs(xs) //only if refine?=refine

CT,CN[refine? method T mxs((T x)s) newWithFwd]
  public static CT*TX mxs(CT*(TX x)s){
    CN res=new CN();
    res.x1=x1;Fwd.addIfFwd(x1,CN.FieldAssFor_x1);
    ..;
    res.xn=xn;Fwd.addIfFwd(xn,CN.FieldAssFor_xn);
    return res;
    }
  public CT*TX £mxs(CT*(TX x)s) {return CN.mxs(xs);} //only if refine?=refine

//and then the field ones?
CT,CN[refine? method TX x(TX' this) getter]=
  public static CT*TX x(CT*TX' £this){return £this.£x;}
  CT*TX £x;
  public static BiConsumer<Object,Object> FieldAssFor£x=(f,o)->{
    ((CN)o).£x=(CT*TX)f;
    }
  public CT*TX £x() {return this.mxs();} //only if refine?=refine

CT,CN[refine? method Void x(TX this, TX' that) setter]=
  public static Void x(CT*TX £this, CT*TX' that){
    £this.£x=that; return Void.instance();}
  public CT*TX £x(CT*TX' that) {return CN.x(this,that);} //only if refine?=refine

CT,CN[ _ NewFwd() newFwd]=
  public static CN NewFwd(){return new _Fwd();}
  private static class _Fwd extends CN implements Fwd{
    private List<Object> os=new ArrayList<>();
    private List<BiConsumer<Object,Object>> fs=new ArrayList<>();
    public List<Object> os(){return os;}
    public List<BiConsumer<Object,Object>> fs(){return fs;}
    }


###Assumed
---
interface Fwd{
  static  void addIfFwd(Object x1,BiConsumer<Object,Object> action){
    if(x1 instanceof Fwd){((Fwd)x1).rememberAssign(res,action);}
    }
  List<Object> os();
  List<BiConsumer<Object,Object>> fs();
  default void rememberAssign(Object f,BiConsumer<Object,Object> fo){
    os().add(f);
    fs().add(fo);
    }
  default void fix(){
    List<Object> os=os();
    List<BiConsumer<Object,Object>> fs=fs();
    assert os.size()==fs.size();
    for(int i=0;i<os.size();i++){
      fs.get(i).accept(this,os.get(i));
      }
    }
  }


---
Translation example
a+b //42 user
a.#plus( that: b) //42 core
a.#plus[Nat]( that: b) //42 annotated
Nat.#plus_that(a,b) //42F
nativeInt32 Nat: {   Nat #plus_that(Nat a, Nat b)nativeInt32Plus} //42F class
Nat._hash_plus_that(a,b)//Java
class Nat {  public static int _hash_plus_that(int a, int b){return a+b;}  }//Java class

-----------------------------
4 General execution
-----------------------------

before p  --enter* +top-->  p'

now L,CT,cache  --enter* +top-->  L',CT',cache'

every project save cache every step?

on start:
A- if no cache, create empty cache,
B- load cache, parse/desugar L, emptyCT
C- apply 1 step of  enter* +top, CT/cache just got propagated over enter/top
D- locally update L, CT, cache, and either save new cache or give error
E- goto C

CT::= CN->p,L42F,MiniJ,bytecode,CNs //dependencies
  not all fields are availabe all time:
  CN->p if p.top() only normalized/not executable
cache::=CN->L42F,bytecode

Execution

Loader: a mutable object containing CT,cache and java classloaders

Loader.execute(p,paths,e)=LC
  Loader.load(p,paths) //Loader change state here
  LC=Loader.run(p,e)//Loader change state here but should be irrelevant

Loader.run(p,e)
  ps,sJ=Loader.CT;empty;empty*(p;empty[e])
  //ps is the collected L inside e.
  Loader.CT=Loader.CT+ p1, nullKind p1.CN implements empty{}
  ...
  + pn, nullKind pn.CN implements empty{}
  with ps=p1..pn

  J=class CN{ public static Object execute(){sJ}}//CN fresh
  Loader.classLoader=Loader.load(toBytecode(J))
  return Loader.classLoader.usualReflectionToCall("CN.execute()")

-------------
should we use a db instead of files?
when L42 run in a folder, near This.L42 we create a _This.db
that contains a serialized cache object


-----------------------
plan for caching

-Dep
We keep dependency in the CT map Dep=CNs
where all the transitive dependencies are contained in Dep
that is: in a well formed CT, forall CN
* if CT' in CT(CN).CD then CT' in CT(CN).Dep
* if CT' in CT(CN).Dep then CT(CT').Dep subseteq CT(CN).Dep


-CT.has(CN)= CT(CN).bytecode is defined
-cache.has(CN,CT)= cache(CN).CD=CT(CN)

###
---
When from program p we need to load classes Ps0 to CT
using cache:

Loader.load(p,paths)
  CT'=Loader.CT.growWith(p,paths).computeDep()
  cache=Loader.cache
  clMap=Loader.clMap
  chunks=CT'.listOfDeps() // ordered over superSet relation
  for deps in chunks://take smaller deps in chunks 
    1a-if CT' deps in cache and clMap: nothing
    1b-if CT' deps in cache: clMap.putAll(cache(depts)\dom(clMap))
    1c-else: javac(CT, deps, clMap) and cache= cache, deps->clMap(deps) //with coherence to save space
    //note: javac will not recompile what is already in clMap
    2 -remove deps from chunks.
  Loader.cache=cache
  Loader.CT=CT'
//loader using CT/CT can be updated/swapped (this will not influence already loaded classes)

Yet Another dependency handling:
 
clMap: byteName->byteCode
cache:  depSet-> CDSet, clMap
clMap in cache is coherent/save space:
if byteName->byteCode and byteName->byteCode' 
then byteCode==byteCode' (pointer equality)
    
Define
CT deps in cache and clMap'=
  cache(deps)=CDs,clMap
  CT(deps)=CDs
  clMap subsetOf clMap'
 
CT deps in cache=
  cache(deps)=CDs,clMap
  CT(deps)=CDs

javac(CT, deps, clMap)
  javac([CT(CN) | for CN in deps if CN notin dom(clMap)])
  //each CN can correspond to more then one element in clMap,
  //but if there is CN, then all is in clMap already.


    
CT'=CT.need(cache,p,Ps0) //need all the chunk together, since Javac may do multi-class inlining
  Ps1={P in Ps0 | not CT.has(p,P)}
  CT0=CT.growWith(p,reorganize(Ps1)) //note, this does not compute java/bytecode yet
  CT1=CT0.computeDeps()
  //assert all classes in CT are also "cached well"
  //Dag where nodes are set CNs closed for dependency
  Dag: //may not have a single root
    Nodes={CT1(p(P).CN)\dom(CT1.has)| P in Ps1} //note, dependencies are transitive
    Edges={ CNs1->CNs2 | CNs1,CNs2 in Nodes, CNs1 supersetof CNs2}
  var CTres=CT1
  Repeat:
    Take one clean leave CNs in Dag
      assert !CTres.has(CN) forall CN in CNs
      if forall CN in CNs:
        cache.has(CN,CT1) //or CTres??
      then:
        -add CTres=CTres.addCache(cache,CNs)
        -remove the leave from Dag
        -remove CNs from all the nodes of the graph
      else:
        -mark that leave as dirty
  When all the existing leaves are dirty,then:
     -we load paths=reorganize(all the P in the roots of the Dag) without using the cache:
       CTres=CTres.computeJavaAndBytecodeForNullFields()
  //this algorithm require to not cache the "e",
  //may be is not a problem since they are usually small?
  return CTRes

###auxiliary functions

CT.computeDeps()=CT'
  if CT(CN)=p,CD,JCD?,byteCode?,empty
  then CT'(CN)=p,CD,JCD?,byteCode?,CNs
  CN0 in CNs if CN0 somewhere inside CD
  CN1 in CNs if CN0 in Cns, CN1 somewhere inside CT(CN0)



CT.computeJavaAndBytecodeForNullFields()=
  CT.computeJavaForNullFields().computeBytecodeForNullFields()


CT.computeJavaForNulls()
  uses CT[CD]=JClass
CT.computeBytecodeForNulls()
  uses tools.javac


reuse at               //0
A:Data<<{}             //1 require paths1, e1 -> J1,Je1
B:Data<<{}             //2 require paths1,e2 -> Je2
C:Collections.vector(A) //3 require paths1,A,paths3,e3 -> J3,Je3
D:Data<<{C,A}          //4 require paths1,A,C,e4  ->,Je4
Main:D.run()           //5 require A,B,C,D,e5 -> JA,JB,JC,JD,Je5

algoritm?
l have CN
l have Phase
l have Dep: (P,CN)s
need p,Path
if p(Path).CN notin cache
  return addToLoad(p,Path)
l,lf,j,jb=cache(p(Path).CN)
if l!=p(Path) //this also check l.Dep=p(Path).Dep
  removeCache(p(Path).CN)
  return addToLoad(p,Path)
return lf,j,jb





//Path2={P in Path1 | not cache.has(p,P)}

-----------------------------
5 Optimization//later?
-----------------------------
Goals:
-bool/int/float etc should be types directly used in the code and
their operations should be directly used.
-Strings/other well known plugin imported data should be directly used too.
-if and while should be handled without exceptions
-Opt should be implemented with normal (optionally null) pointers
-lists (also of mutable objects) should use a primitive vector/arraylist concept
-classes with a single fields should be "erased" most of the times
-method inlining should happen often
-type cases/casts should be simplified away when possible (may be thanks to inlining?)
-optimization of number/string literal

optimization of number/string literal:
during de sugaring make them separete functions, then all class method imm Foo are cached the first time they are executed
(since 42 is compiled on the way, it is as fast as executing them at compile time, and for
precompiled libraries we can have an operator forcing it)
-------
Note: optimizing a local variable seams harder then adding them to the core...
In case we want to add local var to core, need to happen after /at the same time
of implementing L42IntoJava.


Main idea: a sequence of iteration over
CT-->CT[CN=nativeOfThatPattern(CT(CN))]
if CT(CN)= aSpecificPattern
something like this should work for int,float,arrays and a couple more stuff
for Opts would work in combination with wrapper class optimization


###Optimizations over blocks:
---
#Var Local binding optimization
if a block declare a binding x that:
-has non interface type
-is initialized from constructor
-is only used as receiver //includes is never returned
-the called methods on it are only get/set
then you can replace the x with the wrapped type(s) and avoid creation
of such object.
TODO: can be extended allowing calls for other kinds of methods?
//Note, we still have to keep the class in existence, since could be used somewhere else.

###Optimizations over whole classes:
---
Example int:
for some x, CN, m, P, plus,times
int32Pattern=//input
class CN{
  method Library x() getter
  method CN New_m(x)(Library x) new
  method CN plus(CN this,CN that)
    CN.New_m(use P
    check int32_sum(left:this.x(), right: that.x())
    error _)
  method CN times(CN that) ...
  }//note, not all methods need to be there
int32Native=//output
int32Native CN{//here instead we will generate all methods
  method Library x() int32NativeToLib
  method CN New_m(Library x) int32NativeFromLib
  method CN plus(CN this,CN that)int32NativeSum
  method CN times(CN this,CN that)int32NativeMul
  }
  //discuss: can we have two plus methods? can we have extra methods and just leave them be?

WrapperClasses:
class CN is wrapper if
- exactly one field,
- no setter(opt has no setter)
then
replace all CN with the field type except for CN.mxs
CN constructors are simplified away
CN.f(x,z) setters are x:=z ?? we just said no setter?
CN.f(x) getter are y=x
if x passed to a method needing an interface type, then it is wrapped as for throw(see later)?
all throw x where G(x)=mdf CN in the original program//all throw of form throw x in this language
are transformed in (mdf CN x'=CN.new(x) throw x') //x will be now of the wrapped type
all catch throw CN x e,
if x used outside of throws in e
are transformed in (mdf?? CN x'=x.field() transformedOf(e)[x'=x] )
//TODO: check this does not break {..return..} optimization

  //note for marco: I believe/ed that this means redirect need to refuse to work on private P, no idea what that could mean now
  //oddly correlated note for marco: if we rename all private nested classes to the top level, we can avoid most privacy coupuled; it would only stay for private methods; not sure is what we want

If/While insertion:
If insertion:
(T y=CN.#checkTrue(x)  catch exception Void ex1 ex2)
  replaced with
if x ex2 else ex1
  if CT(CN).kind=nativeBool

While insertion
while cond block
----------------
( loop (cond.#checkTrue(),  block ), catch exception Void x void, void)

( loop (x=cond   Bool.#checkTrue( x),  block ), catch exception Void x void, void)

( loop ( x=cond if x breakWhile block) catch exception Void x void, void)
//If the block does not leak exception Void, we can also avoid the catch
Throw/cast simplification
(throw[T,_] ax
 catch throw T x x
 _)
   replaced with
   ax

Throw/cast simplification
(throw[T0,_] ax
 catch throw T1 x x
 ..
 catch throw Tn x x
 e)
????? need casts ? ifs? type switch?//Note: this is not the patter used in sugar


---------









####### G.typeOf(e) //is it used now?
G.typeOf(P)=class P if G.p(P) not interface
otherwise
G.typeOf(P)=class Any
(_, x:T,_).typeOf(x)=T
G.typeOf(void)=imm Void
G.typeOf(L)=imm Library
G.typeOf(loop e)=imm Void
G.typeOf(throw[T1,T2] e)=T1
G.typeOf( (_[T]) )=T
G.typeOf( e.m[mdf P](x1:e1..xn:en) )=P::m(x1..xn)//resolved?

//Note for marco: Guess type in formal
//case use: use the plugin information, not the e!



