-----------------------------
Structure of this document:

1 Type Grammar

2 Type manipulation

3 ExpressionTypeJudgement

4 Subtyping p|- T<=T'

5 LibraryAndMemberTyping

6 Deteministic strategy for type system
-----------------------------
1 Grammar
-----------------------------
//In this file, all the L are LC   //LC == in all C:e, e of form L

G::=x1: var?1 T1..xn: var?n Tn  //G reads Gamma
D::= Phase `|` p `|` G  //D reads Delta
Tr::=Ts; Ps //Tr reads Throws
MethT::=Ts->T;Ps

--------------------------------------------
2 Type manipulation
--------------------------------------------

onlyMutOrImm(G)={x:G(x) | G(x) only mut or imm}

fwd T
  fwd imm P=fwd fwd%imm P=fwdImm P
  fwd mut P=fwd fwd%mut P=fwdMut P
  otherwise fwd T=T

fwd% T
  fwd% imm P=fwd%Imm P
  fwd% mut P=fwd%Mut P
  otherwise fwd% T=T
 
fwd_or_fwd%_in Ts
  exists T in Ts such that
  T in {fwdImm _,fwdMut_,fwd%Imm _,fwd%Mut _}

noFwd T
  noFwd fwdImm P=noFwd fwd%Imm P=imm P
  noFwd fwdMut P=noFwd fwd%Mut P=mut P
  otherwise noFwd T=T

noFwd T1..Tn= noFwd T1 .. noFwd Tn
  
//toImm(T) //unused?        
//toImm(class P)=class P
//otherwise, toImm(mdf P)=imm P

toImmOrCapsule(T) //used for parameters
  toImmOrCapsule(mdf P)=capsule P with mdf in {lent,mut,fwdMut,fwd%Mut}
  toImmOrCapsule(read P)=imm P
  otherwise toImmOrCapsule(T)=T//mdf in {class,imm,fwdImm,fwd%Imm,capsule}

toLent(T)//used for return types and gamma
  toLent(mut P)=lent P,
  toLent(fwdMut P) and toLent(fwd%Mut P) undefined;
  otherwise toLent(T)=T
  
mutOnlyToLent(T) //used for parameters in deterministic strategy
  mutOnlyToLent(mut P)=lent P,
  otherwise mutOnlyToLent(T)=T 

capsuleToLent(T)  //used for return type in get/exposer
  capsuleToLent(capsule P)=lent P
  otherwise capsuleToLent(mdf P)=mdf P
   
toRead(T) //used in gamma and in return type getter
  toRead(fwdMut P)=toRead(fwd%Mut P)=undefined
  toRead(fwdImm P)=toRead(fwd%Imm P)=undefined  
  toRead(lent P)=toRead(mut P)=toRead(capsule P)=read P
  otherwise read(T)=T//mdf in imm,read,class  

toRead(G)
  toRead(G)(x)=toRead(G(x))[with var?=empty] //thus undefined where toRead undefined 

toLent(G)
  toLent(G)(x)=G(x) if G(x).T.mdf=immutable
  otherwise
  toLent(G)(x)=toLent(G(x))[with var?=empty] //thus undefined where toLent undefined

//lentToMut(T) //unused
//  lentToMut(lent P)=mut P
//  otherwise lentToMut(T)=T  

mutToCapsule(T) //used for parameters
  mutToCapsule(fwdMut P) and mutToCapsule(fwd%Mut P) undefined//NO? no reason to restrict?
  mutToCapsule(mut P)=capsule P
  otherwise mutToCapsule(T)=T
//used for parameters
mutToCapsuleAndFwdMutToFwdImm(T) //used for parameters//called f in the implementation
  f(fwd%Mut P) undefined
  f(mut P)=capsule P
  f(fwdMut P)= fwdImm P 
  otherwise f(T)=T

mutToCapsuleAndFwdRead(T) //used for parameters//called f in the implementation
  f(fwd%Mut P) undefined
  f(mut P)=capsule P
  f(fwdMut P)= read P
  f(fwdImm P)= imm P //Note: read here would be unsound 
  otherwise f(T)=T


G[G']
  G[G'](x)=G'(x) if x in dom(G'); otherwise G[G'](x)=G(x)
 
G[ks]
  G[]=G
  G[k ks]=toRead(G) with k.throw=error and not catchRethrow(k)
  otherwise G[k ks] = G[ks]

mostGeneralMdf(throw,Tr)  
  mostGeneralMdf(error,Tr)=imm
  mostGeneralMdf(return,empty;Ps) undefined
  mostGeneralMdf(return,T1..Tn;Ps)=mostGeneralMdf({T1.mdf .. Tn.mdf})
  otherwise 
  mostGeneralMdf(exception,_;Ps)=imm

mostGeneralMdf(mdfs)
  mostGeneralMdf(mdfs)=mdf
  case by exclusion:
    if mdfs=mdf', then mdf=mdf' //that is the only way mdf=class
    if class in mdfs, then undefined //and size>1
    if mdfs\capsule=mdf', then mdf=mdf'
    if fwd_or_fwd%_in(mdfs) {
      if read or lent in mdfs, then undefined
      if imm and mut both in noFwd(mdfs) then undefined
      //we know: more then one, no read/lent, either all imm side or mut side
      if fwdImm in mdfs mdf=fwdImm
      if fwd%Imm in mdfs mdf=fwd%Imm
      if fwdMut in mdfs mdf=fwdMut
      assert fwd%Mut in mdfs
      mdf=fwd%Mut
      }
    if read in mdfs, mdf=read
    if imm in mdfs, mdf=read
    mdf=lent
  //set oriented definition from james: 
  //generalEnough(mdfs)
  //  mdf | forall mdf1 in mdfs, mdf1 <= mdf
  //mostGeneralMdf(mdfs)
  //mdf = generalEnough(mdfs) such that
  //  forall mdf1 = generalEnough(mdfs) mdf <= mdf1
  // that is, the most speficic generalEnough.
//liberal use of desugaring in the line under
catchRethrow(k) iff k=catch throw Any x ((e catch error Any z void void) throw x)

Tr1 U Tr2
  Ts1;Ps1 U Ts2;Ps2 =  Ts1,Ts2; Ps1,Ps2  

Tr.capture(p,k1..kn)= Tr.capture(p,k1)...capture(p,kn)

Tr.capture(p,catch error P x e)=Tr
(Ts;Ps).capture(p,catch exception P x e)=Ts;{P'| P' in Ps, not p|-P'<=P}
(Ts;Ps).capture(p,catch return P x e)={T| T in Ts, not p|-T.P<=P};Ps


--------------
methTypes(p,P,ms)  Expressed as metarules

//first managing placeholders

       p(P)(ms).mh[from P]=refine? mdf0 method T m(T1 x1,..Tn xn) exception Ps
       T'=fwd% T if fwd_or_fwd%_in(Ts)
       otherwise T'=T       
(mBase)-------------------------------------------------------------------
       mdf0 P T1..Tn-> T';Ps in methTypes(p,P,ms)
 
         Ts->T;Ps in methTypes(p,P,ms) 
(mNoFwd)-------------------------------------------------------------------
         noFwd Ts-> noFwd T;Ps in methTypes(p,P,ms)

//then capsule and imm promotion
    Ts->mut P0;Ps in methTypes(p,P,ms)
(mC)-------------------------------------------------------------------
    mutToCapsule(Ts)->capsule P0;Ps in methTypes(p,P,ms)

    Ts->read/*or lent*/ P0;Ps in methTypes(p,P,ms) //by well formedness if return type is read, not fwd_or_fwd%_in Ts
(mI)-------------------------------------------------------------------
    toImmOrCapsule(Ts)->imm P0;Ps in methTypes(p,P,ms) 
    //the behaviour of immorcapsule on fwd is not relevant since the method
    // returns a read and will be not well formed if it had fwd parameters
  
//then lent viewpoint adaptation    

     Ts0 mut P Ts2->T;Ps in methTypes(p,P,ms)
     Ts'=mutToCapsule(Ts0) lent P mutToCapsule(Ts2) //this implies not fwd_or_fwd%_in Ts0,Ts2
(mVp)-------------------------------------------------------------------
     Ts'->toLent(T);Ps in methTypes(p,P,ms)
//and then rules about fwd and fwd%
    Ts->fwd%Mut P0;Ps in methTypes(p,P,ms)//could be generalized to make fwdMut in fwdImm 
    fwd_or_fwd%_in(Ts)
(mImmFwd)-------------------------------------------------------------------
    mutToCapsuleAndFwdMutToFwdImm(Ts)->fwd%Imm P0;Ps in methTypes(p,P,ms)   

    Ts->fwd%Mut P0;Ps in methTypes(p,P,ms)//could be generalized to make fwdMut in read
    fwd_or_fwd%_in(Ts)
(mRead)-------------------------------------------------------------------
    mutToCapsuleAndFwdRead(Ts)->read P0;Ps in methTypes(p,P,ms)

--------------------------------------------
3 ExpressionTypeJudgement
--------------------------------------------
  D |- e ~> e':T <=T'| Tr  
    where e' is an annotated version of expression e and is of type T
    D.p points to where the e is located, //D.p.top()=ctxL[e]
    so if P inside e, D.p(P) is a reasonable operation
    Tr is the computed set of thrown returns and exceptions.
    
  Phase| p| G |- ds ~> ds'| Tr | G0
    where ds' is an annotated version of ds.
    The resulting G0 is the enriched G containing info about ds too. 

  D |Tr |- k ~> k':T <=T' |Tr'    
    where k' is an annotated version of catch k and k.e is of type T
    we need the Tr of the ds to extract the mdf for caught returns
    Tr' contains only the throws from the catch k itself.
  
  D| Tr |- ks ~> k's:Ts <= T | Tr'
    just types a set of catches.
    
---------------------------------

(void)
D |- void~> void:imm Void <= T | emptyTr
  where
  D.p|-imm Void <= T
  
(Path)
D |- P~>P:class P <= T | emptyTr
  where
  D.p|-class P <= T// interface should be class Any
  assert p(P) well defined

(library propagation)
D |- L ~> L' : imm Library <= T | emptyTr
  where
  D.p|-imm Library <= T
  D.Phase  |- D.p.evilPush(L) ~> L'

(x)
D |-x ~> x :D.G(x) <= T | emptyTr
  where
  D.p|- D.G(x) <= T

(loop)
D |- loop e ~> loop e' : imm Void <= T | Tr
  where
  D.p|-imm Void <= T
  D|- e ~> e' : _ <= imm Void | Tr

(throw)   // expression of type T0 throws the result of an expression where:
          // T1 is the guess type of the expression
          // T2 is the modified type, taking into account kind of thrown
          // T3 is the type of the expression, including promotions
          // and T3 is the type of the value thrown, this allows to use alternative method typing
D |- throw[_,_] e~> throw[T0,T3] e' : T0 <= T0 | Tr
  where
  T1 = resolve(D.p,guessType(D.G,e))// Note, resolves and guessTypes can go in error, and need to become a type error here
  if throw=exception, T2= imm T1.P and Tr=Ts;Ps,P
  if throw=error,     T2= imm T1.P and Tr=Ts;Ps
  if throw=return,    T2= (fwd T1) and Tr=(Ts,T3);Ps  //TODO: add(also in code) that return classAny is forbidden
  D|- e~>  e' :  T3 <=T2|Ts;Ps 

(mcall)
D |-  e0.m[_](x1:e1..Xn:en) ~> e'0.m[P0](x1:e'1..xn:e'n)  : T <= T'| Tr0 U..U Trn U (empty;Ps)
  //e0 will be of form chain
  where
  resolve(D.p,guessType(D.G,e0))= _ P0 //assert T'0.P=P0 //again, can go in error resolve+guess
  T0..Tn->T;Ps in methTypes(p,P0,m(x1..xn)) //can not be avaible, find skeme of error similar to before for guess?
  D.p|-T <= T'
  forall i 0..n D|- ei ~> e'i : T'i <=Ti | Tri //T'0 is correctly a free variable    
  
(using)
 D |- use P check m(x1:e1.. xn:en) e0 ~>use P check m(x1:e'1.. xn:e'n) e'0 :T0 <= T | Tr0 U..U Trn
 where
   plugin(D.p,P,m(x1..xn))=plg, T1..Tn->T0;empty //plg is a free variable, in the small step reduction would be the function representing the behaviour
   //plugin/meth not found error //assert T0..Tn exists in p
   D.p|-T0 <= T
   forall i 0..n D|- ei ~> e'i : T'i <=Ti |Tri
//Note: what happen if a parameter take mut and the plugin throw error w.r.t. strong error safety? can we catch it soon?
//The idea is that I can still use the normal pattern to throw error if the plugin fail, but to catch that error we will have to go up the stack a lot.
//Now plugings are assumed to always ask for imm/class parameters
  
(block)
Phase| p| G |- (ds  ks  e0  [_]) ~>(ds' ks' e'0 [T]) 
     : T <= T' | Tr'.capture(p,ks') U Tr U Tr0
  where
  G'=G/dom(ds)
  Phase| p| G'[ks] |- ds ~> ds' |Tr' | G0
  //[ks] removes fwdMut, but we wonder if they could stay and all would be sound?
  //here we have the info to capture a failure about ds and discover if 
  //extant name (fwd[%]* x) was hidden by error safety or  modifiable name (capsule/mut/lent x)
  //was locked by error safety[cite the line number of the catch]
  Phase| p| G'| Tr' |- ks~> ks' : Ts <= T' | Tr 
  Phase| p| G'[G0\dom(G')] |- e0~>e'0:T0 <=T' | Tr0
  T= mostGeneralMdf({T0.mdf,Ts.mdfs}) T'.P //set of Mdfs admits no single most general mdf
  // assert D.p|-T <= T'
//TODO: list of changes to update in code:
//either T?i etcetera
//type in the annotated result is not just the resolved one!
//check for well formedness too in code! can be violated adding a T fwd or capsule
//note how G2 is now used instead of G' in a couple of places 
(ds)  // G is clipped for error safety; G2 is clipped and complete
Phase| p| G |- var?0 T?0  x0=e0 .. var?n T?n  xn=en, ds ~>
              var?0 T'0  x0=e'0 ..var?0 T'n  xn=e'n, ds'|Tr U Tr' | G2
  where
  dom(ds) disjoint FV(e0..en)
  for i in 0..n
    either T?i =empty and Ti=guessType(G,ei) 
    or Ti=resolve(p,T?i)
  G'=x0:T0..xn:Tn
  G1= G[fwd(onlyMutOrImm(G'))] //capturing error for next line if not onlyMutOrImm(G') is used and is errored by next line 
  for i in 0..n Phase| p| G1|-ei~>e'i: T'i <= fwd% Ti | Tri
  G2=x0:T'0..xn:T'n
  Tr=Tr0 U .. U Trn
  if fwd_or_fwd%_in Tr.Ts
    then x0..xn disjoint FV(e0..en)//returning unresolved items from cycles is prohibited
  if fwd_or_fwd%_in { G(x) | x in FV(e0..en) } // x0..xn already excluded
    then G0=G[fwd%(G2)]
    otherwise G0=G[G2]//capturing error for next line, see if the difference between fwd%(G2) ad G2 would fix it. Still, then we need to check for the fwd x in FV(e0..en)..
  Phase| p| G0|- ds ~> ds'|Tr' | G2

(dsEmpty)
Phase| p| G |- empty ~> empty| empty;empty | G
   
//TODO: check that this kind of things work {Bar:{}   method m (foo catch exception Bar x e1 e0)  } redirect Bar->Any
//Note: the new idea is that catch throw Any will catch all that can be thrown,
// if not of form catchRethrow(k); in that case *only* the catchRethrow rule will apply
(catchMany)
D| Tr |-k1..kn ~> k'1..k'n:T1..Tn <= T | Tr1 U .. U Trn
  where
  forall i in 1..n D| Tr |-ki ~> k'i:Ti <= T |Tri
  //we used to have Tr.capture(D.p,k1..ki-1) instead of D|Tr|-ki, but it was wrong in case of redirect; for example
  //Elem e=(return that catch return Elem x x catch return Any y error void)[redirect Elem in Any]
  //in this setting the second catch return Any would fail for "no return in scope"
 
  
(catch)
   // T0 is the declared caught type, which contributes only a path
   // T1 is the actual caught type, based on the types which can be thrown in context
   // T2 is the type of the expression, based on x being bound T1

Phase| p| G| Tr' |- catch throw T0 x e ~> catch throw T1.P x e' :T2 <= T | Tr
  where
  mdf1 = mostGeneralMdf(throw,Tr') //set of Mdfs admits no single most general mdf, or mdfs is empty
  //inconsistent set of thrown things, which do not share a most
  //general modifier [list of line numbers of the throws]
  T1 = mdf1 resolve (p, T0).P //resolve can fail
  not catchRethrow(catch throw T1 x e)
  Phase| p| G[x:T1]|- e ~> e' : T2 <= T | Tr

(catch and rethrow any)// could be sugared as "on throw doAndPropagate e"  
Phase |p |G |Tr|-catch throw Any x (e0 throw x) ~> catch throw Any x (e0' throw x): T<=T | Tr
  where //Note: e0, e, e0',e' are using the sugar imm Void x=e == e
  e0=(e catch error Any z void void)
  e0'=(e' catch error Any z void void)
  Phase |p |G\x |- e ~> e':_ <=imm Void | empty
  catchRethrow(catch throw Any x(e0 throw x)) 

(capsule promotion)//we are discussing if some blocks may not be promotable:
//for example blocks with empty ds and ks.
Phase |p |G |- (ds ks e)~>(ds' ks' e'):capsule P <=mdf P | Tr
  where
  mdf in {capsule, imm fwdImm, fwd%Imm}
  Phase |p |toLent(G) |-(ds ks e)~>(ds' ks' e'):mut P <=mut P   | Tr
//this rule is now "deterministic" in the sense that if typing the block give us a capsule directly,
//this rule can not be applied, since we require mut P <=mut P in the premise.
//this is another point wher x can become undefined
------------------------------------------------------
4 Subtyping p |- T<=T'
------------------------------------------------------
  
(subtype)
p |- mdf0 P0<=mdf1 P1
  where
  mdf0<=mdf1
  P in P0 U (p(P0).Ps[from P0])
  p.equiv(P,P1)
  
mdf<=mdf
mdf1<=mdf3 if mdf1<=mdf2 and mdf2<=mdf3
capsule<=mut,imm  //,lent,read,fwd%Mut,fwdMut,fwd%Imm, fwdImm
imm<=read,fwd%Imm //,fwdImm
mut<=lent,fwd%Mut //,read,fwdMut
lent<=read
fwd%Mut<=fwdMut
fwd%Imm<=fwdImm


-----------------------------------------------
5 LibraryAndMemberTyping
-----------------------------------------------
 Phase |- p ~> L   and   p | Ps |- M ~> M'
 L is the typed/annotated version of p.top()
 M' is the annotated version of M
 and p.top() is the literal containing M

  
(library shallow norm)
Norm  |- p ~> p.top()  //remember: norm ignores meth bodies
//assert forall P in norm(p).Ps p(P).Phase>=Norm
//assert p.top().Phase!=None
(library well typed)  //TODO: check interfaces has no unique named methods
Phase |- p ~> L' //In implementation, if p.top().Phase>=Phase, L'=p.Top()
   where
   Phase in {Typed,Coherent}
   L0={interface? implements Ps M1..Mn Phase'}=norm(p)
   L'={interface? implements Ps M1'..Mn' max(Phase',Phase)}
   //assert forall P in Ps p(P).Phase>=Norm
   forall i in 1..n
     Phase| p.updateTop(L0)| Ps |- Mi ~> Mi'
   if Phase=Coherent then coherent(p.udatateTop(L'))
   //or error not coherent set of abstr. methods:list

(member nested)
Phase| p| Ps |-C:L ~>  C:L'
   where
   Phase |-p.push(C) ~> L'

(member method)
Phase| p| Ps |-M ~> M'
  where
  M =refine? mdf method T m(T1 x1 .. Tn xn)exceptions Ps0 e?
  M'=refine? mdf method T m(T1 x1 .. Tn xn)exceptions Ps0 e?'
  G=this:mdf This0,x1:T1,..,xn:Tn
  if e?=e then
    Typed| p| G |- e ~>  e?':_ <=fwd% T | empty;Ps1//TODO: IN CODE, check empty ts
    forall P1 in Ps1 exists P0 in Ps0 such that p|-P1<=P0
  else
    e?=e?'
  refine? = refine <=> 
    forall P in Ps such that p(P)(m(x1..xn))[from P]=M0 //that is, is defined
      all of the following hold:
      M0=refine?' mdf method T' m(T'1 x1..T'n xn)exceptions Ps'
      p|-T<= T' //method returns a type which is not a sybtype of its ancestor "name"
      p.equiv(T1,T'1)..p.equiv(Tn,T'n) //invalid type w.r.t. ancestor paramerer xi   
      forall Pi in Ps0 exists Pj in Ps' such that p |- Pi<=Pj
      //or error: leaked exception P is not the subtype of a declared exception
      /or  method declares an exception (P) which is not a subtype of ancestor exceptions 


coherent(p) //interfaces are always coherent
  where
  p.top()={interface implements _ mwts ncs}
    
coherent(p) //classes are coherent if they have a coherent set of abstract methods
  where
  p.top()={implements _ mwts' ncs} //note, no interface
  mwts={mwt in mwts'| mwt.e undefined } //collect the abstract methods
  either mwts is empty or
    there is exactly 1 class method with parameters (T x)s and n? such that 
      forall mwt in mwts coherent(n?,p,noFwd((T x)s), mwt) //all abstract methods are coherent according to those fields
      
m[n]==m_$_n
m[]==m
      
coherent(n?,p,T1 x1..Tn xn,
      refine? class method T m[n?] (T1' x1..Tn' xn) exception _)
  where
    p|- This0 <=T.P and p|-Ti'<=fwd Ti
    T.mdf!=class
    lent notin (T1..Tn).mdfs
    if T.mdf in {imm,capsule}, mut notin (T1..Tn).mdfs
    forall j in 1..n !=i, read != Tj.mdf
    if T.mdf notin {lent,read}, i=0


coherent(n?,p,T1 x1..Tn xn,
    refine? mdf method T m[n?]() exception _)
  where
  m=#?xi
  either
    mdf=mut and p|-capsuleToLent(Ti)<=T //exposer
  or 
    mdf in {read,imm} and p|-toRead(Ti)<=T //getter //note for James, toRead need to keep imm as imm, toRead code reverted again :)
  
coherent(n?,p,T1 x1..Tn xn,
    refine? mut method Void m[n?](T that) exception _)
  where
  m=#?xi
  p|-T<=Ti//setter
  if Ti=read then T.mdf in {capsule,imm}
 
----------------------------- 
6 Deteministic strategy for type system
-----------------------------
type system:
TSIn: Delta,e,T
TSOut: either OK(TSIn,e,T,Tr) or Error(TSIn,String,Opt(T)) //Error.T is the obtained type that is not a subtype of expected one.

object with 
-memoized hash map TSIn->TSOut

ts(TSIn in)->TSOut
  use Anonymous Visitor to dispatch to specific ts
tsPath(TSIn in,Path p)->TSOut //assert in.e == p, etc. for other cases
  ...follow rule Path...
..other cases...
  
structure of all tsXX methods://or just the dispatch one :-)
  TSOut res=_memoizedTSRes(in);
  if (res!=null){return res;}
  try{
    ... return res=e; ...
    }
  finally{memoizeTSRes(in,res);}//remember, memoizeTSRes need to not memoize null res
  
non trivial methods: tsBlock and tsMCall 

tsBlock(TsIn in,Block e)->TSOut
  res1=tsBlockBase(in,e)
  if res1.isOk(){return res=res1;}
  if !promotionMakesSense(){return res=res1;}//promotionMakesSense: mut that need capsule
  res2=tsBlockPromotion(in,e)//calls tsBlock internally,
  //thanks to promotionMakesSense does not goes in loop
  if res2.isOk(){return res=res2;}
  //if we are here, both res1,res2 not ok
  return res=combine(res1,res2)
  
splitDs(ds)->i
  //Algorithm to divide ds in the first minimal ds1, ds2
  ds=ds0..dsn;
  domi=dom(dsi+1..dsn)
  var xs=empty
  var i=0
  loop (
    xs= xs U  FV(ei)
    if (domi\xs) = domi then return i
    //cut will be from 0 to i included
    i:=i+1
    if i==n return i //ds.size-1
    )
   error X""// would be unreachable return i //that is, ds=d1..di , di+1..dn
  
tsMCall(TSIn in,MCall e)->TSOut
  Path rec=guessType(e.receiver)
  mTypes=computeMTypes(in.p,rec,e.ms)//TODO: in code error if meth not there
  //memoizing mTypes would be a mistake since we can not abstract over p and [from rec]
  // 1 select the first match with acceptable return type
  mType=_firstMatchReturn(TSIn.T,mTypes)
  if mType==null return res=Error???
  //unachievable return type (T) for method (P.ms) [line numbers of expression and declaration]
  //2 type all the parameters with mutOnlyToLent(Ts) //we may include mutOnlyToLent in the computation of the MTypes, instead of in the loop below
  resp=TSOut[with ei in e.es.withAlso(left:e.receiver), Ti in mTypes.Ts
    resi=ts(in.with(e:ei, t:mutOnlyToLent(Ti)))
    if !resi.isOk() return res=combineContext(TSIn,resi)
    use[resi]   
    ]
  assert forall r in resp, r.isOk()
  ---------------------
  mTypeRev=_bestMatchMtype(Ts[with r in resp (use[r.T])],TSIn.T,mTypes) 
  if mTypeRev!=null 
    return res=makeMCallOK(TSIn,resp,mTypeRev)//mTypeRev.returnType needed, and Trs[with r in resp (use[r.Tr])].collapse())
  //3 if there is no matching method, we may need to retype some mut
  //in capsule caused by mvp:
  //it is  not over if there is a mathing method type with mutToCapsule(result param types)
  tsToCaps=Ts[with r in resp (use[mutToCapsule(r.T)])] //TODO: If some mutToCapsule fails, then the whole methCall fails
  mTypeMVP=_bestMatchMtype(tsToCaps,TSIn.T,mTypes)
  ------------------
  if mTypeMVP==null Error????
  //this assert could not work: assert firstMatchParameters(tsToCaps,mTypesRes-mTypeMVP) fails
  //To be happy, we can retype the obtained mut parameters into expected capsule
  respMVP=TSOut[with ri in resp, T ti in mTypeMVP.TS (
    if (ri.mdf <= ti.mfd) (
      assert ri.mdf != Mdf.mut //James think this assertion may fail for ri/ti= read 
      use [ri]
      )
    else(
      assert ri.mdf == Mdf.mut
      assert ti.mdf == Mdf.capsule
      resi=ts(ri.in.with(expectedT:ti))
      if !resi.isOK()  return Error???
      use [resi]
      )
    )]
  assert forall r in respMVP, r.isOk()
  return res=makeMCallOK(TSIn,respMVP,mTypeMVP)

//Notes on mtypes obtained during testing:
-noFwd(mImmFwd(base))!=mI(mRead(base)), for example if
a read parameter is present in base, it becomes imm only on the left
-they can be different, and none of the two 
is always better (methT subtype)
//----
computeMTypes
  order of first list; //some entries may have the same value
  mBase
  mNoFwd(mBase)
  mImmFwd(mBase)
  mRead(mBase)
  mC(mBase)
  mC(mNoFwd(mBase))
  mI(mBase)
  mI(mRead(mBase))
  mNoFwd(mImmFwd(mBase))  
  mVp(mBase) //1 mType for each mut parameter
  mVp(mNoFwd(base))//1 mType for each mut parameter
  
_firstMatchReturn(T)
moves along the list and select the first with a
compatible return type
_bestMatchMtype(Ts->T)
for all the mt subtype of Ts->T, select the one with
the most precise return type

_memoizedTSRes(in) //need attention: we can not use .equals on p
  in=Phase,p,G,e,T
  equality on in will use the identity of p and e
  return map.get(in)
memoizeTSRes(in,res)
  assert map(in)==null
  return map.put(in,res)
  
  -------------
  Erorr structors and error improvments:
  -error safety interact badly with error messages:
    can we retype without error safety to discover where is the problem?
    can we identify when a certain variable is hidden/demotes?
  -method chunks? calling a(b(c(d))), where is the problem if 
  there is an invalid subtype, thanks to alternative method typing?
  should we blame the whole chunk?
  
  
  
  
  
----------------
Notes:
Coherent and union types:
to easy translation in Java/etc, we can not accept the following
A,B interface
C,D implements A,B

I implements C,D
class method This f(I x   )
mut method Void x ( C that)
mut method Void #x ( D that)
read method A x()
read method B #x()
as coherent, since the field would be an union type of C and D





--------------------------
Notationandgrammar:
e::=..|  x:=e
d::= var? T x=e | var? x=chain
chain::=..|(ds ks e) with guessable(ds ks e)
T::= mdf P /*remove skeletaltypes*/

d not well formed if var+capsule or var+fwd

guessable(ds e)=guessable(e)
guessable(ds ks catch throw x e ks' throw _)= guessable(e)
  with
  all e in {ks.es,ks'.es} of form throw _
  not catchRethrow(catch throw x e)

How to actually guess if is return?
guess(G, d1..dn ks catch return T x e ks' throw _)= guess(G[x:mdf T.P],e)
  with
  all e in {ks.es,ks'.es} of form throw _
  not catchRethrow(catch throw x e)
  mdf=mostGeneralMdf(guessMdf(G[d1..dn],d1.e)U..U guessMdf(G[d1..dn],dn.e))
  
guessMdf(G,void)=guessMdf(G,P)=guessMdf(G,L)=guessMdf(G,x)=..=empty
guessMdf(G,return e)=guess(G,e).mdf
guessMdf(G,(ds k1..kn e))=guessMdf(G,e)U?? guessMdf(G[ki.x:ki.T],ki.e).. 
  with return =ki.throw
// do we still have a limit that all the catches must catch the same kind of throw?
otherwise
guessMdf(G,(d1..dj k1..kn e))=guessMdf(G,e) 
  U guessMdf(G[k1.x:k1.T],k1.e) U..U guessMdf(G[kn.x:kn.T],kn.e)
  U guessMdf(G[d1..dj],d1.e) U..U guessMdf(G[d1..dj],dj.e)
  
D::= ...;xs //the var in G//no added to the G as var?

(xUpdate)//TODO: to move up
D |-x:=e ~> x:=e' :imm Void <= T | Tr
  where
  D.G(x).var?=var
  D.p|- imm Void <= T
  D|- e ~> e':_<=D.G(x).T|Tr
  not fwd_or_fwd%_in(D.G(x).T)
  //TODO: note the change in toRead and toLent!!
 in rule ds now we add the guessed T to ds without T; this
 can cause a type error if guessed is capsule and d is var
 since d not well formed if var+capsule
 Note: capsule P is never guessed, is demoted to mut P,
 to avoid suprisingly use only onece references.