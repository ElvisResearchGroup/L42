
-----------------------------------------------------------
Part 2: reduction rules and notations
-----------------------------------------------------------
depend on:
 Phase|p|empty|empty|empty|-e ~> e' : T
 Phase |-p ~> L
 e -->p+ r //we discussued with James: should we use ~> or a kind of big step arrow for type judgment that do annotation?
 
-----------------------------------------------------------
### reduction rules
ReductionTop:
precondition: at top level we have a L not of form LC

r::=LC| exception v | error v
 
          eC' -->p'+ r              p.top()={_ implements Ps0, MCs  C:eC Ms}
(top)------------------------       eC not of form LC
     p ==> p'.update(p'.top()[C=L]) <paths; paths'>=usedPathsE(p,eC) //tuple notation
                                    p0=multiNorm(p,paths U paths')//norm the part of p required by eC
                                    path;paths' ||-p0 ~> p' //the part of p' referred to by paths' is well typed
                                    Norm | p'| empty| empty| empty |-toAny(paths,eC) ~> _ : imm Library //replace paths with Any //eC is well typed
                                    Norm | p'| empty| empty| empty |-eC ~> eC' : imm Library //duplicated typing, so we can have eC non with Anys
                                    L=refreshUniqueNames(r) //may fail if r not of form L, and that would be lifted as compilation error.
                                    


        p.push(ctxL, L)==>+ p'      p.top()={interface? implements Ps, MCs  M Ms}
(enter)-------------------------    M not of form MC
          p ==> p'.pop()            M.e=ctxC[L], L not of form LC
                                    ctxL={interface? implements Ps, MCs  M[with e=ctxC] Ms}
                                    p'.top() of form LC

------------------------------------------
###define methods(p,P)=Ms

subdefinitions:
//if in the sum we have two normalized implements lists Ps1, Ps2, then the resulting Ps0= Ps1\Ps2, Ps2 follows the "collect order"
-collect(p,empty)=empty  
  //an implementation could keep a list of visited P instead of diverging, mathematically is the same.
-collect(p,P0 Ps)=(P0,Ps')\collect(p,Ps), collect(p,Ps) //that is,crucially: dept first but we avoid duplicates by keeping the rightmost occurence.  
  p(P0)={_ implements Ps0 _}
  Ps'=collect(p,Ps0[from P0])
  //this check absence of circularity by looping
  //TODO Note for marco: we remove circularity; update operator sum; plus add privatly implemented concept/error
  //may be a good strategy could be that 
  //"sum can not add abstract implemented methods", this enforces adding either equal hierarchies with different operators, or different hierarchies with equal operators.
  //Or we can make this kind of check happens as extra at the end of multiple sums?

maindefinition:
-methods(p,P0)=M1'..Mk'
  p(P0)={interface? implements Ps Ms Phase}
  if Phase!=None, M1'..Mk' are extracted from Ms[from P0]//TODO
  P1..Pn=collect(p,Ps[from P0]), error unless forall i in 1..n, p(Pi) is an interface
  ms1..msk={ms|forall i in 0..n : p(Pi)(ms) is defined}//Note, in the code it (properly implemented but) is done in 2 steps, first cb0, then p1n
  forall ms in ms1..msk, there is exactly 1 j in 0..n //TODO: this is problematic: In case multiple P are either exactly the same or points to the same interface!! for now the problem is just hacked away in the code
    such that p(Pj)(ms)=mh e? //no refine
  //cases like A:  {interface refine method A()}  B: { implements A method A()} are ok wrt B but fails for A  
  forall i in 1..k //i comes from k in ms1..msk
    Mi= p(P0)(msi)[from P0] if it is of form  refine? mh e?,
    otherwise
    Mi=addRefine(methods(p,Pj)(msi)) //ok if it stay the same since already refine
      for the smallest j in 1..k such that methods(p,Pj)(msi) of form refine? mh
  
    Mi'=Mi[with e=p(P0)(msi).e[from P0]] if defined,
    otherwise
    Mi'=Mi

------------------------------------------
###define norm(p,e)=e
subdefinitions:
-resolve(p,mdf P)=mdf P
-resolve(p,P::ms)=resolve(p,T)//and avoid circularity
  methods(p,P)(ms)=refine? _ method T ms e?
-resolve(p,P::ms::x)=resolve(p,T)//and avoid circularity
  methods(p,P)(ms)=refine? _ method _ _( _ T x _) e? 
-resolve(p,P::msx::msxs)=resolve(p,P'::msxs) //here be carefull for possible infinite recursion 
  resolve(p,P::msx)= _ P'              
  
maindefinition:

-norm(p,L)=norm(p.push(L))//can be evilPush
-norm(p)=p.top()
  if p.top().phase!=None
  otherwise
-norm(p)={interface? implements Ps' norm(p,Ms') Norm}
 p.top()={interface? implements Ps Ms} //Ms is free var and is ok
 Ps'=collect(p,Ps) //Marco does not likes that Ps get reordered also if they are all present, but is hard to predict what will happen if not reorder only in that fragile circustance
 Ms'=methods(p,This0), {C:e in Ms} //norm now put all the nested classes in the back.
  
//norm(p,ms e) should never be call 

-norm(p,refine? mh e?)= refine? resolve(p,mh) e'?
  where e'?=empty if e?=empty
  otherwise e'?= e where we replace all Li inside e?
    with norm(p,Li) 
    
-norm(p, C:L) =C:norm(p,L)
//we could do a norm(p.push(C)) to avoid an evil push, now we do not, the code seams to work fine.

------------------------------------------
### define multiNorm(p,paths)

- multiNorm(p,empty) = p

- multiNorm(p, Cs1..Csn)/*a single Css*/= p.update(L)
  pi = p.navigate(Csi) 
  Li = norm(pi)//norming the top
  L = p.top()[Cs1=L1..Csk=Lk] //replace the nested classes in paths Csi with libraries Li.

- multiNorm(p, Css,paths) =multiNorm(p',Css) 
  p'=p.growFellow(multiNorm(p.pop(), paths))
   
------------------------------------------     
###define usedPathsE
//note we could have redundant paths, like This1.C and This2.B.C and is ok
//and this is also ok for path,path' for toAny
- usedPathsE(p,eC)= <path\paths';paths'>//assert that the result includes paths in usedPathsFix(p,paths, empty)  
 =Ps,Ps'={P|P inside eC}//arbitrary split of the set; heuristic will apply in the implementation.
  paths'=usedPathsFix(p,reorganize(Ps'), empty,Coherent)
  paths0=reorganize(Ps,Ps') U paths' U (deepImplements(L1)U..U deepImplements(Ln)).pop()
  paths=usedPathsFix(p,paths0, empty,Typed)
  L1..Ln={L| L inside eC}//in path not prime// not repeat check stage

- deepImplements(L0)=reorganize(L0.Ps)
  U (deepImplements(L1) U..deepImplements(Ln)).pop()
  L1..Ln={L|L in M, M in L0.Ms}//TODO> was L instead of L0, check in code 
 
- usedPathsFix(p,paths,Css,Phase0)= usedPathsFix(p, paths U paths0,Css',Phase0) // U on paths does minimize() internally
  paths.top()\Css!=empty
  paths0=usedPathsL(p.top(),paths.top()\Css,Phase0)
  Css'=minimize(paths.top() U Css)
     
- usedPathsFix(p,paths,Css,Phase0)=paths0
  paths.top()\Css==empty
  if paths.pop() not empty
    paths0=usedPathsFix(p.pop(),paths.pop(),empty,Phase0).push(Css)
  otherwise //this if is to avoid p.pop() undefined
    paths0=empty.push(Css)
- usedPathsFix(p,empty,empty,Phase0) =empty   
    
- usedPathsL(L, Cs1..Csn,Phase0)=usedInnerL(L(Cs1),Cs1,Phase0) U ... U usedInnerL(L(Csn),Csn,Phase0)
  where for all i in 1..n 
  Csi=C._
  L(C) of form LC //this allows for clearer error messages and less fragile code

- usedInnerL(LC,Cs,Phase0)=paths.prefix(Cs)
  LC={_ implements Ps, M1..Mn Phase}//in implementation, error if not compiled
  paths=reorganize(Ps) U usedInnerM(M1,Phase0) U... U usedInnerM(Mn,Phase0))
  Phase in{None,Norm}
  
- usedInnerL(LC,Cs,Phase0)=empty //TODO: Possible huge performance boost when implemented. Not implemented at 1/10/2016
  LC.Phase not in{None,Norm}

- usedInnerM(C:L,phase0)= usedInnerL(L,empty,phase0).pop()
- usedInnerM(M,Coherent)=reorganize({P| P inside M}) 
    with M not of form C:L
- usedInnerM(M,Typed)=reorganize({P| P inside M}) 
    U (usedInnerL(L1,empty,Typed) U...U usedInnerL(Ln,empty,Typed)).pop()
    L1..Ln={L| L inside M.e?}
    with M not of form C:L

  non determinism heuristic:
  **if P.m(_) inside e, P not Any
  **if ( _ T x=P _ _) inside e and T!=class Any, P not Any.
  **if p(Pi).Phase=Typed, Pi is not Any
  **if ( _ T x=_  _ _) inside e, T.P not Any
  **if catch throw T x _ inside e, T.P not Any  
  **if using P _ _ inside e, P not Any
  **if catch T inside e, T.P not Any
  otherwise, P is considered of type class Any.
  // note that user can always force a not any by writing (x=P x)
  // note, if p(P) not defined, the path will be consider an any, and error will be rised somewhere else.

------------------------------------------     
###define toAny
- toAny(Css0..Cssn,eC)=eC iff forall i in 0..n, Cs in Cssi, not Thisi.Cs inside eC
  otherwise toAny(Css0..Cssn, ctxC[Thisi.Cs])=toAny(Css1..Cssn,ctxC[Any]) 
  where Cs in Cssi

------------------------------------------     
###define paths ||-p ~> p    //James may like notation path ||- p~>p' to underline is an addition layer

  paths;path' ||-p ~> p'
  
        paths;path' ||- p.pop() ~> p0
        Css; Css' ||-p1 ~> L
(pPop)----------------------------------  p1=p.growFellow(p0)
        Css paths;Css'path' ||- p  ~>  p1.update(L)
  

         Css;Css' ||-p ~> L
(pNoPop)--------------------------------  p.pop() undefined
         Css;Css'  ||- p  ~> L,empty


(pEmpty)--------------------------------
         empty;empty ||- p ~> p

// the type system can be optimized to just assert  tests for libraries that are
// annotated as already checked 
// However, this is  the responsibility of the TS and not MultiTypeSystem
     forall Csi in 1..n : Typed |-p.navigate(Csi) ~> Li 
     forall Csi' in 1..k: Coherent |-p.navigate(Csi') ~> Li' 
(pL) --------------------------------------- 
     Cs1..Csn;Cs1'..Csk' ||-p ~> p.top()[Cs1=L1,.. Csn=Ln][Cs1'=L1'..Csk'=Lk']    //Li will have Phase=Typed also inside all somehow contained Ls
//assert Csi' not contained, even as postfix in Cs1..Csn
 