The execution of a 42 project can be seen as a state machine with
that proceeds through the following phases:
0 parsing
1 desugaring
2 from the top, find the left-most inner-most C:eC with eC!=LC
3 collect all the transitive dependencies of eC.
4 type these dependencies.
5 type as "coherent" (aka not abstract) all dependencies needed to execute eC.
6 type eC:Library in the program composed by those dependencies.
7 execute eC until you get an LC, and replace eC with LC in the program
8 jump back to 2. 

The rules exposed here covers 2-8, and depends on other notations defined in this file
and on reduction (in progress) and typing defined in other files.
Paths (introduced later in the file) represent organized/restricted collections of P.

-----------------------------------------------------------
Part 1: 42 top level reduction rules
-----------------------------------------------------------
### reduction rules
ReductionTop:
precondition: at top level we have a L not of form LC
Rule top performs a step of execution, while rule enter
propagates the execution inside nested classes and method bodies.


r::=LC| exception v | error v

(top)                                   
p ==> p'.update(p'.top()[C=L]) 
  where
  p.top()={_ implements Ps0, MCs  C:eC Ms}//MCs are already compiled
  eC not of form L//thus eC is the first point to execute
  paths'=tryCoherentPaths(p,eC)//TODO: we change lots in here update code also for ||-
  paths=tryTypedPaths(p,eC)
  //paths and paths' represents the Ps recursively used by eC,
  //paths' needs to be coherent, while paths needs only to be typed
  p0=multiNorm(p; paths)//norm the part of p required by eC
  paths;paths' ||-p0 ~> p' //type all the paths
  Norm | p'| empty |-eC ~> eC' : _<= imm Library //typing eC normally
  Norm | p'| empty |-toAny(paths',eC) ~> _ :_<= imm Library //check that even replacing paths with Any eC is well typed
  eC' -->p'+ r //execute the expression under the program and obtain a result
  L=refreshUniqueNames(r) //may fail if r not of form L, and that would be lifted as compilation error.

(enter)
p ==> p'.pop()
  where
  p.push(ctxL, L)==>+ p' 
  p.top()={interface? implements Ps, MCs  M Ms}
  M not of form MC
  M.e=ctxC[L], L not of form LC
  ctxL={interface? implements Ps, MCs  M[with e=ctxC] Ms}
  p'.top() of form LC //Note: p' is one level deeper than p,
  // and p'.top() is the LC result of metaprogramming L



-----------------------------------------------------------
Part 2: paths //James suggest name "stset" for Paths
-----------------------------------------------------------
"paths" is a datastructure to store P1..Pn in a organized way:
The idea is to store them as a stack, where the first level
stores subtrees rooted in  This0, the second level store the ones rooted
in This1 and so on.
Moreover, if Thisn.Cs is present, then we do not store
any of its sub paths Thisn.Cs.Cs'.
We model this idea with
- minimize(Css)={Csi in Css | forall Csj in Css\Csi,  Csj._!=Csi}//Note: _ can be the empty Cs

- paths::= Csss //list of set of list of C

We construct paths from P1..Pn as follow:
 -reorganize(empty)=empty
 -reorganize(Ps)=Css0',...,Cssn'
  Cs in Cssi iff Thisi.Cs in Ps //this filter out Any,Void, Library since they have no Thisi
  Cssn!=empty
  Cssi'=minimize(Cssi)

Simple operations:
 -(Css paths).top()=Css
 -empty.top()=empty

 -(Css paths).pop()=paths
 -empty.pop()=empty
 
 -paths.push(Css)=minimize(Css) paths
 
 -(Css paths) U (Css' paths')=(paths U paths').push(Css U Css')
 -paths U empty=empty U paths = paths

//TODO: remove  (Css paths) \(Css' paths') from code

The prefix operation adds Cs in front of all the P in paths.
It is unobvious since we need to consider the n in Thisn.
for example: reorganize(This0.A,This1.B,This2.C,This3.D)=((A)  (B)  (C)  (D));
((A)  (B)  (C)  (D)).prefix(W.E) = ((W.E.A  W.B  C) (D)),
representing paths This0.W.E.A  This0.W.B  This0.C This1.D
//Note: prexifx() and [from _] are related: reorganize(Ps[from This0.Cs])=reorganize(Ps).prefix(Cs)

 -empty.prefix(_)=empty
 -paths.prefix(empty)= paths
 -(Cs1..Csn).prefix(Cs)=Cs.Cs1 .. Cs.Csn
 -(Css paths).prefix(Cs.C)= Css.prefix(Cs.C) U paths.prefix(Cs)
//the formalization relies on Cs1..Csn being a set.  
//TODO: in code remove duplicates from the list

-----------------------------------------------------------
Part 3: methods(p,P)=Ms,  collect(p,Ps)=Ps'
-----------------------------------------------------------
methods(), applied to a non normalized L, will return a mixture of
the methods written directly into the L and methods declared in its
implemented interfaces.
methods() collects such methods and their types. It may have to choose a type
in case of methods refined in different ways from interface diamond implements.

_______
#define collect(p,Ps)=Ps' //collects transitively implemented interfaces
-collect(p,empty)=empty  
  //an implementation could keep a list of visited P instead of diverging, mathematically is the same.
-collect(p,P0 Ps)=((P0 Ps') \p collect(p,Ps)) collect(p,Ps) //that is,crucially: dept first but we avoid duplicates by keeping the rightmost occurence.  
  p(P0)={interface implements Ps0 _}//TODO: add check for "interface" in code
  Ps'=collect(p,Ps0[from P0])
  where "\p" is set minus on lists using p.equiv(P1,P2) //TODO: update code, this should fix concern in TODO "just hacked away"
  //this checks absence of circularity by looping

_______
#define methods(p,P0)=M1'..Mk' //methods returns a set: the order of the methods is not relevant
  p(P0)={interface? implements Ps Ms Phase}
  if Phase!=None, M1'..Mk' are extracted from Ms[from P0]//TODO: do it in the code
  P1..Pn=collect(p,Ps[from P0])
  //TODO: in code move the check for "error unless forall i in 1..n, p(Pi) is an interface" into the former definition
  ms1..msk={ms|exists i in 0..n : p(Pi)(ms) is defined}//Note, in the code it is(properly implemented but) done in 2 steps, first cb0, then p1n
  forall ms in ms1..msk, there is exactly 1 j in 0..n //TODO: this is problematic: In case multiple P are either exactly the same or points to the same interface!! for now the problem is just hacked away in the code; may be is solved by change in collect "\p"
    such that p(Pj)(ms)=mh e? //no refine
  forall i in 1..k //i comes from k in ms1..msk
    Mi= p(P0)(msi)[from P0] if it is of form  refine? mh e?,
    otherwise
    Mi=addRefine(methods(p,Pj)(msi)) //ok if it stay the same since already refine
      for the smallest j in 1..k such that methods(p,Pj)(msi) of form refine? mh
    //this ordering of j leverages the smart ordering of collect() 
    Mi'=Mi[with e=p(P0)(msi).e[from P0]] if defined,
    otherwise
    Mi'=Mi
//Note, in this model cases like 
//"A:  {interface refine method A m()} 
// B: { implements A method A m()}"
// are ok wrt B but fails for A  


-----------------------------------------------------------
Part 4: norm(p)=L, multiNorm 
-----------------------------------------------------------
_______
#define alive(p,P) //check if P is defined or has hope to be defined in the future
alive(p,Any),alive(p,Void),alive(p,Library) holds
alive(p,Thisn.Cs)=alive(p(Thisn),Cs) //TODO: we assume the sugar
// will check for all paths to be alive after desugaring
alive(L,empty) holds
alive(L,C.Cs) if L(C)=L' and alive(L',Cs)
  or  L(C)=e not of form L // or L doc
_______
#define norm(p,L)=norm(p.evilPush(L))

_______
#define norm(p)=L
-norm(p)=p.top()
  if p.top().phase!=None
  otherwise
-norm(p)={interface? implements Ps' norm(p,Ms') Norm}
 p.top()={interface? implements Ps Ms}
 Ps'=collect(p,Ps) //Marco does not likes that Ps get reordered also if they are all present, but is hard to predict what will happen if not reorder only in that fragile circustance
 Ms'=methods(p,This0)\Ms.mss, [methods(p,This0)(M.ms)| M in Ms],[C:e| C:e in Ms]
 //TODO: former line now have well defined order (for the 2nd and 3rd part). Fix the order in the code 

-norm(p,refine? mh e?)= refine? mh e'?
  where e'?=empty if e?=empty
  otherwise e'?= e where we replace all Li inside e?
    with norm(p,Li)
  forall P inside mh e?, alive(p,P)//TODO: add in code 
    
-norm(p, C:L) =C:norm(p,L)
//we could do a norm(p.push(C)) to avoid an evil push, now we do not, the code seams to work fine.

_______
#define multiNorm(p; paths)=p' //multinorm assumes that p does not have evil pushes

- multiNorm(p; empty) = p //Note: for populated paths, the end point of recursion is the next clause

- multiNorm(p; Cs1..Csn)= p.update(L)//case of paths= a single Css
  pi = p.navigate(Csi) 
  Li = norm(pi)//norming the top
  L = p.top()[Cs1=L1..Csk=Lk] //replace the nested classes in paths Csi with libraries Li.

- multiNorm(p; Css,paths) =multiNorm(p'; Css) 
  p'=p.growFellow(multiNorm(p.pop(); paths))



-----------------------------------------------------------
Part 5: reachability
-----------------------------------------------------------
//note we could have redundant paths, like This1.C and This2.B.C and is ok
//and this is also ok for paths,paths' for toAny

-tryCoherentPaths(p,eC)=reachablePaths(p,reorganize(Ps'), empty,empty)
  _,Ps'={P|P inside eC}//arbitrary split of the set; heuristic as modeled later will apply in the implementation

-tryTypedPaths(p,eC)=reachablePaths(p,paths0, empty,Typed)
  paths0=reorganize({P|P inside eC}) U (stronglyDeepImplements(L1)U..U stronglyDeepImplements(Ln)).pop()
  L1..Ln={L| L inside eC}//in path not prime// not repeat check stage

- stronglyDeepImplements(L0)=reorganize(L0.Ps)
  U (stronglyDeepImplements(L1) U..stronglyDeepImplements(Ln)).pop()
  L1..Ln={L|L inside M.e, M in L0.Ms}//TODO: was L instead of L0, check in code 
 
- reachablePaths(p,paths,Css,Typed?)= reachablePaths(p, paths U paths0,Css',Typed?) // U on paths does minimize() internally
  paths.top()\Css!=empty
  Cs1..Csn=paths.top()\Css
  paths0=usedInnerL(p.top()(Cs1),Cs1,Typed?) U ... U usedInnerL(p.top()(Csn),Csn,Typed?)
  error if Csi= C._ and L(C) not of form LC //this allows for clearer error messages and less fragile code
  Css'=minimize(paths.top() U Css)  
     
- reachablePaths(p,paths,Css,Typed?)=paths0
  paths.top()\Css==empty
  if paths.pop() not empty
    paths0=reachablePaths(p.pop(),paths.pop(),empty,Typed?).push(Css)
  otherwise //this if is to avoid p.pop() undefined
    paths0=empty.push(Css)
- reachablePaths(p,empty,empty,Typed?) =empty   
    
- reachableFromL(LC,Cs,Typed?)=paths.prefix(Cs)
  LC={_ implements Ps, M1..Mn Phase}//in implementation, error if not compiled
  paths=reorganize(Ps) U reachableFromM(M1,Typed?) U... U reachableFromM(Mn,Typed?))
  Phase in{None,Norm}
  
- reachableFromL(LC,Cs,Typed?)=empty //TODO: Possible huge performance boost when implemented. Not implemented at 1/10/2016
  LC.Phase not in{None,Norm}

- reachableFromM(C:L,Typed?)= reachableFromL(L,empty,Typed?).pop()
- reachableFromM(mwt,empty)=reorganize({P| P inside mwt}) 
- reachableFromM(mwt,Typed)=reorganize({P| P inside mwt}) 
    U (reachableFromL(L1,empty,Typed) U...U reachableFromL(Ln,empty,Typed)).pop()
    L1..Ln={L| L inside mwt.e?}

  non determinism heuristic used in tryCoherentPaths(p,eC):
  **if P.m(_) inside e, P in Ps'
  **if p(Pi).Phase=Coherent, Pi  in Ps' // note, if p(P) is not defined, the path will be consider an any, and error will be raised somewhere else. 
  **if ( _ T? x=P _ _) inside e and T? != class Any, P in Ps'.
  **if ( _ T x=_  _ _) inside e, T.P  in Ps'//TODO: update the code for this heuristic
  **if catch throw T x _ inside e, T.P  in Ps'  
  **if using P _ _ inside e, P  in Ps'
  **if catch T inside e, T.P  in Ps'
  otherwise, P is in Ps instead of Ps'.
  // note that user can always force a not any by writing (x=P x)
  

-----------------------------------------------------------
Part 6: paths;paths' ||-p ~> p,  toAny(paths, eC) //assumes that p does not have evil pushes
-----------------------------------------------------------
(pPop)
paths;paths' ||- p  ~>  p1.update(L)
  where
  p1=p.growFellow(p0)
  paths.pop();paths'.pop() ||- p.pop() ~> p0
  paths.top(); paths'.top() ||-p1 ~> L
  
(pNoPop)
Css;Css'  ||- p  ~> L,empty // 'L,empty' is a program with only 1 level
    where
    p.pop() undefined
    Css;Css' ||-p ~> L

(pEmpty)
empty;empty ||- p ~> p

(pL)
Css;Cs1'..Csk' ||-p ~> p'[Cs1'=L1'..Csk'=Lk']    //Li will have Phase=Typed also inside all somehow contained Ls
  where
  Cs1..Csn=Css\Cs1'..Csk' 
  forall Csi in 1..n : Typed |-p.navigate(Csi) ~> Li 
  p'=p.top()[Cs1=L1,.. Csn=Ln]//TODO: in code, insert p' to avoid scribbling over
  forall Csj' in 1..k: Coherent |-p'.navigate(Csj') ~> Lj' 
  //assert Csj' not contained, even as postfix in Cs1..Csn //Note: James believe this does not hold
  // the type system can be optimized to just assert  tests for libraries that are
  // annotated as already checked 
  // However, this is  the responsibility of the TS and not MultiTypeSystem
_______
#define toAny(paths', eC)//TODO: update in code, now it takes paths' instead of paths and have inverted behavior
- toAny(Css0..Cssn,eC)=eC iff forall Thisi.Cs inside eC, Cs in Cssi
  otherwise toAny(Css0..Cssn, ctxC[Thisi.Cs])=toAny(Css1..Cssn,ctxC[Any]) 
  where forall i in 0..n, Cs notin Cssi
 