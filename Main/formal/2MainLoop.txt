The execution of a 42 project can be seen as a state machine with
that proceeds through the following phases:
0 parsing
1 desugaring
2 from the top, find the left-most inner-most C:eC with eC!=LC
3 collect all the transitive dependencies of eC.
4 type these dependencies.
5 type as "coherent" (aka not abstract) all dependencies needed to execute eC.
6 type eC:Library in the program composed by those dependencies.
7 execute eC until you get an LC, and replace eC with LC in the program
8 jump back to 2. 

The rules exposed here covers 2-8, and depends on other notations defined in this file
and on reduction (in progress) and typing defined in other files.
Paths (introduced later in the file) represent organized collections of P.

-----------------------------------------------------------
Part 1: 42 top level reduction rules
-----------------------------------------------------------
### reduction rules
ReductionTop:
precondition: at top level we have a L not of form LC
Rule top performs a step of execution, while rule enter
propagates the execution inside nested classes and method bodies.


r::=LC| exception v | error v

(top)                                   
p ==> p'.update(p'.top()[C=L]) 
  where
  p.top()={_ implements Ps0, MCs  C:eC Ms}//MCs are already compiled
  eC not of form LC//thus eC is the first point to execute
  <paths; paths'>=usedPathsE(p,eC) //paths U paths' are the Ps recursively used by eC, paths need not to be executable
  p0=multiNorm(p,paths U paths')//norm the part of p required by eC
  path;paths' ||-p0 ~> p' //type all the paths
  Norm | p'| empty| empty| empty |-eC ~> eC' : imm Library //typing eC normally
  Norm | p'| empty| empty| empty |-toAny(paths,eC) ~> _ : imm Library //check that even replacing paths with Any eC is well typed
  eC' -->p'+ r //execute the expression under the program and obtain a result
  L=refreshUniqueNames(r) //may fail if r not of form L, and that would be lifted as compilation error.

(enter)
p ==> p'.pop()
  where
  p.push(ctxL, L)==>+ p' 
  p.top()={interface? implements Ps, MCs  M Ms}
  M not of form MC
  M.e=ctxC[L], L not of form LC
  ctxL={interface? implements Ps, MCs  M[with e=ctxC] Ms}
  p'.top() of form LC



-----------------------------------------------------------
Part 2: paths //James suggest name "stset" for Paths
-----------------------------------------------------------
"paths" is a datastructure to store P1..Pn in a organized way:
The idea is to store them as a stack, where the first level
stores subtrees rooted in  This0, the second level store the ones rooted
in This1 and so on.
Moreover, if Thisn.Cs is present, then we do not store
any of its sub paths Thisn.Cs.Cs'.
We model this idea with
- minimize(Css)={Cs1 in Css | forall Cs2 in Css\Cs1,  Cs2._!=Cs1}

- paths::= Csss //list of set of list of C

We construct paths from P1..Pn as follow:
 -reorganize(empty)=empty
 -reorganize(Ps)=Css0,...,Cssn
  Cssn!=empty
  Cs in Cssi' iff Thisi.Cs in Ps
  Cssi=minimize(Cssi')

Simple operations:
 -(Css paths).top()=Css
 
 -(Css paths).pop()=paths
 -empty.pop()=empty
 
 -paths.push(Css)=minimize(Css) paths
 
 -(Css paths) U (Css' paths')=(paths U paths').push(Css U Css')
 -paths U empty=empty U paths = paths

 -(Css paths) \(Css' paths')=(path\path').push(Css\Css')
   where Css\Css' ={Cs in Css|  Cs._ notin Css'}


The prefix operation adds Cs in front of all the P in paths.
It is unobvious since we need to consider the n in Thisn.
for example: reorganize(This0.A,This1.B,This2.C,This3.D)=((A)  (B)  (C)  (D));
((A)  (B)  (C)  (D)).prefix(W.E) = ((W.E.A  W.B  C) (D)),
representing paths This0.W.E.A  This0.W.B  This0.C This1.D

 -empty.prefix(_)=empty
 -paths.prefix(empty)= paths
 -(Cs1..Csn).prefix(Cs)=Cs.Cs1 .. Cs.Csn
 -(Css paths).prefix(Cs.C)= paths.prefix(Cs) U Css.prefix(Cs.C)
  


-----------------------------------------------------------
Part 3: methods(p,P)=Ms,  collect(p,Ps)=Ps'
-----------------------------------------------------------
A non normalized L may have methods from its implemented interfaces.
Methods collect such methods and their type. It may have to choose a type
in case of differently refined methods from interface diamond implements.

_______
#define collect(p,Ps)=Ps' //collects transitively implemented interfaces
-collect(p,empty)=empty  
  //an implementation could keep a list of visited P instead of diverging, mathematically is the same.
-collect(p,P0 Ps)=(P0,Ps')\collect(p,Ps), collect(p,Ps) //that is,crucially: dept first but we avoid duplicates by keeping the rightmost occurence.  
  p(P0)={_ implements Ps0 _}
  Ps'=collect(p,Ps0[from P0])
  //this check absence of circularity by looping

_______
#define methods(p,P0)=M1'..Mk' //methods returns a set: the order of the methods is not relevant
  p(P0)={interface? implements Ps Ms Phase}
  if Phase!=None, M1'..Mk' are extracted from Ms[from P0]//TODO: do it in the code
  P1..Pn=collect(p,Ps[from P0]), error unless forall i in 1..n, p(Pi) is an interface
  ms1..msk={ms|forall i in 0..n : p(Pi)(ms) is defined}//Note, in the code it is(properly implemented but) done in 2 steps, first cb0, then p1n
  forall ms in ms1..msk, there is exactly 1 j in 0..n //TODO: this is problematic: In case multiple P are either exactly the same or points to the same interface!! for now the problem is just hacked away in the code
    such that p(Pj)(ms)=mh e? //no refine
  forall i in 1..k //i comes from k in ms1..msk
    Mi= p(P0)(msi)[from P0] if it is of form  refine? mh e?,
    otherwise
    Mi=addRefine(methods(p,Pj)(msi)) //ok if it stay the same since already refine
      for the smallest j in 1..k such that methods(p,Pj)(msi) of form refine? mh
    Mi'=Mi[with e=p(P0)(msi).e[from P0]] if defined,
    otherwise
    Mi'=Mi
//Note, in this model cases like 
//"A:  {interface refine method A()}  B: { implements A method A()}"
// are ok wrt B but fails for A  


-----------------------------------------------------------
Part 4: norm(p)=L, multiNorm 
-----------------------------------------------------------
//TODO: thinking if norm should check that all paths are not doomed
//i.e. available somewhere or still pointing to meta

_______
#define norm(p,L)=norm(p.evilPush(L))

_______
#define norm(p)=L
-norm(p)=p.top()
  if p.top().phase!=None
  otherwise
-norm(p)={interface? implements Ps' norm(p,Ms') Norm}
 p.top()={interface? implements Ps Ms}
 Ps'=collect(p,Ps) //Marco does not likes that Ps get reordered also if they are all present, but is hard to predict what will happen if not reorder only in that fragile circustance
 Ms'=methods(p,This0)\Ms.mss, [methods(p,This0)(M.ms)| M in Ms],[C:e| C:e in Ms]
 //TODO: former line now have well defined order (for the 2nd and 3rd part). Fix the order in the code 

-norm(p,refine? mh e?)= refine? mh e'?
  where e'?=empty if e?=empty
  otherwise e'?= e where we replace all Li inside e?
    with norm(p,Li) 
    
-norm(p, C:L) =C:norm(p,L)
//we could do a norm(p.push(C)) to avoid an evil push, now we do not, the code seams to work fine.

_______
#define multiNorm(p,paths)=p'

- multiNorm(p,empty) = p

- multiNorm(p, Cs1..Csn)= p.update(L)//case of paths= a single Css
  pi = p.navigate(Csi) 
  Li = norm(pi)//norming the top
  L = p.top()[Cs1=L1..Csk=Lk] //replace the nested classes in paths Csi with libraries Li.

- multiNorm(p, Css,paths) =multiNorm(p',Css) 
  p'=p.growFellow(multiNorm(p.pop(), paths))



-----------------------------------------------------------
Part 5: usedPathsE(p,eC)= <path;paths'>
-----------------------------------------------------------
//note we could have redundant paths, like This1.C and This2.B.C and is ok
//and this is also ok for path,path' for toAny

- usedPathsE(p,eC)= <path\paths';paths'>//assert that the result includes paths in usedPathsFix(p,paths, empty)  
  Ps,Ps'={P|P inside eC}//arbitrary split of the set; heuristic as modeled later will apply in the implementation.
  paths'=usedPathsFix(p,reorganize(Ps'), empty,Coherent)
  paths0=reorganize(Ps,Ps') U paths' U (deepImplements(L1)U..U deepImplements(Ln)).pop()
  paths=usedPathsFix(p,paths0, empty,Typed)
  L1..Ln={L| L inside eC}//in path not prime// not repeat check stage

- deepImplements(L0)=reorganize(L0.Ps)
  U (deepImplements(L1) U..deepImplements(Ln)).pop()
  L1..Ln={L|L in M, M in L0.Ms}//TODO> was L instead of L0, check in code 
 
- usedPathsFix(p,paths,Css,Phase0)= usedPathsFix(p, paths U paths0,Css',Phase0) // U on paths does minimize() internally
  paths.top()\Css!=empty
  paths0=usedPathsL(p.top(),paths.top()\Css,Phase0)
  Css'=minimize(paths.top() U Css)
     
- usedPathsFix(p,paths,Css,Phase0)=paths0
  paths.top()\Css==empty
  if paths.pop() not empty
    paths0=usedPathsFix(p.pop(),paths.pop(),empty,Phase0).push(Css)
  otherwise //this if is to avoid p.pop() undefined
    paths0=empty.push(Css)
- usedPathsFix(p,empty,empty,Phase0) =empty   
    
- usedPathsL(L, Cs1..Csn,Phase0)=usedInnerL(L(Cs1),Cs1,Phase0) U ... U usedInnerL(L(Csn),Csn,Phase0)
  where for all i in 1..n 
  Csi=C._
  L(C) of form LC //this allows for clearer error messages and less fragile code

- usedInnerL(LC,Cs,Phase0)=paths.prefix(Cs)
  LC={_ implements Ps, M1..Mn Phase}//in implementation, error if not compiled
  paths=reorganize(Ps) U usedInnerM(M1,Phase0) U... U usedInnerM(Mn,Phase0))
  Phase in{None,Norm}
  
- usedInnerL(LC,Cs,Phase0)=empty //TODO: Possible huge performance boost when implemented. Not implemented at 1/10/2016
  LC.Phase not in{None,Norm}

- usedInnerM(C:L,phase0)= usedInnerL(L,empty,phase0).pop()
- usedInnerM(M,Coherent)=reorganize({P| P inside M}) 
    with M not of form C:L
- usedInnerM(M,Typed)=reorganize({P| P inside M}) 
    U (usedInnerL(L1,empty,Typed) U...U usedInnerL(Ln,empty,Typed)).pop()
    L1..Ln={L| L inside M.e?}
    with M not of form C:L

  non determinism heuristic:
  **if P.m(_) inside e, P not Any
  **if ( _ T x=P _ _) inside e and T!=class Any, P not Any.
  **if p(Pi).Phase=Typed, Pi is not Any
  **if ( _ T x=_  _ _) inside e, T.P not Any
  **if catch throw T x _ inside e, T.P not Any  
  **if using P _ _ inside e, P not Any
  **if catch T inside e, T.P not Any
  otherwise, P is considered of type class Any.
  // note that user can always force a not any by writing (x=P x)
  // note, if p(P) not defined, the path will be consider an any, and error will be rised somewhere else.


-----------------------------------------------------------
Part 6: paths;path' ||-p ~> p, toAny
-----------------------------------------------------------
(pPop)
Css paths;Css'path' ||- p  ~>  p1.update(L)
  where
  p1=p.growFellow(p0)
  paths;path' ||- p.pop() ~> p0
  Css; Css' ||-p1 ~> L
  
(pNoPop)
Css;Css'  ||- p  ~> L,empty
    where
    p.pop() undefined
    Css;Css' ||-p ~> L

(pEmpty)
empty;empty ||- p ~> p

(pL)
Cs1..Csn;Cs1'..Csk' ||-p ~> p.top()[Cs1=L1,.. Csn=Ln][Cs1'=L1'..Csk'=Lk']    //Li will have Phase=Typed also inside all somehow contained Ls
  where
  forall Csi in 1..n : Typed |-p.navigate(Csi) ~> Li 
  forall Csi' in 1..k: Coherent |-p.navigate(Csi') ~> Li' 
  //assert Csi' not contained, even as postfix in Cs1..Csn
  // the type system can be optimized to just assert  tests for libraries that are
  // annotated as already checked 
  // However, this is  the responsibility of the TS and not MultiTypeSystem
_______
#define toAny
- toAny(Css0..Cssn,eC)=eC iff forall i in 0..n, Cs in Cssi, not Thisi.Cs inside eC
  otherwise toAny(Css0..Cssn, ctxC[Thisi.Cs])=toAny(Css1..Cssn,ctxC[Any]) 
  where Cs in Cssi
 