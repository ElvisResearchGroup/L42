-----------------------------
Structure of this document:

1 Type Grammar

2 Type manipulation

3 ExpressionTypeJudgement

4 Subtyping p|- T<=T' and shortcut D |- e ~> e':T | Tr<=T'

5 LibraryAndMemberTyping

-----------------------------
1 Grammar
-----------------------------
//In this file, all the L are LC   //LC == in all C:e, e of form L

G::=x1:T1..xn:Tn  //G reads Gamma
D::= Phase `|` p `|` G `|` Cage  //D reads Delta
Cage::= xss; xs
Tr::=Ts; Ps //Tr reads Throws

//we believe that at any moment, in a D:
//Cage.xss contains only bindings that are mut in G
//Cage.xs contains only bindings that are mut, fwd%Mut, fwdMut, lent, read in G 

--------------------------------------------
2 Type manipulation
--------------------------------------------

complete(G)={x:T | G(x) not fwd/fwd%}

fwd T
  fwd imm P=fwd fwd%imm P=fwdImm P
  fwd mut P=fwd fwd%mut P=fwdMut P
  otherwise fwd T=T

fwd% T
  fwd% imm P=fwd%Imm P
  fwd% mut P=fwd%Mut P
  otherwise fwd% T=T
 
noFwd
  noFwd imm P=noFwd fwd%imm P=Imm P
  noFwd mut P=noFwd fwd%mut P=Mut P
  otherwise noFwd T=T

toImm(T)        
  toImm(class P)=class P
  otherwise, toImm(mdf P)=imm P

toLent(T)
  toLent(mut P)=lent P,
  toLent(mutFwd P) and toLent(mutFwd% P) undefined;
  otherwise toLent(T)=T 

capsuleToLent(T)  
  capsuleToLent(capsule P)=lent P
  otherwise capsuleToLent(mdf P)=mdf P
   
toRead(T)
  toRead(imm P)=imm P
  toRead(fwdImm P)=fwdImm P
  toRead(fwd%Imm P)=fwd%Imm P
  toRead(fwdMut P)=toRead(fwd%Mut P)=undefined
  toRead(class P)=class P
  otherwise toRead(mdf P)=read P //mdf in read,lent,mut,capsule

toRead(G)
  toRead(G)(x)=toRead(G(x)) //thus undefined where toRead undefined 

toLent(T1..Tn;Ps)=toLent(T1)..toLent(Tn);Ps

G[G']
  G[G'](x)=G'(x) if x in dom(G'); otherwise G[G'](x)=G(x)

G[ks]
  G[catch error mdf P x e ks]=toRead(G) with P not Any
  otherwise G[ks]=G 

mostGeneral(p,error,Tr)=imm Any
mostGeneral(p,return,empty;Ps) undefined??
mostGeneral(p,exception,_;empty) undefined?? TODO:Need discussion
mostGeneral(p,return,T1..Tn;Ps)=mostGeneral(T1.mdf .. Tn.mdf) mostGeneral(p,T1.P .. Tn.P)
otherwise 
mostGeneral(p,exception,_;Ps)=imm mostGeneral(p,Ps)

mostGeneral(p,P)=P
otherwise
mostGeneral(p,Ps1 P Ps2)=mostGeneral(p,Ps1 Ps2)
  if exists P' in Ps1,Ps2 such that p|-P<=P'
otherwise
mostGeneral(p,Ps)=Any 

catchRethrow(k) iff k=catch throw T x ((imm Void y=e catch error Any z void void) throw x)

mostGeneral(mdfs)=mdf //assert fwd and fwd% not in mdfs
  if mdfs=mdf', then mdf=mdf' //that is the only way mdf=class
  otherwise if class in mdfs, then undefined
  otherwise if read in mdfs, mdf=read
  otherwise if capsule in mdfs, then mdf=mostGeneral(mdfs\capsule)
  //from now on, we have at least two of those:lent, mut, imm //Note: fwd and fwd% are cutted out in the throw rule
  otherwise if imm in mdfs, mdf=read
  otherwise mdf=lent

Tr1 U Tr2
  Ts1;Ps1 U Ts2;Ps2 =  Ts1,Ts2; Ps1,Ps2  

--------------------------------------------
3 ExpressionTypeJudgement
--------------------------------------------
  D |- e ~> e':T   and D |- k ~> k':T 
  where e' is an annotated version of expression e and is of type T
  where k' is an annotated version of catch k and k.e is of type T
  D.p points to where the e is located, //D.p.top()=ctxL[e]
  so if P inside e, D.p(P) is a reasonable operation


(void)
_ |- void~> void:imm Void | emptyTr

(Path)
_ |- P~>P:class P | emptyTr

(library prop)
Phase |p |_ |_ |_ |- L ~> L' : imm Library | emptyTr
  where
  Phase  |- p.evilPush(L) ~> L'

(x)
Phase| p| G| xss; xs| Tr |-x:T | emptyTr
  where
  x notin xs
  if x in xss T=toLent(G(x))
  otherwise T=G(x)

(loop)
D |- loop e ~> loop e' : imm Void | Tr
  where
  D|- e ~> e' : imm Void | Tr

(throw)
D|-throw[T?,_] e~> throw[T,mdf P] e' :  T | Tr
  where
  resolve(D.p,guessType(D.G,e))=mdf' P //TODO: is it needed somehow or should just be asserted?
  D|- e~>  e' :  mdf' P |Tr' <=mdf P
  either T?=empty or T?=T
  if throw=exception, mdf=imm and Tr=Tr'.with(exceptions:\++P)
  if throw=return, mdf=mdf',Tr=Tr',with(returns:(mdf P)++\) and mdf not fwd or fwd% 
  if throw=error, mdf=imm and Tr=Tr'  

(mcall)
D|- e0.m[_](x1:e1..Xn:en) ~> e'0.m[P0](x1:e'1..xn:e'n)  : T' | Tr0 U..U Trn U empty;Ps //e0 will be of form mr
  where
  resolve(D.p,guessType(D.G,e0))= _ P0=T'0=T0
  D.p(P0).m(x1..xn).mh[from P0]=mdf0 method T m(T1 x1,..Tn xn) exception Ps
  forall P in Ps exists P' in D.Tr.Ps such that p|- P <= P'
  forall i 0..n D|- ei ~> e'i : T'i | Tri<=Ti
  if no fwd or fwd% in T'1..T'n
    T'=T
  otherwise 
    T'=fwd% T
     
(using)
 D|-use P check m(x1:e1.. xn:en) e0 ~>use P check m(x1:e'1.. xn:e'n) e'0 :T0 | Tr0 U..U Trn
 where
   plugin(D.p,P,m(x1..xn))=plg, T0..Tn //plg is a free variable, in the small step reduction would be the function representing the behaviour
   forall i 0..n D|- ei ~> e'i : T'i <=Ti


(block divide scope)
//This rule is not materialized in the sugar since it would duplicate the catches (potentially exponentially) //also a desugaring tring to assign the inner block to a variable and then do the catches only one would capture also errors in the "e"
//type system need not to repeat the test for ks in the two contexts,
//since if ks typed in the outer block, it would also type in the same way
//in the richer context in the inner block.
D|- (ds1 ds2 ks e)~>(ds'1 ds'2 ks' e'):T
  where
  D|- (ds1 ks (ds2 ks e) )~>(ds'1 ks'(ds'2 ks' e')):T
  dom(ds2) not in FV(ds1)
  //we do not need to state FV(ks) not in dom(ds1,ds2) since rule block do G/x1..xn
  //to optimize, we could use a empty shell ks (with all es replaced with error void), but then we will need to explicitly test for FV(ks) not in dom(ds1,ds2)

(block)
Phase| p| G| Cage| Tr|-(T1 x1=e1..Tn xn=en ks e0[_]) ~>(T'1 x1=e'1..T'n xn=e'n ks' e'0 [T]) : T | (Tr1 U..U Trn)\Ks' Tr U Tr0
  where
  for i in 1..n T'i=resolve(p,Ti)
  G'=x1:T'1..xn:T'n
  G1=G[ks][fwd(complete(G'))]
  for i in 1..n Phase| p| G1| Cage|-ei~>e'i: _ | Tri <=fwd% T'i
  Phase| p| G/x1..xn| Cage | Tr1 U .. U Trn |-ks~> ks' : T | Tr
  if exists x in FV(e1..en) such that G(x)=fwd _ or G(x)=fwd% _
    G0=G[fwd%(G')]
  otherwise
    G0=G[G']
  Phase| p| G0| Cage |-e0~>e'0:_ | Tr0<=T

    

//Note: the new idea is that catch throw Any will catch all that can be thrown,
// if not of form catchRethrow(k); in that case *only* the catchRethrow rule will apply
(catchMany)
D| Tr |-k1..kn ~> k'1..k'n:T | Tr1 U .. U Trn
  where
  forall i in 1..n D| Tr|-ki ~> k'i:T|Tri
  either forall i 1..(n-1) Any notEq k'i.P //That is, only the last one can 
  
(catch)
Phase| p| G| Cage| Tr|-catch throw T0 x e ~> catch throw resolve(p,T0) x e' :T1| Tr
  where
  Phase| p| G[x:T0]| Cage|- e ~> e':_<=T1| Tr
  either throw=return or resolve(p,T0)=imm _
  resolve(p,T0) not in {_ Any, fwdImm _,fwdMut, fwd%Imm _,fwd%Mut _}//This cause strong limitation in factories using conditionals (as in if-return)

(catch and rethrow any)// could be sugared as "on throw mdf x doAndPropagate e"  
Phase |p |G |Cage |Tr|-catch throw T x (e0 throw x) ~> catch throw mdf Any x (e0' throw x): _ | Tr
  where
  resolve(p,T)=mdf Any //mdf is ignored
  e0=(imm Void y=e catch error Any z void void)
  e0'=(imm Void y=e' catch error Any z void void)
  Phase |p |G\x |Cage |empty |- e ~> e':imm Void

(catch precise any)// could be sugared as "on throw mdf x doAndPropagate e"  
Phase |p |G |Cage |Tr|-catch throw T0 x e ~> catch throw Any x e': T | Tr'
  where
  not catchRethrow(catch throw Any x e)
  resolve(p,T0)=mdf Any
  //more expressive rule would say e type for any T in Tr.Ts
  T1=mostGeneral(throw,Tr)//may be Any, or even undefined for return class+read
  Phase |p |G+x:T1 |Cage |- e ~> e':T| Tr'


(unlock)
Phase |p |G |xss;xs|-e~>e':mdf P | Tr
  where
  Phase |p |G |xss,domMut(G)\xss ; empty |-e~>e':mdf P | Tr
  mdf in {imm,fwd%Imm,fwdImm,capsule,class}
  forall T in Tr.Ts, T.mdf in {imm,capsule,class} 

(swap)
Phase |p |G |xs0,xss;xs|-e~>e':toLent(mdf P) | toLent(Tr)
  where
  Phase |p |G |xss,domMut(G)\xss ; xs |Tr|-e~>e':mdf P | Tr

(capsule promotion)
Phase |p |G |Cage |-e~>e':capsule P | Tr
  where
  Phase |p |G |Cage'|-e~>e':mut P   | Tr
  Cage=xss;xs
  Cage'=xss,domMut(G)\xss;xs

(imm promotion)
Phase |p |G |Cage|-e~>e':imm P | Tr
  where
  Phase |p |G |Cage' |Tr|-e~>e':mdf P | Tr
  mdf in {read,lent} //TODO: what about fwd/fwd%  
  Cage=xss;xs
  Cage'=xss,domMut(G)\xss;domMutLentRead(G)//fwd%Mut, fwdMut in xs too

(lent to singleton)
Phase| p| G, x:lent C, G'|  xss;xs |-e~>e':T  | Tr
  where 
  Phase| p| G, x:mut C, G'|  xss,{x};xs |-e~>e':T | Tr


------------------------------------------------------
4 Subtyping p|- T<=T' and shortcut D |- e ~> e':T<=T'
------------------------------------------------------
  
(subtype)
p|-mdf0 P0<=mdf1 P1
  where
  mdf0<=mdf1
  P in P0 U (p(P0).Ps[from P0])
  p.equiv(P,P1)
  
(shortcut)
D |- e ~> e':T<=T'
  where
  D |- e ~> e':T
  D.p |-T<=T'
  
mdf<=mdf
mdf1<=mdf3 if mdf1<=mdf2 and mdf2<=mdf3
capsule<=mut,imm
imm<=read
mut<=lent
lent<=read
mut<=fwd%Mut
fwd%Mut<=fwdMut
imm<=fwd%imm
fwd%Imm<=fwdImm
-----------------------------------------------
5 LibraryAndMemberTyping
-----------------------------------------------
 Phase |- p ~> L   and   p | Ps |- M ~> M'
 L is the typed/annotated version of p.top()
 M' is the annotated version of M
 and p.top() is the literal containing M

  
(library shallow norm)
Norm  |- p ~> norm(p)  //remember: norm ignores meth bodies
//assert forall P in norm(p).Ps p(P).Phase>=Norm

(library well typed)
Phase |- p ~> L' //In implementation, if p.top().Phase>=Phase, L'=p.Top()
   where
   Phase in {Typed,Coherent}
   L0={interface? implements Ps M1..Mn Phase'}=norm(p)
   L'={interface? implements Ps M1'..Mn' max(Phase',Phase)}
   //assert forall P in Ps p(P).Phase>=Norm
   forall i in 1..n
     Phase| p| Ps |- Mi ~> Mi'
   if Phase=Coherent then coherent(p)

Phase| p| Ps |-C:L ~>  C:L'
   where
   Phase |-p.push(C) ~> L'

Phase| p| Ps |-M ~> M'
  where
  M =refine? mdf method T m(T1 x1 .. Tn xn)exceptions Ps' e?
  M'=refine? mdf method T m(T1 x1 .. Tn xn)exceptions Ps' e?'
  G=this:mdf This0,x1:T1,..,xn:Tn
  if e?=e then
    Typed| p| G|empty;empty|empty;Ps' |- e ~>  e?':_ <=fwd% T
  else
    e?=e?'
  refine? != empty <=> 
    forall P in Ps such that p(P)(m(x1..xn))=M0 //that is, is defined
      M0=mdf method T' m(T1 x1..Tn xn)exceptions Ps' and p|-T<=T'


coherent(p) //interfaces are always coherent
  where
  p.top()={interface implements _ mwts ncs}
    
coherent(p)  //classes are coherent if they have a coherent set of abstract methods
  where
  p.top()={implements _ mwts' ncs} //note, no interface
  mwts={mwt in mwts'| mwt.e undefined } //collect the abstract methods
  either mwts is empty or
    at least 1 mwt in mwts is class method 
    and
    exists some (T x)s such that //angelic non determinism to figure out at least one set of types for the fields 
      all T in (T x)s are mut, imm, class or capsule //thus, no fwd
      forall mwt in mwts coherent(p,(T x)s, mwt) //all abstract methods are coherent according to those fields
      
      
coherent(p,T1 x1..Tn xn,
      refine? class method T m(T1' x1..Tn' xn) exception _)
  where
  either
    p|-mut This0 <=T and p|-Ti'<=fwd Ti
  or   
    p|-imm This0 <=T and p|-Ti'<=fwd toImm(Ti)
  or
    p|-read This0 <=T and p|-Ti'<=fwd toRead(Ti) //how with capsule?


coherent(p,T1 x1..Tn xn,
    refine? mdf method T m() exception _)
  where
  m=#?xi
  either
    mdf=mut and p|-capsuleToLent(Ti)<=T //exposer
  or 
    mdf=read and p|-toRead(Ti)<=T //getter
  

coherent(p,T1 x1..Tn xn,
    refine? mut method Void m(T that) exception _)
  where
  m=#?xi
  p|-T<=Ti//setter
  

  
------------------
Dispatch //HARD
-------------------

1- e:imm Library do we always know the expected (super) type?
  D,e,expectedT-->e'
  D|-e~>e' :_<=expectedT



Calling type system on e:

SimpleTS: //input the expected type, return the computed type or the kind of error
if e is a block, then
  if possible apply(block divide scope) to the smallest possible starting ds
  else apply (block)
  inside (block) we will apply (catchMany),(catch),(catch and rethrow any) 
otherwise
  if e not block, apply rule for (void) (Path) (library prop)(x) (loop) (throw) (mcall) (using)

CompleteTs://the one called recursivelly every time we do a "D|-e~>e' :_<=expectedT", return void or the error
  as much as possible, apply (lent to singleton)  
  if possible and do not restrict the returns, apply unlock  
  try SwapTS
  on result subtype of expected: all ok
  on result not subtype of expected:
    if result is different w.r.t. the expected, fixable modulo capsule promotion:
      apply (capsule promotion), then UnlockTS
      if fail and expression is block in shape, apply (propagate promotions to catches):
      apply to change to mut, apply (capsule promotion), apply SwapTS; assert: the result is subtype of the expected.
    if result is different w.r.t. the expected, fixable modulo imm promotion:
      apply (imm promotion), then UnlockTS
      if fail and expression is block in shape, apply (propagate promotions to catches):
      apply to change to mut, apply (capsule promotion), apply SwapTS; assert: the result is subtype of the expected.
      if fail
      apply change to read, apply (imm promotion), apply SwapTS; assert: the result is subtype of the expected.

SwapTS: //return computed type or error
  try SimpleTS
  on result subtype of expected: all ok
  on fail:
    if "lent should be mut", apply swap, then SimpleTS
    propagate other failures

UnlockTS: //return computed type or error
  try SwapTS
  on result subtype of expected: all ok
  on fail:
    if "required variable is strongly locked", apply unlock, then SwapTS
    propagate other failures

----------------

Coherent and union types:
to easy translation in Java/etc, we can not accept the following
A,B interface
C,D implements A,B

I implements C,D
class method This f(I x   )
mut method Void x ( C that)
mut method Void #x ( D that)
read method A x()
read method B #x()
as coherent, since the field would be an union type of C and D
