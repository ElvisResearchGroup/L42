-----------------------------
Structure of this document:

1 Type Grammar

2 Type manipulation

3 ExpressionTypeJudgement

4 Subtyping p|- T<=T'

5 LibraryAndMemberTyping

6 Deteministic strategy for type system
-----------------------------
1 Grammar
-----------------------------
//In this file, all the L are LC   //LC == in all C:e, e of form L

G::=x1:T1..xn:Tn  //G reads Gamma
D::= Phase `|` p `|` G   //D reads Delta
Tr::=Ts; Ps //Tr reads Throws
MethT::=Ts->T;Ps

--------------------------------------------
2 Type manipulation
--------------------------------------------

onlyMutOrImm(G)={x:G(x) | G(x) only mut or imm}

fwd T
  fwd imm P=fwd fwd%imm P=fwdImm P
  fwd mut P=fwd fwd%mut P=fwdMut P
  otherwise fwd T=T

fwd% T
  fwd% imm P=fwd%Imm P
  fwd% mut P=fwd%Mut P
  otherwise fwd% T=T
 
fwd_or_fwd%_in Ts
  exists T in Ts such that
  T in {fwdImm _,fwdMut_,fwd%Imm _,fwd%Mut _}

noFwd T
  noFwd fwdImm P=noFwd fwd%Imm P=imm P
  noFwd fwdMut P=noFwd fwd%Mut P=mut P
  otherwise noFwd T=T

noFwd T1..Tn= noFwd T1 .. noFwd Tn
  
toImm(T)        
  toImm(class P)=class P
  otherwise, toImm(mdf P)=imm P

toImmOrCapsule(T)
  toImmOrCapsule(mdf C)=capsule C with mdf in {lent,mut,fwdMut,fwd%Mut}
  toImmOrCapsule(read C)=imm C
  otherwise toImmOrCapsule(T)=T//mdf in {class,imm,fwdImm,fwd%Imm,capsule}

toLent(T)
  toLent(mut P)=lent P,
  toLent(fwdMut P) and toLent(fwd%Mut P) undefined;
  otherwise toLent(T)=T
  
mutOnlyToLent(T)
  toLent(mut P)=lent P,
  otherwise toLent(T)=T 

capsuleToLent(T)  
  capsuleToLent(capsule P)=lent P
  otherwise capsuleToLent(mdf P)=mdf P
   
toRead(T)
  toRead(imm P)=imm P
  toRead(fwdImm P)=fwdImm P
  toRead(fwd%Imm P)=fwd%Imm P
  toRead(fwdMut P)=toRead(fwd%Mut P)=undefined
  toRead(class P)=class P
  otherwise toRead(mdf P)=read P //mdf in read,lent,mut,capsule

toRead(G)
  toRead(G)(x)=toRead(G(x)) //thus undefined where toRead undefined 

toLent(G)
  toLent(G)(x)=toLent(G(x)) //thus undefined where toLent undefined

lentToMut(T)
  lentToMut(lent C)=mut C
  otherwise lentToMut(T)=T  

mutToCapsule(T)
  mutToCapsule(fwdMut C) and mutToCapsule(fwd%Mut C) undefined
  mutToCapsule(mut C)=capsule C
  otherwise mutToCapsule(T)=T

G[G']
  G[G'](x)=G'(x) if x in dom(G'); otherwise G[G'](x)=G(x)
 
G[ks]
  G[]=G
  G[k ks]=toRead(G) with k.throw=error and not catchRethrow(k)
  otherwise G[k ks] = G[ks]

mostGeneralMdf(throw,Tr)  
  mostGeneralMdf(error,Tr)=imm
  mostGeneralMdf(return,empty;Ps) undefined
  mostGeneralMdf(return,T1..Tn;Ps)=mostGeneralMdf({T1.mdf .. Tn.mdf})
  otherwise 
  mostGeneralMdf(exception,_;Ps)=imm

mostGeneralMdf(mdfs)
  mostGeneralMdf(mdfs)=mdf //assert fwd and fwd% not in mdfs
    if mdfs=mdf', then mdf=mdf' //that is the only way mdf=class
  otherwise if class in mdfs, then undefined
  otherwise if read in mdfs, mdf=read
  otherwise if capsule in mdfs, then mdf=mostGeneralMdf(mdfs\capsule)
  //from now on, we have at least two of those:lent, mut, imm //Note: fwd and fwd% are cutted out in the throw rule
  otherwise if imm in mdfs, mdf=read
  otherwise mdf=lent
  //set oriented definition from james: mostGeneralMdf(mdfs) = mdf0 such that 
  //forall mdf1 in mdfs, mdf1 <= mdf0
  //forall mdf2
  //  either mdf0 <= mdf2
  //  or exists mdf3 in mdfs  not mdf3 <= mdf2

//liberal use of desugaring in the line under
catchRethrow(k) iff k=catch throw Any x ((e catch error Any z void void) throw x)

Tr1 U Tr2
  Ts1;Ps1 U Ts2;Ps2 =  Ts1,Ts2; Ps1,Ps2  

Tr.capture(p,k1..kn)= Tr.capture(p,k1)...capture(p,kn)

Tr.capture(p,catch error P x e)=Tr
(Ts;Ps).capture(p,catch exception P x e)=Ts;{P'| P' in Ps, not p|-P'<=P}
(Ts;Ps).capture(p,catch return P x e)={T| T in Ts, not p|-T.P<=P};Ps


--------------
methTypes(p,P,ms)  Expressed as metarules

//first managing placeholders

       p(P).ms.mh[from P]=refine? mdf0 method T m(T1 x1,..Tn xn) exception Ps
(mBase)-------------------------------------------------------------------
       mdf0 P T1..Tn-> fwd% T;Ps in methTypes(p,P,ms)
 
         Ts->T;Ps in methTypes(p,P,ms) 
(mNoFwd)-------------------------------------------------------------------
         noFwd Ts-> noFwd T;Ps in methTypes(p,P,ms)

//then capsule and imm promotion
    Ts->mut P0;Ps in methTypes(p,P,ms)
(mC)-------------------------------------------------------------------
    mutToCapsule(Ts)->capsule P0;Ps in methTypes(p,P,ms)

    Ts->read P0;Ps in methTypes(p,P,ms) //by well formedness if return type is read, not fwd_or_fwd%_in Ts
(mI)-------------------------------------------------------------------
    toImmOrCapsule(Ts)->imm P0;Ps in methTypes(p,P,ms) 
    //the behaviour of immorcapsule on fwd is not relevant since the method
    // returns a read and will be not well formed if it had fwd parameters
  
//then lent viewpoint adaptation    

     Ts0 mut P Ts2->T;Ps in methTypes(p,P,ms)
     Ts'=mutToCapsule(Ts0) lent P mutToCapsule(Ts2) //this implies not fwd_or_fwd%_in Ts0,Ts2
(mVp)-------------------------------------------------------------------
     Ts'->toLent(T);Ps in methTypes(p,P,ms)
   
--------------------------------------------
3 ExpressionTypeJudgement
--------------------------------------------
  D |- e ~> e':T <=T'| Tr  
    where e' is an annotated version of expression e and is of type T
    D.p points to where the e is located, //D.p.top()=ctxL[e]
    so if P inside e, D.p(P) is a reasonable operation
    Tr is the computed set of thrown returns and exceptions.
    
  Phase| p| G|ks|- ds ~> ds'| Tr | G0
    where ds' is an annotated version of ds.
    We need the catches to seal the gamma to ensure "strong error safety".
    The resulting G0 is the enriched G containing info about ds too. 

  D |Tr|- k ~> k':T <=T' |Tr'    
    where k' is an annotated version of catch k and k.e is of type T
    we need the Tr of the ds to extract the mdf for caught returns
    Tr' contains only the throws from the catch k itself.
  
  D| Tr |-ks ~> k's:Ts <= T | Tr'
    just types a set of catches.
    

(void)
D |- void~> void:imm Void <= T | emptyTr
  where
  D.p|-imm Void <= T
  
(Path)
D |- P~>P:class P <= T | emptyTr
  where
  D.p|-class P <= T

(library propagation)
D |- L ~> L' : imm Library <= T | emptyTr
  where
  D.p|-imm Library <= T
  D.Phase  |- D.p.evilPush(L) ~> L'

(x)
D |-x ~> x :D.G(x) <= T | emptyTr
  where
  D.p|- D.G(x) <= T

(loop)
D |- loop e ~> loop e' : imm Void <= T | Tr
  where
  D.p|-imm Void <= T
  D|- e ~> e' : _ <= imm Void | Tr

(throw)   // expression of type T0 throws the result of an expression where:
          // T1 is the guess type of the expression
          // T2 is the modified type, taking into account kind of thrown
          // T3 is the type of the expression, including promotions
          // and T3 is the type of the value thrown, this allows to use alternative method typing
D|-throw[_,_] e~> throw[T0,T3] e' : T0 <= T0 | Tr
  where
  T1 = resolve(D.p,guessType(D.G,e))
  if throw=exception, T2= imm T1.P and Tr=Ts;Ps,P
  if throw=error,     T2= imm T1.P and Tr=Ts;Ps
  if throw=return,    T2= (fwd T1) and Tr=(Ts,T3);Ps 
  D|- e~>  e' :  T3 <=T2|Ts;Ps 

(mcall)
D|- e0.m[_](x1:e1..Xn:en) ~> e'0.m[P0](x1:e'1..xn:e'n)  : T <= T'| Tr0 U..U Trn U (empty;Ps)
  //e0 will be of form chain
  where
  resolve(D.p,guessType(D.G,e0))= _ P0 //assert T'0.P=P0
  T0..Tn->T;Ps in methTypes(p,P0,m(x1..xn))
  D.p|-T <= T'
  forall i 0..n D|- ei ~> e'i : T'i <=Ti | Tri //T'0 is correctly a free variable    
  
(using)
 D|-use P check m(x1:e1.. xn:en) e0 ~>use P check m(x1:e'1.. xn:e'n) e'0 :T0 <= T | Tr0 U..U Trn
 where
   plugin(D.p,P,m(x1..xn))=plg, T1..Tn->T0;empty //plg is a free variable, in the small step reduction would be the function representing the behaviour
   D.p|-T0 <= T
   forall i 0..n D|- ei ~> e'i : T'i <=Ti |Tri
//Note: what happen if a parameter take mut and the plugin throw error w.r.t. strong error safety? can we catch it soon?
//The idea is that I can still use the normal pattern to throw error if the plugin fail, but to catch that error we will have to go up the stack a lot.
//Now plugings are assumed to always ask for imm/class parameters
  
(block)
Phase| p| G|-(ds  ks  e0  [_]) ~>(ds' ks' e'0 [T]) 
     : T <= T' | Tr'.capture(p,ks') U Tr U Tr0
  where
  Phase| p| G/dom(ds)| ks|- ds ~> ds' |Tr' | G0
  Phase| p| G/dom(ds)| Tr1 U .. U Trn |-ks~> ks' : Ts <= T' | Tr
  Phase| p| G0 |-e0~>e'0:T0 <=T' | Tr0
  T= mostGeneralMdf({T0.mdf,Ts.mdfs}) T'.P
  // assert D.p|-T <= T'

(ds)
Phase| p| G| ks|- T0  x0=e0 ..Tn  xn=en, ds ~>  T'1  x1=e'1 ..T'n  xn=e'n, ds'|Tr U Tr' | G2
  where
  dom(ds) notin FV(e0..en)
  for i in 0..n T'i=resolve(p,Ti)
  G'=x0:T'0..xn:T'n
  G1= (G\x0..xn)[ks][fwd(onlyMutOrImm(G'))] //[ks] removes fwdMut, but we wonder if they could stay and all would be sound?
  for i in 0..n Phase| p| G1|-ei~>e'i: _ <= fwd% T'i | Tri
  Tr=Tr0 U .. U Trn
  if fwd_or_fwd%_in Tr.Ts
    then x1..xn disjoint FV(e0..en)
  if fwd_or_fwd%_in { G\x0..xn(x) | x in FV(e0..en) }
    then G0=G[fwd%(G')]
    otherwise G0=G[G']
  Phase| p| G0|ks|- ds ~> ds'|Tr' | G2

(dsEmpty)
Phase| p| G|ks|- empty ~> empty| empty;empty | G
   
//TODO: check that this kind of things work {Bar:{}   method m (foo catch exception Bar x e1 e0)  } redirect Bar->Any
//Note: the new idea is that catch throw Any will catch all that can be thrown,
// if not of form catchRethrow(k); in that case *only* the catchRethrow rule will apply
(catchMany)
D| Tr |-k1..kn ~> k'1..k'n:T1..Tn <= T | Tr1 U .. U Trn
  where
  forall i in 1..n D| Tr.capture(D.p,k1..ki-1)|-ki ~> k'i:Ti <= T |Tri
  
(catch)
   // T0 is the declared caught type, which contributes only a path
   // T1 is the actual caught type, based on the types which can be thrown in context
   // T2 is the type of the expression, based on x being bound T1

Phase| p| G| Tr' |-catch throw T0 x e ~> catch throw resolve(p,T0).P x e' :T2 <= T | Tr
  where
  mdf1 = mostGeneralMdf(throw,Tr')
  T1 = mdf1 resolve (p, T0).P
  not catchRethrow(catch throw T1 x e)
  Phase| p| G[x:T1]|- e ~> e' : T2 <= T | Tr

(catch and rethrow any)// could be sugared as "on throw doAndPropagate e"  
Phase |p |G |Tr|-catch throw Any x (e0 throw x) ~> catch throw Any x (e0' throw x): T<=T | Tr
  where //Note: e0, e, e0',e' are using the sugar imm Void x=e == e
  e0=(e catch error Any z void void)
  e0'=(e' catch error Any z void void)
  Phase |p |G\x |- e ~> e':_ <=imm Void | empty
  catchRethrow(catch throw Any x(e0 throw x)) 

(capsule promotion)
Phase |p |G |-(ds ks e)~>(ds' ks' e'):capsule P <=capsule P | Tr
  where
  Phase |p |toLent(G) |-(ds ks e)~>(ds' ks' e'):mut P <=mut P   | Tr
//this rule is now "deterministic" in the sense that if typing the block give us a capsule directly,
//this rule can not be applied, since we require mut P <=mut P in the premise.

------------------------------------------------------
4 Subtyping p|- T<=T'
------------------------------------------------------
  
(subtype)
p|-mdf0 P0<=mdf1 P1
  where
  mdf0<=mdf1
  P in P0 U (p(P0).Ps[from P0])
  p.equiv(P,P1)
  
mdf<=mdf
mdf1<=mdf3 if mdf1<=mdf2 and mdf2<=mdf3
capsule<=mut,imm  //,lent,read,fwd%Mut,fwdMut,fwd%Imm, fwdImm
imm<=read,fwd%Imm //,fwdImm
mut<=lent,fwd%Mut //,read,fwdMut
lent<=read
fwd%Mut<=fwdMut
fwd%Imm<=fwdImm


-----------------------------------------------
5 LibraryAndMemberTyping
-----------------------------------------------
 Phase |- p ~> L   and   p | Ps |- M ~> M'
 L is the typed/annotated version of p.top()
 M' is the annotated version of M
 and p.top() is the literal containing M

  
(library shallow norm)
Norm  |- p ~> norm(p)  //remember: norm ignores meth bodies
//assert forall P in norm(p).Ps p(P).Phase>=Norm

(library well typed)
Phase |- p ~> L' //In implementation, if p.top().Phase>=Phase, L'=p.Top()
   where
   Phase in {Typed,Coherent}
   L0={interface? implements Ps M1..Mn Phase'}=norm(p)
   L'={interface? implements Ps M1'..Mn' max(Phase',Phase)}
   //assert forall P in Ps p(P).Phase>=Norm
   forall i in 1..n
     Phase| p| Ps |- Mi ~> Mi'
   if Phase=Coherent then coherent(p.updateTop(L'))

(member nested)
Phase| p| Ps |-C:L ~>  C:L'
   where
   Phase |-p.push(C) ~> L'

(member method)
Phase| p| Ps |-M ~> M'
  where
  M =refine? mdf method T m(T1 x1 .. Tn xn)exceptions Ps0 e?
  M'=refine? mdf method T m(T1 x1 .. Tn xn)exceptions Ps0 e?'
  G=this:mdf This0,x1:T1,..,xn:Tn
  if e?=e then
    Typed| p| G |- e ~>  e?':_ <=fwd% T | empty;Ps1
    forall P1 in Ps1 exists P0 in Ps0 such that p|-P1<=P0
  else
    e?=e?'
  refine? = refine <=> 
    forall P in Ps such that p(P)(m(x1..xn))=M0 //that is, is defined
      M0=mdf method T' m(T1 x1..Tn xn)exceptions Ps' and p|-T<= (T'[from P])


coherent(p) //interfaces are always coherent
  where
  p.top()={interface implements _ mwts ncs}
    
coherent(p)  //classes are coherent if they have a coherent set of abstract methods
  where
  p.top()={implements _ mwts' ncs} //note, no interface
  mwts={mwt in mwts'| mwt.e undefined } //collect the abstract methods
  either mwts is empty or
    at least 1 mwt in mwts is class method 
    and
    exists some (T x)s and n? such that //angelic non determinism to figure out at least one set of types for the fields 
      all T in (T x)s are mut, imm, class or capsule //thus, no fwd
      forall mwt in mwts coherent(n?,p,(T x)s, mwt) //all abstract methods are coherent according to those fields
      
m[n]==m_$_n
m[]==m
      
coherent(n?,p,T1 x1..Tn xn,
      refine? class method T m[n?] (T1' x1..Tn' xn) exception _)
  where
  either
    p|-mut This0 <=T and p|-Ti'<=fwd Ti
  or   
    p|-imm This0 <=T and p|-Ti'<=fwd toImm(Ti)
  or
    p|-read This0 <=T and p|-Ti'<=fwd toRead(Ti) //how with capsule?


coherent(n?,p,T1 x1..Tn xn,
    refine? mdf method T m[n?]() exception _)
  where
  m=#?xi
  either
    mdf=mut and p|-capsuleToLent(Ti)<=T //exposer
  or 
    mdf=read and p|-toRead(Ti)<=T //getter
  
coherent(n?,p,T1 x1..Tn xn,
    refine? mut method Void m[n?](T that) exception _)
  where
  m=#?xi
  p|-T<=Ti//setter
 
----------------------------- 
6 Deteministic strategy for type system
-----------------------------
type system:
TSIn: Delta,e,T
TSOut: either OK(TSIn,e,T,Tr) or Error(TSIn,String,Opt(T)) //Error.T is the obtained type that is not a subtype of expected one.

object with 
-memoized hash map TSIn->TSOut

ts(TSIn in)->TSOut
  use Anonymous Visitor to dispatch to specific ts
tsPath(TSIn in,Path p)->TSOut //assert in.e == p, etc. for other cases
  ...follow rule Path...
..other cases...
  
structure of all tsXX methods://or just the dispatch one :-)
  TSOut res=_memoizedTSRes(in);
  if (res!=null){return res;}
  try{
    ... return res=e; ...
    }
  finally{memoizeTSRes(in,res);}//remember, memoizeTSRes need to not memoize null res
  
non trivial methods: tsBlock and tsMCall 

tsBlock(TsIn in,Block e)->TSOut
  res1=tsBlockBase(in,e) //will use splitDs
  if res1.isOk(){return res=res1;}
  if !promotionMakesSense(){return res=res1;}//promotionMakesSense: mut that need capsule
  res2=tsBlockPromotion(in,e)//calls tsBlock internally,
  //thanks to promotionMakesSense does not goes in loop
  if res2.isOk(){return res=res2;}
  //if we are here, both res1,res2 not ok
  return res=combine(res1,res2)
  
splitDs(ds)->i
  //Algorithm to divide ds in the first minimal ds1, ds2
  ds=ds0..dsn;
  domi=dom(dsi+1..dsn)
  var xs=empty
  var i=0
  loop (
    xs= xs U  FV(ei)
    if (domi\xs) = domi then return i
    //cut will be from 0 to i included
    i:=i+1
    if i==n return i //ds.size-1
    )
   error X""// would be unreachable return i //that is, ds=d1..di , di+1..dn
  
tsMCall(TSIn in,MCall e)->TSOut
  Path rec=guessType(e.receiver)
  mTypes,mTypesRev=computeMTypes(in.p,rec,e.ms)
  //memoizing mTypes would be a mistake since we can not abstract over p and [from rec]
  // 1 select the first match with acceptable return type
  mType=_firstMatchReturn(TSIn.T,mTypes)
  if mType==null return res=Error???
  //2 type all the parameters with mutOnlyToLent(Ts) //we may store the mutOnlyToLent result already in the first memoized map
  resp=TSOut[with ei in e.es.withAlso(left:e.receiver), Ti in mTypes.Ts
    resi=ts(in.with(e:ei, t:mutOnlyToLent(Ti)))
    if !resi.isOk() return res=combineContext(TSIn,resi)
    use[resi]   
    ]
  assert forall r in resp, r.isOk()
  mTypeRev=_firstMatchParameters(Ts[with r in resp (use[r.T])],mTypesRev) 
  if mTypeRev!=null 
    return res=makeMCallOK(TSIn,resp,mTypeRev)//mTypeRev.returnType needed, and Trs[with r in resp (use[r.Tr])].collapse())
  //3 if there is no matching method, we may need to retype some mut
  //in capsule caused by mvp:
  //it is  not over if there is a mathing method type with mutToCapsule(result param types)
  //in this case assert "there is exactly 1 matching method"
  tsToCaps=Ts[with r in resp (use[mutToCapsule(r.T)])]
  mTypeMVP=firstMatchParameters(tsToCaps,mTypesRev) //or mTypes?
  if mTypeMVP==null Error????
  //this assert could not work: assert firstMatchParameters(tsToCaps,mTypesRes-mTypeMVP) fails
  //To be happy, we can retype the obtained mut parameters into expected capsule
  respMVP=TSOut[with ri in resp, T ti in mTypeMVP.TS (
    if (ri.mdf <= ti.mfd) (
      assert ri.mdf != Mdf.mut
      use [ri]
      )
    else(
      assert ri.mdf == Mdf.mut
      assert ti.mdf == Mdf.capsule
      resi=ts(ri.in.with(expectedT:ti))
      if !resi.isOK()  return Error???
      use [resi]
      )
    )]
  return res=makeMCallOK(TSIn,respMVP,mTypeMVP)

computeMTypes
  order of first list:
    base,
    noFwd(if diff from base (use .equals ?) ),
    zero or 1 of {mc,mi} based on noFwd,
    1 mType for each mut parameter using mvp based on noFwd
    1 mType for each mut parameter using mvp based on base

  order of second list:
    zero or 1 of {mc,mi} based on noFwd,
    noFwd
    base(if diff from noFwd),
    1 mType for each mut parameter using mvp based on noFwd
    1 mType for each mut parameter using mvp based on base
      
_memoizedTSRes(in) //need attention: we can not use .equals on p
  in=Phase,p,G,e,T
  equality on in will use the identity of p and e
  return map.get(in)
memoizeTSRes(in,res)
  assert map(in)==null
  return map.put(in,res)
  
----------------
Notes:
Coherent and union types:
to easy translation in Java/etc, we can not accept the following
A,B interface
C,D implements A,B

I implements C,D
class method This f(I x   )
mut method Void x ( C that)
mut method Void #x ( D that)
read method A x()
read method B #x()
as coherent, since the field would be an union type of C and D