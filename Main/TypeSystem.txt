//all the L are LC   
//a b, c;d |e == ((((a b), c);d) |e)
mwt::=refine? mh e? //method with type
nc::=C:L
T::= mdf P
e::=x|void|P|L|throw[T1,T2] e|loop e|(ds ks e[T])
 | e.m[T]((x:e)s)| use P check m((x:e)s) e
throw::= exception | error | return
k::=catch T x e
d::= T x=e
mdf::= imm|mut|lent|read|capsule|class | fwdImm | fwdMut | fwd%Imm | fwd%Mut
Phase::=None|Norm|Type+|Type*
//what about calling coherence/consistency in a better way?
//like executable? so it would be
Phase::=None|Norm|Typed|Executable

TypeJudgement::=D |- e : e':T
G::=x1:T1..xn:Tn
D::= Phase | p | G | Cage | Tr
Cage::= xss; xs
Tr::=Ts; Ps

We have well formedness on capsules bindings:
used at most once for each "branch"
formally: cX(e)=xs is defined for all e, and for all meth bodies, the capsule x appears 0 or 1 times
cX(x)=x
cX(void)=cX(P)=cX(L)=empty
cX(throw[T1,T2] e)=cX(e)
cX(loop e)=cX(e),cX(e)  //two times, that is enough
cX(e0.m[T](x1:e1..xn:en) )=cX(e0)..cX(en)
cX(use P check m(x1:e1..xn:en) e0)=cX(e0)..cX(en)

cX( (T1 x1=e1..Tn xn=en k1..km e0[T]) )=ys/x1..xn ,max( (xs0/x1..xn), xs1,..,xsm)
  where
  ys=cX(e1),..,cX(en)
  xsi=cX(ki)
  xs0=cX(e0) 
  if Ti=capsule _ then
    xi at most 1 in ys,xs0

max(empty,ys)=ys
max (x xs,ys)=x max(xs,ys) if x not in ys
max (x xs,ys)=x max(xs,removeOne(x,ys)) 
max(xs, xs0..xsn) = max(max(xs,xs0),xs1..xsn)
max(xs)=xs

complete(G)={x:T | G(x) not fwd/fwd%}

fwd T and fwd% T return the fwd/fwd% version of T


(void)
_ |- void: void:imm Void

(Path)
_ |- P:P:class P

(library shallow norm)
Norm p _|- L : norm(p,L) : imm Library  //light norm: ignore meth bodies

(library well typed)
Type+| p |_|- L : L' : imm Library
   where
   L0={interface? implements Ps M1..Mn}=norm(p,L)
   L'={interface? implements Ps M1'..Mn'}
   Type+| p.evilPush(L0)| Ps |-Mi : Mi'
   forall ms in dom(p.evilPush(L0))
     ms in dom(L0)


(library coherent)
Type*| p| _|- L : L' : imm Library
   where
   Type+| p| _|- L : L' : imm Library
   coherent(L')//not abstract//executable(L')?
    
(x)
Phase| p| G| xss; xs| Tr |-x:T
  where
  x notin xs
  if x in xss T=lentOf(G(x))
  otherwise T=G(x)

(loop)
D |- loop e:loop e':imm Void
  where
  D|- e:e':imm Void

(throw)
D|-throw[_,_] e: throw[T,mdf P] e' :  T
  where
  D|- e:  e' :  mdf P
  if throw=return, p|-mdf P<=T', T' in D.Ts
  otherwise p|-mdf P<=imm P', P' in D.Ps  

(mcall)
D|- e0.m[_](x1:e1..Xn:en) : e'0.m[mdf0 P0](x1:e'1..xn:e'n)  : T
  where
  D|-e0: e'0:mdf0 P0<=mdf'0 P0
  not D|-e0: _:imm Void //makes (error x).m(...) not well typed
  D.p(P0).m(x1..xn).mh=mdf'0 method T' m(T'1 x1,..T'n xn) exception Ps
  p|- Ps in D.Tr.Ps
  forall i 1..n D|- ei : e'i : Ti <=T'i
  if no fwd in T1..Tn
    T=T'
  otherwise 
    T=fwd% T'
     
(using)
 D|-use P check m(x1:e1.. xn:en) e0 :use P check m(x1:e'1.. xn:e'n) e'0 :T'0
 where
   plugin(D.p,P,m(x1..xn))=plg, T'0..T'n
   forall i 0..n D|- ei : e'i : Ti <=T'i


(block)
Phase p G Cage Tr|-(T1 x1=e1..Tn xn=en ks e0[_]) :(resolve(p,T1) x1=e1..resolve(p,Tn) xn=en ks e0[T]) : T
  where
  Phase p G Cage Tr|-ks: ks' :T
  for i in 1..n Phase p G1 Cage Tr[ks]|-ei:e'i:T'i<=fwd% Ti
  G'=x1:T1..xn:Tn
  G1=G[ks],fwd(complete(G'))
  Phase p G0 Cage Tr|-e0:e'0:T
  if exists x in FV(e1..en) such that G1(x)=fwd _
    G0=G,fwd%(G')
  otherwise
    G0=G,G'
  
(block divide scope)
D|- (ds1 ds2 K e):(ds'1 ds'2 K' e'):T
  where
  D|- (ds1 K (ds2 K e) ):(ds'1 K'(ds'2 K' e')):T
  

(propagate promotions to catches)
//dec-k-prom-t seams broken but is actually ok since use x as the catch e
//basically is a late fix for the poor sintactic sugar...
//should it be encoded in the sugar??
//No, the application of this rule needs to be dynamic and failure driven
//note, the sugar just use a single k...
D|- (ds ks1 catch return mdf Path x x ks2 e):(ds' ks'1 catch return mdf' Path x x ks'2 e') :T
  where
  D|-(ds ks1 catch return mdf' Path x x ks2 e):(ds' ks'1 catch return mdf' Path x x ks'2 e') :T
  either
    mdf=capsule, mdf'=mut
  or
    mdf=imm, mdf' in {mut,read}
  
(catch)
Phase p G Cage Tr|-catch throw T x e : catch throw resolve(p,T) x e' :T'
  where
  Phase p G,x:T Cage Tr |- e : e':T'

(cath and rethrow any)  
Phase p G Cage Tr|-k0 : catch throw resolve(p,T0) x e0 :T0
  where
  k0=catch throw mdf0 Any x e
  k1=catch throw T1 x e
  k2=catch throw T2 x e
  for i in 0,1,2 Phase p G Cage Tr[ki]|-ki : catch throw resolve(p,Ti) x ei :Ti
  either
    throw=exception, mdf=imm, T0=imm Library, T1=imm Void
  or
    throw=return, T0=class Library, T1=read Void

(lent viewpoint adaptation)
Phase p G Cage Tr|-e:e':mdf P
  where
  Phase p G Cage' Tr|-e:e':mutToLent(mdf P)
  Cage=xs0,xss;xs
  Cage'=xss,domMut(G)\xss ; xs'
  if mdf in {read,lent,mut} then xs'=xs
  otherwise xs'=empty
  

(capsule promotion)
Phase p G Cage Tr|-e:e':capsule P
  where
  Phase p G Cage' Tr|-e:e':mut P  
  Cage=xss;xs
  Cage'=xss,domMut(G)\xss;xs

(imm promotion)
Phase p G Cage Tr|-e:e':imm P
  where
  Phase p G Cage' Tr|-e:e':mdf P
  mdf in {read,lent}  
  Cage=xss;xs
  Cage'=xss,domMut(G)\xss;domMutLentRead(G)

(lent to singleton)
Phase| p| G x:lent C G'|  xss;xs | Tr |-e:e':T
  where 
  Phase| p| G x:mut C G'|  xss,{x};xs| Tr |-e:e':T

  
(subtype)
p|-mdf P<=mdf' P'
  where
  mdf<=mdf
  either P=P'
  or P' in p(P).Ps[from P]

Type+ p; Ps |-C:L :  C:L'
   where
   Type+ p.push(C,L) |-L : L': _ //can be evilPush? may be not? consistency?


Type+ p; Ps |-M : M'
  where
  M =refine? mdf method T m(T1 x1 .. Tn xn)exceptions Ps' e?
  M'=refine? mdf method T m(T1 x1 .. Tn xn)exceptions Ps' e?'
  if e?=e then
    Type+ p; G;empty,empty;empty,Ps'|-e:e?' :_ <=T
  else
    e?=e?'
  existsExactly 1 P in Ps,This0
    such that p(P)(m(x1..xn)).refine? = empty
  refine? != empty <=> 
    forall P in Ps such that p(P)(m(x1..xn))=M //that is, is defined
      M=mdf method T' m(T1 x1..Tn xn)exceptions Ps' and p|-T<=T'


  coherent(C1:L1..Cn:Ln)=coherent(L1)..coherent(Ln)

coherent({interface _ mwts ncs})
  where
  coherent(ncs)
    
coherent({implements _ mwts ncs})    
  where
  coherent(ncs)
  mwt1..mwtn={mwt in mwts| mwt.e undefined }
  either n=0
  or
    mwt1=refine? class method T m(T1 x1..Tn xm) exception _,
    p|-mdf This0 <=T, T1..Tn not read/lent
    forall mwti in mwt2..mwtn
      in the following Ti not fwd and mi=#?xj
      mwti=mut method Ti mi() exception _, p|-Tj<=capsuleToLent(Ti)//exposer
      or
      mwti=read method Ti mi() exception _, p|-Tj<=toRead(Ti)//getter
      or
      mwti=mut method Void mi(Ti that) exception _, p|-Ti<=Tj//setter
      
    read=toRead(mut)=toRead(mutFwd)=toRead(capsule)
    imm=toRead(imm)=toRead(immFwd)
    class=toRead(class)
    
    lent=capsuleToLent(capsule)
    mut=capsuleToLent(mutFwd)
    imm=capsuleToLent(immFwd)
    otherwise mdf=capsuleToLent(mdf)
  
------------------
Dispatch //HARD