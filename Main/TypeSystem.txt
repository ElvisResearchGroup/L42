-----------------------------
Structure of this document:

1 Type Grammar

2 Type manipulation

3 ExpressionTypeJudgement

4 Subtyping p|- T<=T' and shortcut D |- e ~> e':T<=T'

5 LibraryAndMemberTyping

-----------------------------
1 Grammar
-----------------------------
//In this file, all the L are LC   //LC == in all C:e, e of form L

G::=x1:T1..xn:Tn  //G reads Gamma
D::= Phase `|` p `|` G `|` Cage `|` Tr  //D reads Delta
Cage::= xss; xs
Tr::=Ps; Ps //Tr reads Throws
We can extract Tr.returns and Tr.exceptions for the first and the second group of Ps

//we believe that at any moment, in a D:
//Cage.xss contains only bindings that are mut in G
//Cage.xs contains only bindings that are mut, fwd%Mut, fwdMut, lent, read in G 

--------------------------------------------
2 Type manipulation
--------------------------------------------

complete(G)={x:T | G(x) not fwd/fwd%}

fwd T
  fwd imm P=fwd fwd%imm P=fwdImm P
  fwd mut P=fwd fwd%mut P=fwdMut P
  otherwise fwd T=T

fwd% T
  fwd% imm P=fwd%Imm P
  fwd% mut P=fwd%Mut P
  otherwise fwd% T=T
 
noFwd
  noFwd imm P=noFwd fwd%imm P=Imm P
  noFwd mut P=noFwd fwd%mut P=Mut P
  otherwise noFwd T=T

toImm(T)        
  toImm(class P)=class P
  otherwise, toImm(mdf P)=imm P

toLent(T)
  toLent(mut P)=lent P,
  toLent(mutFwd P) and toLent(mutFwd% P) undefined;
  otherwise toLent(T)=T 

capsuleToLent(T)  
  capsuleToLent(capsule P)=lent P
  otherwise capsuleToLent(mdf P)=mdf P
   
toRead(T)
  toRead(imm P)=imm P
  toRead(fwdImm P)=fwdImm P
  toRead(fwd%Imm P)=fwd%Imm P
  toRead(fwdMut P)=toRead(fwd%Mut P)=undefined
  toRead(class P)=class P
  otherwise toRead(mdf P)=read P //mdf in read,lent,mut,capsule

toRead(G)
  toRead(G)(x)=toRead(G(x)) //thus undefined where toRead undefined 

G[G']
  G[G'](x)=G'(x) if x in dom(G'); otherwise G[G'](x)=G(x)

G[ks]
  G[catch error mdf P x e ks]=toRead(G) with P not Any
  otherwise G[ks]=G 

Tr[ks]
  if ks='catch throw _ Any e' then Tr[ks]=Tr else
  Ts; Ps [catch error T1 x1 e1..catch error Tn xn en..]=Ts; Ps
  Ts; Ps [catch exception _ P1 x1 e1..catch exception _ Pn xn en..]=Ts; Ps,P1..Pn
  Ts; Ps [catch return mdf P1 x1 e1..catch return mdf Pn xn en..]=Ts[adaptMdfForReturn mdf P1]..[adaptMdfForReturn mdf Pn];Ps 
  //Note: all the mdf of the various Ts are required to be the same, or the operation is undefined and we get a type error

Ts[adaptMdfForReturn T]
  mdf P1..mdf Pn[adaptMdfForReturn mdf' P0]=mdf' P0..mdf' Pn  if mdf' <= mdf
  otherwise mdf P1..mdf Pn[adaptMdfForReturn mdf' P0]=mdf' P0 //this case will also be triggered for n=0 
  //is multi level return needed by the sugar? can we optimize more during java generation if we do not?

Tr[lessReturnMut]
  mut C1..mut Cn; Ps[lessReturnMut] = capsule C1..capsule Cn; Ps
  otherwise Tr[lessReturnMut] = Tr
Tr[lessReturnReadLentMut]
   mdf C1..mdf Cn; Ps[lessReturnReadLentMut] = capsule C1..capsule Cn; Ps if mdf in {lent,mut}
   read C1..read Cn; Ps[lessReturnReadLentMut] = imm C1..imm Cn; Ps
   otherwise Tr[lessReturnReadLentMut] = Tr 

extractReturnMdf(e1..en)=mdf //annotated expressions
  mdfs=extractReturnMdf(e1),...,extractReturnMdf(en)
  mdf=mostGeneral({mdfs})//make a set to remove duplicates

extractReturnMdf(void)=extractReturnMdf(L)=extractReturnMdf(x)=extractReturnMdf(P)=empty
extractReturnMdf(return[T, mdf P] e)=mdf,extractReturnMdf(e)
extractReturnMdf(loop e)=extractReturnMdf(error e)=extractReturnMdf(exception e)=extractReturnMdf(e)
extractReturnMdf( e0.m[_](x1:e1,..,xn:en) )=extractReturnMdf( use P check m(x1:e1,..,xn:en) e0)=extractReturnMdf(e0),...,extractReturnMdf(en)

extractReturnMdf( (T1 x1=e1 Tn xn=en k1..km e0 [_]) )=extractReturnMdf(e0),...,extractReturnMdf(en),extractReturnMdf(k1),..,extractReturnMdf(km)
where km not of form return Any e
No, need subtyping reasoning? Need to return the T instead of the mdf,
and to supply the p, then check for subtyping 
otherwise 

extractReturnMdf(catch throw P x e)=extractReturnMdf(e)

//TODO: sugar uses return T+return Any to do cast. Current restrictions
//would prevent this.
//If we then support return T+return Any, then need to
//prevent a return* +return Any to be explored by extractReturnMdf  

mostGeneral(mdfs)=mdf //assert fwd and fwd% not in mdfs
  if mdfs=mdf', then mdf=mdf' //that is the only way mdf=class
  otherwise if class in mdfs, then undefined
  otherwise if read in mdfs, mdf=read
  otherwise if capsule in mdfs, then mdf=mostGeneral(mdfs\capsule)
  //from now on, we have at least two of those:lent, mut, imm //Note: fwd and fwd% are cutted out in the throw rule
  otherwise if imm in mdfs, mdf=read
  otherwise mdf=lent

  
--------------------------------------------
3 ExpressionTypeJudgement
--------------------------------------------
  D |- e ~> e':T   and D |- k ~> k':T 
  where e' is an annotated version of expression e and is of type T
  where k' is an annotated version of catch k and k.e is of type T
  D.p points to where the e is located, //D.p.top()=ctxL[e]
  so if P inside e, D.p(P) is a reasonable operation


(void)
_ |- void~> void:imm Void

(Path)
_ |- P~>P:class P

(library prop)
Phase |p |_ |_ |_ |- L ~> L' : imm Library
  where
  Phase  |- p.evilPush(L) ~> L'

(x)
Phase| p| G| xss; xs| Tr |-x:T
  where
  x notin xs
  if x in xss T=toLent(G(x))
  otherwise T=G(x)

(loop)
D |- loop e ~> loop e' : imm Void
  where
  D|- e ~> e' : imm Void

(throw)
D|-throw[T?,_] e~> throw[T,mdf P] e' :  T
  where
  resolve(D.p,guessType(D.G,e))=T' //TODO: is it needed somehow or should just be asserted?
  D|- e~>  e' :  mdf P<=T'
  either T?=empty or T?=T
  if throw=exception, p|-mdf P<=imm P' and P' in D.Tr.exceptions
  if throw=return, p|-mdf P<=T', P in D.Tr.returns and mdf not fwd or fwd% 
  if throw=error, p|-mdf P<=imm Any  

(mcall)
D|- e0.m[_](x1:e1..Xn:en) ~> e'0.m[P0](x1:e'1..xn:e'n)  : T' //e0 will be of form mr
  where
  resolve(D.p,guessType(D.G,e0))= _ P0=T'0
  D.p(P0).m(x1..xn).mh[from P0]=mdf0 method T m(T1 x1,..Tn xn) exception Ps
  forall P in Ps exists P' in D.Tr.Ps such that p|- P <= P'
  forall i 0..n D|- ei ~> e'i : T'i <=Ti
  if no fwd or fwd% in T'1..T'n
    T'=T
  otherwise 
    T'=fwd% T
     
(using)
 D|-use P check m(x1:e1.. xn:en) e0 ~>use P check m(x1:e'1.. xn:e'n) e'0 :T0
 where
   plugin(D.p,P,m(x1..xn))=plg, T0..Tn //plg is a free variable, in the small step reduction would be the function representing the behaviour
   forall i 0..n D|- ei ~> e'i : T'i <=Ti


(block)
Phase| p| G| Cage| Tr|-(T1 x1=e1..Tn xn=en ks e0[_]) ~>(T'1 x1=e'1..T'n xn=e'n ks' e'0 [T]) : T
  where
  for i in 1..n T'i=resolve(p,Ti)
  Phase| p| G/x1..xn| Cage| Tr| mdf|-ks~> ks' : T
  G'=x1:T'1..xn:T'n
  G1=G[ks'][fwd(complete(G'))]
  for i in 1..n Phase| p| G1| Cage| Tr[ks']|-ei~>e'i: _ <=fwd% T'i
  mdf=extractReturnMdf(e'1..e'n)
  if exists x in FV(e1..en) such that G(x)=fwd _ or G(x)=fwd% _
    G0=G[fwd%(G')]
  otherwise
    G0=G[G']
  Phase| p| G0| Cage| Tr|-e0~>e'0:_<=T

  
(block divide scope)
//This rule is not materialized in the sugar since it would duplicate the catches (potentially exponentially) //also a desugaring tring to assign the inner block to a variable and then do the catches only one would capture also errors in the "e"
//type system need not to repeat the test for ks in the two contexts,
//since if ks typed in the outer block, it would also type in the same way
//in the richer context in the inner block.
D|- (ds1 ds2 ks e)~>(ds'1 ds'2 ks' e'):T
  where
  D|- (ds1 ks (ds2 ks e) )~>(ds'1 ks'(ds'2 ks' e')):T
  dom(ds2) not in FV(ds1)
  //we do not need to state FV(ks) not in dom(ds1,ds2) since rule block do G/x1..xn
  //to optimize, we could use a empty shell ks (with all es replaced with error void), but then we will need to explicitly test for FV(ks) not in dom(ds1,ds2)
  
(propagate promotions to catches)
//This rule is basically is a fix to support the syntactic sugar
//Can not be in the sugar since it needs to be applied dynamically and failure driven
//note, the sugar just use a single k, here is generalized
D|- (d catch return mdf Path x x e)~>(d' catch return mdf' Path x x e') :mdf' Path
  where
  D|-(d catch return mdf' Path x x e)~>(d' catch return mdf' Path x x e') :mdf' Path
  either
    mdf=capsule, mdf'=mut
  or
    mdf=imm, mdf' in {mut,read} //mut case is needed if we need capsule promotion+subtyping
    //is there a way to make this rule more deterministic?
    //if we look in FV(d) and compare with D.Cage.xss/xs we may work out what we need?


(catchMany)
D|-k1..kn ~> k'1..k'n:T
  where
  forall i in 1..n D|-ki ~> k'i:T
  either n=1 or forall i 1..n Any notEq k'i.T.P 
  
(catch)
Phase| p| G| Cage| Tr|-catch throw T0 x e ~> catch throw resolve(p,T0) x e' :T1
  where
  Phase| p| G[x:T0]| Cage| Tr |- e ~> e':_<=T1
  either throw=return or resolve(p,T0)=imm _
  resolve(p,T0) not in {_ Any, fwdImm _,fwdMut, fwd%Imm _,fwd%Mut _}//This cause strong limitation in factories using conditionals (as in if-return)

(catch and rethrow any)// could be sugared as "on throw mdf x doAndPropagate e"  
Phase |p |G |Cage |Tr|-catch throw T x (e0 throw x) ~> catch throw mdf Any x (e0' throw x): _
  where
  resolve(p,T)=mdf Any, mdf notin {fwdImm,fwd%Imm,fwdMut,fwd%Mut}
  either throw =return or mdf=imm
  e0=(imm Void y=e catch error Any z void void)
  e0'=(imm Void y=e' catch error Any z void void)
  Phase |p |G\x |Cage |empty |- e ~> e':imm Void

(unlock)
Phase |p |G |xss;xs |Tr[lessReturnReadLentMut]|-e~>e':mdf P
  where
  Phase |p |G |xss,domMut(G)\xss ; empty |Tr|-e~>e':mdf P
  mdf in {imm,fwd%Imm,fwdImm,capsule,class}

(swap)
Phase |p |G |xs0,xss;xs |Tr[lessReturnMut]|-e~>e':toLent(mdf P)
  where
  Phase |p |G |xss,domMut(G)\xss ; xs |Tr|-e~>e':mdf P

(capsule promotion)
Phase |p |G |Cage |Tr|-e~>e':capsule P
  where
  Phase |p |G |Cage' |Tr|-e~>e':mut P  
  Cage=xss;xs
  Cage'=xss,domMut(G)\xss;xs

(imm promotion)
Phase |p |G |Cage |Tr|-e~>e':imm P
  where
  Phase |p |G |Cage' |Tr|-e~>e':mdf P
  mdf in {read,lent} //TODO: what about fwd/fwd%  
  Cage=xss;xs
  Cage'=xss,domMut(G)\xss;domMutLentRead(G)//fwd%Mut, fwdMut in xs too

(lent to singleton)
Phase| p| G, x:lent C, G'|  xss;xs | Tr |-e~>e':T
  where 
  Phase| p| G, x:mut C, G'|  xss,{x};xs| Tr |-e~>e':T


------------------------------------------------------
4 Subtyping p|- T<=T' and shortcut D |- e ~> e':T<=T'
------------------------------------------------------
  
(subtype)
p|-mdf0 P0<=mdf1 P1
  where
  mdf0<=mdf1
  P in P0 U (p(P0).Ps[from P0])
  p.equiv(P,P1)
  
(shortcut)
D |- e ~> e':T<=T'
  where
  D |- e ~> e':T
  D.p |-T<=T'
  
mdf<=mdf
mdf1<=mdf3 if mdf1<=mdf2 and mdf2<=mdf3
capsule<=mut,imm
imm<=read
mut<=lent
lent<=read
mut<=fwd%Mut
fwd%Mut<=fwdMut
imm<=fwd%imm
fwd%Imm<=fwdImm
-----------------------------------------------
5 LibraryAndMemberTyping
-----------------------------------------------
 Phase |- p ~> L   and   p | Ps |- M ~> M'
 L is the typed/annotated version of p.top()
 M' is the annotated version of M
 and p.top() is the literal containing M

  
(library shallow norm)
Norm  |- p ~> norm(p)  //remember: norm ignores meth bodies
//assert forall P in norm(p).Ps p(P).Phase>=Norm

(library well typed)
Phase |- p ~> L' //In implementation, if p.top().Phase>=Phase, L'=p.Top()
   where
   Phase in {Typed,Coherent}
   L0={interface? implements Ps M1..Mn Phase'}=norm(p)
   L'={interface? implements Ps M1'..Mn' max(Phase',Phase)}
   //assert forall P in Ps p(P).Phase>=Norm
   forall i in 1..n
     Phase| p| Ps |- Mi ~> Mi'
   if Phase=Coherent then coherent(p)

Phase| p| Ps |-C:L ~>  C:L'
   where
   Phase |-p.push(C) ~> L'

Phase| p| Ps |-M ~> M'
  where
  M =refine? mdf method T m(T1 x1 .. Tn xn)exceptions Ps' e?
  M'=refine? mdf method T m(T1 x1 .. Tn xn)exceptions Ps' e?'
  G=this:mdf This0,x1:T1,..,xn:Tn
  if e?=e then
    Typed| p| G|empty;empty|empty;Ps' |- e ~>  e?':_ <=fwd% T
  else
    e?=e?'
  refine? != empty <=> 
    forall P in Ps such that p(P)(m(x1..xn))=M0 //that is, is defined
      M0=mdf method T' m(T1 x1..Tn xn)exceptions Ps' and p|-T<=T'


coherent(p) //interfaces are always coherent
  where
  p.top()={interface implements _ mwts ncs}
    
coherent(p)  //classes are coherent if they have a coherent set of abstract methods
  where
  p.top()={implements _ mwts' ncs} //note, no interface
  mwts={mwt in mwts'| mwt.e undefined } //collect the abstract methods
  either mwts is empty or
    at least 1 mwt in mwts is class method 
    and
    exists some (T x)s such that //angelic non determinism to figure out at least one set of types for the fields 
      all T in (T x)s are mut, imm, class or capsule //thus, no fwd
      forall mwt in mwts coherent(p,(T x)s, mwt) //all abstract methods are coherent according to those fields
      
      
coherent(p,T1 x1..Tn xn,
      refine? class method T m(T1' x1..Tn' xn) exception _)
  where
  either
    p|-mut This0 <=T and p|-Ti'<=fwd Ti
  or   
    p|-imm This0 <=T and p|-Ti'<=fwd toImm(Ti)
  or
    p|-read This0 <=T and p|-Ti'<=fwd toRead(Ti) //how with capsule?


coherent(p,T1 x1..Tn xn,
    refine? mdf method T m() exception _)
  where
  m=#?xi
  either
    mdf=mut and p|-capsuleToLent(Ti)<=T //exposer
  or 
    mdf=read and p|-toRead(Ti)<=T //getter
  

coherent(p,T1 x1..Tn xn,
    refine? mut method Void m(T that) exception _)
  where
  m=#?xi
  p|-T<=Ti//setter
  

  
------------------
Dispatch //HARD
-------------------

1- e:imm Library do we always know the expected (super) type?
  D,e,expectedT-->e'
  D|-e~>e' :_<=expectedT



Calling type system on e:

SimpleTS: //input the expected type, return the computed type or the kind of error
if e is a block, then
  if possible apply(block divide scope) to the smallest possible starting ds
  else apply (block)
  inside (block) we will apply (catchMany),(catch),(catch and rethrow any) 
otherwise
  if e not block, apply rule for (void) (Path) (library prop)(x) (loop) (throw) (mcall) (using)

CompleteTs://the one called recursivelly every time we do a "D|-e~>e' :_<=expectedT", return void or the error
  as much as possible, apply (lent to singleton)  
  if possible and do not restrict the returns, apply unlock  
  try SwapTS
  on result subtype of expected: all ok
  on result not subtype of expected:
    if result is different w.r.t. the expected, fixable modulo capsule promotion:
      apply (capsule promotion), then UnlockTS
      if fail and expression is block in shape, apply (propagate promotions to catches):
      apply to change to mut, apply (capsule promotion), apply SwapTS; assert: the result is subtype of the expected.
    if result is different w.r.t. the expected, fixable modulo imm promotion:
      apply (imm promotion), then UnlockTS
      if fail and expression is block in shape, apply (propagate promotions to catches):
      apply to change to mut, apply (capsule promotion), apply SwapTS; assert: the result is subtype of the expected.
      if fail
      apply change to read, apply (imm promotion), apply SwapTS; assert: the result is subtype of the expected.

SwapTS: //return computed type or error
  try SimpleTS
  on result subtype of expected: all ok
  on fail:
    if "lent should be mut", apply swap, then SimpleTS
    propagate other failures

UnlockTS: //return computed type or error
  try SwapTS
  on result subtype of expected: all ok
  on fail:
    if "required variable is strongly locked", apply unlock, then SwapTS
    propagate other failures

----------------

Coherent and union types:
to easy translation in Java/etc, we can not accept the following
A,B interface
C,D implements A,B

I implements C,D
class method This f(I x   )
mut method Void x ( C that)
mut method Void #x ( D that)
read method A x()
read method B #x()
as coherent, since the field would be an union type of C and D
