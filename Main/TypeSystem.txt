-----------------------------
Structure of this document:

1 Type Grammar

2 Type manipulation

3 ExpressionTypeJudgement

4 Subtyping p|- T<=T' and shortcut D |- e ~> e':T<=T'

5 LibraryAndMemberTyping

-----------------------------
1 Grammar
-----------------------------
//In this file, all the L are LC   //LC == in all C:e, e of form L

G::=x1:T1..xn:Tn  //G reads Gamma
D::= Phase `|` p `|` G `|` Cage `|` Tr  //D reads Delta
Cage::= xss; xs
Tr::=Ts; Ps //Tr reads Throws

//we believe that at any moment, in a D:
//Cage.xss contains only bindings that are mut in G
//Cage.xs contains only bindings that are mut, fwd%Mut, fwdMut, lent, read in G 

--------------------------------------------
2 Type manipulation
--------------------------------------------

complete(G)={x:T | G(x) not fwd/fwd%}

fwd T
  fwd imm P=fwd fwd%imm P=fwdImm P
  fwd mut P=fwd fwd%mut P=fwdMut P
  otherwise fwd T=T

fwd% T
  fwd% imm P=fwd%Imm P
  fwd% mut P=fwd%Mut P
  otherwise fwd% T=T
 
noFwd
  noFwd imm P=noFwd fwd%imm P=Imm P
  noFwd mut P=noFwd fwd%mut P=Mut P
  otherwise noFwd T=T

toImm(T)        
  toImm(class P)=class P
  otherwise, toImm(mdf P)=imm P

toLent(T)
  toLent(mut P)=lent P,
  toLent(mutFwd P) and toLent(mutFwd% P) undefined;
  otherwise toLent(T)=T 

capsuleToLent(T)  
  capsuleToLent(capsule P)=lent P
  otherwise capsuleToLent(mdf P)=mdf P
   
toRead(T)
  toRead(imm P)=imm P
  toRead(fwdImm P)=fwdImm P
  toRead(fwd%Imm P)=fwd%Imm P
  toRead(fwdMut P)=toRead(fwd%Mut P)=undefined
  toRead(class P)=class P
  otherwise toRead(mdf P)=read P //mdf in read,lent,mut,capsule

toRead(G)
  toRead(G)(x)=toRead(G(x)) //thus undefined where toRead undefined 

G[G']
  G[G'](x)=G'(x) if x in dom(G'); otherwise G[G'](x)=G(x)

G[ks]
  G[catch error mdf P x e ks]=toRead(G) with P not Any
  otherwise G[ks]=G 

Tr[ks]
  Ts; Ps [catch error T1 x1 e1..catch error Tn xn en..]=Ts; Ps
  Ts; Ps [catch exception _ P1 x1 e1..catch exception _ Pn xn en..]=Ts; Ps,P1..Pn/Any
  Ts; Ps [catch return mdf P1 x1 e1..catch return mdf Pn xn en..]=Ts[adaptMdfForReturn mdf P1]..[adaptMdfForReturn mdf Pn];Ps 
  //Note: all the mdf of the various Ts are required to be the same, or the operation is undefined and we get a type error

mdf P1..mdf Pn[adaptMdfForReturn mdf' P0]
  mdf P1..mdf Pn[adaptMdfForReturn mdf' P0]=mdf' P0..mdf' Pn  if mdf' <= mdf
  otherwise mdf P1..mdf Pn[adaptMdfForReturn mdf' P0]=mdf' P0 //this case will also be triggered for n=0 
  //is multi level return needed by the sugar? can we optimize more during java generation if we do not?


--------------------------------------------
3 ExpressionTypeJudgement
--------------------------------------------
  D |- e ~> e':T   and D |- k ~> k':T 
  where e' is an annotated version of expression e and is of type T
  where k' is an annotated version of catch k and k.e is of type T
  D.p points to where the e is located, //D.p.top()=ctxL[e]
  so if P inside e, D.p(P) is a reasonable operation


(void)
_ |- void~> void:imm Void

(Path)
_ |- P~>P:class P

(library prop)
Phase |p |_ |_ |_ |- L ~> L' : imm Library
  where
  Phase  |- p.evilPush(L) ~> L' // is it clashing on the notation in the end of Normalization.txt?

(x)
Phase| p| G| xss; xs| Tr |-x:T
  where
  x notin xs
  if x in xss T=toLent(G(x))
  otherwise T=G(x)

(loop)
D |- loop e ~> loop e' : imm Void
  where
  D|- e ~> e' : imm Void

(throw)
D|-throw[_,_] e~> throw[T,mdf P] e' :  T
  where
  D|- e~>  e' :  mdf P
  if throw=exception, p|-mdf P<=imm P' and P' in D.Ps
  if throw=return, p|-mdf P<=T' and T' in D.Ts
  if throw=error, p|-mdf P<=imm Any  

(mcall)
D|- e0.m[_](x1:e1..Xn:en) ~> e'0.m[P0](x1:e'1..xn:e'n)  : T'
  where
  D|-e0~> e'0:mdf'0 P0<=mdf0 P0
  not D|-e0~> _:imm Void //makes (error x).m(...) not well typed// talked with James, not convinced is needed, we do not have way to recognize if a block has a specific type
  D.p(P0).m(x1..xn).mh[from P0]=mdf0 method T m(T1 x1,..Tn xn) exception Ps
  forall P in Ps exists P' in D.Tr.Ps such that p|- P <= P'
  forall i 1..n D|- ei ~> e'i : T'i <=Ti
  if no fwd or fwd% in T'1..T'n
    T'=T
  otherwise 
    T'=fwd% T
     
(using)
 D|-use P check m(x1:e1.. xn:en) e0 ~>use P check m(x1:e'1.. xn:e'n) e'0 :T0
 where
   plugin(D.p,P,m(x1..xn))=plg, T0..Tn //plg is a free variable, in the small step reduction would be the function representing the behaviour
   forall i 0..n D|- ei ~> e'i : T'i <=Ti


(block)
Phase| p| G| Cage| Tr|-(T1 x1=e1..Tn xn=en ks e0[_]) ~>(T'1 x1=e'1..T'n xn=e'n ks' e'0 [T]) : T
  where
  for i in 1..n T'i=resolve(p,Ti)
  Phase| p| G/x1..xn| Cage| Tr|-ks~> ks' : T
  G'=x1:T'1..xn:T'n
  G1=G[ks'][fwd(complete(G'))]
  for i in 1..n Phase| p| G1| Cage| Tr[ks']|-ei~>e'i: _ <=fwd% T'i
  if exists x in FV(e1..en) such that G(x)=fwd _ or G(x)=fwd% _
    G0=G[fwd%(G')]
  otherwise
    G0=G[G']
  Phase| p| G0| Cage| Tr|-e0~>e'0:T //if the expected type is ALWAYS available, we can allow subtyping here and in catch.
  
(block divide scope)
//This rule is not materialized in the sugar since it would duplicate the catches (potentially exponentially)
//type system need not to repeat the test for ks in the two contexts,
//since if ks typed in the outer block, it would also type in the same way
//in the richer context in the inner block.
D|- (ds1 ds2 ks e)~>(ds'1 ds'2 ks' e'):T
  where
  D|- (ds1 ks (ds2 ks e) )~>(ds'1 ks'(ds'2 ks' e')):T
  dom(ds2) not in FV(ds1)
  

(propagate promotions to catches)
//This rule is basically is a fix to support the syntactic sugar
//Can not be in the sugar since it needs to be applied dynamically and failure driven
//note, the sugar just use a single k, here is generalized
D|- (d catch return mdf Path x x e)~>(d' catch return mdf' Path x x e') :mdf' Path
  where
  D|-(d catch return mdf' Path x x e)~>(d' catch return mdf' Path x x e') :mdf' Path
  either
    mdf=capsule, mdf'=mut
  or
    mdf=imm, mdf' in {mut,read} //mut case is needed if we need capsule promotion+subtyping
    //is there a way to make this rule more deterministic?
    //if we look in FV(d) and compare with D.Cage.xss/xs we may work out what we need?


(catchMany)
D|-k1..kn ~> k'1..k'n:T
  where
  forall i in 1..n D|-ki ~> k'i:T
  either n=1 or forall i 1..n Any notEq k'i.T.P 
  
(catch)
Phase| p| G| Cage| Tr|-catch throw T0 x e ~> catch throw resolve(p,T0) x e' :T1
  where
  Phase| p| G[x:T0]| Cage| Tr |- e ~> e':T1
  either throw=return or resolve(p,T0)=imm _
  resolve(p,T0) not of form _ Any

(catch and rethrow any)// could be sugared as "on throw mdf x doAndPropagate e"  
Phase |p |G |Cage |Tr|-catch throw T x (e0 throw x) ~> catch throw mdf Any x (e0' throw x):T
  where
  resolve(p,T)=mdf Any
  either throw =return or mdf=imm
  e0=(imm Void y=e catch error Any z void void)
  e0'=(imm Void y=e' catch error Any z void void)
  Phase |p |G\x |Cage |empty |- e0 ~> e0':imm Void

(lent viewpoint adaptation)//We may want to split t-swap and t-unlock again
Phase |p |G |Cage |Tr|-e~>e':toLent(mdf P)
  where
  Phase |p |G |Cage' |Tr|-e~>e':mdf P
  Cage=xs0,xss;xs
  Cage'=xss,domMut(G)\xss ; xs'
  if mdf in {imm,fwd%Imm,fwdImm,capsule,class} then xs'=empty
  otherwise  xs'=xs

(capsule promotion)
Phase |p |G |Cage |Tr|-e~>e':capsule P
  where
  Phase |p |G |Cage' |Tr|-e~>e':mut P  
  Cage=xss;xs
  Cage'=xss,domMut(G)\xss;xs

(imm promotion)
Phase |p |G |Cage |Tr|-e~>e':imm P
  where
  Phase |p |G |Cage' |Tr|-e~>e':mdf P
  mdf in {read,lent}  
  Cage=xss;xs
  Cage'=xss,domMut(G)\xss;domMutLentRead(G)//fwd%Mut, fwdMut in xs too

(lent to singleton)
Phase| p| G, x:lent C, G'|  xss;xs | Tr |-e~>e':T
  where 
  Phase| p| G, x:mut C, G'|  xss,{x};xs| Tr |-e~>e':T


------------------------------------------------------
4 Subtyping p|- T<=T' and shortcut D |- e ~> e':T<=T'
------------------------------------------------------
  
(subtype)
p|-mdf0 P0<=mdf1 P1
  where
  mdf0<=mdf1
  P in P0 U (p(P0).Ps[from P0])
  p.equiv(P,P1)
  
(shortcut)
D |- e ~> e':T<=T'
  where
  D |- e ~> e':T
  D.p |-T<=T'
  
mdf<=mdf
mdf1<=mdf3 if mdf1<=mdf2 and mdf2<=mdf3
capsule<=mut,imm
imm<=read
mut<=lent
lent<=read
mut<=fwd%Mut
fwd%Mut<=fwdMut
imm<=fwd%imm
fwd%Imm<=fwdImm
-----------------------------------------------
5 LibraryAndMemberTyping
-----------------------------------------------
 Phase |- p ~> L   and   p |- M ~> M'
 L is the typed/annotated version of p.top()
 M' is the annotated version of M
 and p.top() is the literal containing M

  
(library shallow norm)
Norm  |- p ~> norm(p)  //light norm: ignore meth bodies

(library well typed)
Typed |- p ~> L'
   where
   L0={interface? implements Ps M1..Mn Phase}=norm(p)
   L'={interface? implements Ps M1'..Mn' max(Phase,Typed)}
   p| Ps |- Mi ~> Mi'
   forall ms in dom(p(P1))U..U dom(p(Pm))
     where Ps=P1..Pm
     ms in dom(L0)


(library coherent)
Coherent |- p ~> L'
   where
   Typed |- p ~> L'
   coherent(p)
    


p| Ps |-C:L ~>  C:L'
   where
   Typed |-p.push(C) ~> L'

p| Ps |-M ~> M'
  where
  M =refine? mdf method T m(T1 x1 .. Tn xn)exceptions Ps' e?
  M'=refine? mdf method T m(T1 x1 .. Tn xn)exceptions Ps' e?'
  if e?=e then
    Typed p| G|empty;empty|empty;Ps' |- e ~>  e?':_ <=T//should it be fwd% T ?? check in formal.pdf
  else
    e?=e?'
  existsExactly 1 P in Ps,This0
    such that p(P)(m(x1..xn)).refine? = empty
  refine? != empty <=> 
    forall P in Ps such that p(P)(m(x1..xn))=M //that is, is defined
      M=mdf method T' m(T1 x1..Tn xn)exceptions Ps' and p|-T<=T'

coherent(p,C1:L1..Cn:Ln)=coherent(p.push(C1),L1)..coherent(p.push(Cn),Ln)

coherent(p)
  where
  p.top()={interface implements _ mwts ncs}
  coherent(p,ncs)
    
coherent(p)    
  where
  p.top()={implements _ mwts' ncs} //note, no interface
  coherent(p,ncs)
  mwts={mwt in mwts'| mwt.e undefined }
  either mwts is empty or
    at least 1 mwt in mwts is class method 
    and
    exists (T x)s such that
      all T in (T x)s are mut, imm, class or capsule //thus, no fwd
      forall mwt in mwts coherent(p,(T x)s, mwt)
      
      
coherent(p,T1 x1..Tn xn,
      refine? class method T m(T1' x1..Tn' xn) exception _)
  where
  either
    p|-mut This0 <=T and p|-Ti'<=fwd Ti
  or   
    p|-imm This0 <=T and p|-Ti'<=fwd toImm(Ti)
  or
    p|-read This0 <=T and p|-Ti'<=fwd toRead(Ti) //how with capsule?


coherent(p,T1 x1..Tn xn,
    refine? mdf method T m() exception _)
  where
  m=#?xi
  either
    mdf=mut and p|-capsuleToLent(Ti)<=T //exposer
  or 
    mdf=read and p|-toRead(Ti)<=T //getter
  

coherent(p,T1 x1..Tn xn,
    refine? mut method Void m(T that) exception _)
  where
  m=#?xi
  p|-T<=Ti//setter
  

  
------------------
Dispatch //HARD