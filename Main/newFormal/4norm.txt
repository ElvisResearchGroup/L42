//Can now be done that all P in a CORE.L are minimized?


_______
#define expandFields(Ms)=Ms'
* M in expandFields(Ms) 
    M in Ms
    M not of form F
* method toRead(T) x() in expandFields(Ms) 
    var? T x in Ms
* method capsuleToLent(T) #x() in expandFields(Ms) 
    var? T x in Ms
    T.mdf in {lent, mut, capsule}
* method Void x(T that) in expandFields(Ms) 
    var T x in Ms
_______
#define Ts\p Tz,   collect(p,Ts)=Ts' //collects transitively implemented interfaces
* Ts \p Tz=Ts'  //"\p" is set minus on lists using p.equiv(P1,P2)
* empty \p Tz=empty
* T,Ts\p T',Tz = Ts\p T',Tz
    p.equiv(T.P,T'.P)
* T,Ts\p Tz) = T,(Ts\p Tz)
    otherwise

* collect(p,empty)=empty
* collect(p,T0 Ts)=((T0 Ts') \p collect(p,Ts)) collect(p,Ts)
    //that is, crucially: depth first but we avoid duplicates by keeping the rightmost occurrence.
    p(T0.P)=interface Ts0 {_}=FULL.L
    Ts'=collect(p,Ts0[from T0.P])
    //this checks absence of circularity by diverging
    //an implementation could keep a list of visited P instead of diverging; mathematically it is the same
* collect(p,T0 Ts)=((T0 Ts0[from T0.P]) \p collect(p,Ts)) collect(p,Ts)
    p(T0.P)=interface Ts0 {_}=CORE.L
_______
#define methods(p,P0)=MWTs //methods returns a set: the order of the methods is not relevant
//methods(), applied to a CORE.L will just return the MWTs;
//applied to a FULL.L, will return a merge of the methods retrieved directly from the L and methods types declared
//in its implemented interfaces. It chooses a type in case of different refines in interface diamond implementations
//In this model cases like
//    A=  interface {refine method A m()}
//    B= [A]{ method A m()}
//are ok wrt B but fail for A

* methods(p,P0)=CORE.L.MWTs[from P0]
    p(P0)=CORE.L
  
* methods(p,P0)=MWT1..MWTn
    p(P0)=interface? Ts{ Ms }=FULL.L
    Ps=collect(p,Ts[from P0]).Ps//T1..Tn is a list, not a set
    s1..sn=[ss | P in Ps, ss in p(T.P).Ms.ss].flatten().distinct()//an ordered version of {s | P in Ps, s in dom(p(P))}
    //Note, in the code it is(properly implemented but) done in 2 steps, first cb0, then p1n
    forall s in s1..sn, there is exactly 1 P in Ps such that p(P)(s).refine=empty //origin
    [Mi,_]=[MWT[?refine=refine]| P in P0,Ps such that methods(p,P)(si)=MWT]
    MWTi=Mi [with e=p(P0)(si).e[from P0]] if defined,
    MWTi=Mi otherwise
_______
#define resolveCs(p,FULL.T)=CORE.T,   resolveCs(p,FULL.P)=CORE.P,  resolveCs(p,FULL.docs)=CORE.docs
* resolveCs(p,docs mdf P)=resolveCs(p,docs) mdf resolveCs(p,P)
* resolveCs(p,empty)=X with fresh X //case T?=empty

* resolveCs(p,CORE.P)=CORE.P
* resolveCs(p,C.Cs)=Thisn.C.Cs
    where n is the smallest number such that either
      C in dom(p.get(n))
      or p.get(n)={@{__STOP_SCOPE__} _}
      or p.get(n+1) undefined

* resolveCs(p,FULL.docs) =docs' where all the Full.P are replaced with resolveCs(p,FULL.P)

_______
#define p|-T <= Tz //todo: move in typesystem
* p|-T <= T0..Tn  iff  p|-T <= T0,..,p|-T <= Tn
_______
#define PT in CCz
* PT in PT<=_,_
* PT in _<=PT,_
_______
#define origin(s; P) = P
* origin(s; P) = P
    {P} = {P| P in collect(p,P) and p(P)(s).refine?=empty}
_______
#define mostSpecific(Tz) = T
* mostSpecific(Tz) = T
    {T}={T| T in p.minimize(Tz) and p|-T<=p.minimize(Tz)}
_______
#define collect(CCz)=CCz'
* CC in collect(CCz)
    CC in collect(collect(CCz)) //CC in collect(CCz,CCz') where CC in collect(collect(CCz))
* CC in collect(CC,_)
* PT <= PT" in collect(PT <= PT', PT' <= PT",_)
* PT <= PT in collect(CCz)
    PT in CCz
* mdf P <= mdf' P' in collect(_) //TODO: explosive, can we make it more computational? can we mix it with CollectSolution? 
    p |- mdf P <= mdf' P' // I.e. every subtype relation we know about
    P' != _ Any // Just for consistency with everything else, not important!
* mdf P <= PT in collect(PT <= mdf P,_)// since all classes are final!
	p[P].interface = empty 
* T.s <= PT in collect(CCz)//since they are alias of each other 
    PT <= T.s in collect(CCz)
    PT=p[T.s].T
* T.s.i <= PT in collect(CCz)//since method parameter types can not be refined (or since they are aliases?)
    PT <= T.s.i in collect(CCz)
    PT=p[T.s].Ti
* PT.s <= PT'.s in collect(PT <= PT', CCz)
    PT'.s in CCz
* PT'.s.i <= PT.s.i in collect(PT <= PT',CC')
    PT'.s.i in CC'
* PT.s.i <= PT'.s.i in collect(PT <= PT',CC')//since method parameter types can not be refined 
    PT'.s.i in CC'
* PT1' <= Origin(s, P2') in collect(PT1 <= P2', PT1 <= PT1', CCz)
    P2'.s in CCz
    PT1'.s in CCz
_______
#define commonSuperT(p,Tz)=Tz'
* commonSuperT(p,T0 .. Tn) =Tz0 intersect..intersect Tzn
    Tzi={T| p|-Ti<=T}//computable as {mdf P | P in p.minimize(p(P).Pz[from T.P] U {T.P, Any}, T.mdf <= mdf}  
_______
#define solve(p, CCz) = IMap,  chooseT(CCz;Tz)=T
* solve(p, CCz) = X1:T1 .. Xn:Tn
    X1 .. Xn = { X | X inside p.top() }
    Tzi = {T | T in commonSuperT(p,{T|T<=Xi in CCz}) and p |- T <= {T|Xi<=T in CCz}} //possible solutions
    Ti = chooseT({T|Xi<=T in CCz} U {T|T<=Xi in CCz};Tzi)
* chooseT(CCz;class Any,_)=class Any
* chooseT(CCz;Tz)=mostSpecific(Tz)
    mostSpecific(Tz)!= capsule P or capsule _ in CCz
* chooseT(Tz)=imm P
    mostSpecific(Tz)= capsule P
    imm _ in CCz
    not capsule _ in CCz
* chooseT(Tz)=mut P 
    mostSpecific(Tz)= capsule P
    not imm _ in CCz
    not capsule _ in CCzP
_______
#define unsatisfiable(P <= P', CCz)   
unsatisfiable(P <= P', CCz)
  if p |/- P <= P'
unsatisfiable(PP <= P', PP <= P", CCz)
  exists s in dom p[P'] and p[P"], where origin(s, P') != origin(s, P")
unsatisfiable(PP <= P', PP <= P", CCz)
  no P in dom(p) such that P <= P' and P <= P"
_______
#define paramaterPaths(PT, CCz, s)  
paramaterPaths(PT, CCz, s) = p[T.s].Ps
	PT <= T in collect(CCz)




 