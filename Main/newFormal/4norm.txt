Here we define normalize(p,FULL.L):HALF.L  and  normalize(Y,FULL.e):HALF.e
Then p !!e or Y!!e will go to CORE.e
normalize(Y,FULL.e):HALF.e
 will be called on an expression in the full language that may contain FULL.L, but in those all the
NC's are CORE.NCs, that is, C=e are of form C=CORE.L

The result should be of form HALF.e
ideally, we can define another function typeInference(p,HALF.e):CORE.e using your algorithm
-------------
HALF.e
------------- // For consistency
HALF.L ::= H { MWT* CORE.NC* }
HALF.xP ::= x | CORE.P | (CORE.T CORE.P)

HALF.e::= x | (TX CORE.P) | void | FULL.L | \
 | throw e | loop e | x := e 
 | xP.m(xe*)
 | xP (op xP)+
 | ( Ds Ks e )  
HALF.K ::= "catch" throw TX x e
HALF.D ::= "var"? TX x = e
TX::=CORE.T | X | \

-------------
Y environment
-------------
Y ::= p; xP?; T?; PType
PType::=error| classP |classAny| \ | m(n)
_______
#define toBinOp(x,Op=) // convenience method to desugar updateOps
toBinOp(x, :=) = x :=
toBinOp(x, OP=) = x := x OP 
_______
#define Y(xP),  PType(p,xP) 
  
  Y(x)= resolveCs(p,Y.PType(Y.p,xP)) // You're going to need to define resolveCs
  
  PType(p, x) = x
  PType(p, (T P)) = (T P)
  classP(p, P) = (class P P)
  \(p,P) =  (\ P)
  m(n)(p,P)= (class P P) iff m(x1..xn) in dom p(P) 
  m(n)(p,P)= (class Any P) otherwise 
  // so error(p, e) is undefined?

_______
#define expandFields(Ms)
M in expandFields(Ms) 
  where M in Ms, M not of form F
method toRead(T) x() in expandFields(Ms) 
  where var? T x in Ms
method capsuleToLent(T) #x() in expandFields(Ms) 
  where var? T x in Ms  and   T.mdf in {lent, mut, capsule}
method Void x(T that) in expandFields(Ms) 
  where var T x in Ms

-----------------------------------------------------------
Part 3: methods(p,P)=Ms,  collect(p,Ps)=Ps'
-----------------------------------------------------------
methods(), applied to a FULL.L, will return a mixture of
the methods retrieved directly from the L and methods declared in its
implemented interfaces.
Applied to a CORE.L will just return the methods

methods() collects such methods and their types. It may have to choose a type
in case of methods refined in different ways from interface diamond implements.

_______
#define Ts\p Tz,   collect(p,Ts)=Ts' //collects transitively implemented interfaces
-collect(p,empty)=empty
  //an implementation could keep a list of visited P instead of diverging; mathematically it is the same.

-collect(p,T0 Ts)=((T0 Ts') \p collect(p,Ts)) collect(p,Ts)
  //that is, crucially: depth first but we avoid duplicates by keeping the rightmost occurrence.
  p(T0.P)=interface Ts0 {_}=FULL.L
  Ts'=collect(p,Ts0[from T0.P])
  //this checks absence of circularity by diverging (i.e. looping until stack overflow)

-collect(p,T0 Ts)=((T0 Ts0[from T0.P]) \p collect(p,Ts)) collect(p,Ts)
  //that is, crucially: depth first but we avoid duplicates by keeping the rightmost occurrence.
  p(T0.P)=interface Ts0 {_}=CORE.L

-Ts \p Tz=Ts'  //"\p" is set minus on lists using p.equiv(P1,P2)
 empty \p Tz=empty
 T,Ts\p T',Tz = Ts\p T',Tz
   where p.equiv(T.P,T'.P)
 T,Ts\p Tz) = T,(Ts\p Tz)
   otherwise

_______
#define methods(p,P0)=M1'..Mk' //methods returns a set: the order of the methods is not relevant
  p(P0)=interface? Ts{ Ms }=FULL.L
  T1..Tn=collect(p,Ts[from P0])
  s1..sk={s|exists i in 0..n : p(Ti.P)(s) is defined}
  //Note, in the code it is(properly implemented but) done in 2 steps, first cb0, then p1n
  forall s in s1..sk, there is exactly 1 j in 0..n
    such that p(Tj.P)(s).refine=empty
  forall i in 1..k //i comes from k in s1..sk
    Mi= p(P0)(si)[from P0],  with p(P0)(si) of form MWT,
    otherwise //note: 's e' and missing methods both become MWT from implemented interfaces
    Mi=methods(p,Pj)(si)[?refine=refine]
      for the smallest j in 1..n such that methods(p,Pj)(si) is of form MWT
      //this ordering of j leverages the smart ordering of collect()
    Mi'=Mi[with e=p(P0)(si).e[from P0]] if defined,
    otherwise
    Mi'=Mi
    
#define methods(p,P0)=MWTs[from P0]
  p(P0)=interface? Ts{ MWTs NCs }=CORE.L
    
//Note, in this model cases like
//"A:  interface {refine method A m()}
// B: [A]{ method A m()}"
// are ok wrt B but fail for A
-------------
NORMALIZATION
-------------
_______
#define normalize(p,FullE):HalfE

normalize(Y,CORE.L)=CORE.L

normalize(p,H{reuse [URL] Ms})=normalize(p,H{NCs,Ms})
  where followURL(URL)=NCs //all the NC of form Docs C=core(L)
normalize(Y,H{... Ms})=normalize(Y,H{readFolder(Y.p),Ms})

normalize(p,CORE.L)=CORE.L //assert never happens (not true in real language but good for debugging at the start)
normalize(p,FULL.L)=CORE.L
  where 
    LL=interface? Ts{Ms0}
    CORE.L=interface? Ts,(Ts'\p Ts){Info normalize(p',Ms')}
    Info=
      norm;
      depType;depCoherent=collectDeps(CORE.L);
      friendsDep Ps= ??;//using private methods (or paths??)
      usedMethDep (P.s)s; //non private
      privateImplements Ps //interfaces implemented by a private nested       
    p'=p.push(LL)
    Ts'=collect(p',Ts) // this gets the transitively implemented interfaces (-Any)
    Ms=expandFields(Ms0) // And this turns the fields into abstract methods
    forall T in Ts'\p Ts, p'.noUnique(T) //no private interfaces are added
    Ms'=methods(p',This0)\Ms.ss, [methods(p',This0)(M.s)| M in Ms],[C:e| C:e in Ms]
    //the line above use [|] to make sequences nor sets. The order of members is important here.
    //Note: using Ts'\p Ts the docs of any T inside Ts override the one inside Ts'

normalize(p,M'1..M'n)=apply(solve(p,CCz),M1)..apply(solve(p,CCz),Mn)
  where
    M1..Mn=normalize(p,M'1) .. normalize(p,M'n)
    var CCz = empty
    while CCz changes:
    	CCz' = p|p[P1] +> ... p[Pn]
    	CCz = Collect(p, (p|Ccz +>M1+>..+>Mn).CCz) // TODO: call p|CCz +> L directly?
    
    
normalize(p,MH e?)= resolveCs(p,MH) e'?
  where 
    e'?=empty if e?=empty
    e'?= normalize(Y[p=p,&xP=empty,T=MH.T,PType=MH.T],e?) otherwise
normalize(p,CORE.NC) =CORE.NC[docs=resolveCs(p,CORE.NC.docs)] 
//assert never happens normalize(p,C:Full.L)
//assert never happens normalize(p,s e)

_______
#define p|CCz +>M = p|CCz' 
p|CCz +> C = L = p|CCz +> L[from This0.C]
	where L.Info is defined
p|CCz +> H { Info; M1 ... Mn } = p|CCz +> M1 +> ... +> Mn
p|CCz +>MWT =p|CCz
  where MWT.e?=empty
p|CCz +>MWT =p|CCz',PT<=MWT.T
  p|G^MWT|CCz +>MWT.e:PT =p|_|CCz'
  
  NOTE/TODO; we need to expand reuse and ... 'earlier', as if they was an additional nested
  {... Ms}
  {reuse [towel1]//expanded before 
  method Foo x()=( x=1Num)//type error
  EE=foo(`towel1,lib={...})
  D=deployTowel(`towel1,lib={...})
  G={reuse [towel1]}
  C={method foo()=( x=1Num)}
  }

_______
#define normalize(Y,FullE):HalfE
//simple cases first

normalize(Y,x)=x //assert x not of form _
normalize(Y,P)=Y.PType(P)
normalize(Y,void)=void
normalize(Y,L)=normalize(Y.p,L)
normalize(Y, (T e) )=(T' x=normalize(Y[T=T'],e) x)
  where 
    T'=resolveCs(Y.p,T)
    e not of form P // Ok now I just hate you...
normalize(Y, (T P) )= resolveCs(Y.p,(T P) )
normalize(Y,\)=\
normalize(Y,\x)=(Y.xP).x()
normalize(Y,'PathLit)=normalize(Y,\"PathLit")
normalize(Y,return e)=return normalize(Y[PType=classP],e) // Because you'd never want to return a class Any?
normalize(Y,throw e)=throw normalize(Y[PType=error],e)
  where throw in {error,exception}
normalize(Y,loop e)=loop normalize(Y[PType=error],e)
normalize(Y,~e)=normalize(Y[PType=classP],e).methName(~)()
normalize(Y,!e)=normalize(Y[PType=classP],e).methName(!)()
normalize(Y, NumLit e)=normalize(Y, e"NumLit")
normalize(Y,x updateOp e)=  normalize(Y,toBinOp(x, updateOp) e)
normalize(Y, e(.m)?(par))=(x=normalize(Y[PType=classP],e) x.methName(m?)(normalizePar(Y[xP=x,T=\,PType=\],par))
  where e not of form xP, x fresh
normalize(Y, xP(.m)?(par))= Y[PType=classP](xP).methName(.m?)( normalizePar(Y[xP=x,T=\,PType=\],par) )
  
//bin operators
normalize(Y,e1 op3 e2)= (x=normalize(Y,e1) normalize(Y,x op3 e2) )
  where e1 not of form xP //op3: &&, || and => are not static-dispatch, to have short circuit 
normalize(Y,xP op3 e)= (
  classP(xP).#shortCircut'op3'().#checkTrue()  //here and and under, using ' to generate method names in some standard way
  catch exception Void _ normalize(Y,e2)
  classP(xP).#shortCircut'op3'Result()
  )
 Isaac propose to save this temp e1 && e2 ==>
 	x = e1	
 	y = x.#shortCircut#and()
 	if y y.#shortcircuit#and#combine(e2) else x.#shortCircuit#and#result()

normalize(Y,e0 op .. op en)=(Ds e0" op .. op en")
  ei'=normalize(Y[PType=methName(op)(n)],ei)
  Ds=[xi=e'i| e'i not of form xP]
  ei"=e'i if e'i of form xP,
  ei"=xi otherwise
  where x1..xn fresh, op not of form op3, n>=1
   
//blocks
normalize(Y,( DEs Ks Wops? DEs2))=normalize(Y,(DEs Ks Wops? DEs2 void))
normalize(Y,( DEs Ks Wops? DE DEs2 e))=normalize(Y,( DEs Ks Wops? (DE DEs2 e)))
normalize(Y,( DEs Ks "wops" T1..Tn e)=( normalizeDE(Y,DEs) normalizeK(Y,Ks) K1..Kn normalize(Y,e) ) 
  where Ki=catch exception resolveCs(p,Ti) xi error xi.#intoErrorAt(that:core({}))
   // what if xi has no #intoError method?
   
normalize(Y,{ DEs Ks Wops? DEs2 }) = (Y.T x=(
    Void x''=normalize(Y[T=Void],(DEs Ks Wops? DEs2 void))
    catch return Y.T x' x'
    error void//unreachable thanks to {return} well formedness   
    )x)
  where x,x',x'' fresh

//builders
normalize(Y,e(.m)?[pars])= normalize(Y[PType=classP],e).methName(.m?)(squareBuilder:(
   b=\.#squareBuilder()
   void x=normalize(Y,(\.#shortCircutSquare().#checkTrue()     
     b.add(par1) //ok no #, it is a builder, 
     ..
     b.add(parn)))
   b))
 where b,x fresh

normalize(Y,e StrLit)= normalize(Y[PType=classP],e).#from(stringLiteral=(
    b=\.#stringLiteralBuilder()
    b.chars0() //one call for each char
    b.#splice(normalize(Y[xP=x,T=\,PType=\],e1))
    b.chars1()
    ..
    b.#splice(normalize(Y[xP=x,T=\,PType=\],en))
    b.charsn()
    b))
  where StrLit= chars0 e1 chars1 .. en charsn

//statements 
normalize(Y,if e0 e1)=normalize(Y,if e0 e1 else void)
normalize(Y,if e0 e1 else e2)= ( x=normalize(Y,e0) normalize(Y,if x e1 else e2) )
  where e0 not of form xP

normalize(Y,if xP e1 else e2)=(
  Void x=xP.#if().#checkTrue()
  catch exception Void x' normalize(Y,e2)
  normalize(Y,e1) 
  )
  where x, x' fresh
 
normalize(Y,if tMatch tMatch+ e) = normalize(Y,if tMatch if tMatch+ e)

normalize(Y,if T x e) = normalize(Y,if T x'= x e[x=x'] )
  where x' fresh
  
normalize(Y,if T x = e e')= ( x'=normalize(Y,e) normalize(Y,if T x= x' e') )
  where e not of form xP //TODO: check the latter for xP vs x
  
normalize(Y,if T x= xP e)= (
  T x=(return xP catch return T x1 x1 error void)
  catch return T.mdf Any x2 void
  normalize(Y,e)
  )  

normalize(Y,if T(T?1 x1 ..T?n x1)=e e')=normalize(Y,
  if T x=e (
    (x1, ..., xn)=x
    e''
    ))
  where 
    x fresh, Txs=[Ti xi | T?i != empty]
    e''= """if Txs  e""" if Txs!=empty
    e''=e' otherwise
    
normalize(Y,if (T?1 x1 .. T?2 xn)=e e')=normalize(Y, (
  (x1 .. xn)=e
  if Tx e1
  ))
  where x fresh, Tx=[Ti xi | T?i != empty]

normalize(Y,while e0 e1)=(Void x=loop(  normalize(Y,(e0.#checkTrue() e1)) ) catch exception Void x' void))
  where x,x' fresh  

normalize(Y,for DX1 in e1..DXn in en e)=normalize(Y,(
  c1=e1.iterator'var1?'(); .. cn=en.iterator'varn?'();//varIterator if var x in..
  var i1=c1.indexZero() .. var i1=cn.indexZero()
  while c1.hasElem(i1) &&..&& cn.hasElem(in) && ( c1.incomplete(i1) ||..||cn.incomplete(in)) (
    DX1 = c1.elem(i) .. DXn = cn.elem(i);
    e[xi updateOp e'= (toBinOp(xi, updateOp) e' ci.update(ii, xi))]
    i1:=i1.succ() .. in:=in.succ()
    )
  c1.close(i1) .. cn.close(in)
  ) )
  where c1..cn, i1..in fresh
   
//auxiliary definitions
normalizePar(Y,e xes)=   that=normalize(Y,e) normalizePar(Y,xes)
normalizePar(Y,x1=e1 .. xn=en)=  x1=normalize(Y,e1) .. xn=normalize(Y,en)

normalizeDE(Y,e)= Void x= normalize(Y[T=empty],e), with x fresh //so that ({..return void ..} {.. return void ..}) is a mistake
normalizeDE(Y,T? x=e)= resolveCs(Y.p,T?) underscoreIntoFresh(x)= normalize(Y[T=T?,PType=classAny],e), with x fresh
normalizeDE(Y,var T? x = e)=var resolveCs(Y.p,T?) x = normalize(Y',e) //assert x not of form _
  Y'=Y[T=T?,PType=classAny] if T? in {empty,class Any} // to obtain classP the user just write down the type
  Y'=Y[T=T?,PType=classP] otherwise
normalizeDE(Y,T?(var1? T1? x1.. varn?Tn? xn)=e) = 
  resolveCs(Y.p,T?) x=normalize(Y[T=T?,PType=classAny],e)
  var1? resolveCs(Y.p,T1?) x1=x.methNameTrim(x1)() //removes any numberPedex from the end
  ..
  varn? resolveCs(Y.p,Tn?) xn=x.methNameTrim(xn)()
  where x fresh
normalizeK(Y,catch throw T x e)=catch throw resolveCs(Y.p,T) underscoreIntoFresh(x) normalizeK(Y,e)
normalizeK(Y,catch T x e)=catch exception resolveCs(Y.p,T) underscoreIntoFresh(x) normalizeK(Y,e) 
  
_______
#define resolveCs(p,FULL.T)=CORE.T,   resolveCs(p,FULL.P)=CORE.P,  resolveCs(p,FULL.docs)=CORE.docs

resolveCs(p,docs mdf P)=resolveCs(p,docs) mdf resolveCs(p,P)
resolveCs(p,empty)=X with fresh X //case T?=empty

resolveCs(p,CORE.P)=CORE.P
resolveCs(p,C.Cs)=Thisn.C.Cs
  where n is the smallest number such that either
    C in dom(p.get(n))
    or p.get(n)=H{... _}
    or p.get(n)=H{reuse[URL] _}
    or p.get(n+1) undefined

resolveCs(p,FULL.docs) =docs' where all the Full.P are replaced with resolveCs(p,FULL.P) 
------------------
operator replacement:
CASE1 assuming xP0..xP1 :T0..Tn
  xP0 OP ..OP xPn = e
  where
    {e} = { xPi.methName(OP)_i(x1=e1 .. xn=en) 
      | forall x1..xn, forall {i}={0..n} where
        p|-(T0..Tn/i).Ps <= p(Ti.P).methName(OP)_i(x1..xn).Ts.Ps[From Ti.P],
        e1..en=xP0..xPn/i }
    forall j,x1..xn forall (T P) in xP0..xPn:
      p(P.$methName(OP)_j).#apply(x1..xn) undefined
    //that is, if any xP is a P with a suitable nested class, that one must have precedence

CASE2 assuming xP0..xP1 :T0..Tn
  xP0 OP ..OP xPn = e
  where
    exists unique i such that:
      xPi=(T P)
      p(P.$methName(OP)_i).#apply(_).Ts.Ps=P1..Pn
      p|-(T0..Tn\i).Ps <= P1..Pn[From P.$methName(OP)_i]
  //Why this looks so different from the other one?