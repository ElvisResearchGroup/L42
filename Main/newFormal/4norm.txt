_______
#define I.add(FULL.MWT : CORE.MH HAlf.e?) = I'    I.add(CORE.NC)=I'    I.addAll(FULL.Ms)=I'
* I.add(MWT : I.p♥MWT.MH) = I
    MWT.e?=empty
* I.add(MWT : I.p♥MWT.MH HALF.e)=I[CCz=I.CCz U CCz U STs<=MWT.T]
    class?=empty if MWT.T=class Any
    class?=class otherwise
    Y=Y[p=I.p;GX=G^MWT;onSlash=MWT.T;onSlashX=empty;onReturn=MWT.T;onPath=class?]
    Y!MWT.e = Half.e; STs; empty; CCz

* I.add(C=CORE.L) = I[CCz=I.CCz U I'.CCz[from C;I.p]]
    CORE.L.MWTs = MWT1..MWTn
    CORE.L.NCs = NC1..NCk
    I[p=p.push(C,CORE.L);CCz=empty]
      .add(MWT1:_).. .add(MWTn:_).add(NC1).. .add(NCk)=I'

* I.addAll()=I
* I.addAll(MWT,Ms)=I.add(MWT).addAll(Ms)
* I.addAll(NC,Ms)=I.add(NC).addAll(Ms)
* I.addAll(MI,Ms)=I.addAll(Ms)
* I.addAll(F,Ms)=I.addAll(Ms)

* I(mdf STz)=T[mdf=mdf]
    I(STz)=T
* I(ST1..STn)=mostGeneralMdf(Tz.mdfz) P
    Tz=I.coreTof(ST1) U..U I.coreTof(STn)
    {P}={T.P| T in Tz and p|-Tz.Pz<=T.P}

* T in I.coreTof(T)
* T in I.coreTof(ST)
    ST<=ST' in I.CCz
    T in I.coreTof(ST')
_______
#define I.selectedOption(OP, xPs)= xP.s(x1=xP'1..xn=xP'n)
* I.p.selectedOption(OP,xPs) = P,m(x1..xn),i
    {P,s,i}=I.p.opOptions(OP, I.typesOf(xPs))
    xP'1..xP'n=xPs\i
    xP=xPs\xP'1..xP'n
_______
#define collectDeps(p;CORE.MWT)=Ps;Ps' collectDeps(p;T)=Ps;Ps' collectDeps(p;Doc)=Ps;Ps'
//collectDeps(sequence)=union of the results of elements of the sequence
* collectDeps(Docs mdf method T0 m(T1 x1..Tn xn)[Ts] e?)=
    collectDeps(Docs) U collectDeps(T0..Tn,Ts) U collectDepsE(e?)
* collectDeps(T)=T.P;empty U collectDeps(T.Docs)
* collectDeps(Doc)={P| @P._ inside Doc};empty     
_______
#define collectDepsE(p;CORE.e?)  //collectDepsE(p;L) adds NCs dependencies and relies on cached Info
* collectDepsE(p;empty)=collectDepsE(p;x)=collectDepsE(p;void)=empty;empty
* collectDepsE(p;CORE.L)=Ps0..Psn;Ps'0..Ps'n
    Ps0=CORE.L.Info.typeDep
    Ps'0=CORE.L.Info.coherent
    Ps1..Psn={CORE.L(Cs).Info.typeDep[from This.Cs;p]| Cs in dom(CORE.L)}
    Ps'1..Ps'n={CORE.L(Cs).Info.coherent[from This.Cs;p]| Cs in dom(CORE.L)}
* collectDepsE(p; e0.m( x1=e1 .. xn=en ) )= collectDepsE(p;e0) U..U collectDepsE(p;en) 
* collectDepsE(p;loop e)=collectDepsE(p;throw e)=collectDepsE(p;x :=e)=collectDepsE(p;e)
* collectDepsE(p;P<:class Any)= P;empty
* collectDepsE(p;P<:class P')= P',P;P
    P'!=Any
* collectDepsE(p; (Ds Ks e) ) =collectDepsE(p;Ds) U collectDepsE(p;Ks) U collectDepsE(p;e)
* collectDepsE(p;var? T x=e)=collectDepsE(p;catch throw T x e)= collectDeps(T) U collectDepsE(p;e)
_______
#define expandFields(Ms)=Ms' //need to keep the order
* expandFields(empty)=empty
* expandFields(M,Ms)=M,expandFields(Ms) 
    M not of form F
* expandFields(T x,Ms)=method toRead(T) x(), expandFields(Ms)
    T.mdf not in {lent, mut, capsule}
* expandFields(T x,Ms)=method capsuleToLent(T) #x(), expandFields(toRead(T) x,Ms)
    T.mdf in {lent, mut, capsule}
* expandFields(var T x,Ms)=Void x(T that), expandFields(T x,Ms)    
_______
#define collect(p,Ts)=Ts' //collects transitively implemented interfaces
* collect(p,empty)=empty
* collect(p,T0 Ts)=((p♥T0 Ts') \ collect(p,Ts)) collect(p,Ts)
    p(T0.P)={interface [Ts0] _}=FULL.L
    Ts'=collect(p,Ts0[from T0.P;p])
* collect(p,T0 Ts)=((p♥T0 Ts0[from T0.P;p]) \ collect(p,Ts)) collect(p,Ts)
    p(T0.P)={interface Ts0 _}=CORE.L
_______
#define methods(p,P0)=MWTs //methods returns a set: the order of the methods is not relevant
* methods(p,P0)=CORE.L.MWTs[from P0;p]
    p(P0)=CORE.L
* methods(p,P0)=MWT1..MWTn //method headers are minimized, not the body
    p(P0)=interface? Ts{ Ms0 }=FULL.L
    Ms=expandFields(Ms0)
    Ps=collect(p,Ts[from P0;p]).Ps
    s1..sn=[ss | P in Ps, ss in p(T.P).Ms.ss].flatten().distinct()//an ordered version of {s | P in Ps, s in dom(p(P))}
    origin(p;s1,P0)..origin(p;sn,P0) all defined
    [Mi,_]=[MWT| P in P0,Ps such that methods(p,P)(si)=MWT]
    MWTi=Mi[with e=e[from P0;p]] if si in p(P0) and P(P0)(s).e?=e
    MWTi=Mi otherwise
