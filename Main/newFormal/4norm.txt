_______
#define expandFields(Ms)=Ms'
* M in expandFields(Ms) 
    M in Ms
    M not of form F
* method toRead(T) x() in expandFields(Ms) 
    var? T x in Ms
* method capsuleToLent(T) #x() in expandFields(Ms) 
    var? T x in Ms
    T.mdf in {lent, mut, capsule}
* method Void x(T that) in expandFields(Ms) 
    var T x in Ms
_______
#define collect(p,Ts)=Ts' //collects transitively implemented interfaces
* collect(p,empty)=empty
* collect(p,T0 Ts)=((p.resolveCs(T0) Ts') \ collect(p,Ts)) collect(p,Ts)
    p(T0.P)=interface Ts0 {_}=FULL.L
    Ts'=collect(p,Ts0[from T0.P])
* collect(p,T0 Ts)=((p.resolveCs(T0) Ts0[from T0.P]) \ collect(p,Ts)) collect(p,Ts)
    p(T0.P)=interface Ts0 {_}=CORE.L
_______
#define methods(p,P0)=MWTs //methods returns a set: the order of the methods is not relevant
* methods(p,P0)=CORE.L.MWTs[from P0]
    p(P0)=CORE.L
* methods(p,P0)=MWT1..MWTn //method headers are minimized, not the body
    p(P0)=interface? Ts{ Ms }=FULL.L
    Ps=collect(p,Ts[from P0]).Ps//T1..Tn is a list, not a set
    s1..sn=[ss | P in Ps, ss in p(T.P).Ms.ss].flatten().distinct()//an ordered version of {s | P in Ps, s in dom(p(P))}
    //Note, in the code it is(properly implemented but) done in 2 steps, first cb0, then p1n
    forall s in s1..sn, there is exactly 1 P in Ps such that p(P)(s).refine=empty //origin
    [Mi,_]=[MWT[?refine=refine]| P in P0,Ps such that methods(p,P)(si)=MWT]
    MWTi=p.resolveCs(Mi) [with e=p(P0)(si).e[from P0]] if defined,
    MWTi=p.resolveCs(Mi) otherwise
_______
#define p|-T <= Tz //todo: move in typesystem
* p|-T <= T0..Tn  iff  p|-T <= T0,..,p|-T <= Tn
_______
#define PT in CCz
* PT in PT<=_,_
* PT in _<=PT,_
_______
#define origin(s; P) = P
* origin(s; P) = P
    {P} = {P| P in collect(p,P) and p(P)(s).refine?=empty}
_______
#define mostSpecific(Tz) = T
* mostSpecific(Tz) = T
    {T}={T| T in p.minimize(Tz) and p|-T<=p.minimize(Tz)}
_______
#define commonSuperT(p,Tz)=Tz'
* commonSuperT(p,T0 .. Tn) =Tz0 intersect..intersect Tzn
    Tzi={T| p|-Ti<=T}//computable as {mdf P | P in p.minimize(p(P).Pz[from T.P] U {T.P, Any}, T.mdf <= mdf}  
_______
#define solve(p, CCz) = IMap,  chooseT(CCz;Tz)=T
* solve(p, CCz) = X1:T1 .. Xn:Tn
    X1 .. Xn = { X | X inside p.top() }
    Tzi = {T | T in commonSuperT(p,{T|T<=Xi in CCz}) and p |- T <= {T|Xi<=T in CCz}} //possible solutions
    Ti = chooseT({T|Xi<=T in CCz} U {T|T<=Xi in CCz};Tzi)
* chooseT(CCz;class Any,_)=class Any
* chooseT(CCz;Tz)=mostSpecific(Tz)
    mostSpecific(Tz)!= capsule P or capsule _ in CCz
* chooseT(Tz)=imm P
    mostSpecific(Tz)= capsule P
    imm _ in CCz
    not capsule _ in CCz
* chooseT(Tz)=mut P 
    mostSpecific(Tz)= capsule P
    not imm _ in CCz
    not capsule _ in CCzP
_______
#define unsatisfiable(P <= P', CCz)   
unsatisfiable(P <= P', CCz)
  if p |/- P <= P'
unsatisfiable(PP <= P', PP <= P", CCz)
  exists s in dom p[P'] and p[P"], where origin(s, P') != origin(s, P")
unsatisfiable(PP <= P', PP <= P", CCz)
  no P in dom(p) such that P <= P' and P <= P"
_______
#define paramaterPaths(PT, CCz, s)  
paramaterPaths(PT, CCz, s) = p[T.s].Ps
	PT <= T in collect(CCz)

-----------------
UNISED; since now collect produce minimized paths, no need for equiv set removal
_______
#define Ts\p Tz
* Ts \p Tz=Ts'  //"\p" is set minus on lists using p.equiv(P1,P2)
* empty \p Tz=empty
* T,Ts\p T',Tz = Ts\p T',Tz
    p.equiv(T.P,T'.P)
* T,Ts\p Tz) = T,(Ts\p Tz)
    otherwise