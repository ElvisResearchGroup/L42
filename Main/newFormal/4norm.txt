_______
#define norm(CMP/FULL.L;pTail)=CORE.L    norm(p,CMP.e)=CORE.e infer(p,FULL.Ms)=CORE.MWTs U CORE.NCs
* norm(p) = {interface? [Ts'] MWT1..MWTn NC1..NCk Info} //ordering of members is important here
    p={interface? [Ts] CMs};pTail//assert {reuse [URL] _}, {... _} and CORE.L never happens
    Ts0=p.minimize(p♥Ts)
    Ts'=Ts0,(collect(p,Ts0)\ Ts0) // this gets the transitively implemented interfaces (-Any)
    forall imm P in Ts'\ Ts0, P not of form Thisk._.C::n._ //private interfaces not added
    MWTs=methods(p,This0)
    ss=expandFields(CMs).ss    
    MWT1..MWTn NC1..NCk=infer(p;MWTs\ss,[MWTs(s)| s in ss],[NC| NC in CMs])//NC of form CORE.NC
    Ps;Ps'=collectDeps(p;Ts') U collectDeps(p;MWT1..MWTn) U collectDeps(NC1.Docs..NCk.Docs)
    Info=#norm{typeDep=Ps,coherentDep=Ps',friendsDep= ??Ps,usedMethDep=??(P.s)s,privateImpl=??Ps}
  
* norm(p,e)=I(Y♥e)
    Y[p;onSlash=empty,onReturn=Library,onPath=error]
    I=I[p;IMap=solve(p,PAccOf(p).CCz);G=empty;CCz;onSlash=empty]

* infer(p,CoM1..CoMn)=I(p♥CoM1)..I(p♥CoMn)
    PAcc=PAccOf(p).fixInfer(p♥CoM1..p♥CoMn)
    I=I[p;IMap=solve(p,PAcc.CCz);G=empty;CCz;onSlash=empty]
_______
#define collectDeps(p;CORE.MWT)=Ps;Ps' collectDeps(p;T)=Ps;Ps' collectDeps(p;Doc)=Ps;Ps'
//collectDeps(sequence)=union of the results of elements of the sequence
* collectDeps(Docs mdf method T0 m(T1 x1..Tn xn)[Ts] e?)=
    collectDeps(Docs) U collectDeps(T0..Tn,Ts) U collectDepsE(e?)
* collectDeps(T)=T.P;empty U collectDeps(T.Docs)
* collectDeps(Doc)={P| @P._ inside Doc};empty     
_______
#define collectDepsE(p;CORE.e?)  //collectDepsE(p;L) adds NCs dependencies and relies on cached Info
* collectDepsE(p;empty)=collectDepsE(p;x)=collectDepsE(p;void)=empty;empty
* collectDepsE(p;CORE.L)=Ps0..Psn;Ps'0..Ps'n
    Ps0=CORE.L.Info.typeDep
    Ps'0=CORE.L.Info.coherent
    Ps1..Psn={CORE.L(Cs).Info.typeDep[from This.Cs;p]| Cs in dom(CORE.L)}
    Ps'1..Ps'n={CORE.L(Cs).Info.coherent[from This.Cs;p]| Cs in dom(CORE.L)}
* collectDepsE(p; e0.m( x1=e1 .. xn=en ) )= collectDepsE(p;e0) U..U collectDepsE(p;en) 
* collectDepsE(p;loop e)=collectDepsE(p;throw e)=collectDepsE(p;x :=e)=collectDepsE(p;e)
* collectDepsE(p;(class Any P))= P;empty
* collectDepsE(p;(class P' P))= P',P;P
    P'!=Any
* collectDepsE(p; (Ds Ks e) ) =collectDepsE(p;Ds) U collectDepsE(p;Ks) U collectDepsE(p;e)
* collectDepsE(p;var? T x=e)=collectDepsE(p;catch throw T x e)= collectDeps(T) U collectDepsE(p;e)
_______
#define expandFields(Ms)=Ms' //need to keep the order
* expandFields(empty)=empty
* expandFields(M,Ms)=M,expandFields(Ms) 
    M not of form F
* expandFields(T x,Ms)=method toRead(T) x(), expandFields(Ms)
    T.mdf not in {lent, mut, capsule}
* expandFields(T x,Ms)=method capsuleToLent(T) #x(), expandFields(toRead(T) x,Ms)
    T.mdf in {lent, mut, capsule}
* expandFields(var T x,Ms)=Void x(T that), expandFields(T x,Ms)    
_______
#define collect(p,Ts)=Ts' //collects transitively implemented interfaces
* collect(p,empty)=empty
* collect(p,T0 Ts)=((p♥T0 Ts') \ collect(p,Ts)) collect(p,Ts)
    p(T0.P)={interface [Ts0] _}=FULL.L
    Ts'=collect(p,Ts0[from T0.P;p])
* collect(p,T0 Ts)=((p♥T0 Ts0[from T0.P;p]) \ collect(p,Ts)) collect(p,Ts)
    p(T0.P)={interface Ts0 _}=CORE.L
_______
#define methods(p,P0)=MWTs //methods returns a set: the order of the methods is not relevant
* methods(p,P0)=CORE.L.MWTs[from P0;p]
    p(P0)=CORE.L
* methods(p,P0)=MWT1..MWTn //method headers are minimized, not the body
    p(P0)=interface? Ts{ Ms0 }=FULL.L
    Ms=expandFields(Ms0)
    Ps=collect(p,Ts[from P0;p]).Ps
    s1..sn=[ss | P in Ps, ss in p(T.P).Ms.ss].flatten().distinct()//an ordered version of {s | P in Ps, s in dom(p(P))}
    origin(p;s1,P0)..origin(p;sn,P0) all defined
    [Mi,_]=[MWT| P in P0,Ps such that methods(p,P)(si)=MWT]
    MWTi=p♥Mi[with e=e[from P0;p]] if si in p(P0) and P(P0)(s).e?=e
    MWTi=p♥Mi otherwise
_______
#define PT in CCz
* PT in PT<=_,CCz
* PT in _<=PT,CCz 
_______
#define commonSuperT(p,Tz)=Tz'
* commonSuperT(p,T0 .. Tn) =Tz0 intersect..intersect Tzn
    Tzi={T| p|-Ti<=T}//computable as {mdf P | P in p(P).Pz[from T.P;p] U {T.P, Any}, T.mdf <= mdf}  
_______
#define solve(p, CCz) = IMap,  chooseT(CCz;Tz)=T,     mostSpecific(Tz) = T
* solve(p, CCz) = X1:T1 .. Xn:Tn
    X1 .. Xn = { X | X inside p(This0) }
    Tzi = {T | T in commonSuperT(p,{T|T<=Xi in CCz}) and p |- T <= {T|Xi<=T in CCz}} //possible solutions
    Ti = chooseT({T|Xi<=T in CCz} U {T|T<=Xi in CCz};Tzi)

* chooseT(CCz;class Any,_)=class Any
* chooseT(CCz;Tz)=mostSpecific(Tz)
    mostSpecific(Tz)!= capsule P or capsule _ in CCz
* chooseT(CCz;Tz)=imm P
    mostSpecific(Tz)= capsule P
    imm _ in CCz
    not capsule _ in CCz
* chooseT(CCz;Tz)=mut P 
    mostSpecific(Tz)= capsule P
    not imm _ in CCz
    not capsule _ in CCzP

* mostSpecific(Tz) = T
    {T}={T| T in p.minimize(Tz) and p|-T<=Tz}
_______
#define I(HALF.M) = CORE.M,  I(HALF.e) = CORE.e
* I(CORE.M) = CORE.M
* I(MH = reuse[URL]? e) = MH =reuse[URL]? I[G=G^MH;onSlash=MH.T](e)

* I(\) = I.onSlash.P //undefined if it is empty
* I((Ds Ks e)) = (I[Ds](Ds) I[Ds]\dom(Ds)(Ks) I[Ds](e)) //not just I(Ks) since I[Ds] modifies I.IMap
* I((TX P)) = (iType(I,TX) P)
* I(xP.m(x1=e1 .. xn=en)) = I(xP).m(x1=I1(e1) .. xn=In(en))
    P=I.IMap(I.G(xP)).P
    MWT=I.p(P)(m(x1..xn))
    Ii=I[onSlash=MWT.pari[from P;I.p]]
* I(xP0 OP..OP xPn)=I(e)
    Ti=I.IMap(I.G(xPi))
    PAcc[I.p;GX=empty;I.CCz].selectedOption(OP, T0..Tn, xPs)=PT,s,i
    xP'1..xP'n=xP0..xPn/i
    e=xPi.m(x1=xP'1 .. xn=xP'n)  if s=methName(OP)_i(x1..xn)
    e=(class PT PT).#apply(x1=xP'1 .. xn=xP'n)  if s=#apply(x1..xn)
* I(e)=e if e in {x, void, CORE.L} 
* I(e)=e' propagates on the structure for throw e, loop e, x := e
_______
#define I[Ds] = I',  I\xs I(HALF.D) = CORE.D,  I(HALF.K) = CORE.K
* I[]=I
* I[TX1 x1=e1 .. TXn xn=en]=I[IMap=IMap'][D; Ds][Ds]
    mdf1 X1..mdfk Xk={mdf X | TX1..TXn}
    I.IMap=IMdf,X1: _ P1 .. Xk: _ Pk
    IMap'=IMdf,X1: mdf1 P1 .. Xk: mdfk Pk
    D,Ds=TX1[\=I.onSlash] x1=e1 .. TXn[\=I.onSlash] xn=en
* I[TX x=e; Ds]=I[IMap=IMap,X: mdf' P][TX x=e; Ds]
    x' in FV(e)
    x' not in dom(I.G) //assert x' in dom(X x=e,Ds), else x not in scope
    Ds(x').TX=X
    I.IMap=IMap,X: mdf P
    mdf'=imm if mdf in {read, fwd imm}    
    mdf'=mut if mdf in {lent, fwd mut}    
    mfd'=mdf otherwise
 otherwise
* I[T x=e; Ds]=I[G=I.G,x:T]
* I[X x=e; Ds]=I[G=I.G,x:I.IMap(X)]
    I.IMap(X).mdf!=read
* I[X x=e; Ds]=I[G=I.G,x:I.IMap(X)]
    I.IMap(X).mdf=read
    x' in FV(e)
    G(x').mdf notin {imm,class,capsule}//and fwd imm?
* I[X x=e; Ds]=I[G=I.G,x:imm P; IMap=IMap,X:imm P]
    I.IMap=IMap,X:read P
    forall x' in FV(e)\x,
      if x' in dom(G) then G(x').mdf in {imm,class,capsule}//and fwd imm?
      else IMap(Ds(x').TX).mdf in {imm,class,capsule}//and fwd imm?
otherwise
* I[X x=e; Ds]=I[G=I.G,x:I.IMap(X)]
* I\xs=I[G=G\xs]

* I(TX x=e) = G(x) x=I(e) //assert G(x) is defined here thanks to I[Ds] above

* I(catch throw TX x e)=catch throw iType(I,TX) x I(e)
_______
#define iType(I,TX)=CORE.T
* iType(I,T)=T
* iType(I,mdf? X)=I.IMap(X)
* iType(I,\)=I.onSlash