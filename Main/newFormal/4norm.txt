_______
#define norm(CMP/FULL.L;pTail)=CORE.L    norm(p,CMP.e)=CORE.e
* norm(p) = {interface? Ts' M1..Mn Info}
    p={interface? Ts Ms0};pTail //TODO: is Ts minimized? if not the set minus below is wrong
    Ts'=Ts,(collect(p,Ts)\ Ts) // this gets the transitively implemented interfaces (-Any)
    forall imm P in Ts'\ Ts, P not of form Thisk._.C::n._ //private interfaces not added
    Ms=expandFields(Ms0) // this turns the fields into abstract methods
    Ms'=methods(p,This0)//next line order Ms' following Ms
    M1..Mn=infer(p;Ms'\Ms.ss, [Ms'(M.s)| M in Ms],[C:e| C:e in Ms])
    Info=Info[norm;//ok, non computational rule checking that Info in CORE.L is consistent
      typeDep;coherentDep==Ts';empty U collectDeps(M1) U..U collectDeps(Mn);
      friendsDep= ??Ps;//using private methods (or paths??)
      usedMethDep=??(P.s)s;
      privateImpl=??Ps]
* norm(p,e)=infer(p,e) //to turn dependencies into a tree 
     
//the line above use [|] to make sequences nor sets. The order of members is important here.
//Note: using Ts'\ Ts the docs of any T inside Ts overrides the one inside Ts'      
//assert norm(p,{reuse [URL] _}) and norm(p,{... _} never happens
//norm(CORE.L;pTail) = CORE.L //assert never happens (not sure if true in real language but good for debugging at the start)
_______
#define collectDeps(CORE.L)  //dont collect dependencies from NCs, Info and Docs
* collectDeps(C=_)=empty;empty
* collectDeps(_ mdf method T0 m(T1 x1..Tn xn)[Ts] e?)=T0..Tn, Ts;empty U collectDepsE(e?)
_______
#define collectDepsE(CORE.e?)    //collectDepsE(L) adds NCs dependiencies and relies on cached Info
* collectDepsE(empty)=collectDepsE(x)=collectDepsE(void)=empty;empty
* collectDepsE({H MWTs NC1..NCn Info})=Info.typeDep;Info.coherent U Ps1;Ps'1 U..U Psn;Ps'n
    Psi;Ps'i=collectDepsE(NCi.L)[from This0.(NCi.C)]
* collectDepsE( e0.m( x1=e1 .. xn=en ) )= collectDepsE(e0) U..U collectDepsE(en) 
* collectDepsE(loop e)=collectDepsE(throw e)=collectDepsE(x :=e)=collectDepsE(e)
* collectDepsE((class Any P))= P;empty
* collectDepsE((class P' P))= P',P;P
    P'!=Any
* collectDepsE( (Ds Ks e) ) =collectDepsE(Ds) U collectDepsE(Ks) U collectDepsE(e)
* collectDepsE(var? T x=e)=collectDepsE(catch throw T x e)= T;empty U collectDepsE(e)
_______
#define expandFields(Ms)=Ms' //need to keep the order
* expandFields(M,Ms)=M,expandFields(Ms) 
    M not of form F
* expandFields(T x,Ms)=method toRead(T) x(), expandFields(Ms)
    T.mdf not in {lent, mut, capsule}
* expandFields(T x,Ms)=method capsuleToLent(T) #x(), expandFields(toRead(T) x,Ms)
    T.mdf in {lent, mut, capsule}
* expandFields(var T x,Ms)=Void x(T that), expandFields(T x,Ms)    
_______
#define collect(p,Ts)=Ts' //collects transitively implemented interfaces
* collect(p,empty)=empty
* collect(p,T0 Ts)=((p.resolveCs(T0) Ts') \ collect(p,Ts)) collect(p,Ts)
    p(T0.P)=interface Ts0 {_}=FULL.L
    Ts'=collect(p,Ts0[from T0.P])
* collect(p,T0 Ts)=((p.resolveCs(T0) Ts0[from T0.P]) \ collect(p,Ts)) collect(p,Ts)
    p(T0.P)={interface Ts0 _}=CORE.L
_______
#define methods(p,P0)=MWTs //methods returns a set: the order of the methods is not relevant
* methods(p,P0)=CORE.L.MWTs[from P0]
    p(P0)=CORE.L
* methods(p,P0)=MWT1..MWTn //method headers are minimized, not the body
    p(P0)=interface? Ts{ Ms0 }=FULL.L
    Ms=expandFields(Ms0)
    Ps=collect(p,Ts[from P0]).Ps
    s1..sn=[ss | P in Ps, ss in p(T.P).Ms.ss].flatten().distinct()//an ordered version of {s | P in Ps, s in dom(p(P))}
    //Note, in the code it is(properly implemented but) done in 2 steps, first cb0, then p1n
    forall s in s1..sn, there is exactly 1 P in Ps such that p(P)(s).refine=empty //origin
    [Mi,_]=[MWT[?refine=refine]| P in P0,Ps such that methods(p,P)(si)=MWT]
    MWTi=p.resolveCs(Mi) [with e=p(P0)(si).e[from P0]] if defined,
    MWTi=p.resolveCs(Mi) otherwise
_______
#define PT in CCz
* PT in PT<=_,CCz
* PT in _<=PT,CCz 