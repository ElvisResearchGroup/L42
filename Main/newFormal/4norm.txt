_______
#define norm(CMP/FULL.L;pTail)=CORE.L    norm(p,CMP.e)=CORE.e infer(p,FULL.Ms)=CORE.Ms
* norm(p) = {interface? Ts' M1..Mn Info}
    p={interface? Ts Ms0};pTail //TODO: is Ts minimized? if not the set minus below is wrong
    Ts'=Ts,(collect(p,Ts)\ Ts) // this gets the transitively implemented interfaces (-Any)
    forall imm P in Ts'\ Ts, P not of form Thisk._.C::n._ //private interfaces not added
    Ms=expandFields(Ms0) // this turns the fields into abstract methods
    Ms'=methods(p,This0)//next line order Ms' following Ms
    M1..Mn=infer(p;Ms'\Ms.ss, [Ms'(M.s)| M in Ms],[C:e| C:e in Ms])
    Info=Info[norm;//ok, non computational rule checking that Info in CORE.L is consistent
      typeDep;coherentDep==Ts';empty U collectDeps(M1) U..U collectDeps(Mn);
      friendsDep= ??Ps;//using private methods (or paths??)
      usedMethDep=??(P.s)s;
      privateImpl=??Ps]     
//the line above use [|] to make sequences nor sets. The order of members is important here.
//Note: using Ts'\ Ts the docs of any T inside Ts overrides the one inside Ts'      
//assert norm(p,{reuse [URL] _}) and norm(p,{... _} never happens
//norm(CORE.L;pTail) = CORE.L //assert never happens (not sure if true in real language but good for debugging at the start)
  
  * norm(p,e)=I(Y♥e)
    Y[p;onSlash=empty,onReturn=Library,onPath=error]
    PAcc=PAccOf(p).fixInfer(p♥M1..p♥Mn)
    I=I[p;IMap=solve(p,PAcc.CCz);G=empty;CCz;onSlash=empty]

* infer(p,M1..Mn)=I(p♥M1)..I(p♥M1)
    PAcc=PAccOf(p).fixInfer(p♥M1..p♥Mn)
    I=I[p;IMap=solve(p,PAcc.CCz);G=empty;CCz;onSlash=empty]
_______
#define collectDeps(CORE.L)  //dont collect dependencies from NCs, Info and Docs
* collectDeps(C=_)=empty;empty
* collectDeps(_ mdf method T0 m(T1 x1..Tn xn)[Ts] e?)=T0..Tn, Ts;empty U collectDepsE(e?)
_______
#define collectDepsE(CORE.e?)    //collectDepsE(L) adds NCs dependiencies and relies on cached Info
* collectDepsE(empty)=collectDepsE(x)=collectDepsE(void)=empty;empty
* collectDepsE({H MWTs NC1..NCn Info})=Info.typeDep;Info.coherent U Ps1;Ps'1 U..U Psn;Ps'n
    Psi;Ps'i=collectDepsE(NCi.L)[from This0.(NCi.C)]
* collectDepsE( e0.m( x1=e1 .. xn=en ) )= collectDepsE(e0) U..U collectDepsE(en) 
* collectDepsE(loop e)=collectDepsE(throw e)=collectDepsE(x :=e)=collectDepsE(e)
* collectDepsE((class Any P))= P;empty
* collectDepsE((class P' P))= P',P;P
    P'!=Any
* collectDepsE( (Ds Ks e) ) =collectDepsE(Ds) U collectDepsE(Ks) U collectDepsE(e)
* collectDepsE(var? T x=e)=collectDepsE(catch throw T x e)= T;empty U collectDepsE(e)
_______
#define expandFields(Ms)=Ms' //need to keep the order
* expandFields(M,Ms)=M,expandFields(Ms) 
    M not of form F
* expandFields(T x,Ms)=method toRead(T) x(), expandFields(Ms)
    T.mdf not in {lent, mut, capsule}
* expandFields(T x,Ms)=method capsuleToLent(T) #x(), expandFields(toRead(T) x,Ms)
    T.mdf in {lent, mut, capsule}
* expandFields(var T x,Ms)=Void x(T that), expandFields(T x,Ms)    
_______
#define collect(p,Ts)=Ts' //collects transitively implemented interfaces
* collect(p,empty)=empty
* collect(p,T0 Ts)=((p.resolveCs(T0) Ts') \ collect(p,Ts)) collect(p,Ts)
    p(T0.P)=interface Ts0 {_}=FULL.L
    Ts'=collect(p,Ts0[from T0.P])
* collect(p,T0 Ts)=((p.resolveCs(T0) Ts0[from T0.P]) \ collect(p,Ts)) collect(p,Ts)
    p(T0.P)={interface Ts0 _}=CORE.L
_______
#define methods(p,P0)=MWTs //methods returns a set: the order of the methods is not relevant
* methods(p,P0)=CORE.L.MWTs[from P0]
    p(P0)=CORE.L
* methods(p,P0)=MWT1..MWTn //method headers are minimized, not the body
    p(P0)=interface? Ts{ Ms0 }=FULL.L
    Ms=expandFields(Ms0)
    Ps=collect(p,Ts[from P0]).Ps
    s1..sn=[ss | P in Ps, ss in p(T.P).Ms.ss].flatten().distinct()//an ordered version of {s | P in Ps, s in dom(p(P))}
    //Note, in the code it is(properly implemented but) done in 2 steps, first cb0, then p1n
    forall s in s1..sn, there is exactly 1 P in Ps such that p(P)(s).refine=empty //origin
    [Mi,_]=[MWT[?refine=refine]| P in P0,Ps such that methods(p,P)(si)=MWT]
    MWTi=p.resolveCs(Mi) [with e=p(P0)(si).e[from P0]] if defined,
    MWTi=p.resolveCs(Mi) otherwise
_______
#define PT in CCz
* PT in PT<=_,CCz
* PT in _<=PT,CCz 
_______
#define commonSuperT(p,Tz)=Tz'
* commonSuperT(p,T0 .. Tn) =Tz0 intersect..intersect Tzn
    Tzi={T| p|-Ti<=T}//computable as {mdf P | P in p.minimize(p(P).Pz[from T.P] U {T.P, Any}, T.mdf <= mdf}  
_______
#define solve(p, CCz) = IMap,  chooseT(CCz;Tz)=T,     mostSpecific(Tz) = T
* solve(p, CCz) = X1:T1 .. Xn:Tn
    X1 .. Xn = { X | X inside p.top() }
    Tzi = {T | T in commonSuperT(p,{T|T<=Xi in CCz}) and p |- T <= {T|Xi<=T in CCz}} //possible solutions
    Ti = chooseT({T|Xi<=T in CCz} U {T|T<=Xi in CCz};Tzi)

* chooseT(CCz;class Any,_)=class Any
* chooseT(CCz;Tz)=mostSpecific(Tz)
    mostSpecific(Tz)!= capsule P or capsule _ in CCz
* chooseT(CCz;Tz)=imm P
    mostSpecific(Tz)= capsule P
    imm _ in CCz
    not capsule _ in CCz
* chooseT(CCz;Tz)=mut P 
    mostSpecific(Tz)= capsule P
    not imm _ in CCz
    not capsule _ in CCzP

* mostSpecific(Tz) = T
    {T}={T| T in p.minimize(Tz) and p|-T<=Tz}
_______
#define I(HALF.M) = CORE.M,  I(HALF.e) = CORE.e
* I(CORE.M) = CORE.M
* I(MH e) = MH I[G=G^MH;onSlash=MH.T](e)

* I(\) = I.onSlash.P //undefined if it is empty
* I((Ds Ks e)) = (I[Ds](Ds) I(Ks) I[Ds](e))
* I((TX CORE.P)) = (iType(I,TX) CORE.P)
* I(xP.m(x1=e1 .. xn=en)) = I(xP).m(x1=I'(e1) .. xn=I'(en))
    I'=I[onSlash=I.IMap(I.G(xP))]
* I(xP0 OP..OP xPn)=I(e)
    Ti=I.IMap(I.G(xPi))
    PAcc[I.p;GX=empty;I.CCz].selectedOption(OP, T0..Tn, xPs)=PT,s,i
    xP'1..xP'n=xP0..xPn/i
    e=xPi.m(x1=xP'1 .. xn=xP'n)  if s=methName(OP)_i(x1..xn)
    e=(class PT PT).#apply(x1=xP'1 .. xn=xP'n)  if s=#apply(x1..xn)
* I(e)=e' propagates on the structure for 
    x, void, CORE.L, throw e, loop e, x := e
_______
#define I[DS] = I',  I(HALF.D) = CORE.D,  I(HALF.K) = CORE.K
* I[TX1 x1=_ .. TXn xn=_]=I[G=I.G,x1:iType(I,TX1),..,xn:iType(I,TXn)]

* I(TX x=e) = iType(I,TX) x=I(e) 

* I(catch TX x e)[IMap;G;T]=catch iType(I,TX) x I(e)
_______
#define iType(I,TX)=CORE.T
* iType(I,T)=T
* iType(I,X)=I.IMap(X)
* iType(I,\)=I.onSlash