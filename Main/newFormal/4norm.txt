-----------------------------------------------------
Definition of p ♥ FULL.L=CORE.L and Y ♥ FULL.E=CORE.E
-----------------------------------------------------
Part 1 Auxiliary
----------------
_______
#define grammar HALF.e and Y environment

HALF.L ::= H { MWT* CORE.NC* }
HALF.xP ::= x | CORE.P | (CORE.T CORE.P)
HALF.e::= x | (TX CORE.P) | void | FULL.L | \
 | throw e | loop e | x := e 
 | xP.m(xe*)
 | xP (op xP)+
 | ( Ds Ks e )  
HALF.K ::= "catch" throw TX x e
HALF.D ::= "var"? TX x = e
TX::=CORE.T | X | \
Y ::= p; xP?; T?; PType
PType::=error| classP |classAny| \ | m(n)
_______
#define toBinOp(x,Op=) // convenience method to desugar updateOps

toBinOp(x, :=) = x :=
toBinOp(x, OP=) = x := x OP 
_______
#define Y(xP),  PType(p,xP)   // where error(p, e) is undefined

Y(x)= resolveCs(p,Y.PType(Y.p,xP))
  
PType(p, x) = x
PType(p, (T P)) = (T P)
classP(p, P) = (class P P)
\(p,P) =  (\ P)
m(n)(p,P)= (X P) //TODO: TO CHANGE 

_______
#define expandFields(Ms)

M in expandFields(Ms) 
  where M in Ms, M not of form F
method toRead(T) x() in expandFields(Ms) 
  where var? T x in Ms
method capsuleToLent(T) #x() in expandFields(Ms) 
  where var? T x in Ms  and   T.mdf in {lent, mut, capsule}
method Void x(T that) in expandFields(Ms) 
  where var T x in Ms
_______
#define Ts\p Tz,   collect(p,Ts)=Ts' //collects transitively implemented interfaces

Ts \p Tz=Ts'  //"\p" is set minus on lists using p.equiv(P1,P2)
empty \p Tz=empty
T,Ts\p T',Tz = Ts\p T',Tz
  where p.equiv(T.P,T'.P)
T,Ts\p Tz) = T,(Ts\p Tz)
  otherwise

collect(p,empty)=empty
collect(p,T0 Ts)=((T0 Ts') \p collect(p,Ts)) collect(p,Ts)
  //that is, crucially: depth first but we avoid duplicates by keeping the rightmost occurrence.
  p(T0.P)=interface Ts0 {_}=FULL.L
  Ts'=collect(p,Ts0[from T0.P])
  //this checks absence of circularity by diverging
  //an implementation could keep a list of visited P instead of diverging; mathematically it is the same
collect(p,T0 Ts)=((T0 Ts0[from T0.P]) \p collect(p,Ts)) collect(p,Ts)
  p(T0.P)=interface Ts0 {_}=CORE.L
_______
#define methods(p,P0)=MWTs //methods returns a set: the order of the methods is not relevant
//methods(), applied to a CORE.L will just return the MWTs;
//applied to a FULL.L, will return a merge of the methods retrieved directly from the L and methods types declared
//in its implemented interfaces. It chooses a type in case of different refines in interface diamond implementations
//In this model cases like
//    A=  interface {refine method A m()}
//    B= [A]{ method A m()}
//are ok wrt B but fail for A

methods(p,P0)=CORE.L.MWTs[from P0]
  where p(P0)=CORE.L
  
methods(p,P0)=MWT1..MWTn
  p(P0)=interface? Ts{ Ms }=FULL.L
  Ps=collect(p,Ts[from P0]).Ps//T1..Tn is a list, not a set
  s1..sn=[ss | P in Ps, ss in p(T.P).Ms.ss].flatten().distinct()//an ordered version of {s | P in Ps, s in dom(p(P))}
  //Note, in the code it is(properly implemented but) done in 2 steps, first cb0, then p1n
  forall s in s1..sn, there is exactly 1 P in Ps such that p(P)(s).refine=empty //origin
  [Mi,_]=[MWT[?refine=refine]| P in P0,Ps such that methods(p,P)(si)=MWT]
  MWTi=Mi [with e=p(P0)(si).e[from P0]] if defined,
  MWTi=Mi otherwise
_______
#define resolveCs(p,FULL.T)=CORE.T,   resolveCs(p,FULL.P)=CORE.P,  resolveCs(p,FULL.docs)=CORE.docs

resolveCs(p,docs mdf P)=resolveCs(p,docs) mdf resolveCs(p,P)
resolveCs(p,empty)=X with fresh X //case T?=empty

resolveCs(p,CORE.P)=CORE.P
resolveCs(p,C.Cs)=Thisn.C.Cs
  where n is the smallest number such that either
    C in dom(p.get(n))
    or p.get(n)=H{... _}
    or p.get(n)=H{reuse[URL] _}
    or p.get(n+1) undefined

resolveCs(p,FULL.docs) =docs' where all the Full.P are replaced with resolveCs(p,FULL.P) 
_____________________
Part 2: normalization
---------------------
_______
#define p♥Full.L=CORE.L,    infer(p,M'1..M'n),   p♥Full.M=Half.H,   Y♥Full.E=CORE.E
//assert p♥H{reuse [URL] _} and p♥{... _} never happens
p♥CORE.L=CORE.L //assert never happens (not true in real language but good for debugging at the start)
p♥FULL.L=CORE.L
  where 
    LL=interface? Ts{Ms0}
    CORE.L=interface? Ts,(Ts'\p Ts){Info infer(p',Ms')}
    Info=
      norm;
      depType;depCoherent=collectDeps(CORE.L);
      friendsDep Ps= ??;//using private methods (or paths??)
      usedMethDep (P.s)s; //non private
      privateImplements Ps //interfaces implemented by a private nested       
    p'=p.push(LL)
    Ts'=collect(p',Ts) // this gets the transitively implemented interfaces (-Any)
    Ms=expandFields(Ms0) // this turns the fields into abstract methods
    forall T in Ts'\p Ts, p'.noUnique(T) //no private interfaces are added
    Ms'=methods(p',This0)\Ms.ss, [methods(p',This0)(M.s)| M in Ms],[C:e| C:e in Ms]
    //the line above use [|] to make sequences nor sets. The order of members is important here.
    //Note: using Ts'\p Ts the docs of any T inside Ts overrides the one inside Ts'

infer(p,M'1..M'n)=M1[solve(p,CCz)]..Mn[solve(p,CCz)]
  where
    M1..Mn=p♥M'1 .. p♥M'n
    n = max {n | p.get(n) is defined }
    p.get(i)={Hi MCsi Mi _}, where Mi not of form Mc
    var CCz = p|Ccz +> MCs1[from This1] +>..+> MCsn[from Thisn]
    while CCz changes:
    	CCz = Collect(p, (p|Ccz +>M1+>..+>Mn).CCz)
    
p♥MH = resolveCs(p,MH) 
p♥MH e= resolveCs(p,MH) Y[p=p,&xP=empty,T=MH.T,PType=MH.T]♥e
p♥CORE.NC =CORE.NC[docs=resolveCs(p,CORE.NC.docs)] 
//assert never happens p♥C:Full.L or p♥s e
_______
#define Y♥FullE = HalfE
//simple cases first

Y♥x=x //assert x not of form _
Y♥P=Y.PType(P)
Y♥void=void
Y♥L=Y.p♥L
Y♥(T e)=(resolveCs(Y.p,T) x=Y[T=resolveCs(Y.p,T)]♥e x)
  where e not of form P
Y♥(T P)= resolveCs(Y.p,(T P) )
Y♥\=\ 
  where Y.xp? !=empty
Y♥\=T
  where T=Y.T?  //assert either this or the former case holds
Y♥\x=(Y.xP).x()
Y♥'PathLit=Y♥\"PathLit"
Y♥return e=return Y[PType=classP]♥e //We can never return class Any anyway, or we could catch return class P on a non coherent P
Y♥throw e=throw Y[PType=error]♥e
  where throw in {error,exception}
Y♥loop e=loop Y[PType=error]♥e
Y♥~e=Y[PType=classP]♥e.methName(~)()
Y♥!e=Y[PType=classP]♥e.methName(!)()
Y♥NumLit e=Y♥e"NumLit"
Y♥ x updateOp e=  Y♥toBinOp(x, updateOp) e)
Y♥e(.m)?(par)=(x=Y[PType=classP]♥e x.methName(m?)( Y[xP=x,T=\,PType=\]♥par ) )
  where e not of form xP, x fresh
Y♥xP(.m)?(par)= Y[PType=classP](xP).methName(.m?)( Y[xP=x,T=\,PType=\]♥par )
  
//bin operators
Y♥e1 OP3 e2= (x=Y♥e1 Y♥x OP3 e2 )
  where e1 not of form xP //OP3: &&, || and => are not static-dispatch, to have short circuit 
Y♥xP op3 e= (
  x=classP(xP).#shortCircut'OP3'()  //here and and under, using ' to generate method names in some standard way
  Y♥if x.#shortResult() 
  else x.#shortProcess(that=Y♥e2)
  )
  where x, x' fresh

Y♥e0 op .. op en =(Ds e0" op .. op en")
  ei'=Y[PType=methName(op)(n)]♥ei
  Ds=[xi=e'i| e'i not of form xP]
  ei"=e'i if e'i of form xP,
  ei"=xi otherwise
  where x1..xn fresh, op not of form op3, n>=1
   
//blocks
Y♥( DEs Ks Wops? DEs2)=Y♥(DEs Ks Wops? DEs2 void)
Y♥( DEs Ks Wops? DE DEs2 e))=Y♥( DEs Ks Wops? (DE DEs2 e))
Y♥( DEs Ks "wops" T1..Tn e)=( Y♥DEs Y♥Ks K1..Kn Y♥e ) 
  where Ki=catch exception resolveCs(p,Ti) xi error xi.#intoErrorAt(that:core({}))
   // what if xi has no #intoError method?
   
Y♥{ DEs Ks Wops? DEs2 } = (Y.T x=(
    Void x''=Y[T=Void]♥(DEs Ks Wops? DEs2 void))
    catch return Y.T x' x'
    error void//unreachable thanks to {return} well formedness   
    )x)
  where x,x',x'' fresh

//builders
Y♥e(.m)?[pars]= Y[PType=classP]♥e.methName(.m?)(squareBuilder:(
   b=\.#squareBuilder()
   Void x=Y♥if \.#shortCircutSquare() (     
     b.add(par1) //ok no #, it is a builder, 
     ..
     b.add(parn))
   b))
 where b,x fresh

Y♥e StrLit= Y[PType=classP]♥e.#from(stringLiteral=(
    b=\.#stringLiteralBuilder()
    b.chars0() //one call for each char
    b.#splice(that=Y[xP=x,T=\,PType=\]♥e1)
    b.chars1()
    ..
    b.#splice(that=Y[xP=x,T=\,PType=\]♥en)
    b.charsn()
    b))
  where StrLit= chars0 e1 chars1 .. en charsn

//statements 
Y♥if e0 e1 = Y♥if e0 e1 else void
Y♥if e0 e1 else e2 = ( x=Y♥e0 Y♥if x e1 else e2 )
  where e0 not of form xP

Y♥if xP e1 else e2=(
  Void x=xP.#if().#checkTrue()
  catch exception Void x' Y♥e2
  Y♥e1 
  )
  where x, x' fresh
 
Y♥if tMatch tMatch+ e = Y♥if tMatch if tMatch+ e

Y♥if T x e = Y♥if T x'= x e[x=x']
  where x' fresh
  
Y♥if T x = e e' = ( x'=Y♥e Y♥if T x= x' e')
  where e not of form xP
  
Y♥if T x= xP e= (
  T x=(return xP catch return T x1 x1 error void)
  catch return T.mdf Any x2 void
  Y♥e
  )  

Y♥if T(T?1 x1 ..T?n x1)=e e' = Y♥if T x=e ( (x1, ..., xn)=x e'')
  where 
    x fresh, Txs=[Ti xi | T?i != empty]
    e''=e'   if Txs=empty
    e''= if Txs e  otherwise
    
Y♥if (T?1 x1 .. T?2 xn)=e e') = Y♥( (x1 .. xn)=e if Tx e1)
  where x fresh, Tx=[Ti xi | T?i != empty]

Y♥while e0 e1 = (Void x=loop Y♥(e0.#checkTrue() e1) catch exception Void x' void))
  where x,x' fresh  

Y♥for DX1 in e1..DXn in en e = Y♥(
  c1=e1.iterator'var1?'(); .. cn=en.iterator'varn?'();//varIterator if var x in..
  var i1=c1.indexZero() .. var in=cn.indexZero()
  while c1.hasElem(i1) &&..&& cn.hasElem(in) && ( c1.incomplete(i1) ||..||cn.incomplete(in)) (
    DX1 = c1.elem(i) .. DXn = cn.elem(i);
    e[xi updateOp e'= (toBinOp(xi, updateOp) e' ci.update(ii, xi))]
    i1:=i1.succ() .. in:=in.succ()
    )
  c1.close(i1) .. cn.close(in)
  )
  where c1..cn, i1..in fresh
   
//auxiliary definitions
Y♥e xes=  that=Y♥e,Y♥xes
Y♥x1=e1 .. xn=en=  x1=Y♥e1 .. xn=Y♥en

Y♥DE= Void x= Y[T=empty]♥e, with DE=e, x fresh //so that ({..return void ..} {.. return void ..}) is a mistake
Y♥T? x=e= resolveCs(Y.p,T?) underscoreIntoFresh(x)= Y[T=T?,PType=classAny]♥e, with x fresh
Y♥var T? x = e=var resolveCs(Y.p,T?) x =Y'♥e //assert x not of form _
  with Y'=Y[T=resolveCs(Y.p,T?),PType=resolveCs(Y.p,T?)]
  
Y♥T?(var1? T1? x1.. varn?Tn? xn)=e = 
  resolveCs(Y.p,T?) x=Y[T=resolveCs(Y.p,T?),PType=resolveCs(Y.p,T?)]♥e
  var1? resolveCs(Y.p,T1?) x1=x.methNameTrim(x1)() //removes any numberPedex from the end
  ..
  varn? resolveCs(Y.p,Tn?) xn=x.methNameTrim(xn)()
  where x fresh
Y♥catch throw T x e = catch throw resolveCs(Y.p,T) underscoreIntoFresh(x) Y♥e
Y♥catch T x e = catch exception resolveCs(Y.p,T) underscoreIntoFresh(x) Y♥e 
  
------------------
operator replacement:
CASE1 assuming xP0..xP1 :T0..Tn
  xP0 OP ..OP xPn = e
  where
    {e} = { xPi.methName(OP)_i(x1=e1 .. xn=en) 
      | forall x1..xn, forall {i}={0..n} where
        p|-(T0..Tn/i).Ps <= p(Ti.P).methName(OP)_i(x1..xn).Ts.Ps[From Ti.P],
        e1..en=xP0..xPn/i }
    forall j,x1..xn forall (T P) in xP0..xPn:
      p(P.$methName(OP)_j).#apply(x1..xn) undefined
    //that is, if any xP is a P with a suitable nested class, that one must have precedence

CASE2 assuming xP0..xP1 :T0..Tn
  xP0 OP ..OP xPn = e
  where
    exists unique i such that:
      xPi=(T P)
      p(P.$methName(OP)_i).#apply(_).Ts.Ps=P1..Pn
      p|-(T0..Tn\i).Ps <= P1..Pn[From P.$methName(OP)_i]
  //Why this looks so different from the other one?