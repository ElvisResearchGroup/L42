_______
#define p(P) = LL //functional notation
* (LL;pTails)(This0.Cs) = LL(Cs)
* p(Thisn+1.Cs) = p.pop(n+1)(This0.Cs)
* p(Any) = {interface}
* p(Void) = p(Library) = {}
_______
#define p.pop(n) = p'
* p.pop(0) = p
* (LL;C:LL';pTails).pop(n+1) = (LL'[C=LL];pTails).pop(n)
* (LL;CORE.L;pTails).pop(n+1) = (CORE.L;pTails).pop(n)
_______
#define p.push(C,LL') = p'    p.push(LL') = p'    p.push(C)
* (LL;pTails).push(C,LL') = LL';C:LL,pTails

* (CORE.L;pTails).push(LL) = LL;CORE.L,pTails

* (LL;pTails).push(C) = (LL;pTails).push(C,LL')
    LL(C) = LL'
_______
#define p.update(LL) = p'
* (_;pTails).update(LL) = LL;pTails
_______
#define p.navigate(P) = p' 
* p.navigate(Thisn.C1..Ck) = p.pop(n).push(C1)...push(Ck)
_______
#define P0[from P1;p] = P2 e[from P;p] = e' e[from P;p;n] = e'  CTz[from P;p] = CTz'
* Thisn.Cs[from Thism.C1..Ck;p] = Thism.C1..C(k-n).Cs if n<k
* Thisn.Cs[from Thism.C1..Ck;p] = p.minimize(This(m+n-k).Cs) if n>=k

* Any[from _] = Any,    Library[from _] = Library,    Void[from _] = Void

* e[from P;p] propagate on the structure, 
    and L[from P;p] = L[from P;p;0] //assert p.push(L[from P;p;0]).checkAllMinimized(L[from P;p;0]))
    and P'[from P;p] as defined above

* {H Ms}[from P;p;j] = {H[Ts=H.Ts[from P;p;j+1] Ms[from P;p;j+1]}
* This(j+n).Cs0[from P;p;j] = This(j+k).Cs1
    Thisn.Cs0[from P;p] = Thisk.Cs1
* Thisn.Cs[from P;p;j] = Thisn.Cs with n<j
* All cases for other expressions/terms propagate to submembers, including docs  

* (ST1<=mdf?1 STz1..STn<=mdf?n STzn)[from P;p] =//TODO: somewhere remove CORE.T<=CORE.T' ? 
    ST1[from P;p] <= mdf?1 STz1[from P;p] .. STn[from P;p] <= mdf?n STzn[from P;p]
* ST1..STn[from P;p] = ST1[from P';p]..STn[from P';p]
* ST.s[from P;p] = p.minimize(ST[from P;p].s)
* ST.s.i[from P;p] = p.minimize(ST[from P;p].s.i)
* (OP STz1..STzn)[from P;p] = p.minimize(OP STz1[from P;p]..STzn[from P;p])
_______
#define collect(p,Core.Ts)=Core.Ts'    collect(p,P)=Core.Ts //collects transitively implemented interfaces
* collect(p,empty)=empty
* collect(p,T0 Ts)=((T0, Ts') \ collect(p,Ts)) collect(p,Ts)
    p(T0.P)={interface [Ts0] _}=FULL.L
    Ts'=collect(p,p♥Ts0[from T0.P;p])
* collect(p,T0 Ts)=((T0, Ts0[from T0.P;p]) \ collect(p,Ts)) collect(p,Ts)
    p(T0.P)={interface Ts0 _}=CORE.L
* collect(p,P)=Ts[from P;p] //does not collect P
    p(T0.P)={interface Ts _}=CORE.L
* collect(p,P)=collect(p,p♥Ts[from P;p]) //does not collect P
    p(T0.P)={interface Ts _}=FULL.L

_______
#define p|-T <= Tz    p|-T0 <= T1    p|-P0 <= P1    mdf0<=mdf1
* p|-T <= T0..Tn  iff  p|-T <= T0,..,p|-T <= Tn

 *p |- mdf0 P0 <= mdf1 P1
    mdf0 <= mdf1
    p |- P0 <= P1

* p |- P0 <= P1  
    P1 in {P0} U (collect(p,P0)) U {Any} //assert p.minimize(Pi)=Pi

* mdf <= mdf
* capsule <= mdf, if mdf in {mut,imm,lent,read,fwd%Mut,fwdMut,fwd%Imm, fwdImm}
* imm <= mdf, if mdf in {read,fwd%Imm,fwdImm}
* mut <= mdf, if mdf in {lent,fwd%Mut,read,fwdMut}
* lent <= read
* fwd%Mut <= fwdMut
* fwd%Imm <= fwdImm
_______
#define origin(p;s;P) = P'   refine(p;s;P)
* origin(p;s; P) = P'
    {P'} = {P'| P' in collect(p,P) and !refine(p;s;P')}
    
* refine(p;s;P) iff exists T in collect(p,P) such that s in dom(p(T.P))
_______
#define p♥FULL.MH = CORE.MH    p♥FULL.TLocal = CORE.T   p♥CsP = P,  p♥FULL.Docs = CORE.Docs
* p♥((mdf Docs)? method T mOp (T1 x1..Tn xn)[Ts])
    =(mdf p♥Docs)? method p♥T methName(mOp)(p♥T1 x1..p♥Tn xn)[p♥Ts]

* p♥(Docs CsP) = imm p♥Docs p♥CsP
* p♥(mdf Docs CsP) = mdf p♥Docs p♥CsP

* p♥P = p.minimize(P)
* p♥C.Cs = p.minimize(Thisn.C.Cs) //not already minimized
    where n is the smallest number such that either
      C in dom(p.get(n))
      or @{__STOP_SCOPE__} in p.get(n).Docs
      or p.get(n+1) undefined

* p♥FULL.Docs = CORE.Docs
    all CsP are replaced with p♥CsP; all (CsP.)? s(.x)? with empty (CsP.)? are This0.s(.x)?
_______
#define methods(p,P0,FULL.Ms)=CORE.MHs //methods returns a sequence with relevant order
* methods(p,P0,empty)=CORE.L.MWTs[from P0;p]
    p(P0)=CORE.L //TODO: handle case with Ms not empty
* methods(p,P0,empty)=MH1..MHn //method headers are minimized, not the body
    p(P0)=interface? Ts{ Ms }=FULL.L
    MHs=expandFields(Ms)
    Ps=collect(p,Ts[from P0;p]).Ps
    s1..sn=[extractMHs(p,p(P).Ms).ss | P in Ps].flatten().distinct()//an ordered version of {s | P in Ps, s in extractMHs(p,p(P).Ms).ss}
    origin(p;s1,P0)..origin(p;sn,P0) all defined
    [MHi,_]=[MH| MH in MHs and MH.s=si],[MH| P in Ps such that methods(p,P)(si)=MH] for i in 1..n
_______
#define p.minimize(P) = P'    p.minimize(STz) = STz'  chooseT(CORE.Tz) = CORE.T
* p.minimize(P) = P
    P in {Any,Void,Library,This0.Cs}
* p.minimize(This(n+1).Cs) = P
    p.pop(1).minimize(Thisn.Cs) = Thisk.Cs'
    P=p.minimize(This1.Cs')  if k=0
    P=This(k+1).Cs'  otherwise   
* (CORE.L;C:LL;_).minimize(This1.C.Cs)=This0.Cs
* (CORE.L;LL;_).minimize(This1.Cs)=This1.Cs
* (CORE.L;C:LL;_).minimize(This1.C'.Cs)=This1.C.Cs
    C!=C'

* p.minimize(ST1..STn) = STz'
    STz = p.minimize(ST1)..p.minimize(STn)
    Tz = {T| T in STz} //CORE.T
    STz' = STz if chooseT({T| T in STz}) undefined
    STz' = chooseT({T| T in STz}) otherwise
* p.minimize(ST.s(.i)?) = ST'.s(.i)?
    p.minimize(ST) = ST'
    p(ST')(s) undefined
* p.minimize(ST.s) = p♥MH.T //♥ already do minimize
    p.minimize(ST) = CORE.T
    p(CORE.T.P)(s) = MH //NOPE p(T.P) may be a FULL.L //use methods? in code have a methodH that is just the method headers?
* p.minimize(ST.s.i) = p♥MH.pari
    p.minimize(ST) = CORE.T
    p(CORE.T.P)(s) = MH
* p.minimize(op STz1..STzn) = p(P)(s).T[from P;p]
    p.minimize(STz1) = T1, ..., p.minimize(STzn) = Tn
    {P.s.i} = p.opOptions(OP, Ts)

_______
#define chooseT(Tz) = T    mostGeneralMdf(mdfz) = mdf     generalEnough(mdfz) = mdfs'
*chooseT(Tz) = mostGeneralMdf(Tz.mdfz) P
  {P} = {T.P| T in Tz and p|-Tz.Pz<=T.P}

* mostGeneralMdf(mdfz) = mdf //the most specific generalEnough.
    mdf in generalEnough(mdfz)
    forall mdf1 in generalEnough(mdfz): mdf <= mdf1

* generalEnough(mdfz) = {mdf | forall mdf1 in mdfz, mdf1<=mdf}
_______
#define P.s.i in p.opOptions(OP, CORE.Ts) //note: now the special case for Path is 
* P.s.i in p.opOptions(OP, T0..Tn)//handled with a 'non op dispatch' desugar
    i in 0..n,
    s = methName(OP_i)(x1..xn)
    P1 ... Pn = methods(p,Ti.P)(s).pars.Ps[from Ti.P;p]
    P'1 ... P'n = (T0..Tn\i).Ps
    P=Ti.P
    p|-P'1<=P1 .. p|-P'1<=P1
_______
#define MH notations, MWT notations just inherit them,
with MH=mdf method T mOp(T1 x1..Tn xn)[Ts] 
* MH.pars = T1..Tn
* MH.exceptions = Ts
* G^MH = this:mdf This0, x1:T1..xn:Tn
* MH.pari = Ti
* MH.s=methName(mOp)(x1..xn)//LL(s) and well formedness for no repetition in dom uses MH.s
_______
#define name manglings methName(mOP) = m, methNameTrim(m) = m, methName(x, mdf?) = m
* methName(m) = m
* methName(UOp) = m // m is from a table
* methName(OP) = methname(OP_0)
* methName(Op_i) = mi //m is from a table, for example methName(++_3)=#plusplus3
* #m'OP' = methName(OP)#m
* methNameTrim(mn) = methNameTrim(m) //removes any numeric suffix, for example methNameTrim(foo1b34)=foo1b
* methNameTrim(m) = m, where m not of form m'n
* methName(x,mdf) = x#mdf
* methName(x,empty) = x#'default' // for example methName(#bar,empty)=#bar#default
_______
#define CORE.e inside CORE.e'
  e inside CORE.ctx[e]
_______
#define toRead(T)   toRead(G) capsuleToLent(T) //toRead of fwd, fwd% is undefined
* toRead(lent P) = toRead(mut P) = toRead(capsule P) = read P
* toRead(mdf P) = mdf P if mdf in {imm,read,class}

* toRead(G)(x) = toRead(G(x))[with var?=empty] //thus single entry undefined where toRead undefined

* capsuleToLent(capsule P) = lent P
* capsuleToLent(mdf P) = mdf P, if mdf != capsule
_______
#define extractMHs(p;Full.Ms)=CORE.MHs //need to keep the order
* expandFields(p;empty)=empty
* expandFields(p;NC,Ms)=expandFields(Ms) 
* expandFields(p;M,Ms)=M,expandFields(Ms) 
    M of form MWT or MI
* expandFields(p;T x,Ms)=read method T x(), expandFields(Ms)
    T = toRead(T)
* expandFields(p;T x,Ms)=mut method capsuleToLent(T) #x(), expandFields(toRead(T) x,Ms)
    T != toRead(T) // TODO: should we use capsuleToMut(T) instead? I'm really on the fence
* expandFields(var T x,Ms)=mut method Void x(T that), expandFields(T x,Ms)    
