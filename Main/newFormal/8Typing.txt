_______
#define D |-e: T<=T 
* D |- void : imm Void <= T //(void)
    D.p|-imm Void <= T
* D |- (class P' P): class P' <= T //(Path)
    D.p(P) of form CORE.L
    D.p(P') of form CORE.L
    D.p|-class P' <= T
    P'=Any if D.p(P).interface?!=empty or class notin D.p(P).mhs.mdfs
* D |- L : imm Library <= T //(library propagation)
    D.p |- imm Library <= T
    if D.Flag==typed |- D.p.push(L)
* D |-x : D.G(x).T <= T  //(x)
    D.p|- D.G(x).T <= T
* D |- loop e ~> loop e' : imm Void <= T //(loop)
  D.p|-imm Void <= T
  D|- e : _ <= imm Void
* D |- return e : T0 <= T0 //(throw-return)
    D|- e : T <=fwd T1
    exists T' in D.Ts such that D.p |-T <= T'
    if T=class P then:
      D.p(P).interface?=empty
      class in D.p(P).mhs.mdfs
  //this forbids return (x:class Any): class Any is forbidden in order to prevent casting it to "class Foo" even if Foo was still not coherent
  //we also check that is a P that could be assigned to a class P, P!=Any 
* D |- throw e : T0 <= T0 //(throw)
    D|- e : imm P <=T2
    either throw=error
    or exists P' in D.Ps such that D.p |-P <= P'
* D |- e0.m(x1:e1..xn:en) : T <= T' //(mcall)
    P0=D.guess(e0)//simple since e0 of form xP
    T0..Tn->T;Ps in methTypes(p,P0,m(x1..xn)) //can be not available, how?
    D.p |- T <= T'
    forall i 0..n D|- ei : T'i <= Ti //T'0 is correctly a free variable
    if m of form #$_ then
      either D.MH?=empty
      or D.MH?.m of form #$_
      or D.MH.mdf in {lent,mut,capsule} and !trusted(D.p.top())
* D |- x:=e : imm Void <= T //(xUpdate)
    D.G(x).var?=var
    D.p|- imm Void <= T
    D|- e : _ <= D.G(x).T 
    assert not fwd_or_fwd%_in(D.G(x).T)
* Flag;p;G;Ts;Ps |- (Ds Ks e):capsule P <=mdf P  //(capsule promotion)
    Ds!=empty //TODO: may make the sugar for (capsule P e)==(capsule P (mut P e)) so that it can be promoted
    mdf in {capsule, imm, fwdImm, fwd%Imm}
    Flag; p; toLent(G);Ts;Ps |-(Ds Ks e) : mut P <=mut P
//this rule is now "deterministic" in the sense that if typing the block give us a capsule directly,
//this rule can not be applied, since we require mut P <=mut P in the premise.
//this is another point where a variable 'x' can become undefined thanks to toLent(G)

* Flag; p; G; Ts; Ps |- (Ds  Ks  e0) : T <= T' //(block)
    Flag; p; G; Ts; Ps |- Ks : Ts'' <= T' |Ts';Ps'
    G'=toRead(G/dom(ds)) if error in Ks.throws
    G'=G/dom(ds) otherwise     //toRead removes fwdMut; if they stayed would it still be sound?
    Flag; p; G'[ks]; Ts U Ts'; Ps U Ps' |- Ds | G0
    //here we have the info to capture a failure about ds and discover if
    //extant name (fwd[%]* x) was hidden by error safety or  modifiable name (capsule/mut/lent x)
    //was locked by error safety[cite the line number of the catch] 
    Flag; p; G',(G0\dom(G')); Ts; Ps |- e0 : T0 <=T'
    T= mostGeneralMdf({T0.mdf,Ts''.mdfs}) T'.P //set of Mdfs admits no single most general mdf
    // assert D.p|-T <= T'
_______
#define D |- ds | G0 // The resulting G0 is the enriched G containing info about ds too.
* Flag; p; G0; Ts; Ps |- var?0 T0 x0=e0 ..var?n Tn xn=en,  ds | G3  //(ds)
    dom(ds) disjoint FV(e0..en)
    G1= G0[ fwd( onlyMutOrImm(x0:T0..xn:Tn)) ]// G0 is clipped for error safety; G1 is clipped and complete
    for i in 0..n: Flag; p; G'; Ts; Ps|-ei : T'i <= fwd% Ti
    if fwd_or_fwd%_in Ts
      then x0..xn disjoint FV(e0..en)//returning unresolved items from cycles is prohibited
    if fwd_or_fwd%_in { G0(x) | x in FV(e0..en) } // x0..xn already excluded
      then G2=G0[fwd%(x0:T0..xn:Tn)]
      otherwise G2=G0[x0:var?0 T0 ..xn:var?n Tn]
    Flag; p; G2; Ts; Ps|- ds | G3
* D |- empty | D.G //(dsEmpty)
_______
#define D |-k1..kn : T1..Tn <= T | Ts;Ps   D |-k : T' <= T |Ts;Ps
* D |-k1..kn : T1..Tn <= T |Ts1 U..U Tsn;Ps1 U..U Psn //(catchMany)
    forall i in 1..n D |-ki : Ti <= T |Tsi;Psi
* D |- catch return T0 x e : T <= T' |T0;empty //(catch)
    D |- e : T <= T'
    if T0.mdf=class then T0.P=Any or class in p(P).mhs.mdfs
* D |- catch throw imm P x e : T <= T' |empty;P //(catch)
    throw !=return
    D |- e : T <= T'

* |- p      //(library well typed)
   assert L.Info.Flag=norm // does it holds? 
   forall P in p(This0).Ts.Ps:  p(P).interface?=interface 
   forall M in p(This0).Ms:  p |- M
* p |- C=L  //(member nested)
   |-p.push(C)
* p|-MH e? //(member method)
    //using MH.Ts to give the arguments(with or without this?) or the exceptions? 
    //TODO: define MH.s MH.Ts MH. ... and say it propagates to MWT
    if MH.native=native[uURL] then //uUrl=untrusted URL
      either MH.s of form #$_(_)
      or MH.mdf in {lent,mut,capsule}
    D = typed; MH; p; G^MH; empty; MH.Ts.Ps
    if e?=e then D |- e :_ <=fwd% MH.T
    MHs={p.minimize(MH'[from P]) | p(This0).Ts.Ps and p(P)(MH.s)=MH'}//assert all abstract
    if ?refine=empty, then MHs=empty
    else forall MH' in MHs:
      p|-MH.T<= MH'.T //method returns a type which is not a sybtype of its ancestor "name"
      G^MH=G^MH' //invalid type w.r.t. implemented paramerer xi
      forall Pi in MH.Ts.Ps exists Pj in MH'.Ts.Ps such that p |- Pi <= Pj
      //or error: leaked exception P is not the subtype of a declared exception
      //or  method declares an exception (P) which is not a subtype of implemented exceptions
_______
#define  mostGeneralMdf(mdfs)=mdf     generalEnough(mdfs)=mdfs'
* mostGeneralMdf(mdfs)=mdf //the most specific generalEnough.
    mdf in generalEnough(mdfs)
    forall mdf1 in generalEnough(mdfs): mdf <= mdf1
* generalEnough(mdfs)={mdf | forall mdf1 in mdfs, mdf1 <= mdf}
_______
#define methTypes(p,P,s) = MethT
* mdf0 P T1..Tn-> T';Ts.Ps in methTypes(p,P,s)  //(mBase)
    p(P)(s).MH[from P]=refine? native? mdf0 method T m(T1 x1,..Tn xn) Ts
    T'=fwd% T if fwd_or_fwd%_in(Ts)
    otherwise T'=T
* noFwd Ts-> noFwd T;Ps in methTypes(p,P,s)  //(mNoFwd)
    Ts->T;Ps in methTypes(p,P,s)
* mutToCapsule(Ts)->capsule P0;Ps in methTypes(p,P,s)  //(mC)
    Ts->mut P0;Ps in methTypes(p,P,s)
* toImmOrCapsule(Ts)->imm P0;Ps in methTypes(p,P,s)  //(mI)
    Ts->mdf P0;Ps in methTypes(p,P,s), mdf in {read,lent}
//the behaviour of toImmOrCapsule on fwd is not relevant since the method
// returns a read and will be not well formed if it had fwd parameters
//by well formedness if return type is read, not fwd_or_fwd%_in Ts
* Ts'->toLent(T);Ps in methTypes(p,P,s) //(mVp)
    Ts0 mut P Ts2->T;Ps in methTypes(p,P,s)
    Ts'=mutToCapsule(Ts0) lent P mutToCapsule(Ts2) //this implies not fwd_or_fwd%_in Ts0,Ts2
* mutToCapsuleAndFwdMutToFwdImm(Ts)->fwd%Imm P0;Ps in methTypes(p,P,s)  //(mImmFwd)
    Ts->fwd%Mut P0;Ps in methTypes(p,P,s)//could be generalized to make fwdMut in fwdImm
    fwd_or_fwd%_in(Ts)
* mutToCapsuleAndFwdRead(Ts)->read P0;Ps in methTypes(p,P,s) //(mRead)
    Ts->fwd%Mut P0;Ps in methTypes(p,P,s)//could be generalized to make fwdMut in read
    fwd_or_fwd%_in(Ts)
_______
#define toLent(G)=G'    toLent(T)=T'
* toLent(G)(x)=G(x) if G(x).T.mdf=immutable
* toLent(G)(x)=toLent(G(x))[with var?=empty] otherwise //thus undefined where toLent undefined

* toLent(mut P)=lent P,
* toLent(fwdMut P) and toLent(fwd%Mut P) undefined;
* toLent(T)=T otherwise
_______
#define fwd% T = T'    fwd_or_fwd%_in Ts    noFwd T = T'    noFwd Ts=Ts'
* fwd% imm P=fwd%Imm P
* fwd% mut P=fwd%Mut P
* fwd% T=T otherwise

* fwd_or_fwd%_in Ts
  exists T in Ts such that T in {fwdImm _,fwdMut_,fwd%Imm _,fwd%Mut _}

* noFwd fwdImm P = noFwd fwd%Imm P = imm P
* noFwd fwdMut P = noFwd fwd%Mut P = mut P
* noFwd T = T otherwise 

* noFwd T1..Tn= noFwd T1 .. noFwd Tn
_______
#define mutToCapsule(T)=T'    mutToCapsuleAndFwdRead(T)=T'    mutToCapsuleAndFwdMutToFwdImm(T)=T'   toImmOrCapsule(T)=T'
* mutToCapsule(fwdMut P) and mutToCapsule(fwd%Mut P) undefined//NO? no reason to restrict?
* mutToCapsule(mut P)=capsule P
* mutToCapsule(T)=T otherwise

* mutToCapsuleAndFwdRead(mut P)=capsule P   //mutToCapsuleAndFwdRead(fwd%Mut P) undefined
* mutToCapsuleAndFwdRead(fwdMut P)= read P
* mutToCapsuleAndFwdRead(fwdImm P)= imm P //Note: read here would be unsound
* mutToCapsuleAndFwdRead(T)=T otherwise

* mutToCapsuleAndFwdMutToFwdImm(mut P)=capsule P  //mutToCapsuleAndFwdMutToFwdImm(fwd%Mut P) undefined
* mutToCapsuleAndFwdMutToFwdImm(fwdMut P)= fwdImm P
* mutToCapsuleAndFwdMutToFwdImm(T)=T otherwise

* toImmOrCapsule(mdf P)=capsule P with mdf in {lent,mut,fwdMut,fwd%Mut}
* toImmOrCapsule(read P)=imm P
* toImmOrCapsule(T)=T otherwise//mdf in {class,imm,fwdImm,fwd%Imm,capsule}

 ----------------
 -------------------------
It is possible to obtain all the variations with the following table:
  mBase
  mNoFwd(mBase)
  mImmFwd(mBase)
  mRead(mBase)
  mC(mBase)
  mC(mNoFwd(mBase))
  mI(mBase)
  mI(mRead(mBase))
  mNoFwd(mImmFwd(mBase))
  mVp(mBase) //1 mType for each mut parameter
  mVp(mNoFwd(base))//1 mType for each mut parameter
 
    
//TODO: check that this kind of things work {Bar:{}   method m (foo catch exception Bar x e1 e0)  } redirect Bar->Any
//also check the following:
//Elem e=(return that catch return Elem x x catch return Any y error error)[redirect Elem in Any]


  rule path:
//Note: we need p(P) not interface and with some class methods to prevent a bug in sum/redirect
//when a class 'A' may become an interface, and annotations 'class A' would be invalid.
//since classes without class methods may become interfaces, we accept the type class A only
//when class methods are present.
//Example
{T:{} //well typed
method class T ()=T
method Void doStuff(class T x)
}[redirect T=Base]
+
{method Void doStuff(class Base x)=x.class()}//well typed
//result would not work
  