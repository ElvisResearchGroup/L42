_______
#define A.rog(v)
//obvious
_______
#define A.free()
//the set of all the a in the right side of A but not in the dom(A)
_______
#define A.pathOf(v)
* A.pathOf(P)=P
* A.pathOf(a)=A(a).P
_______
#define A[mdf v0..vn]=A' //if mdf is imm, mark A.rog(v) as imm
* A[mdf v]=A if mdf!=imm
* A[imm v]=A if v not of form a or L^as
* A[imm Ls^as]=A[imm A.rog(as)]
* A[imm a]=A[imm A.rog(a)]
* A[imm a1..an]=A[imm? a1->Obj1=imm a1->Obj1 .. imm?n an->Obj1=imm an->Obj1] 
_______
#define A[mdf x=v]=A'
* (A,mdf x=_)[mdf x=v]=A[mdf v], mdf x=v
* A[mdf x=v]=A[mdf v], mdf x=v
    x not in dom(A)
_______
#define A|e --> A'|e'    
* A | x  -->p  A| A(x)
* A | L  -->p  A,imm a->L empty| a
    fresh a
* A | x := v  -->p  A[_ x=v]| void //non derministically chose the mdf that would make it work
* A | loop e  -->p  A | (void x=e loop e)  
* A0 | (var? T x=e0 Ds Ks e)  -->p  A1 | (var? T x=e1 Ds Ks e)
    A0 | e0  -->p  A1 | e1
* A0 | (var? T x=v Ds Ks e)  -->p  A[T.mdf x=v] | (Ds Ks e)
* A | (Ks e)  -->p  A| e
* A | (var? T x=ctxV[K.throw v] Ds K Ks e)  -->p  A[K.T.mdf K.x=v] | K.e
    p |- A.pathOf(v) <= K.T.P
* A | (var? T x=ctxV[throw v] Ds K Ks e)  -->p  A | (var? T x=ctxV[throw v] Ds Ks e)
    throw!=K.throw or not p |- A.pathOf(v) <= K.T.P
* A | (var? T x=ctxV[throw v] Ds e)  -->p  A | throw v 
* A0 | v0.m(x1=v1 .. xn=vn)  -->p  A1 | MWT.e[this=v0,x1=v1,..xn=vn]
    MWT=p(A0.pathOf(v0)).m(x1..xn)[from A0.pathOf(v0);p]
    MWT.native[Url]? = empty
    //or is not empty but next rule can not be applied, may be just remove this line and make it non deterministic?
    A1=A0[MWT.mdf0 v0]..[MWT.mdfn vn]
* A0 | v0.m(x1=v1 .. xn=vn)  -->p  A1,A',A2|v
    MWT = p(A0.pathOf(v0)).m(x1..xn)[from A0.pathOf(v0);p]
    MWT.native[Url]? != empty
    A1,A = A0[MWT.mdf0 v0]..[MWT.mdfn vn]
    Ts = MWT.pars, MWT.mdf A0.pathOf(v0)
    capsule not in Ts.mdfs//not a loss in expressiveness, we can use a wrapper
    A = plgMuts(A1,A;Ts;v0..vn)//mutLibs(A1,A;Ts,v0..vn)
    as1 = accessibleMutAddresses(A,Ts,v0..vn)
    as2 = accessibleImmAddresses(A,Ts,v0..vn)
    callPlugin(A1,A;MWT;v0..vn)=A1,A'|v
    A' = A~as1;as2
    either MWT.T.mdf=mut, v in as1, v->P(_)_;_ in A and p|-P<=MWT.T.P
    or MWT.T.mdf=imm
    //untyped libs, now if a lib is not typed we know it could not have been typed yet
    either v=L and L.flag=norm implies {L| L in v1..vn, L.flag=norm} not empty
    or v in as2, imm v->P(_)_;_ in A and p|-P<=MWT.T.P 
//rationale: plg values P() as are created (with empty as1;as2) by normal constructors, no need of plg calls.
//plg can reorganize the as on top of any P().
//plg can create a new L or return any accessible as consistent with the method return mdf
_______
#define accessibleMutAddresses(A;Ts;vs)=as      accessibleImmAddresses(A;Ts;vs)=as
* a0..an in accessibleMutAddresses(A;T1..Tn;v1..vn)
    vi=a0
    Ti.mdf=mut
    a0->P(_)a1..an;_ in A

* a1..an in accessibleImmAddresses(A;T1..Tn;v1..vn)
    vi=a0
    Ti.mdf=mut
    a0->P(_) _;a1..an in A
* a0,as1,as2 in accessibleImmAddresses(A;T1..Tn;v1..vn)
    vi=a0
    Ti.mdf=imm
    a0->P(_) as1;as2 in A
_______
#define A~as1;as2 = A'
* A~as1;as2 = A'    //note: no imm a-> P()_;_ in A', since is only mut stuff
    dom(A') = dom(A)
    if a-> P() as1';as2' in A' then a-> P() _;_ in A, as1' subsetEq as1 and as2' subsetEq as2
_______
#define plgMuts(A;Ts;vs) = A'
* a->P() as1;as2 in plgMuts(A,T1..Tn,v1..vn)
    vi=a
    Ti.mdf=mut
    a->P() as1;as2 in A
    