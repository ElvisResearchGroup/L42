_______
#define A.rog(v)
//obvious
_______
#define A.free()
//the set of all the a in the right side of A but not in the dom(A)
_______
#define A.pathOf(v)
* A.pathOf(P)=P
* A.pathOf(a)=A(a).P
_______
#define A[mdf v0..vn]=A' //if mdf is imm, mark A.rog(v) as imm
* A[mdf v]=A if mdf!=imm
* A[imm v]=A if v not of form a or L^as
* A[imm Ls^as]=A[imm A.rog(as)]
* A[imm a]=A[imm A.rog(a)]
* A[imm a1..an]=A[imm? a1->Obj1=imm a1->Obj1 .. imm?n an->Obj1=imm an->Obj1] 
_______
#define A[mdf x=v]=A'
(A,mdf x=_)[mdf x=v]=A[mdf v], mdf x=v
A[mdf x=v]=A, mdf x=v
  where x not in dom(A)
_______
#define A|e --> A'|e'    
* A | x  -->p  A| A(x)
* A | L  -->p  A,imm a->L empty| a
    fresh a
* A | x := v  -->p  A[_ x=v]| void //non derministically chose the mdf that would make it work
* A | loop e  -->p  A | (void x=e loop e)  
* A0 | (var? T x=e0 Ds Ks e)  -->p  A1 | (var? T x=e1 Ds Ks e)
    A0 | e0  -->p  A1 | e1
* A0 | (var? T x=v Ds Ks e)  -->p  A[T.mdf x=v] | (Ds Ks e)
* A0 | (Ks e)  -->p  A| e
* A | (var? T x=ctxV[throw v] Ds K Ks e)  -->p  A[K.T.mdf K.x=v] | K.e
    throw=K.throw
  p |- A.pathOf(v) <= K.T.P
* A | (var? T x=ctxV[throw v] Ds K Ks e)  -->p  (var? T x=ctxV[throw v] Ds Ks e)
    throw!=K.throw or not p |- A.pathOf(v) <= K.T.P
* A | (var? T x=ctxV[throw v] Ds e)  -->p  throw v 
* A0 | v0.m(x1=v1 .. xn=vn)  -->p  A1 | MWT.e[this=v0,x1=v1,..xn=vn]
    MWT=p[A0.pathOf(v0)].m(x1..xn)
    MWT.nativeUrl = empty
    A1=A0[MWT.mdf0 v0]..[MWT.mdfn vn]
* A0 | v0.m(x1=v1 .. xn=vn)  -->p  A1,A',A2|v
    MWT=p[A0.pathOf(v0)].m(x1..xn)
    MWT.nativeUrl = URL
    either mut or capsule in MWT.Ts.mdfs
    A1,A=A0[MWT.mdf0 v0]..[MWT.mdfn vn]
    A=mutLibs(A1,A;MWT.Ts,v0..vn) //MWT.Ts includes mdf This
    as=accessibleAddresses(A,MWT.Ts,v0..vn) //MWT.Ts includes mdf This
    callPlugin(A1,MWT,v0..vn)=A1,A',A2|v
    A'=A~as
    exists e:  A1,A'| e -->p* A1,A',A2 | v  
    Free(A2) subsetOf {a| imm a->Obj in A1} U dom(A')
_______
#define accessibleAddresses(A;Ts;vs)=as
* a in accessibleAddresses(A;T1..Tn;v1..vn)
    vi=a
    Ti.mdf=mut
    Ti.P!=Library
* a' in accessibleAddresses(A;T1..Tn;v1..vn)
    vi=a
    Ti= mut Library
    a->L _a'_ in A  
_______
#define A~as = A'
* A~as = A'
    dom(A') = dom(A)
    if mut a-> L as' in A' then mut a-> L _ in A and as' subsetEq as
_______
#define mutLibs(A;Ts;vs) = A'
* a->L as in mutLibs(A,T1..Tn,v1..vn)
    vi=a
    Ti= mut Library
    a->L as in A  
    