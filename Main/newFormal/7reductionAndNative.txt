_______
#define A.rog(v)
//obvious
_______
#define A.free()
//the set of all the a in the right side of A but not in the dom(A)
_______
#define A.pathOf(v)
* A.pathOf(P)=P
* A.pathOf(a)=A(a).P
_______
#define A[mdf v0..vn]=A' //if mdf is imm, mark A.rog(v) as imm
* A[mdf v]=A if mdf!=imm
* A[imm v]=A if v not of form a or L^as
* A[imm Ls^as]=A[imm A.rog(as)]
* A[imm a]=A[imm A.rog(a)]
* A[imm a1..an]=A[imm? a1->Obj1=imm a1->Obj1 .. imm?n an->Obj1=imm an->Obj1] 
_______
#define A[mdf x=v]=A'
(A,mdf x=_)[mdf x=v]=A[mdf v], mdf x=v
A[mdf x=v]=A, mdf x=v
  where x not in dom(A)
_______
#define A|e --> A'|e'    
* A | x  -->p  A| A(x)
* A | L  -->p  A,imm a->L empty| a
    fresh a
* A | x := v  -->p  A[_ x=v]| void //non derministically chose the mdf that would make it work
* A | loop e  -->p  A | (void x=e loop e)  
* A0 | (var? T x=e0 Ds Ks e)  -->p  A1 | (var? T x=e1 Ds Ks e)
    A0 | e0  -->p  A1 | e1
* A0 | (var? T x=v Ds Ks e)  -->p  A[T.mdf x=v] | (Ds Ks e)
* A0 | (Ks e)  -->p  A| e
* A | (var? T x=ctxV[throw v] Ds K Ks e)  -->p  A[K.T.mdf K.x=v] | K.e
    throw=K.throw
  p |- A.pathOf(v) <= K.T.P
* A | (var? T x=ctxV[throw v] Ds K Ks e)  -->p  (var? T x=ctxV[throw v] Ds Ks e)
    throw!=K.throw or not p |- A.pathOf(v) <= K.T.P
* A | (var? T x=ctxV[throw v] Ds e)  -->p  throw v 
* A0 | v0.m(x1=v1 .. xn=vn)  -->p  A1 | MWT.e[this=v0,x1=v1,..xn=vn]
    MWT=p[A0.pathOf(v0)].m(x1..xn)
    MWT.nativeUrl = empty
    A1=A0[MWT.mdf0 v0]..[MWT.mdfn vn]
* A0 | v0.m(x1=v1 .. xn=vn)  -->p  A1,A',A2|v
    MWT=p[A0.pathOf(v0)].m(x1..xn)
    MWT.nativeUrl = URL
    either mut or capsule in MWT.Ts.mdfs
    A1,A=A0[MWT.mdf0 v0]..[MWT.mdfn vn]
    A=mutLibs(A1,A;MWT.Ts,v0..vn) //MWT.Ts includes mdf This
    as=accessibleAddresses(A,MWT.Ts,v0..vn) //MWT.Ts includes mdf This
    callPlugin(A1,MWT,v0..vn)=A1,A',A2|v
    A'=A~as
    exists e:  A1,A'| e -->p* A1,A',A2 | v  
    Free(A2) subsetOf {a| imm a->Obj in A1} U dom(A')
_______
#define accessibleAddresses(A;Ts;vs)=as
* a in accessibleAddresses(A;T1..Tn;v1..vn)
    vi=a
    Ti.mdf=mut
    Ti.P!=Library
* a' in accessibleAddresses(A;T1..Tn;v1..vn)
    vi=a
    Ti= mut Library
    a->L _a'_ in A  
_______
#define A~as = A'
* A~as = A'
    dom(A') = dom(A)
    if mut a-> L as' in A' then mut a-> L _ in A and as' subsetEq as
_______
#define mutLibs(A;Ts;vs) = A'
* a->L as in mutLibs(A,T1..Tn,v1..vn)
    vi=a
    Ti= mut Library
    a->L as in A  

----------------
Note, it would seams like either the plugin url is 
trusted or one of the parameter is a cap object. NOT TRUE, NOT NEEDED.
SEE the fraction of the type system below 
  
Adapting the current type system:

tURL::= /*a trusted url*/
uURL::= /*an untrusted url*/
URL:=tURL|uURL
_______
#define trusted(LL) //Does this need to be added to the INFO?//TODO: move in program

trusted(LL)= forall MWT in LL where MWT.native=native[uURL], MWT.s of form #$_(_)
//trusted is not the right name for this concept
   
-typing a method p,MWT:
  if MWT.native=native[uURL]
  then either
    MWT.s of form #$_(_)
    or MWT.mdf in  {lent,mut,capsule}
-coherent LL:
  if !trusted(LL) then the candidate constructors selectors are of form #$_(_)
    
-while typing the method call: if s of form #$(_)
 then either
    original MWT.s of form #$_(_)
    or original MWT.mdf in {lent,mut,capsule} and !trusted(p.top())

-note: before we could declare a class untrusted explicitly, now you can just add
  "native[untrusted] class method Void untrusted::1()=void"
  to the class 

------------------
TODO: metaprogramming plg restrictions:
 -plg url+plg url=plg url
 -plg +plg url?=plg url?
 -can not rename a $method into a non $ method or vice versa
 -redirect non plugin to plg is ok
 -redirect abstract plg to plg and plg url to plg url

examples:
the plg input no mut/lent/read, execute the expression as usual and return.
  the expression could have run on another machine, we can not know

the plg input no mut/lent/read, execute the expression as usual and return a capsule lib with an a
that is the result of such expression.
  the result could be in a 'future' and trying to read the a with another plugin would block until res is ready
  

//the plg input no mut/lent/read, execute the expression but is first transformed somehow in other well typed one.
  
  
the plg takes no input and produce a mut L (promotable to capsule) that correspond to a java arrayList

the plg takes a mut L representing an arrayList, a imm L representing an int and a mut/imm Any
 and put it into the corresponding position of the arrayList.
the plg takes a mut L representing an arrayList, a imm L representing an int 
 and return a mut/imm Any that is located in the corresponding position of the arrayList.  
 
 take two lib arrayList and add all the elements of the second to the first
mut a-> L1 a1..an, mut b-> L2 b1..bn| plg(a,b) -> 
mut a-> L1 a1..an, mut b-> L2 b1..bn, mut c->L3| plg(a,b) 

native typing:
  typed as a normal MWT, plus:
  -take in input or return either imm/mut/capsule/class P (no read/lent/fwd*)
  -the URL support such s with such type:urlSupport(URL,p,MWT)
  -no generic urls, but no need to go down to Any, since urlSupport takes type in input
   can compute over it, so if it return a parameter, it can use user defined types
     
  -a plugin can return a mut L^as,
  -the annotated 'a' on the L can be all the mut a parameters of the plugin call,
   or other 'a' annotated on other Ls parameter of the same plugin call
  -a plugin can not mutate the ROG of any 'a' took in input,
  
  
-mut libraries created by plugins
ensure a field is controlled by plugins by:
  use is well typed if this.x_n() is the argument and
  This.k_n(use..)
is the only form for ever calling a k of a class with a certain plg annotation.
Such class is coherent only when the state is private.
While privatizing the state, it is easy to check such form is the
only form for k.

Then, mut/mdf libraries has an associated set of mut/mdf objects, and
certain plugin operation allows to add and remove from such set.

In this way, we can implement a vector of mut and imm at the same time.
Now we need to be sure that the desugaring can infer enough types to
work well with such vector, expectially for iteration.


coherent?
 {
  class method This0 native[mutLibK] k_1()
  mut method mut Library native[mutLibGet] f_1()
 }

starting point: Integer, String and other can be seen as imm Library
 this is needed for the plg with part
 
 plugins only take in input imm/class stuff
 
 plugins takes mut stuff only: 
 
 
 {
  class method This0 native[mutK] k_1()
  mut method mut T native[mutGet] f_1(K that)
  
 }