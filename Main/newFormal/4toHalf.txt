_______
#define GX(HALF.xP) = STz    GX^HALF.Ds = GX   GX+GX' = GX"
* _,x:STz,_(x) = STz
* GX(x) = empty if x notin dom(GX) //can happen for forwards
* GX(P<:CORE.T) = CORE.T
* GX(P<: STz) = STz // P <: STz is a type of xP, P <: mdf STz is not
* GX(%STz%) = STz

* GX^D1..Dn = D1.x:D1.T..Dn.x:Dn.T

* GX+GX' = GX\dom(GX'),GX'
_______
#define Y!FULL.e = Half.e; STs; STs'; CTz //e, result type, returns type, constraints
* Y!LL = LL;imm Library;empty;empty
* Y!x = x;Y.GX(x);empty;empty
* Y!x = x;empty;empty;empty
    e x notin dom(Y.GX)
    // will apply if we are typecheking the RHS of a "mdf? x = e", and x is free in e

* Y!void = void;imm Void;empty;empty
* Y!\ = %Y.onSlash%<:Y.onSlash; Y.onSlash; empty; empty //onSlash!=expectedT, consider foo.bar(\.x())
* Y!\x = Y!((Y.onSlashX).x())
* Y!CsP = Y!(CsP <:class CsP)
    Y.expectedT != class Any
* Y!CsP = Y!(CsP <:class Any)
    Y.expectedT = class Any
* Y!CsP<:T = ♥CsP<:♥T; ♥T; empty; empty
* Y!\<:T = %Y.onSlash%<:♥T; ♥T; empty; empty
* Y!e<:T = Y!(T x=e x)
    e not of form CsP or \
* Y!'PathSel = Y!\"PathSel"
* Y!NumLit e = Y!e"NumLit"
* Y!throw e = throw e'; empty; STz',STz"; CTz
    Y[expectedT=empty]!e = e'; STz; STz'; CTz
    STz"=STz if throw = return
    STz"=empty, otherwise
* Y!loop e = loop e'; imm Void; STz'; CTZ,STz<=imm Void
    Y[expectedT=imm Void]!e = e'; STz; STz'; CTz
* Y! UOp e = Y!e.methName(UOp)()//Ok, the only e is the receiver, semantic of '\' is preserved 
* Y! x opUpdate e = Y!(doUpdate(x, opUpdate, e))
    opUpdate != ':='
* Y! (x := e) = (x := e'); imm Void; STz'; CTz,STz<=Y.GX(x)
    Y[expectedT=Y.GX(x)]!e = e'; STz; STz'; CTz
* Y!e(par) = Y!e.#apply(par)
* Y!e.m(x,xes) = Y!e.m(that=x, xes)
* Y!e.m(xes) = Y!(x=e x.m(xes))
    e not of form xP //xP on the argument is FULL.xP, HALF.xP in the result
    x fresh
* Y!xP.m(x1=e1,..xn=en) = xP'.m(x1=e'1,..,xn=e'n); STz"; STz'; CTz
    Y[expectedT=empty]!xP = xP'; STz0; STz'0; CTz0 // Y!HALF.xP is always a FULL.xP
    STz" = Y.p.minimize(STz0.m(x1..xn)) //injects .s on all the elements of STz
    STz"i = Y.p.minimize(STz0.m(x1..xn).i), i in 1..n//same for STz.s.i //no hope to get more for i=0 anyway
    Y[onSlashX=xP;expectedT=STz"i]!ei = e'i; STzi; STz'i; CTzi, i in 1..n
    STz' = STz'0 U..U STz'n;
    CTz = CTz0 U..U CTzn, STz1<=STz"1..,STzn<=STz"n
* Y!e1 OP3 e2 = Y!(x=e1 x OP3 e2)
    e1 not of form xP //&&,||,=> are not static-dispatch to have short circuit 
* Y!xP OP3 e = Y!(
      x = xP.#shortCircut'OP3'()  //see name mangling
      if x x.#shortResult'OP3'()
      else xP.#shortProcess'OP3'(x,other=e2)
      )
    x fresh  
//    T && X= if !T F else X//shortResult&& is false, shortCircut&& is !this
//    T || X= if T T else X//shortResult|| is true, shortCircut|| is this
//    T => X= if !T T else X//shortResult=> is true, shortCircut=> is !this
//    Opt||Val=if Opt.present() Opt.get() else Val
//Path=>classAny = if false err else X//shortResult=> is error, shortCircut=> false
* Y!CsP OP e = CsP'.#apply(that=e'); STz; STz"'; CTz, STz" <= STz'
    CsP' = CsP.$methName(OP)
    STz  = Y.p.minimize(CsP'.#apply(that))
    STz' = Y.p.minimize(CsP'.#apply(that).1)
    Y[expectedT=STz'] ! e = e'; STz"; STz"'; CTz
    // not just doing Y!(CsP.$methName(OP)(that=e)) since that will cause \'s to be re-interpreted.

* Y!(e0 OP..OP en) = Y!(Ds e0' OP..OP en')
    n != 0
    Ds = [xi=ei | ei not of form xP]
    Ds != empty // or else the next case will apply
    ei' = ei if ei of form xP
    ei' = xi otherwise
    x1..xn fresh
    e0 OP..OP en not of forms (CsP OP en) or (e0 OP3 en)//former cases not applicable
* Y! xP0 OP..OP xPn = xP'0 OP..OP xP'i; OP STz0,..,STzn; empty; empty
    n != 0
    Y[expectedT = empty]!xPi = xP'i; STzi; empty; empty
    xP1 OP..OP xPn not of forms (CsP OP en) or (e0 OP3 en)//former cases not applicable
* Y!( Ds Ks WHOOPS? Ds') = Y!(Ds Ks WHOOPS? Ds' void)
* Y!( Ds Ks WHOOPS? D Ds' e)) = Y!( Ds Ks WHOOPS? (D Ds' e))
* Y!( Ds Ks WHOOPS T1..Tn e) = Y!( Ds Ks K1..Kn e ) 
    Ki = catch exception Ti xi error xi.#intoErrorAt(that={#norm{}}) //so that we can recover the position
* Y!( D1..Dn K1..Km e0) = (Ds1..Dsn K'1..K'm e'); STz; STz'; CTz  //Ds is HALF.Ds
    GX = {x : ♥FULL.T | FULL.T x = e in D1..Dn} //(T x,T y)=e case unneeded x,y not fwd
    // ISAAC: why this special case for FULL.T x = e ? Also, what about other kinds of DX = e ?
    GXi = Y.GX + GX + GX^Ds1 + .. + GX^Ds(i-1)
    Y[GX=GXi]!Di = Dsi; STz'i; CTzi
    Y[GX=GXn]!Ki = K'i; STzi; STz"i; CTz'i //catch return do not need special treatment
    Y[GX=GXn]!e  = e'; STz'0;  STz"0; CTz'0

    STz = STz0 U..U STzm
    STz' = STz'1 U..U STz'n U STz"0 U..U STz"m
    CTz = CTz1 U..U CTzn U CTz'0 U..U CTz'm
* Y!{Ds Ks Wops? Ds2} = (Void x=e K error void); STz'; empty; CTz
    // Note: well formedness for {...} wil ensure that the above "error void" is unreachable
    Y[expectedT=imm Void]!(Ds Ks Whoops? Ds2 void) = e; _; STz'; CTz
    HALF.T = Y.expectedT if Y.expectedT!=empty
    HALF.T = STz' if Y.expectedT=empty
    K = catch return HALF.T x' x' //constraints on expected type are added upper in the recursion // ISAAC: what does the comment mean?
    x, x' fresh
* Y!e[pars] = Y!e.#apply[pars]
* Y!e.m[pars]= Y!(e.m(squareBuilder=(if \.#shortCircutSquare() (
        b=\.#squareBuilder()
        e1..en //so \ and \x are about the builder
      b)))
    b fresh
    ei = b.#yield(e'i) if pari=e'i and e'i is an sIf, sWhile, sFor, loop _ or B
    ei = b.#add(pari) otherwise
* Y!e string = Y!(e.#from(stringLiteral=(
      b=\.#stringLiteralBuilder()
      e1..en
      b)))
    string = "stringElement1..stringElementn"

    ei = b.charName(char), if stringElement i = char
    ei = b.charName(%), if stringElement i = %%
    ei = b.#splice(e'), if stringElement i = %e'

    b is fresh
* Y!if e0 e1 = Y!(if e0 e1 else void)
* Y!if e0 e1 else e2 = Y!(x = e0 if x e1 else e2 )
    e0 not of form xP
* Y!if xP e1 else e2 = Y!(
      Void x=xP.#if().#checkTrue()
      catch exception Void x' e2
      e1)
    x, x' fresh
* Y!if match match+ e = Y!(if match if match+ e)
* Y!(if T x e) = Y!(if T x'=x e[x=x'])
    x' fresh
* Y!(if T x=e e') = Y!(x'=e, if T x=x' e')
    e not of form xP
* Y!(if T x=xP e) = Y!(
      T x=(return xP catch return T x' x' error void)
      catch return T.mdf Any x' void
      e)
    x' is fresh

* Y!(if T(T?1 x1 ..T?n xn) = e e') = Y!(if T x = e ((x1,..,xn)=x e"))
    x fresh, Txs=[T?i xi | T?i != empty]
    e" = e'   if Txs = empty
    e" = if Txs e',  otherwise
* Y!if (T?1 x1 .. T?2 xn)=e e0) = Y!( (x1 .. xn)=e if Txs e0)
    Txs = [Ti xi | T?i != empty]
    // By well formedness, Txs won't be empty

* Y!while e0 e1 = Y!(
      loop (e0.#checkTrue() e1)
      catch exception Void _ void)

* Y!for (DX in xP)s DX in e (DX in e)s e' = Y!(x=e for (DX in xP)s DX in x (DX in e)s e')
* Y!for DX1 in xP1..DXn in xPn e = Y!(
      x1 = xP1.iterator() .. xn = xPn.iterator()
      var x'1 = xP1.startIndex() .. var x'n = xPn.startIndex()
      while x1.hasElem(x'1) && .. && xn.hasElem(x'n) && ( x1.incomplete(x'1) || .. || xn.incomplete(x'n)) (
        mdf?i = DXi.TLocal.mdf?, or mdf?i = DXi.TLocal.T.mdf?
        // For each DXi, exactly one of the above will be defined

        x.methName('elem', mdf?1)(that = x') .. x.methName('elem', mdf?n)(that = x')
        e[replaceOnUpdate DX1.x?; mdf?1; x1; x'1]..[replaceOnUpdate DXn.x?; mdf?n; xn; x'n]
        // Note: DXi.x? = empty if DXi is not of form var? TLocal x
        x'1 := x'1.succ() .. xn := x'n.succ())
      x1.close(x'1) .. xn.close(x'n))
    x1..xn, x'1..x'n fresh
_______
#define Y!FULL.D = HALF.Ds; STz; CTz
* Y!(empty e) = Y!(imm Void _=e)
* Y!(TLocal _=e) = Y!(TLocal x=e)
    x fresh
* Y!(var? TLocal x=e) = var? HALF.T x=e'; STz'; CTz'
    if TLocal = FULL.T
      HALF.T = ♥FULL.T
      Y[expectedT=HALF.T]!e = e'; STz; STz'; CTz
      CTz' = CTz, STz<=HALF.T
    if TLocal = mdf? //otherwise
      Y[expectedT = empty]!e = e'; STz; STz'; CTz'
      HALF.T = mdf? STz
* Y!(TLocal(var1? TLocal1 x1..varn? TLocaln xn) = e) = D0..Dn; STz0 U..U STzn; CTz0 U..U CTzn
    Y!(TLocal x = e) = D0; STz0; CTz0
    Y!(var1? TLocal1 x1 = x.methNameTrim(x1)()) = D1; STz1; CTz1
    ..
    Y!(varn? TLocaln xn = x.methNameTrim(xn)()) = Dn; STzn; CTzn
    x fresh

_______
# define Y!FULL.K= HALF.K; STz; STz';CTz
* Y!catch throw? T '_' e = Y!catch throw? T x e
    x fresh
* Y!catch T x e = Y!catch exception T x e
* Y!catch throw T x e = catch throw ♥T x e'; STz; STz'; CTz
    Y[GX=Y.GX+x:T]!e = e'; STz; STz'; CTz
_______
#define doUpdate(x, opUdate, e) // convenience method to desugar opUpdates
* doUpdate(x, :=, e) = x := e
* doUpdate(x, OP=, e) = x := x OP e
    OP != ':'
_______
#define FULL.e[replaceOnUpdate DX; x; x']
* e[replaceOnUpdate mdf?; empty; x; x'] = e,
* (x" opUpdate e)[replaceOnUpdate mdf?; x"; x; x'] = (doUpdate(x", opUpdate, e') e")
    e' = e[replaceOnUpdate mdf?; x"; x; x']
    e" = x.methName('update',mdf?)(that = x', val = x")

* e[replaceOnUpdate x"; x; x'] propagates inductively in all the other cases

#define elemOf(DX,x,x') = e    updateOf(DX, x, x') = e
* elemeOf(DX, x, x') =
