_______
#define GX(HALF.xP) = STz    GX^HALF.Ds = GX   GX+GX' = GX"
* _,x:STz,_(x) = STz
* GX(x) = empty if x notin dom(GX) //can happen for forwards
* GX(P<:CORE.T) = CORE.T
* GX(P<: STz) = STz // P <: STz is a type of xP, P <: mdf STz is not
* GX(%STz%) = STz // ISAAC: is this what this case should be, or was it intentially undefined?

* GX^D1..Dn = D1.x:D1.T..Dn.x:Dn.T

* GX+GX' = GX\dom(GX'),GX'
_______
#define Y!FULL.e = Half.e; STs; STs'; CCz //e, result type, returns type, constraints
* Y!LL = LL;imm Library;empty;empty
* Y!x = x;Y.GX(x);empty;empty
* Y!void = void;imm Void;empty;empty
* Y!\ = %Y.onSlash%; Y.onSlash; empty; empty //onSlash!=expectedT, consider foo.bar(\.x())
* Y!\x = (Y.onSlashX).x(); Y.p.minimize(Y.GX(Y.onSlashX).x()); empty; empty
* Y!CsP = (Y.p♥CsP)<:class (Y.p♥CsP);class (Y.p♥CsP); empty; empty
    Y.expectedT != class Any
* Y!CsP = (Y.p♥CsP)<:class Any; class Any; empty; empty
    Y.expectedT = class Any
* Y!CsP<:T = (Y.p♥CsP)<:(Y.p♥T); Y.p♥T; empty; empty
* Y!e<:T = Y!(T x=e x)
    e not of form CsP
* Y!'PathSel = Y!\"PathSel"
* Y!NumLit e = Y!e"NumLit"
* Y!throw e = throw e'; empty; empty; CCz // ISAAC: TODO check the handling of the returns thing (STz')
    Y[expectedT=empty]!e = e'; STz; STz'; CCz
* Y!loop e = loop e'; imm Void; STz'; CCZ,STz<=imm Void
    Y[expectedT=imm Void]!e = e'; STz; STz'; CCz
* Y! UOp e = Y!e.methName(UOp)()//Ok, the only e is the receiver, semantic of '\' is preserved 
* Y! x opUpdate e = Y!(toBinOp(x, opUpdate) e)
    opUpdate != ':='
* Y! (x := e) = (x := e'); imm Void; STz'; CCz,STz<=Y.GX(x)
    Y[expectedT=Y.GX(x)]!e = e'; STz; STz'; CCz
* Y!e(par) = Y!e.#apply(par)
* Y!e.m(x,xes) = Y!e.m(that=x, xes)
* Y!e.m(xes) = Y!(x=e x.m(xes))
    e not of form xP //xP on the argument is FULL.xP, HALF.xP in the result
    x fresh
* Y!xP.m(x1=e1,..xn=en) = e0.m(x1=e'1,..,xn=e'n); STz"; STz'; CCz
    Y[expectedT=empty]!xP = e0; STz0; STz'0; CCz0
    STz" = Y.p.minimize(STz.m(x1..xn)) //injects .s on all the elements of STz
    STz"i = Y.p.minimize(STz0.m(x1..xn).i), i in 1..n//same for STz.s.i //no hope to get more for i=0 anyway
    Y[onSlashX=xP;expectedT=STz"i]!ei = e'i; STzi; STz'i; CCzi, i in 1..n
    STz' = STz'0 U..U STz'n;
    CCz = CCz0 U..U CCzn, STz1<=STz"1..,STzn<=STz"n
* Y!e1 OP3 e2 = Y!(x=e1 x OP3 e2)
    e1 not of form xP //&&,||,=> are not static-dispatch to have short circuit 
* Y!xP OP3 e = Y!(
      x = xP.#shortCircut'OP3'()  //see name mangling
      if x x.#shortResult'OP3'()
      else xP.#shortProcess'OP3'(x,other=e2)
      )
    x fresh  
//    T && X= if !T F else X//shortResult&& is false, shortCircut&& is !this
//    T || X= if T T else X//shortResult|| is true, shortCircut|| is this
//    T => X= if !T T else X//shortResult=> is true, shortCircut=> is !this
//    Opt||Val=if Opt.present() Opt.get() else Val
//Path=>classAny = if false err else X//shortResult=> is error, shortCircut=> false
* Y!CsP OP e = CsP'.#apply(that=e'); STz; STz"'; CCz, STz" <= STz'
    CsP' = CsP.$methName(OP)
    // ISAAC: so P + x will be P.$#plus(x) even if there is no P.$#plus class but there is a P.#plus method?
    
    // ISAAC: you previously wrote this such that it would "work" for CsP <: T, \ or \<:T
    // however suffixing a ".$m" to any of these would be invalid syntax.
    
    // not just doing Y!(CsP.$methName(OP)(that=e")) since that will cause \'s to be re-interpreted.
    STz  = Y.p.minimize(CsP'.#apply(that))
    STz' = Y.p.minimize(CsP'.#apply(that).1)
    Y[expectedT=STz'] ! e = e'; STz"; STz"'; CCz

// ISAAC: I changed this drastically, as I was worried because the resulting (Ds ...) wasn't being passed through Y!, so now I do it in two stages
* Y!e0 OP .. OP en = Y!(Ds e0' OP ... OP en')
    n != 0
    Ds = [xi=ei | ei not of form xP or ei of form \<:T]
    // because Y!FULL.xP will produce a Y!.HALF.xP if and only xP is not of form \ <: T
    Ds != empty // or else the next case will apply
    ei' = ei if ei of form xP
    ei' = xi otherwise
    x1..xn fresh

    // former two cases not applicable
    e0 OP ... OP en not of form CsP OP en or e0 OP3 en

* Y! xP1 OP .. OP xPn = xP'1 OP .. OP xP'i; OP STz0,..,STzn; empty; empty
    n != 0
    Y[expectedT = empty]!xPi = xP'i; STzi; empty; empty // ISAAC: this will fail only if one of the xPi is of form \ <: T, but then the above case will apply
    
    // Not a short circuit, and not a nested class call
    e0 OP ... OP en not of form CsP OP en or e0 OP3 en

* Y!( Ds Ks WHOOPS? Ds') = Y!(Ds Ks WHOOPS? Ds' void)
* Y!( Ds Ks WHOOPS? D Ds' e)) = Y!( Ds Ks WHOOPS? (D Ds' e))
* Y!( Ds Ks WHOOPS T1..Tn e) = Y!( Ds Ks K1..Kn e ) 
    Ki = catch exception Ti xi error xi.#intoErrorAt(that={#norm{}}) //so that we can recover the position
    // ISAAC: so WHOOPS won't work if #intoErrorAt isn't defined?
* Y!( D1..Dn K1..Km e0) = (Ds1..Dsn K'1..K'm e'); STz; STz'; CCz  //Ds is HALF.Ds
    GX = {x:Y.p♥FULL.T | FULL.T x=e in D1..Dn}//(T x,T y)=e case unneeded x,y not fwd
    GXi = Y.GX+GX+GX^Ds1+..+GX^Dsi
    Y[GXn]!e = e'; STz0;STz'0;CCz0
    Y!Ki[GXn] = K'i; STzi; STz'i; CCzi//catch return do not need special treatment
    Y[GX=GXi]!Di = Dsi; STz"i; CCz'i
    STz = STz0 U..U STzm
    STz' = STz'0 U..U STz'm U STz"1 U..U STz"n
    CCz = CCz0 U..U CCzm U CCz'1 U..U CCz'n
* Y!{Ds Ks Wops? Ds2} = (Void x=e K error void); STz'; empty; CCz
    K = catch return HALF.T x' x' //constraints on expected type are added upper in the recursion
    HALF.T = Y.expectedT if Y.expectedT!=empty
    HALF.T = STz' if Y.expectedT=empty
    Y[expectedT=imm Void]!(Ds Ks Whoops? Ds2 void) = e; _; STz'; CCz 
    x, x' fresh
* Y!e(.m)?[pars]= Y!e.m?(squareBuilder=(if \.#shortCircutSquare() (
        b=\.#squareBuilder()     
        e1..en //so \ and \x are about the builder
      b))
    b fresh
    ei=b.#yeld(e'i) if pari=e'i and e'i is an sIf, sWhile, sFor, loop _ or B
    ei=b.#add(pari) otherwise
* Y!e StrLit = Y!e.#from(stringLiteral=(
      b=\.#stringLiteralBuilder()
      b.methName(chars0)()//one call for each char
      b.#splice(e1)
      b.methName(chars1)()
      ..
      b.#splice(en)
      b.methName(charsn)()
      b))
    StrLit = chars0 e1 chars1 .. en charsn
* Y!if e0 e1 = Y!if e0 e1 else void
* Y!if e0 e1 else e2 = Y!( x=e0 if x e1 else e2 )
    e0 not of form xP
* Y!if xP e1 else e2 = Y!(
      Void x=xP.#if().#checkTrue()
      catch exception Void x' e2
      e1)
    x, x' fresh
* Y!if match match+ e = Y!if match if match+ e
* Y!if T x e = Y!if T x'= x e[x=x']
    x' fresh
* Y!if T x=e e' = Y!( x'=e if T x= x' e')
    e not of form xP
* Y!if T x=xP e = Y!(
      T x=(return xP catch return T x1 x1 error void)
      catch return T.mdf Any x2 void
      e)  
    x1,x2 fresh
* Y!if T(T?1 x1 ..T?n x1)=e e0 = Y!if T x=e ( (x1, ..., xn)=x e1)
    x fresh, Txs=[Ti xi | T?i != empty]
    e1 = e0   if Txs = empty
    e1 = 'if Txs e0'  otherwise
* Y!if (T?1 x1 .. T?2 xn)=e e0) = Y!( (x1 .. xn)=e if Tx e0)
    Tx = [Ti xi | T?i != empty]
* Y!while e0 e1 = Y!(
      loop (e0.#checkTrue() e1)
      catch exception Void _)
* Y!for (DX in xP)s DX in e (DX in e)s e0 = Y!(x=e for (DX in xP)s DX in x (DX in e)s e0)    
* Y!for DX1 in xP1..DXn in xPn e = Y!( //we use c,i as xs used for iterators and indexes
      c1=xP1.iterator(); .. cn=xPn.iterator();
      var i1=xP1.startIndex() .. var in=xPn.startIndex()
      while c1.hasElem(i1) &&..&& cn.hasElem(in) && ( c1.incomplete(i1) ||..||cn.incomplete(in)) (
        DX1=elemOf(DX1,c1,i1) .. DXn=elemOf(DXn,cn,in)
        e[replaceUnOp DX1;i1;c1]..[replaceUnOp DXn;in;cn]
        i1:=i1.succ() .. in:=in.succ() )
      c1.close(i1) .. cn.close(in))
    c1..cn, i1..in fresh
_______
#define Y!FULL.D = HALF.Ds;STz;CCz    Y!FULL.K= HALF.K; STz; STz';CCz
* Y!D = Y!(imm Void _=D.e)
    D of form e 
* Y!TLocal _=e = Y!TLocal x=e 
    x fresh
* Y!var? TLocal x=e = var? HALF.T x=e'; STz'; CCz' 
    if TLocal = FULL.T
      HALF.T = Y.p♥FULL.T
      Y[expectedT=HALF.T]!e = e'; STz; STz'; CCz
      CCz' = CCz,STz<=HALF.T
    if TLocal = mdf? //otherwise
      Y[expectedT=empty]!e = e'; STz; STz'; CCz'
      HALF.T = mdf? STz
* Y!TLocal(var1? TLocal1 x1.. varn? TLocaln xn)=e = D0..Dn; STz0 U..U STzn; CCz0 U..U CCzn
    Y!TLocal x=e = D0; STz0; CCz0 
    Y!var1? TLocal1 x1=x.methNameTrim(x1)() = D1; STz1; CCz1
    ..
    Y!varn? TLocaln xn=x.methNameTrim(xn)() = Dn; STzn; CCzn
    x fresh

* Y!catch throw? T '_' e = Y!catch throw? T x e
    x fresh
* Y!catch T x e = Y!catch exception T x e
* Y!catch throw T x e = catch throw Y.p♥T x e'; STz; STz'; CCz
    Y[GX=Y.GX+x:T]!e = e'; STz; STz'; CCz
_______
#define toBinOp(x,Op=) // convenience method to desugar opUpdates
* toBinOp(x, :=) = x :=
* toBinOp(x, OP=) = x := x OP 
_______
#define FULL.e[replaceUnOp DX;x0;x1]
* DX.x opUpdate e[replaceUnOp DX;x0;x1] = toBinOp(DX.x, opUpdate) e' updateOf(DX,x1,x0)
    e' = e[replaceUnOp DX;x0;x1]
* e[replaceUnOp DX;x0;x1] propagates inductively in all the other cases
_______
#define elemOf(DX,c,i) = e    updateOf(DX,c,i) = e
* elemOf(DX,c,i) = c.methName('elem',mdf?)(that=i)
    mdf? = DX.TLocal.mdf? if DX.TLocal.mdf? defined
    mdf? = DX.TLocal.T.mdf? if DX.TLocal.T defined
    mdf? = empty otherwise  

* updateOf(DX,c,i) = c.methName('update',mdf?)(that=i,val=DX.x)
    mdf? = DX.TLocal.mdf? if DX.TLocal.mdf? defined
    mdf? = DX.TLocal.T.mdf? if DX.TLocal.T defined
    mdf? = empty otherwise  
