_______
#define PAccOf(p)=PAcc
* PAccOf(p)=PAcc[p;GX=empty;CCz=empty].fixInfer(CoMs1 .. CoMsk)
    k = max {k | p(Thisk) is defined }
    p(Thisi)={Hi FULL.Msi FULL.Mi _}, where FULL.Mi not of form CORE.MWT or CORE.NC
    CoMsi={CoM| CoM in FULL.Msi}[from Thisi;p]    
_______
#define PAcc.fixInfer(CoMs) = PAcc'
* PAcc.fixInfer(CoM1..CoMn)=PAcc
    PAcc.add(CoM1).. .add(CoMn).CCz=PAcc.CCz
* fixInfer(PAcc;CoM1..CoMn)=PAcc.add(CoM1).. .add(CoMn).collect().fixInfer(Ms)
    otherwise
_______
#define PAcc.collect()=PAcc'
* CC in PAcc.collect()
    CC in PAcc.collect().collect())//is it needed since we have the fixpoint anyway?
* CC in PAcc.collect()
    CC in PAcc.CCz
* PT <= PT" in PAcc.collect()
    PT <= PT', PT' <= PT" in PAcc
* PT <= PT in PAcc.collect()
    PT in PAcc.CCz
* mdf P <= mdf' P' in PAcc.collect() //TODO: explosive, can we make it more computational? can we mix it with CollectSolution? 
    p |- mdf P <= mdf' P' // I.e. every subtype relation we know about
    P' != _ Any // Just for consistency with everything else, not important!
* mdf P <= PT in PAcc.collect()// since all classes are final
	PT <= mdf P in PAcc
	p(P).interface = empty 
* T.s <= PT in PAcc.collect()//since they are alias of each other 
    PT <= T.s in PAcc.collect().CCz //why noy simply in PAcc.CCz?
    PT=PAcc.p(T.P)(s).MH.T[from T.P;PAcc.p]
* T.s.i <= PT in PAcc.collect()//since method parameter types can not be refined (or since they are aliases?)
    PT <= T.s.i in PAcc.collect().CCz
    PT=PAcc.p(T.P)(s).MH.pari[from T.P;PAcc.p]
* PT.s <= PT'.s in PAcc.collect()
    PT <= PT' in PAcc.CCz
    PT'.s in PAcc.CCz
* PT'.s.i <= PT.s.i in PAcc.collect()
    PT <= PT' in PAcc.CCz
    PT'.s.i in PAcc.CCz
* PT.s.i <= PT'.s.i in PAcc.collect()//since method parameter types can not be refined 
    PT <= PT' in PAcc.CCz
    PT'.s.i in PAcc.CCz
* PT1' <= Origin(s, P2') in PAcc.collect()
    PT1 <= P2', PT1 <= PT1' in PAcc.CCz
    P2'.s in PAcc.CCz
    PT1'.s in PAcc.CCz
_______
#define PAcc[CCz]=PAcc'    PAcc[GX]   PAcc[D1..Dn]
* PAcc[CCz]=PAcc[CCz=PAcc.CCz,CCz]

* PAcc[GX]=PAcc[GX=PAcc.GX,GX]

* PAcc[D1..Dn]=PAcc[D1.x:D1.TX .. Dn.x:Dn.TX]
_______
#define   PAcc.add(CoM) = PAcc'//assert never happens PAcc.add(C = FULL.L)
* PAcc.add(FULL/CORE.MH) =PAcc
* PAcc.add(/*FULL/CORE.*/MH /*CMP/CORE.*/e) = PAcc[G^MH].add(e:PT)[PT<=MH.T] //TODO:does work and extract useful info also on an untyped CORE.MWT?
* PAcc.add(C = CORE.L) = PAcc.add(CoM1).. .add(CoMn)
    CoM1..CoMn=CORE.L.CoMs[from This0.C;PAcc.p]
_______
#define HALF.e[\ = PT] //used in addPar
* \[\ = mdf? PP] = PP
* (\ x = e)[\ = PT] = PT x = (e[\ = PT])
* (catch throw \ e)[\ = PT] = catch throw PT (e[\ = PT])
* otherwise propagate on D, K, e
_______
#define PAcc.addD(HALF.D : PT) = PAcc'    PAcc.addK(HALF.K : PT) = PAcc'   PAcc.addPar(e:PT) = PAcc'
* PAcc.addD(D: PT) = PAcc.add(D.e : PT)[PT <= D.PT]

* PAcc.addK(K : X) = PAcc.add(K.e: PT)[PT <= X]

* PAcc.addPar(e:PT.s.i) = PAcc.add(e[\=PT.s.i]:PT')[PT' <= PT.s.i]
_______
#define PAcc.add(HALF.e : CORE.T) = PAcc'
// TODO: Add ps //WHAT IS ps??? 
* PAcc.add( (D1..Dn K1..Kk e):X ) = PAcc'[PT <= X].add(K1:X).. .add(Kk:X)
    PAcc'=PAcc[D1..Dn].addD(D1).. .addD(Dn).add(e:PT)
* PAcc.add(x:PAcc.GX(x)) = PAcc
* PAcc.add( (TP P):TP) = PAcc[class P <= TP]
* PAcc.add(e0.m(x1=e1..xn=en):PT0.s) = PAcc.add(e0:PT0).addP(e1:PT0.s.1).. .addP(en:PT0.s.n)
    s = m(x1..xn)
* PAcc.add(x := e : Void) = PAcc.add(e:PT)[PT <= PAcc.GX(x)]
* PAcc.add(throw e : X) = PAcc.add(e:PT)[PT <= X]
    fresh X
* PAcc.add(loop e : Void) = PAcc.add(e:PT)[PT <= Void]
* PAcc.add(xP0 OP ... OP xPn : PTi.s) = PAcc.add(xP0:PT0).. .add(xPn:PTn)[PT'1 <= P.s.1]..[PT'n <= P.s.n]
    P, s, i=selectedOption(CCz,p,OP, PT0..PTn, xP0..xPn)
    PT'1 ... PT'n = PT0 ... PTn \ i
_______
#define PAcc.paramaterPaths(PT, s)  
* PAcc.paramaterPaths(T, s) = (G^PAcc.p(T.P)(s)).Ts.Ps[from P;PAcc.p]//TODO: is this what we need? 'this' included here
* PAcc.paramaterPaths(PT, s) = PAcc.paramaterPaths(T, s)
    PT <= T in PAcc.collect()
_______
#define PAcc.unsatisfiable()    origin(p;s; P) = P   
* PAcc[P <= P'].unsatisfiable()
    if not p |- P <= P'
* PAcc[PP <= P', PP <= P"].unsatisfiable()
    exists s in dom(PAcc.p(P'))U dom(PAcc.p(P")), where origin(PAcc.p;s; P') != origin(PAcc.p;s; P") //TODO: do we want the U of the two dom or the intersection?
* PAcc[PP <= P', PP <= P"].unsatisfiable()
    no P in dom(p) such that PAcc.p|-P <= P' and PAcc.p|-P <= P"
* origin(p;s; P) = P
    {P} = {P| P in collect(p,P) and p(P)(s).refine?=empty}
_______
#define PT,s,i in PAcc.opOptions(OP, PTs, xPs)
* PT,s,i in PAcc.opOptions(OP, PT0..PTn, xP0..xPn)
    i in 0..n,
    P'1 ... P'n = (PT0..PTn\i).Ps
    !PAcc[P'1 <= P1, ..., P'n <= Pn].collect().unsatisfiable()//TODO: discuss cachability of collect
    either
      s = methName(OP)_i(x1..xn)
      P1 ... Pn = PAcc.paramaterPaths(PTi, s)
      PT=PTi
    or
      xPi = (PT P')
      P = P'.$methName(OP)_i
      s = #apply(x1..xn)
      P1 ... Pn = PAcc.paramaterPaths(imm P, s)//imm is ignored
_______
#define PAcc.selectedOption(OP, PTs, xPs)= PT,s,i
* PAcc.selectedOptions(OP, PTs, xPs)=PT,s,i
    {PT,s,i}=PAcc.opOptions(OP, PTs, xPs)
* PAcc.selectedOptions(OP, PTs, xP0..xPn)=(xPi.P).$methName(OP)_i, s, i
    (xPi.P).$methName(OP)_i, s, i in PAcc.opOptions(OP, PTs, xP0..xPn)
    forall (xPj.P).$methName(OP)_j, s', j in PAcc.opOptions(OP, PTs, xP0..xPn)
      i=j, s=s'
    
====================OLD RULES, Isaac, check is the same as above

    { s } = { s | *forall x1..xn, forall {i}={0..n} where,
        s = methName(OP)_i(x1..xn)
        P1 ... Pn = paramaterPaths(PTi, CCz, s)
*        P'1 ... P'n = (PT0..PTn\i).PPs
*        !unsatisfiable(collect(P'1 <= P1, ..., P'n <= Pn, CCz)) }
    forall j,x1..xn forall (PT P) in xP0..xPn:
      p(P.$methName(OP)_j)(#apply(x1..xn)) undefined
*    G | CCz0 +> (xP0 : PT0) +> ... +> (xPn : PTn) = _|CCz'
*	PT'1 ... PT'n = PT0 ... PTn \ s.i
---------------------------------------------------------------------------------------------------
    G | CCz0 |- xP0 OP ... OP xPn : PT(s.i).s | CCz', PT'1 <= PTi.s.1 ... PT'n <= PTi.s.n


    { P'.s } = { P'.s | forall x1..xn, forall {i}={0..n} where,
    	P' = P.$methName(OP)_i
    	s = #apply(x1..xn)
        xPi = (PT P)
        P1 ... Pn = p[P'.s].Ps
        P'1 ... P'n = (PT0..PTn\i).PPs
        !unsatisfiable(collect(P'1 <= P1, ..., P'n <= Pn, CCz)) }
	G | CCz0 +> (xP0 : PT0) +> ... +> (xPn : PTn) = _|CCz'
    PT'1 ... PT'n = PT0 ... PTn \ s.i
---------------------------------------------------------------------------------------------------
    G | CCz0 |- xP0 OP ... OP xPn : PT(s.i).s | CCz', PT'1 <= P'.s.1 ... PT'n <= P'.s.n
 
=========================================================================================
NOTE: the following syntax is now unused
  PX ::=  P | X
  PP ::= PX | PX.s | PX.s.i


//OLD------------

foo(class Any that)
foo((\ P) + 3Num)

P + ...
(T P) + ... // will call .$
// nothing ells will!
((T P))
(T (P))
(P)
(T x = P x) + ...  
(class Any P) + x // may call .$, will not call .#
(P) +x may cakk .# will not call .$
((class Any P)) + x will not call anything on P
