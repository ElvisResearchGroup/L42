
//OLD COLLECT. Isaac, can you show me that we still need something like this? now is unused
_______
#define PAcc.collect()=PAcc'
* CC in PAcc.collect()
    CC in PAcc.collect().collect())//is it needed since we have the fixpoint anyway?
* CC in PAcc.collect()
    CC in PAcc.CCz
* PT <= PT" in PAcc.collect()
    PT <= PT', PT' <= PT" in PAcc
* PT <= PT in PAcc.collect()
    PT in PAcc.CCz
* mdf P <= mdf' P' in PAcc.collect() //TODO: explosive, can we make it more computational? can we mix it with solve? 
    p |- mdf P <= mdf' P' // I.e. every subtype relation we know about
    P' != _ Any // Just for consistency with everything else, not important!
* mdf P <= PT in PAcc.collect()// since all classes are final
	PT <= mdf P in PAcc
	p(P).interface = empty 
* T.s <= CORE.T in PAcc.collect()//since they are alias of each other 
    CORE.T <= T.s in PAcc.collect().CCz //why noy simply in PAcc.CCz?
    CORE.T=PAcc.p(T.P)(s).MH.T[from T.P;PAcc.p]//TODO: no, CORE.L(s) works but FULL.L(s) misses on FULL.F and on methods from interfaces. Should we use methods(..)?
* T.s.i <= PT in PAcc.collect()//since method parameter types can not be refined (or since they are aliases?)
    PT <= T.s.i in PAcc.collect().CCz
    PT=PAcc.p(T.P)(s).MH.pari[from T.P;PAcc.p]
* PT.s <= PT'.s in PAcc.collect()
    PT <= PT' in PAcc.CCz
    PT'.s in PAcc.CCz
* PT'.s.i <= PT.s.i in PAcc.collect()
    PT <= PT' in PAcc.CCz
    PT'.s.i in PAcc.CCz
* PT.s.i <= PT'.s.i in PAcc.collect()//since method parameter types can not be refined 
    PT <= PT' in PAcc.CCz
    PT'.s.i in PAcc.CCz
* PT1' <= Origin(s, P2') in PAcc.collect()
    PT1 <= P2', PT1 <= PT1' in PAcc.CCz
    P2'.s in PAcc.CCz
    PT1'.s in PAcc.CCz