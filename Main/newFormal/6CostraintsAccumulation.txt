_______
#define PAccOf(p)=PAcc
* PAccOf(p)=PAcc[p;GX=empty;CCz=empty].fixInfer(CoMs1 .. CoMsk)
    k = max {k | p(Thisk) is defined }
    p(Thisi)={Hi FULL.Msi}//TODO: fix infer and PAccOf are broken?
    CoMsi={FULL.MWT| FULL.MWT in FULL.Msi}[from Thisi;p]    
_______
#define PAcc.fixInfer(CoMs) = PAcc'
* PAcc.fixInfer(CoM1..CoMn)=PAcc
    PAcc.add(CoM1).. .add(CoMn).CCz=PAcc.CCz
* PAcc.fixInfer(CoM1..CoMn)=PAcc.add(CoM1).. .add(CoMn).collect().fixInfer((CoM1..CoMn)
    otherwise
_______
#define PAcc.collect()=PAcc'
* CC in PAcc.collect()
    CC in PAcc.collect().collect())//is it needed since we have the fixpoint anyway?
* CC in PAcc.collect()
    CC in PAcc.CCz
* PT <= PT" in PAcc.collect()
    PT <= PT', PT' <= PT" in PAcc
* PT <= PT in PAcc.collect()
    PT in PAcc.CCz
* mdf P <= mdf' P' in PAcc.collect() //TODO: explosive, can we make it more computational? can we mix it with solve? 
    p |- mdf P <= mdf' P' // I.e. every subtype relation we know about
    P' != _ Any // Just for consistency with everything else, not important!
* mdf P <= PT in PAcc.collect()// since all classes are final
	PT <= mdf P in PAcc
	p(P).interface = empty 
* T.s <= CORE.T in PAcc.collect()//since they are alias of each other 
    CORE.T <= T.s in PAcc.collect().CCz //why noy simply in PAcc.CCz?
    CORE.T=PAcc.p(T.P)(s).MH.T[from T.P;PAcc.p]//TODO: no, CORE.L(s) works but FULL.L(s) misses on FULL.F and on methods from interfaces. Should we use methods(..)?
* T.s.i <= PT in PAcc.collect()//since method parameter types can not be refined (or since they are aliases?)
    PT <= T.s.i in PAcc.collect().CCz
    PT=PAcc.p(T.P)(s).MH.pari[from T.P;PAcc.p]
* PT.s <= PT'.s in PAcc.collect()
    PT <= PT' in PAcc.CCz
    PT'.s in PAcc.CCz
* PT'.s.i <= PT.s.i in PAcc.collect()
    PT <= PT' in PAcc.CCz
    PT'.s.i in PAcc.CCz
* PT.s.i <= PT'.s.i in PAcc.collect()//since method parameter types can not be refined 
    PT <= PT' in PAcc.CCz
    PT'.s.i in PAcc.CCz
* PT1' <= Origin(s, P2') in PAcc.collect()
    PT1 <= P2', PT1 <= PT1' in PAcc.CCz
    P2'.s in PAcc.CCz
    PT1'.s in PAcc.CCz
_______
#define PAcc[CCz]=PAcc'    PAcc[GX]   PAcc[D1..Dn]
* PAcc[CCz]=PAcc[CCz=PAcc.CCz,CCz]

* PAcc[GX]=PAcc[GX=PAcc.GX,GX]

* PAcc[D1..Dn]=PAcc[D1.x:D1.TX .. Dn.x:Dn.TX]
_______
#define   PAcc.add(CoM) = PAcc'//assert never happens PAcc.add(C = FULL.L)
* PAcc.add(FULL/CORE.MH) =PAcc
* PAcc.add(FULL/CORE.MH CMP/CORE.e) = PAcc[G^FULL/CORE.MH].add(HALF.e:PT)[PT<=FULL/CORE.MH.T]
    HALF.e=Y♥CMP/CORE.e
    CORE.MH=p♥FULL/CORE.MH
    Y=Y[p=p,onSlashX=empty,onReturn=CORE.MH.T,onPath=CORE.MH.T]
    //Note: I think the former lines extract useful info also on an untyped CORE.MWT
* PAcc.add(C = CORE.L) = PAcc.add(CoM1).. .add(CoMn)
    CoM1..CoMn=CORE.L.CoMs[from This0.C;PAcc.p]
_______
#define HALF.e[\ = PT] //used in addPar
* \[\ = mdf? PP] = PP
* (\ x = e)[\ = PT] = PT x = (e[\ = PT])
* (catch throw \ e)[\ = PT] = catch throw PT (e[\ = PT])
* otherwise propagate on D, K, e
_______
#define PAcc.addD(HALF.D : PT) = PAcc'    PAcc.addK(HALF.K : PT) = PAcc'   PAcc.addPar(e:PT) = PAcc'
* PAcc.addD(D: PT) = PAcc.add(D.e : PT)[PT <= D.PT]

* PAcc.addK(K : X) = PAcc.add(K.e: PT)[PT <= X]

* PAcc.addPar(e:PT.s.i) = PAcc.add(e[\=PT.s.i]:PT')[PT' <= PT.s.i]
_______
#define PAcc.add(HALF.e : CORE.T) = PAcc'
* PAcc.add( (D1..Dn K1..Kk e):X ) = PAcc'[PT <= X].add(K1:X).. .add(Kk:X)
    PAcc'=PAcc[D1..Dn].addD(D1).. .addD(Dn).add(e:PT)
* PAcc.add(x:PAcc.GX(x)) = PAcc
* PAcc.add( (TP P):TP) = PAcc[class P <= TP]
* PAcc.add(e0.m(x1=e1..xn=en):PT0.s) = PAcc.add(e0:PT0).addP(e1:PT0.s.1).. .addP(en:PT0.s.n)
    s = m(x1..xn)
* PAcc.add(x := e : Void) = PAcc.add(e:PT)[PT <= PAcc.GX(x)]
* PAcc.add(throw e : X) = PAcc.add(e:PT)[PT <= X]
    fresh X
* PAcc.add(loop e : Void) = PAcc.add(e:PT)[PT <= Void]
* PAcc.add(xP0 OP ... OP xPn : PTi.s) = PAcc.add(xP0:PT0).. .add(xPn:PTn)[PT'1 <= P.s.1]..[PT'n <= P.s.n]
    P, s, i=selectedOption(CCz,p,OP, PT0..PTn, xP0..xPn)
    PT'1 ... PT'n = PT0 ... PTn \ i
_______
#define PAcc.paramaterPaths(PT, s)  
* PAcc.paramaterPaths(T, s) = (G^PAcc.p(T.P)(s)).Ts.Ps[from P;PAcc.p]//TODO: is this what we need? 'this' included here
* PAcc.paramaterPaths(PT, s) = PAcc.paramaterPaths(T, s)
    PT <= T in PAcc.collect()
_______
#define PAcc.unsatisfiable()
* PAcc[P <= P'].unsatisfiable()
    if not p |- P <= P'
* PAcc[PP <= P', PP <= P"].unsatisfiable()
    exists s in dom(PAcc.p(P'))U dom(PAcc.p(P")), where origin(PAcc.p;s; P') != origin(PAcc.p;s; P") //TODO: do we want the U of the two dom or the intersection?
* PAcc[PP <= P', PP <= P"].unsatisfiable()
    no P in dom(p) such that PAcc.p|-P <= P' and PAcc.p|-P <= P"
_______
#define PT,s,i in PAcc.opOptions(OP, PTs, xPs)
* PT,s,i in PAcc.opOptions(OP, PT0..PTn, xP0..xPn)
    i in 0..n,
    P'1 ... P'n = (PT0..PTn\i).Ps
    !PAcc[P'1 <= P1, ..., P'n <= Pn].collect().unsatisfiable()//TODO: discuss cachability of collect
    either
      s = methName(OP)_i(x1..xn)
      P1 ... Pn = PAcc.paramaterPaths(PTi, s)
      PT=PTi
    or
      xPi = (PT P')
      P = P'.$methName(OP)_i
      s = #apply(x1..xn)
      P1 ... Pn = PAcc.paramaterPaths(imm P, s)//imm is ignored
_______
#define PAcc.selectedOption(OP, PTs, xPs)= PT,s,i
* PAcc.selectedOptions(OP, PTs, xPs)=PT,s,i
    {PT,s,i}=PAcc.opOptions(OP, PTs, xPs)
* PAcc.selectedOptions(OP, PTs, xP0..xPn)=(xPi.P).$methName(OP)_i, s, i
    (xPi.P).$methName(OP)_i, s, i in PAcc.opOptions(OP, PTs, xP0..xPn)
    forall (xPj.P).$methName(OP)_j, s', j in PAcc.opOptions(OP, PTs, xP0..xPn)
      i=j, s=s'