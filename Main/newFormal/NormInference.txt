_______
#define p|-T <= Tz //todo: move in typesystem
* p|-T <= T0..Tn  iff  p|-T <= T0,..,p|-T <= Tn
_______
#define PT in CCz
* PT in PT<=_,_
* PT in _<=PT,_
_______
#define origin(s; P) = P
* origin(s; P) = P
    {P} = {P| P in collect(p,P) and p(P)(s).refine?=empty}
_______
#define mostSpecific(Tz) = T
* mostSpecific(Tz) = T
    {T}={T| T in p.minimize(Tz) and p|-T<=p.minimize(Tz)}
_______
#define collect(CCz)=CCz'
* CC in collect(CCz)
    CC in collect(collect(CCz)) //CC in collect(CCz,CCz') where CC in collect(collect(CCz))
* CC in collect(CC,_)
* PT <= PT" in collect(PT <= PT', PT' <= PT",_)
* PT <= PT in collect(CCz)
    PT in CCz
* mdf P <= mdf' P' in collect(_) //TODO: explosive, can we make it more computational? can we mix it with CollectSolution? 
    p |- mdf P <= mdf' P' // I.e. every subtype relation we know about
    P' != _ Any // Just for consistency with everything else, not important!
* mdf P <= PT in collect(PT <= mdf P,_)// since all classes are final!
	p[P].interface = empty 
* T.s <= PT in collect(CCz)//since they are alias of each other 
    PT <= T.s in collect(CCz)
    PT=p[T.s].T
* T.s.i <= PT in collect(CCz)//since method parameter types can not be refined (or since they are aliases?)
    PT <= T.s.i in collect(CCz)
    PT=p[T.s].Ti
* PT.s <= PT'.s in collect(PT <= PT', CCz)
    PT'.s in CCz
* PT'.s.i <= PT.s.i in collect(PT <= PT',CC')
    PT'.s.i in CC'
* PT.s.i <= PT'.s.i in collect(PT <= PT',CC')//since method parameter types can not be refined 
    PT'.s.i in CC'
* PT1' <= Origin(s, P2') in collect(PT1 <= P2', PT1 <= PT1', CCz)
    P2'.s in CCz
    PT1'.s in CCz
_______
#define commonSuperT(p,Tz)=Tz'
* commonSuperT(p,T0 .. Tn) =Tz0 intersect..intersect Tzn
    Tzi={T| p|-Ti<=T}//computable as {mdf P | P in p.minimize(p(P).Pz[from T.P] U {T.P, Any}, T.mdf <= mdf}  
_______
#define solve(p, CCz) = IMap,  chooseT(CCz;Tz)=T
* solve(p, CCz) = X1:T1 .. Xn:Tn
    X1 .. Xn = { X | X inside p.top() }
    Tzi = {T | T in commonSuperT(p,{T|T<=Xi in CCz}) and p |- T <= {T|Xi<=T in CCz}} //possible solutions
    Ti = chooseT({T|Xi<=T in CCz} U {T|T<=Xi in CCz};Tzi)
* chooseT(CCz;class Any,_)=class Any
* chooseT(CCz;Tz)=mostSpecific(Tz)
    mostSpecific(Tz)!= capsule P or capsule _ in CCz
* chooseT(Tz)=imm P
    mostSpecific(Tz)= capsule P
    imm _ in CCz
    not capsule _ in CCz
* chooseT(Tz)=mut P 
    mostSpecific(Tz)= capsule P
    not imm _ in CCz
    not capsule _ in CCzP
_______
#define p|CCz +> CORE.Ms = p|CCz',    p|CCz +> CORE.M = p|CCz'
p|CCz +> M1..Mn =p|CCz +> M1 +> .. +> Mn 
//assert never happens p|CCz +> C = FULL.L 
p|CCz +> C = CORE.L = p|CCz +> L.Ms[from This0.C]
p|CCz +> H { Info; M1 ... Mn } = p|CCz +> M1 +> ... +> Mn
p|CCz +>MH =p|CCz
p|CCz +>MH e = p|CCz',PT<=MH.T
  p|G^MH|CCz +> e:PT  = p|_|CCz'
_______
#define HALF.e[\ = PT]
\[\ = mdf? PP] = PP
(\ x = e)[\ = PT] = PT x = (e[\ = PT])
(catch throw \ e)[\ = PT] ::= catch throw PT (e[\ = PT])
otherwise propagate on D, K, e

_______
#define G | CCz |- HALF.e : CORE.T | CCz
// TODO: Add ps //WHAT IS ps??? 

    G|CCz +> e : PT'   = _|CCz'
--------------------------------------
   (G|CCz +> PT x = e) = G|CCz',PT' <= PT


   G, x->PT | CCz +> e : PT' = _|CCz'
--------------------------------------
   G | CCz +> catch throw PT x e : X = G|CCz',PT' <= X


   (G(D1..Dn) | CCz) +> D1 +> .. +> Dn +> (e : PT) = _|CCz'
   (G | CCz',PT <= X) +> (K1 : X) +> .. +> (Kk : X) = _|CCz''
--------------------------------------------------------
   G | CCz +> (D1..Dn K1..Kk e) : X = G|CCz''


---------------------------------
  G | CCz +> (x : G(x)) = G | CCz


-------------------------------------
  G | CCz +> (TP P : TP) = G | CCz, class P <= TP

  
  s = m(x1 ... xn)
  G | CCz +> (e0 : PT0) >+> (e1 : PT0.s.1) +par> .. +par> (en : PT0.s.n) = _| CCz'
-------------------------------------------------------------------
  G | CCz +> (e0.m(x1 = e1, ..., xn = en) : PT0.s) = G | CCz'


  G | CCz +> e[\ := PT.s.i] : PT' = _ | CCz'
---------------------------------------------------- //+par> is the parameter accumulation
  G | CCz +par> e : PT.s.i = G | CCz',PT' <= PT.s.1


  G | CCz +>  e : PT  = _| CCz'
--------------------------------------------------
  G | CCz +> x := e : Void = G | CCz', PT <= G(x)


  G | CCz +> e : PT = _ | CCz'
----------------------------------------------- for fresh X
  G | CCz +> throw e : X  = G | CCz',PT<=X


  G | CCz +> e : PT = _ | CCz'
------------------------------------------------
  G | CCz +> loop e : Void | CCz', PT <= Void

    P, s, i=selectedOption(CCz,p,OP, PT0..PTn, xP0..xPn)
    G | CCz0 +> (xP0 : PT0) +> ... +> (xPn : PTn) = _|CCz'
	PT'1 ... PT'n = PT0 ... PTn \ i
---------------------------------------------------------------------------------------------------
    G | CCz0 |- xP0 OP ... OP xPn : PTi.s | CCz', PT'1 <= P.s.1 ... PT'n <= P.s.n
_______
#define opOptions(CCz, p, OP, PTs, xPs)
PT,s,i in opOptions(CCz, p, OP, PT0..PTn, xP0..xPn)
  where
  i in 0..n,
  P'1 ... P'n = (PT0..PTn\i).PPs
  !unsatisfiable(collect(P'1 <= P1, ..., P'n <= Pn, CCz))//TODO: discuss cachability of collect
  either
    s = methName(OP)_i(x1..xn)
    P1 ... Pn = paramaterPaths(PTi, CCz, s)
    PT=PTi
  or
    xPi = (PT P')
    P = P'.$methName(OP)_i
    s = #apply(x1..xn)
    P1 ... Pn = p[P.s].Ps
_______
#define selectedOption(CCz, p, OP, PTs, xPs)
selectedOptions(CCz, p, OP, PTs, xPs)=PT,s,i
  {PT,s,i}=opOptions(CCz,p,OP, PTs, xPs)
selectedOptions(CCz,p,OP, PTs, xP0..xPn)=(xPi.P).$methName(OP)_i, s, i
  (xPi.P).$methName(OP)_i, s, i in opOptions(CCz,p,OP, PTs, xP0..xPn)
  forall (xPj.P).$methName(OP)_j, s', j in opOptions(CCz,p,OP, PTs, xP0..xPn)
    i=j, s=s'
_______
#define unsatisfiable(P <= P', CCz)   
unsatisfiable(P <= P', CCz)
  if p |/- P <= P'
unsatisfiable(PP <= P', PP <= P", CCz)
  exists s in dom p[P'] and p[P"], where origin(s, P') != origin(s, P")
unsatisfiable(PP <= P', PP <= P", CCz)
  no P in dom(p) such that P <= P' and P <= P"
_______
#define paramaterPaths(PT, CCz, s)  
paramaterPaths(PT, CCz, s) = p[T.s].Ps
	PT <= T in collect(CCz)

    
====================OLD RULES, Isaac, check is the same as above

    { s } = { s | *forall x1..xn, forall {i}={0..n} where,
        s = methName(OP)_i(x1..xn)
        P1 ... Pn = paramaterPaths(PTi, CCz, s)
*        P'1 ... P'n = (PT0..PTn\i).PPs
*        !unsatisfiable(collect(P'1 <= P1, ..., P'n <= Pn, CCz)) }
    forall j,x1..xn forall (PT P) in xP0..xPn:
      p(P.$methName(OP)_j)(#apply(x1..xn)) undefined
*    G | CCz0 +> (xP0 : PT0) +> ... +> (xPn : PTn) = _|CCz'
*	PT'1 ... PT'n = PT0 ... PTn \ s.i
---------------------------------------------------------------------------------------------------
    G | CCz0 |- xP0 OP ... OP xPn : PT(s.i).s | CCz', PT'1 <= PTi.s.1 ... PT'n <= PTi.s.n


    { P'.s } = { P'.s | forall x1..xn, forall {i}={0..n} where,
    	P' = P.$methName(OP)_i
    	s = #apply(x1..xn)
        xPi = (PT P)
        P1 ... Pn = p[P'.s].Ps
        P'1 ... P'n = (PT0..PTn\i).PPs
        !unsatisfiable(collect(P'1 <= P1, ..., P'n <= Pn, CCz)) }
	G | CCz0 +> (xP0 : PT0) +> ... +> (xPn : PTn) = _|CCz'
    PT'1 ... PT'n = PT0 ... PTn \ s.i
---------------------------------------------------------------------------------------------------
    G | CCz0 |- xP0 OP ... OP xPn : PT(s.i).s | CCz', PT'1 <= P'.s.1 ... PT'n <= P'.s.n
 
=========================================================================================


//OLD------------

foo(class Any that)
foo((\ P) + 3Num)

P + ...
(T P) + ... // will call .$
// nothing ells will!
((T P))
(T (P))
(P)
(T x = P x) + ...  
(class Any P) + x // may call .$, will not call .#
(P) +x may cakk .# will not call .$
((class Any P)) + x will not call anything on P
