_______
#define p ==>p'
* p ==> p.update({followURL(URL),Ms})  //(reuse)
    p(This0)={reuse[URL] Ms}
* p ==> p.update({readFolder(p),Ms})  //(dots)
    p(This0)={... Ms}
* p ==> p.update(CORE.L)  //(topNorm)
    p(This0)={H MCs}=FULL.L //note, all M are of form MC
    |- p.update(norm(p,FULL.L)) -> CORE.L
* p ==> p.update(LL)  //(top)
    p(This0)={H CORE.Ms C=C.e FULL.Ms}//MCs are already compiled
    C.e not of form CORE.L//thus e is the first point to execute
    Y=Y[p;onSlash=empty,onReturn=Library,onPath=error]
    p|- Y♥C.e :T
    coherentClasses(p,Y♥C.e)
    cX(eC)=empty
    adapt(Y♥C.e,T.P) -->p+ r //execute the expression under the program and obtain a result
    CORE.L= refreshUniqueNames(r) //may fail if r not of form CORE.L, and that would be lifted as compilation error.
    p'= p.update({H CORE.Ms C=CORE.L FULL.Ms}) if Ms not empty //can remove this if and will just call topNorm after... IDEAS?
    p'= p.update(norm(p,{H CORE.Ms C=CORE.L})) otherwise
    |- p' -> LL //type all the MCs that can be compiled now, including This0
* p ==> p'.pop(1)   //(enter)
    p(This0) = {H CORE.Ms C=ctxC[LL] FULL.Ms}
    LL not of form CORE.L
    p.push({H CORE.Ms C=ctxC FULL.Ms}, LL)  ==>+  p' //Note: p' is one level deeper than p
    p'(This0) of form CORE.L // and p'(This0) is the result of metaprogramming LL
_______
#define adapt(eC,P)
* adapt(eC, Library)=eC
* adapt(eC, Void)=(Void x=eC {}); where x fresh
* adapt(eC, _)= (T x=eC x.#toLibrary()); otherwise, where x fresh
_______
#define norm(p,Full.L)=CORE.L  //assert norm(p,{reuse [URL] _}) and norm(p,{... _} never happens
* norm(p,CORE.L) = CORE.L //assert never happens (not true in real language but good for debugging at the start)
* norm(p,FULL.L) = CORE.L
    FULL.L={interface? Ts Ms0}
    CORE.L={interface? Ts,(Ts'\p Ts) infer(p',Ms') Info }
    Info=Info[norm;//ok, non computational rule checking that Info in CORE.L is consistent
      typeDep;coherentDep==collectDeps(CORE.L);
      friendsDep= ??Ps;//using private methods (or paths??)
      usedMethDep=??(P.s)s;
      privateImpl=??Ps]       
    p'=p.push(LL)
    Ts'=collect(p',Ts) // this gets the transitively implemented interfaces (-Any)
    Ms=expandFields(Ms0) // this turns the fields into abstract methods
    forall T in Ts'\p Ts, p'.noUnique(T) //no private interfaces are added
    Ms'=methods(p',This0)\Ms.ss, [methods(p',This0)(M.s)| M in Ms],[C:e| C:e in Ms]
    //the line above use [|] to make sequences nor sets. The order of members is important here.
    //Note: using Ts'\p Ts the docs of any T inside Ts overrides the one inside Ts'
_______
#define collectDeps(CORE.L)  //dont collect dependencies from NCs, Info and Docs
* collectDeps({H MWT1...MWTn1 NCs Info})=H.Ts;empty U collectDeps(MWT1) U .. U collectDeps(MWTn)
* collectDeps(C=_)=empty;empty
* collectDeps(Docs refine? native[URL]? mdf method T0 mOp(T1 x1 ..Tn xn)[Ts] = e?)
    =T0..Tn, Ts;empty U collectDepsE(e?)
_______
#define collectDepsE(CORE.e)    //collectDepsE(L) adds NCs dependiencies and relies on cached Info
* collectDepsE(x)=collectDepsE(void)=empty;empty
* collectDepsE(L)=L.Info.typeDep;L.Info.coherent U collectDepsE(NC1.L)[from This0.(NC1.C)] U .. U collectDepsE(NCn.L)[from This0.(NCn.C)]
    L={H MWTs NC1..NCn Info}
* collectDepsE( e0.m( x1=e1 .. xn=en ) )=P U collectDepsE(e0) U..U collectDepsE(en) 
* collectDepsE(loop e)=collectDepsE(throw e)=collectDepsE(x :=e)=collectDepsE(e)
* collectDepsE((class Any P))= P;empty
* collectDepsE((class P' P))= P',P;P
    P'!=Any
* collectDepsE( (Ds Ks e) ) =collectDepsE(Ds) U collectDepsE(Ks) U collectDepsE(e)
* collectDepsE(var? T x=e)=collectDepsE(catch throw T x e)= T;empty U collectDepsE(e)
_______
#define P in typed(p)
* P in typed(p) iff p(P).info.Flag=typed
_______
#define typable(p)=Csz
Cs1..Csn=typable(p)
  is the largest subset of dom(p(This0)) so that forall i:
    p(This0.Csi) of form CORE.L
    p(This0.Csi).info.Flag=norm
    p(This0.Csi).depTyped subset typed(p) U This0.Cs1..This0.Csn
  defined only if forall CORE.L in {p(This0.Cs) : Cs in dom(p(This0))}:
    forall P in CORE.L.info.depTypes:
      alive(p,P) //else compile time error here
_______
#define LL[Csz=Flag]=LL'
LL[Cs Csz = Flag]=LL[Cs.info.Flag=Flag][Csz=Flag]
LL[Csz=Flag]=LL
  where dom(LL) not in Csz
_______
#define |- p -> CORE.L'
  |-p -> p(This0)[Csz=typed] //are we sure we want to use empty to mean 'justTyped'
    where
    typable(p)=Csz
    forall Cs in Csz:  p.navigate(Cs)|-p(This0.Cs) : OK
_______
#define CORE.e inside CORE.e'
  e inside ctx[e]
_______
#define coherent(p,CORE.e)    coherent(p)
* coherent(p,e)
    forall (class P' P) inside e: //assert p(P) and p(P') is CORE.L
      either P'=Any
      or coherent(p.navigate(P))

* coherent(p) //interfaces are always coherent
    p(This0).interface?=interface
* coherent(p)
    p(This0).interface?=empty
    MHs={MH | MH in p(This0).MWTs} //thus, abstract
    either for no MH in MHs: MH.mdf=class//there is no abstract class method
    or exists xz  and n? such that:
      forall MH in MHs, coherent(p;MHs;MH;xz;n?)
* coherent(p;_;MH;xz;n?)
    MH=refine? class method T m::n? (_)_
    G^MH.xz=this,xz
    p|-This0<=T.P
    T.mdf not in {class, fwd mut, fwd imm}
    lent not in G^MH.mdfs
    if T.mdf in {imm, capsule} then {mut, fwd mut} disjoint G^MH.mdfs
    if read in G^MWT.mdfs then T.mdf in {read, lent}
    if !trustedClass(p(This0)) then m is of form #$m
* coherent(p;MHs;refine? mdf method T m::n?(_)_;_;n?) //must 'n?' be the same for well formedness?
    mdf in {lent, mut, capsule}
    forall MH' in MHs: either MH'.mdf!=class
    or MH'.T.mdf not in {lent, mut, capsule}
* coherent(p;_;MH;_,x;n?)
    MH=refine? mdf method T #?x::n?(mdf' P' that) _
    p |- imm Void <= T
    mdf' in {imm, mut, capsule, class}//that is not in {read, lent, fwd mut, fwd imm}
    mdf in {lent, mut, capsule}
    if mdf = lent then mdf' != mut
* coherent(p;MHs;MH;_,x;n?)
    MH=refine? mdf method mdf' P' #?x::n?() _
    mdf != class
    forall P in fieldTypes(MHs, x, mdf).Ps:  p |- P <= P'
    coherentGetMdf(mdf',mdf,
      fieldTypes(MHs,x, mdf).mdfs,
      fieldAccessMdf(MHs,x, mdf))
_______
#define coherentGetMdf(/*value*/mdf0,/*getter*/mdf1,/*in*/mdfs0,/*out*/mdfs1)
* coherentGetMdf(imm,imm, mdfs0,_)
    class not in mdfs0
* coherentGetMdf(imm,mdf,mdfs0,mdfs1)
    mdf!=imm
    mdfs0 subseteq {imm, fwd imm,capsule}
    {mut, lent} disjoint mdfs1
* coherentGetMdf(read, _, mdfs0,_)
    class not in mdfs0
* coherentGetMdf(class,_,{class},_)
* coherentGetMdf(capsule,capsule,mdfs0,mdfs1)
    mdfs0 subseteq {mut, fwd mut, capsule}
    imm not in mdfs1
* coherentGetMdf(lent,mdf,mdfs0,_)
    mdfs0 subseteq {mut, fwd mut, capsule}//TODO: error, lent too? else never happens
    mdf in {lent, mut, capsule}
* coherentGetMdf(mut,mdf,mdfs0,_)
    mdfs0 subseteq {mut, fwd mut, capsule}
    mdf in {mut, capsule}

* T in fieldsTypes(MHs, x, mdf)
    either class method mdf" _(_ T x _)_ in MHs
    or mdf" method _ #?x::n?(T that)_ in MHs
    if mdf in {lent, mut, capsule} then mdf" in {lent, mut, capsule}
    //TODO: wrong, if the 'setter' was a method allowed to be abstract because take a mut on imm only class

* mdf' in fieldsAccessMdf(MHs, x, mdf)
    mdf" method mdf' P #?x::n?() in MHs
    mdf" != capsule
    if mdf in {lent, mut, capsule} then mdf" in {read, lent, mut, capsule}
_______
#define alive(p,P) //check if P is defined or has some hope of being defined in the future
alive(p,Any),alive(p,Void),alive(p,Library) holds
alive(p,Thisn.Cs)=alive(p(Thisn),Cs) 
alive(CORE.L,Cs)= Cs in dom(CORE.L)
alive(FULL.L,Cs)=
  if FULL.L(C)=LL and alive(LL,Cs)
  or FULL.L(C)=e, e not of form LL
//WHEN AND HOW docs are checked so that the paths inside
//the docs are alive and not 'mispelled'?