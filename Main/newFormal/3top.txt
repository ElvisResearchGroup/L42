
-----------------------------------------------------------
Part 1: 42 top level reduction rules
-----------------------------------------------------------
### reduction rules
ReductionTop:
precondition: at top level we have an L not of form LC.
Rule (top) performs a step of execution, while rule (enter)
propagates the execution inside nested classes and libraries in method bodies.


r::=LC| exception v | error v

(topNorm)
p ==> p.update(L)
  where
  p.top()=H{MCs}=FULL.L
  CORE.L=normalize(p,p.top())
  |- p.update(CORE.L) -> L

(top)
p ==> p.update(LL)
  where
  p.top()=H{MCs C=e Ms}//MCs are already compiled
  e not of form CORE.L//thus e is the first point to execute
  eC=normalize(Y[p=p,?xP=empty,T?=Library,PType=error],e) //eC is core
  p|-eC:T
  eC'=eC if T.P=Library
  eC'= (Void x=eC {}) if T.P=Void, with x fresh
  eC'=(T x=eC x.#toLibrary()) otherwise, with x fresh
  eC' -->p+ r //execute the expression under the program and obtain a result
  CORE.L=refreshUniqueNames(r) //may fail if r not of form L, and that would be lifted as compilation error.
  p'=p.update(H{MCs C=CORE.L Ms}) if Ms not empty //can remove this if and will just call topNorm after... IDEAS?
  p'=p.update(normalize(p,H{MCs C=CORE.L})) otherwise
  |- p' -> LL //type all the MCs that can be compiled now, including This0

(enter)
p ==> p'.pop()
  where
  p.push(ctxL, L)  ==>+  p'
  p.top() = H{MCs C=e Ms}
  e not of form core(_)
  e = ctxC[L], L not of form CORE.L
  ctxL = H{MCs C=ctxC Ms}
  p'.top() of form LC //Note: p' is one level deeper than p,
  // and p'.top() is the LC result of metaprogramming L
 
 
_______
#define collectDeps(CORE.L) 
collectDeps(interface?[Ts]{MWT1...MWTn1 NCs})=Ts;empty U collectDeps(MWT1) U .. U collectDeps(MWTn)
collectDeps(C=_)=empty;empty
collectDeps(T f)=T;empty
collectDeps(Docs refine? native[URL]? mdf method T0 mOp(T1 x1 ..Tn xn)[Ts] = e?)
  =T0..Tn, Ts;empty U collectDepsE(e?)
//we do not collect dependencies from docs.

collectDepsE(x)=collectDepsE(void)=empty;empty
collectDepsE(L)=collectDeps(L) U Ps11..Ps1n; Ps21..Ps2n 
  L=interface?[Ts]{MWTs NC1..NCn}
  NCi=core(Li;Flagi;Ps1i;Ps2i)
collectDepsE( (P e0).m( x1=e1 .. xn=en ) )=P U collectDepsE(e0) U..U collectDepsE(en) 
collectDepsE(loop e)=collectDepsE(throw e)=collectDepsE(x :=e)=collectDepsE(e)
collectDepsE((class Any P))= P;empty
collectDepsE((class P' P))= P',P;P
  where P'!=Any
collectDepsE( (Ds Ks e) ) =collectDepsE(Ds) U collectDepsE(Ks) U collectDepsE(e)
collectDepsE(var? T x=e)=collectDepsE(catch throw T x e)= T;empty U collectDepsE(e)
collectDepsE(T x=e)=T;empty U collectDepsE(e)

-----------------------------------
|-p->CORE.L
-----------------------------------
//TODO: decide where to check if docs patsh are still alive
_______
#define P in typed(p) iff p(P).info.Flag=typed
_______
#define P in coherent(p) iff p(P).info.Flag=coherent
_______
#define typable(p)=Csz
Cs1..Csn=typable(p)
  is the largest subset of dom(p.top()) so that forall i:
    p(This0.Csi) of form CORE.L
    p(This0.Csi).info.Flag=norm
    p(This0.Csi).depTyped subset typed(p) U This0.Cs1..This0.Csn
  defined only if forall CORE.L in {p.top()(Cs) : Cs in dom(p.top())}:
    forall P in CORE.L.info.depTypes:
      alive(p,P) //else compile time error here

_______
#define typableCoherent(p)=Csz
Cs1..Csn=typableCoherent(p,p.top())
  is the largest subset of dom(p.top()) so that forall i:
    p(This0.Csi) of form CORE.L
    p(This0.Csi).Flag=empty
    p(This0.Csi).depCoherent subset coherent(p) U This0.Cs1..This0.Csn 
  
_______
#define mark(Flag,LL,Csz)=M
markTyped(LL, Cs Csz)=markTyped(LL[Cs.info.Flag=Flag], Csz)
markTyped(LL,Csz)=L
  where dom(LL) not in Csz

_______
#define |- p ->CORE.L'
  |-p -> mark(coherent,mark(empty,L,Csz),Csz')
    where
    typable(p)=Csz
    forall Cs in Csz:
      if p.top()(Cs)=CORE.L
      then p.navigate(Cs)|-p.top()(Cs) : OK
    Csz'=coherent(p,mark(empty,p.top(),Csz))
    
//WHEN AND HOW docs are checked so that the paths inside
//the docs are alive and not 'mispelled'?
// alive(p,P) to check for all P at the end of normalize ??
//forall P inside MH e?, alive(p,P) //else error here 

_______
#define alive(p,P) //check if P is defined or has some hope of being defined in the future
alive(p,Any),alive(p,Void),alive(p,Library) holds
alive(p,Thisn.Cs)=alive(p(Thisn),Cs) 
alive(CORE.L,Cs)= Cs in dom(CORE.L)
alive(FULL.L,Cs)=
  if FULL.L(C)=LL and alive(LL,Cs)
  or FULL.L(C)=e, e not of form LL
  