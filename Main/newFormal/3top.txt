_______
#define p ==>p'
* {reuse[URL] Ms};pTail ==> {followURL(URL),Ms};pTail  //(reuse)
* {... Ms};pTail ==> {readFolder(pTail),Ms};pTail //(dots)//note, ... is cached 
* {H CMs};pTail ==> flagTyped(norm({H CMs};pTail);pTail)  //(topNorm)
* p ==> flagTyped({H CMs pâ™¥Docs C=CORE.L Ms};pTail)  //(top)
    p={H CMs Docs C=CMP.e Ms};pTail
    CMP.e not of form CORE.L//e is the first point to execute
    CORE.e=norm(p,CMP.e)
    FV(CORE.e)=empty //not implied by typing: FV check capsules used 1 or 0
    Q=Q[Flag=norm;MH?=empty;p;G=empty;Ts=empty;Ps=Any]
    Q|- CORE.e :T
    coherentClasses(p,CORE.e)
    empty|adapt(CORE.e,T.P) -->p+ _|r
    CORE.L= refreshUniqueNames(r) //fails if r not of form CORE.L, lifted as compilation error
* {H CMs C=ctxC[LL] FULL.Ms};pTail ==> p.pop(1)   //(enter)
    LL not of form CORE.L
    LL;{H CMP.Ms C=ctxC FULL.Ms};pTail  ==>+  p //Note: p is one level deeper
    p(This0) of form CORE.L // p(This0) is the result of metaprogramming LL
_______
#define adapt(CMP.e,P)
* adapt(CMP.e, Library) = CMP.e
* adapt(CMP.e, Void) = (Void x=CMP.e {}); where x fresh
* adapt(CMP.e, _) = (T x=CMP.e x.#toLibrary()); otherwise, where x fresh
_______
#define flagTyped(p)=p'    LL[Csz=Flag]=LL'
* flagTyped(p) = p.update( p(This0)[typable(p)=typed] )
    forall Cs in typable(p):  |-p.navigate(This0.Cs)
   
* LL[Cs Csz = Flag]=LL[Cs.info.Flag=Flag][Csz=Flag]
* LL[empty=Flag]=LL
_______
#define typable(p)=Csz
* typable(p) = Cs1..Csn
    Cs1..Csn is the largest subset of dom(p(This0)) so that forall i:
    p(This0.Csi) of form CORE.L
    p(This0.Csi).info.Flag=norm
    p(This0.Csi).depTyped subset {P| p(P).info.Flag=typed} U This0.Cs1..This0.Csn
_______
#define coherent(p,CORE.e)    coherent(p)     coherent(p;MHs;MH;xz;n?)
* coherent(p,e)
    forall (class P' P) inside e: //assert p(P) and p(P') is CORE.L
      either P'=Any
      or coherent(p.navigate(P))

* coherent(p)
    MHs={MH | MH in p(This0).MWTs} //thus, abstract
    either p(This0).interface?=interface
    or class not in MHs.mdfs//no abstract class method
    or exists xz  and n? such that:
      forall MH in MHs, coherent(p;MHs;MH;xz;n?)
      
* coherent(p;_;class method T m::n?(T1 x1..Tn xn)_;xz;n?)
    x1..xn=xz
    p|-This0<=T.P
    mdfs=(T1..Tn).mdfs
    T.mdf not in {class, fwd mut, fwd imm}
    lent not in mdfs
    if T.mdf in {imm, capsule} then {mut, fwd mut} disjoint mdfs
    if read or lent in mdfs then T.mdf in {read, lent}
    if !trustedClass(p(This0)) then m is of form #$m
* coherent(p;MHs;mdf' method T m::n?(_)_;_;n?) //by well formedness if n is present is the same, but it may be absent.
    forall class method mdf _(_)_ in MHs:  !mdf canAlsoBe mdf'
* coherent(p;_;mdf method T #?x::n?(mdf' P' that)_;_,x;n?)
    p |- imm Void <= T
    mdf' in {imm, mut, capsule, class}//that is not in {read, lent, fwd mut, fwd imm}
    mdf in {lent, mut}
    if mdf = lent then mdf' != mut
* coherent(p;_;capsule method T #?x::n?(mdf' P' that)_;_,x;n?)
    p |- imm Void <= T //capsule setters are guaranteed to trash the object anywhay... they are also dead code
* coherent(p;MHs;mdf method mdf' P' #?x::n?()_;_,x;n?)
    mdf notin {class, fwd mut, fwd imm}
    forall P in fieldTypes(MHs, x, mdf).Ps:  p |- P <= P'
    coherentGetMdf(mdf',mdf,
      fieldTypes(MHs,x, mdf).mdfs,
      fieldAccessMdf(MHs,x, mdf))
_______
#define mdf canAlsoBe mdf'    fieldTypes(MHs, x, mdf)=Ts    fieldsAccessMdf(MHs, x, mdf)=mdfs    coherentGetMdf(/*value*/mdf0,/*getter*/mdf1,/*in*/mdfs0,/*out*/mdfs1)
* capsule canAlsoBe mdf, with mdf in {capsule,mut,lent, read, imm, fwd imm, fwd mut}
* mut canAlsoBe mdf, with mdf in {mut,lent, read,imm,capsule, fwd imm, fwd mut}
* lent canAlsoBe mdf, with mdf in {mut,lent, read, fwd mut}
* read canAlsoBe mdf, with mdf in {read,imm, fwd imm}
* imm canAlsoBe mdf, with mdf in {read,imm, fwd imm} //is ok that canAlsoBe is undefined on fwd _ and class

* T in fieldTypes(MHs, x, mdf)
    either class method mdf' _(_ T x _)_ in MHs
    or mdf' method _ #?x::n?(T that)_ in MHs
    mdf' != capsule //capsule setters are dead code
    mdf' canAlsoBe mdf
    
* mdf" in fieldAccessMdf(MHs, x, mdf)
    mdf' method mdf" P #?x::n?() in MHs
    mdf' != capsule or mdf" = class//capsule getters can always return any mdf except class
    mdf' canAlsoBe mdf

* coherentGetMdf(class,_,{class},_)//valueMdf, getterMdf, inMdfs, outMdfs
* coherentGetMdf(read, _, mdfs0,_)
    class not in mdfs0
* coherentGetMdf(imm,imm, mdfs0,_)
    class not in mdfs0
* coherentGetMdf(imm,mdf,mdfs0,mdfs1)
    mdf!=imm
    mdfs0 subseteq {imm, fwd imm,capsule}
    {mut, lent} disjoint mdfs1
* coherentGetMdf(capsule,capsule,mdfs0,mdfs1)
    mdfs0 subseteq {mut, fwd mut, capsule}
    imm not in mdfs1
* coherentGetMdf(lent,mdf,mdfs0,mdfs1)
    mdfs0 subseteq {mut, fwd mut, capsule, lent}
    mdf in {lent, mut, capsule}
    imm not in mdfs1
* coherentGetMdf(mut,mdf,mdfs0,mdfs1)
    mdfs0 subseteq {mut, fwd mut, capsule}
    mdf in {mut, capsule}
    imm not in mdfs1
    
--------------------------END, examples only after this line
/*
class method lent This foo(lent X x, lent X y)
mut method lent X x() // ok?
mut method lent X y() // ok?
*/


lent X method evil(lent X x) = 
    foo(x).x()

    if we can have a lent collection of read objects
or anyway update a read field, we have -capsule visible as read
  lent list=.. //lent method add(read r)
  capsule a=..
  capsule a2=(mut b=a
   list.add(b)
   b)
  a2 and list usable
  
  {
  class method mut This (S x)
  class method imm This (N x)
  mut method S #x()
  read method Any x()
  //mut method x(N that) //enabling this method makes #x not valid for coherence
  }
  