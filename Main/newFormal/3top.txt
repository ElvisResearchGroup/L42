_______
#define p ==>p'
* {reuse[URL] Ms};pTail ==> {followURL(URL),Ms};pTail  //(reuse)
* {... Ms};pTail ==> {readFolder(pTail),Ms};pTail //(dots)//note, ... is cached 
* {H CMs};pTail ==> flagTyped(norm({H CMs};pTail);pTail)  //(topNorm)
* p ==> flagTyped({H CMs pâ™¥Docs C=CORE.L Ms};pTail)  //(top)
    p={H CMs Docs C=CMP.e Ms};pTail
    CMP.e not of form CORE.L//e is the first point to execute
    CORE.e=norm(p,CMP.e)
    FV(CORE.e)=empty //not implied by typing: FV check capsules used 1 or 0
    Q=Q[Flag=norm;MH?=empty;p;G=empty;Ts=empty;Ps=Any]
    Q|- CORE.e :T
    coherentClasses(p,CORE.e)
    empty|adapt(CORE.e,T.P) -->p+ _|r
    CORE.L= refreshUniqueNames(r) //fails if r not of form CORE.L, lifted as compilation error
* {H CMs C=ctxC[LL] FULL.Ms};pTail ==> p.pop(1)   //(enter)
    LL not of form CORE.L
    LL;{H CMP.Ms C=ctxC FULL.Ms};pTail  ==>+  p //Note: p is one level deeper
    p(This0) of form CORE.L // p(This0) is the result of metaprogramming LL
_______
#define adapt(CMP.e,P)
* adapt(CMP.e, Library) = CMP.e
* adapt(CMP.e, Void) = (Void x=CMP.e {}); where x fresh
* adapt(CMP.e, _) = (T x=CMP.e x.#toLibrary()); otherwise, where x fresh
_______
#define flagTyped(p)=p'    LL[Csz=Flag]=LL'
* flagTyped(p) = p.update( p(This0)[typable(p)=typed] )
    forall Cs in typable(p):  |-p.navigate(This0.Cs)
   
* LL[Cs Csz = Flag]=LL[Cs.info.Flag=Flag][Csz=Flag]
* LL[empty=Flag]=LL
_______
#define typable(p)=Csz
* typable(p) = Cs1..Csn
    Cs1..Csn is the largest subset of dom(p(This0)) so that forall i:
    p(This0.Csi) of form CORE.L
    p(This0.Csi).info.Flag=norm
    p(This0.Csi).depTyped subset {P| p(P).info.Flag=typed} U This0.Cs1..This0.Csn
_______
#define coherent(p,CORE.e)    coherent(p)     coherent(p;MHs;MH;xz;n?)
* coherent(p,e)
    forall (class P' P) inside e: //assert p(P) and p(P') is CORE.L
      either P'=Any
      or coherent(p.navigate(P))

* coherent(p)
    MHs={MH | MH in p(This0).MWTs} //thus, abstract
    either p(This0).interface?=interface
    or class not in MHs.mdfs//no abstract class method
    or exists xz  and n? such that:
      forall MH in MHs, coherent(p;MHs;MH;xz;n?)
      
* coherent(p;_;class method T m::n?(T1 x1..Tn xn)_;xz;n?)
    x1..xn=xz
    p|-This0<=T.P
    T.mdf not in {class, fwd mut, fwd imm}
    lent _ not in T1..Tn
    if T.mdf in {imm, capsule} then {mut, fwd mut} disjoint (T1..Tn).mdfs
    if {read _, lent _} not disjoint T1..Tn then T.mdf in {read, lent}
    if !trustedClass(p(This0)) then m is of form #$m
* coherent(p;MHs;mdf method T m::n?(_)_;_;n?) //must 'n?' be the same for well formedness?
    not callable(MHs, mdf)

* coherent(p;_;mdf method T #?x::n?(mdf' P' that)_;_,x;n?)
    p |- imm Void <= T
    mdf' in {imm, mut, capsule, class}//that is not in {read, lent, fwd mut, fwd imm}
    mdf in {lent, mut, capsule}
    if mdf = lent then mdf' != mut
* coherent(p;MHs;mdf method mdf' P' #?x::n?()_;_,x;n?)
    mdf != class
    forall P in fieldTypes(MHs, x, mdf).Ps:  p |- P <= P'
    coherentGetMdf(mdf',mdf,
      fieldTypes(MHs,x, mdf).mdfs,
      fieldAccessMdf(MHs,x, mdf))
_______
#define fieldTypes(MHs, x, mdf)=Ts    fieldsAccessMdf(MHs, x, mdf)=mdfs    coherentGetMdf(/*value*/mdf0,/*getter*/mdf1,/*in*/mdfs0,/*out*/mdfs1)

{lent, mut, capsule} subseteq relevent(mdf)
    mdf in {mut, capsule}
{lent, mut} subseteq relevent(lent)


callable(MHs, mdf) // TODO: combine and simplify with relevent?
    mdf in {read, imm}
    class method _ in MHs

callable(MHs, mdf)
    mdf in {mut, lent}
    class method mdf" in MHs
    mdf" in {mut, lent, capsule}

    
callable(MHs, capsule)
    class method mdf" in MHs
    mdf" in {mut, capsule}
    
    
* T in fieldTypes(MHs, x, mdf)
    class method mdf' _(_ T x _)_ in MHs
    mdf' in relevent(mdf)
    
* T in fieldTypes(MHs, x, mdf)
    mdf' method _ #?x::n?(T that)_ in MHs
    callable(MHs, mdf')
    mdf' in relevent(mdf)
    
* mdf' in fieldAccessMdf(MHs, x, mdf)
    mdf" method mdf' P #?x::n?() in MHs
    mdf" != capsule
    mdf' in relevent(mdf)

* coherentGetMdf(class,_,{class},_)
* coherentGetMdf(imm,imm, mdfs0,_)
    class not in mdfs0
* coherentGetMdf(read, _, mdfs0,_)
    class not in mdfs0
* coherentGetMdf(imm,mdf,mdfs0,mdfs1)
    mdf!=imm
    mdfs0 subseteq {imm, fwd imm,capsule}
    {mut, lent} disjoint mdfs1
* coherentGetMdf(capsule,capsule,mdfs0,mdfs1)
    mdfs0 subseteq {mut, fwd mut, capsule}
    imm not in mdfs1
* coherentGetMdf(lent,mdf,mdfs0,_)
    mdfs0 subseteq {mut, fwd mut, capsule, lent}//TODO: error, lent too? else never happens
    mdf in {lent, mut, capsule}
* coherentGetMdf(mut,mdf,mdfs0,_)
    mdfs0 subseteq {mut, fwd mut, capsule}
    mdf in {mut, capsule}
    
/*
class method lent This foo(lent X x, lent X y)
mut method lent X x() // ok?
mut method lent X y() // ok?
*/


lent X method evil(lent X x) = 
    foo(x).x()
