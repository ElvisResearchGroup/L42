
-----------------------------------------------------------
Part 1: 42 top level reduction rules
-----------------------------------------------------------
### reduction rules
ReductionTop:
precondition: at top level we have an L not of form LC.
Rule (top) performs a step of execution, while rule (enter)
propagates the execution inside nested classes and libraries in method bodies.

Flag::= norm |typed 
typed::=uncoherent | coherent

r::=LC| exception v | error v

NC::= Docs C = core(L;Flag;Ps1;Ps2)

(top)
p ==> p.update(p.top()[MCs'])
  where
  p.top()=_[Ps0]{MCs  C:e Ms}//MCs are already compiled
  e not of form core(L)//thus e is the first point to execute
  eC=normalize(p,e) //eC is core
  p|-eC:T
  eC -->p+ r //execute the expression under the program and obtain a result
  L=refreshUniqueNames(r) //may fail if r not of form L, and that would be lifted as compilation error.
  p|- MCs,C=core(L,Norm;collectDeps(L)) ->MCs'

(enter)
p ==> p'.pop()
  where
  p.push(ctxL, L)  ==>+  p'
  p.top()=interface?[Ps]{MCs C=e Ms}
  e not of form core(_)
  e=ctxC[L], L not of form LC
  ctxL=interface?[Ps]{MCs C=ctxC Ms}
  p'.top() of form LC //Note: p' is one level deeper than p,
  // and p'.top() is the LC result of metaprogramming L
 
 
 Need to define:
 normalize(Y,e) normalize(p,e)
 p|-MCs->MCs'
 collectDeps(L)
 alive(p,P) to check for all P at the end of normalize
 //forall P inside MH e?, alive(p,P) //else error here 
 
_______
#define collectDeps(L) //core L 
collectDeps(interface?[Ts]{MWT1...MWTn1 NCs})=Ts;empty U collectDeps(MWT1) U .. U collectDeps(MWTn)
collectDeps(C=_)=empty;empty
collectDeps(T f)=T;empty
collectDeps(refine? native[P]? mdf method T0 mOp(T1 x1 ..Tn xn) [Ts] = e?)
= P?,T0..Tn, Ts;empty U collectDepsE(e?)
//what about Docs 

collectDepsE(x)=collectDepsE(void)=empty;empty
collectDepsE(L)=collectDeps(L) U Ps11..Ps1n; Ps21..Ps2n 
  L=interface?[Ts]{MWTs NC1..NCn}
  NCi=core(Li;Flagi;Ps1i;Ps2i)
collectDepsE( (P e0).m( x1=e1 .. xn=en ) )=P U collectDepsE(e0) U..U collectDepsE(en) 
collectDepsE(loop e)=collectDepsE(throw e)=collectDepsE(x :=e)=collectDepsE(e)
collectDepsE((Any P))= P;empty
collectDepsE((P' P))= P',P;P
  where P'!=Any
collectDepsE( (Ds Ks e) ) =collectDepsE(Ds) U collectDepsE(Ks) U collectDepsE(e)
collectDepsE(var? T x=e)=collectDepsE(catch throw T x e)= T;empty U collectDepsE(e)


T%e
(T e)

T foo()=(
P.foo()
foo.bar(x:(\ P)   class P class Any

foo.bar(x:  //P.foo(P)
  (class P y=P y.foo((\ P)))
xPP::= x| (T P)

e::= xPP.m(..)
D::= T x=e

Foo().bar(\foo)
==> (T x = Foo() x.bar())
	(T Foo()).bar()
	
	(T x = P x.bar())
	(T P).bar()
	
class MethodCall:	
	receiver: AST
	receiver_type: Type-AST
	method-name
	args...




foo.bar(/*Bar*/x:(
  \ y=\
  y.foo()
  catch return \ x
  ))

)
