TOP LEVEL PROCESS:
parsing top level LL, resolve ... and Cs into Thisn.Cs, check well formedness, apply top(empty,(LL;empty)) => PR
_______
#define init(FULL.L) = FULL.L' //with no Cs and no '...'
  it propagates on the structure;
    all the ... are expanded with the code retrieved from the file system.
    on all the FULL.L and CORE.L it grows a local program p,
    on all the Cs applies p.minimize(p.resolve(C.Cs)).
    on all the P applies p.minimize(P).
    the n of every Thisn.Cs must fit in the dept of the program
    forall LL0, LL1 anywhere inside different places: uniqueNs(p,LL0)\0 disjoint uniqueNs(p,LL1)\0
    after the p.minimize happend everywhere, check that for any reached p=CORE.L;pTail:
      if Info.Flag=typed  then Info.typeDep subseteq dom(p) and norm |- p
      ??? watched=Ps,
      ??? usedMethods=(P.s)s,
      ??? hiddenSupertypes=Ps,
      Ps0 subseteq L.Info.typeDep
      Ps1 subseteq L.Info.coherentDep
    where
      Info=CORE.L.Info
      Ps0;Ps1=collectDeps(p;L.MWTs) U collectDeps(L.Docs) U L.Ts.Ps;empty

//Note, when we import a url we should check if the corresponding CORE.L;empty is well formed
//error is reported if an implements list contains This0.Cs or
//Thisn.C.Cs and C is after the current point in the program
_______//owned unique ns
#define uniqueNs(p,LL) = ns    isDefined(p,s,P)
* n in uniqueNs(p,FULL.L) if C::n in dom(FULL.L.Ms)
* n in uniqueNs(p,FULL.L) if m::n(xs) in dom(FULL.L.Ms) and
    forall P in FULL.L.Ts.Ps not isDefined(p,m::n(xs),P)
* n in uniqueNs(p,CORE.L) if C::n in dom(CORE.L.NCs)
* n in uniqueNs(p,CORE.L) if m::n(xs) in dom(CORE.L.MWTs) and
    forall P in FULL.L.Ts.Ps not isDefined(p,m::n(xs),P)//purposly ignoring Info.refine

* isDefined(p,s,P) if s in dom(FULL.L.Ms) //ignoring reuse[URL] on purpose
    p(P)=FULL.L
* isDefined(p,s,P) if s in dom(CORE.L.MWTs)
    p(P)=CORE.L
* isDefined(p,s,P) if Pi in p(P).Ts.Ps and isDefined(p,s,Pi[from P;p])
//ignoring the Info.reuse for the CORE.L case on purpose
_______
#define p.resolve(Cs) = P
p.resolve(C.Cs) = Thisn.C.Cs
  where n is the smallest number such that either
  C in domNC(p(Thisn))
  or p(Thisn) = {reuse[URL]...}
//error is reported if: we try to explore an undefined p(Thisn) or URL has no #$ and C notin dom(followURL(URL)) 
_______
#define metanotation IfNotE, IfErr, IfUndefined
//note: the simpler interpretation (predicate0 and predicates) or predicate1
//would technically allow free variables in predicate0 to be chosen to falsify it
// Note: the "predicates" include those on subsequent (similarlly indented) lines!
* predicate0 IfNotE(Xs) predicate1 predicates == (predicate0 and predicates) or ((not exists Xs such that predicate0) and predicate1)
* predicate0 IfErr(Xs) predicate1 predicates == (predicate0 and predicates) or (Err in Xs  and predicate1)
* predicate0 IfUndefined predicate1 predicates == (predicate0 and predicates) or (predicate0 undefined and predicate1)
_______
#define firstErr(Rs) = Err
* firstErr(Rs,Err,_) = Err
    Err not in Rs
_______
#define top(CTz,p) => PR    topNC(CTz;p;Cs) => PR    sortHeader(p) = p'    addInfo(p) = p'   
* top(CTz,p) => PR
    CORE.L = sortHeader(p) IfNotE(CORE.L) PR = headerErr(p)
    Ms=p(This0).Ms //Ms = FULL.Ms
    p0 = p.update(CORE.L) //assert all levels of p0 are CORE.L TODO: add assert in code
    MWT1..MWTn = CORE.L.MWTs
    CTz.add(p0; MH1 Ms(MWT1.s).e?; e?1).. .add(p0; MHn Ms(MWTn.s).e?; e?n) = CTz0
    topNC(CTz0,p0,[NC| NC in Ms]) => PR1
    PR1 = CTz1; p1 IfErr(PR1) PR = PR1 //top of p1 is a CORE.L with all NCs and ok info
    //here we check that p1(This0) is well formed
    I[C=empty;p1;MWTi.G;CTz1; frommed=empty]!e?i => ERi  for i in 1..n
    ER1 = _;e?'1 .. ERn = _;e?'n IfErr(ER1..ERn) PR = firstErr(ER1..ERn) 
    //novel CTzs are not captured since no Full.L in e?s
    MWT'i = MWTi Ms(MWTi.s).native e?'i
    L = updateInfo(p1, MWT'1..MWT'n)
    p2=p1.update(L)
    PR = CTz1; p2.update(p2.top()[Info.uniqueId=empty])

* topNC(CTz;p;empty) =>CTz;p
* topNC(CTz;p;FULL.Docs C=FULL.e, Full.NCs) => PR
    Y = Y[p;GX=empty;onSlash=imm Library;onSlashX=empty;expectedT=imm Library;CTz]
    Y!FULL.e = HALF.e; _; _; _ // No need to collect CTz's, since we need e to be fully typed anyway
    CTz0 = CTz[from This1;p.push(C,{#norm{}})]
    I[C?=C;p;G=empty;CTz; frommed=CTz0]!HALF.e => ER//could we just pass empty instead of CTz?
    ER = CTz1;CORE.e IfErr(ER) PR = ER
    //here we check CORE.e is well formed
    wellTyped(p,CORE.e) = T IfNotE(T) PR = illTyped(p)
    coherent(p,adapt(CORE.e,T)) IfUndefined PR = incoherent(p)
    reduce(p,empty,adapt(CORE.e,T)) => ER'
    ER' = empty;CORE.L IfErr(ER') PR = ER'
    p' = p.update(updateInfo(p,FULL.e,♥FULL.Docs C=CORE.L))//refreshUniqueNames or not depending on FULL.e
    flagTyped(p') = p" IfNotE(p") PR = illTyped(p')
    topNC(CTz1[from This0.C,p"];p";Full.NCs) => PR 
    
* sortHeader({reuse[URL] Ms};pTail) = {interface? Ts MWTs,CORE.MWTs NCs Info+Info0 Docs}
    followURL(URL) = {interface? Ts MWTs NCs Info Docs} //with info
    //TODO: here we need to rename the private names
    dom(MWTs NCs) disjoint dom(Ms)
    CORE.MWTs = [♥MWT.Docs ♥MWT.MH |MWT in Ms]
    p0=followURL(URL);pTail
    Ps;empty = collectDeps(p0;CORE.MWTs)
    ss=[MWT.s| MWT in CORE.MWTs and refine(p0;s;This0)]
    declaresClassMethods?=empty iff class notin MWTs.mdfs
    Info0 = #norm{typeDep=Ps\{Any,Void,Library},refine=ss, declaresClassMethods?,closeState, uniqueId=n}
    n fresh
    //Note: sortHeader remove  bodies from methdos. This basically guarantees 
    //closeState. The close/open state is fixed later

* sortHeader(p) = CORE.L
    p(This0) = {interface? [Ts] Ms Docs} = FULL.L
    p0 = p.update({interface? [♥Ts] #norm{typeDep=♥Ts}})//to prevent looking to non core
    Ts1 = (♥Ts).distinct(),(collect(p0,♥Ts)\♥Ts)//gets the transitively implemented interfaces -Any
    forall imm P in Ts1\♥Ts, P not of form Thisk._.C::n._//private interfaces not added
    p1 = p.update({interface? [Ts1] #norm{typeDep=Ts1}})//now with correct implements    
    MWTs = [♥Docs MH | MH in methods(p1,Ts1,Ms) and either Docs=Ms(MH.s).Docs or Docs=empty otherwise]
    Ps;empty = collectDeps(p0;MWTs)
    ss=[MWT.s| MWT in MWTs and refine(p1;s;This0)]
    declaresClassMethods?=empty iff class notin MHs.mdfs
    Info = #norm{typeDep=Ts1.Ps U Ps U collectDeps(♥Docs)\{Any,Void,Library},refine=ss, declaresClassMethods?, closeState, uniqueId=n}
    n fresh
    CORE.L = {interface? [Ts1] MWTs Info ♥Docs}
_______
#define CTz[from P;p]    ST[from P;p]
* CTz[from P;p] = CTz' trivially propagates on the structure and applies ST[from P; p] on all the ST in CTz

* ST[from This0.C, p]=p.solve(ST')
  ST' = ST where all the STi inside are replaced with STi[from This0.C, p] 
//Note: an ST that is a CORE.T is already handled by the normal from
_______
#define collect(p,Core.Ts)=Core.Ts'
* collect(p,empty)=empty
* collect(p,T0 Ts)=((T0, Ts0[from T0.P;p]) \ collect(p,Ts)) collect(p,Ts)
    p(T0.P)={interface [Ts0] _}=CORE.L
_______
#define methods(p,Core.Ts, Full.Ms)=CORE.MHs //methods res has relevant order
* methods(p,imm P1..imm Pk, Ms)=MH1..MHn//assert ... and reuse are unreachable
    MHs=[extractMHs(p;Ms)] 
      U [p(P1).MWTs.MH[from P1;p]] U..U [p(Pk).MWTs.MH[from Pk;p]]
    s1..sn=MHs.ss.distinct()
    origin(p;s1)..origin(p;sn) all defined
    [MHi,_]=[MH| MH in MHs and MH.s=si]
    i in 1..n
_______
#define origin(p;s) = P'   refine(p;s;P)
* origin(p;s) = P
    {P}={This0|!refine(p;s;This0)} U
      {P |P in p(This0).Ts.Ps, s in dom(p(P).mwts) and !refine(p;s;P)}
* refine(p;s;P) 
    exists P' in p(P).Ts.Ps[from P;p] such that s in dom(p(P').mwts)
    //assert P' never This0
    //assert s in dom(p(P).mwts)
_______
#define extractMHs(p;Full.Ms)=CORE.MHs //need to keep the order
* extractMHs(p;empty)=empty
* extractMHs(p;NC,Ms)=extractMHs(Ms) 
* extractMHs(p;MI,Ms)=extractMHs(Ms) 
* extractMHs(p;MWT,Ms)=♥MWT.MH,extractMHs(Ms) 
* extractMHs(p;T x,Ms)=read method ♥T x(), extractMHs(Ms)
    ♥T = toRead(♥T)
* extractMHs(p;T x,Ms)=mut method capsuleToLent(♥T) #x(), extractMHs(toRead(♥T) x,Ms)
    ♥T != toRead(♥T) // TODO: should we use capsuleToMut(T) instead? I'm really on the fence
* extractMHs(var T x,Ms)=mut method Void x(♥T that), extractMHs(T x,Ms)    
    
* updateInfo(p,MWTs) = {interface? Ts MWTs0 MWTs NCs Info1}
    p(This0) = {interface? Ts MWTs0 MWTs1 NCs Info0 Docs}
    dom(MWTs) = dom(MWTs1)
    Ps;Ps' = collectDeps(p;MWTs.es)
    Info = #norm{typeDep=Ps\{Any,Void,Library},coherentDep=Ps'\{Any,Void,Library},??}
    Info1 = (Info0+Info) if hasOpenState(interface?,MWTs0 MWTs1)
    Info1 = (Info0+Info)[closeState?=closeState] otherwise
    //TODO: either here we make all P.#from(stringLiteral=..) and P.m(squareBuilder=..)
    //with no free variables into class methods or in the execution we optimize as 
    //class methods all subexpressions with no free var (and not calling #$s)
* updateInfo(p,FULL.e,Docs C=L) = L0[♥Docs C=L'][Info=Info1]
    p(This0) = L0
    Info = #norm{typeDep=collectDeps(p♥Docs)}
    Info1=L0.Info+Info if C not of form _::n
    Info1=L0.Info+Info+collectDepsE(p,L) otherwise //this provides more typeDep and coherentDep
    L'=refreshUniqueNames(L) if FULL.e not of form LL //TODO: may be need to be CORE.L instead of LL?
    L'=L otherwise
    
_______
#define I!HALF.e? => ER
* I!empty => I.frommed;empty
* I!x => I.frommed;x
* I!void => I.frommed;void
* I!FULL.L => ER //undefined if I.C?=empty 
    p=I.p.push(I.C?,FULL.L) //here we intentionally do a push(C,L) where C not in dom(p(This0))  
    top(I.frommed,p) => PR
    PR = CTz';p' IfErr(PR) ER = PR
    ER = CTz';p'(This0)
* I!CORE.L => I.frommed;CORE.L //no useful ccz could be here (assuming no CORE.L in the source)
* I!P<:STz => I.frommed;P<:I(class STz)
* I!P<:STz => inferenceFailure(I,STz)
    I(STz) undefined
* I!%STz%<: STz' => I.frommed;I(STz).P <:I(class STz')
* I!%STz%<: STz' => inferenceFailure(I,STz,STz')
    either I(STz) or I(STz') undefined
* I0!e0.m(x1=e1..xn=en) => ER
    Ii+1 = Ii[frommed=CTzi]
    Ii!ei = ERi //e0 is of form xP
    ER0..ERn = CTz0;e'0..CTzn;e'n IfErr(ER0..ERn) ER = firstErr(ER0..ERn)
    ER = CTzn;e'0.m(x1=e'1..xn=e'n)
* I!xP0 OP..OP xPn => ER
    I!xPi => ERi
    ER0..ERn = _;xP'0.._;xP'n IfErr(ER0..ERn) ER = firstErr(ER0..ERn)
    either xP'i = _ <: Ti
    or Ti = I.G(xP'i)
    {P.m(x1..xn).i} = I.p.opOptions(OP, T0..Tn)//in code this can throw thanks to methods; ok but error will need some wrapping to ease explanation
    xP"1..xP"n = xP'0..xP'n\i
    ER = I.frommed;xP'i.m(x1=xP"1..xn=xP"n)
* I!e0 => ER
    e0 in {throw e, loop e, x:=e}
    I!e => ER'
    ER' = CTz;e' IfErr(ER') ER = ER'
    ER = CTz;e0[e=e']
* I!(Ds K1..Km e) => ER
    xs = FV(Ds.es K1.e..Km.e e)//formally, FV is defined only on CORE.e. This works on HALF.E in the same way
    I!xs;Ds => DsR
    DsR = CTz0;D1..Dn IfErr(DsR) ER = DsR
    I1 = I[frommed=CTz0]
    Ii+1 = Ii[frommed=CTzi]
    Ii!Ki => KRi
    I[G=I.G,D1.x:D1.T,..,Dn.x:Dn.T]!e => ER'
    KR1..KRm,ER' = CTz1;K'1..CTz1;K'm, CTzm+1;e' IfErr(KR1..KRn,ER) ER = firstErr(KR1..KRn,ER)
    ER = CTzm+1;(D1...Dn K'1...K'm e')
_______
#define I!xs;HALF.e? => ER    I!HALF.D => DR    I!HALF.K => KR
* I!xs;empty => I.CTz;empty
* I!xs;var? mdf? STz x=e Ds => DsR
    I(mdf? STz) = CORE.T IfNotE(CORE.T) DsR = inferenceFailure(I,STz)
    I!e => ER 
    ER = CTz';e' IfErr(ER) DR = ER
    CORE.T' = CORE.T[mdf=imm] if mdf?=empty, CORE.T.mdf=read and 
      not exists x in FV(e') such that x in dom(I.G) and I.G(x).mdf in {read,lent,mut}
    CORE.T' = CORE.T[mdf=mut] if mdf?=empty, CORE.T.mdf=capsule and xs=_,x,_,x,_ //2+ usages
    CORE.T' = CORE.T otherwise
    I[G=I.G,x:CORE.T'; CTz=CTz']!Ds => DsR'
    DsR' = CTz;Ds IfErr(DsR') DsR = DsR'
    DsR = CTz;var? CORE.T' x=e',Ds

* I!catch throw STz x e => KR
    I(STz) = CORE.T IfNotE(CORE.T) inferenceFailure(I,STz)
    I[G=I.G,x:Core.T]!e => ER
    ER = CTz';e' IfErr(ER) KR = ER
    KR = CTz';catch throw CORE.T x e' //assert CORE.T.mdf=imm or throw=return
_______
#define adapt(p,CORE.e,T)
* adapt(p,e,imm Library) = e
* adapt(p,e,imm Void) = (imm Void x=e {}) where x fresh
* adapt(p,e,T) = (T x=e x.#toLibrary()) otherwise, where x fresh    
_______
#define CTz.add(p; CORE.MH FULL.e?; HAlf.e?) = CTz' // both CTz' and HALf.e? are computed by this notation
* CTz.add(p; MH empty; empty) = CTz
* CTz.add(p; MH e; Half.e) = CTz'+p STz<=MH.T
    Y = Y[p=p;GX=MH.G;onSlash=MH.T;onSlashX=empty;expectedT=MH.T;CTz]
    Y!e = Half.e; STz; _; CTz'
_______
#define CTz <+p STz<=STz' = CTz'    CTz <+p ST<=STz = CTz'
*CTz<+p STz<=STz' = CTz<+p ST1<=p.solve(STz')..<+p STn<=p.solve(STz')
   ST1..STn={ST| ST in p.solve(STz), ST not of form Core.T}

* CTz,ST<=STz <+p ST <=STz' = CTz,ST<=STz U STz'
    CTz <+p ST <=STz' = CTz,ST<= STz'
    CTz(ST) undefined
_______
#define collectDeps(p;CORE.MWT) = Ps;Ps'    collectDeps(p;CORE.T) = Ps;Ps'    collectDeps(p;Doc) = Ps;Ps'
//collectDeps(sequence)=union of the results of elements of the sequence
* collectDeps(p; Docs mdf method T0 m(T1 x1..Tn xn)[Ts] e?) =
    collectDeps(p; Docs) U collectDeps(p; T0..Tn,Ts) U collectDepsE(p; e?)

* collectDeps(p; T) = T.P;empty U collectDeps(p; T.Docs)
* collectDeps(p; Doc) = {P| @P._ inside Doc};empty
_______
#define collectDepsE(p;CORE.e?)= Ps1;Ps2    Ps[skipThis0;CORE.L] = Ps'
//collectDepsE(p;L) adds NCs dependencies and relies on cached Info
* collectDepsE(p;empty) = collectDepsE(p;x) = collectDepsE(p;void) = empty;empty
* collectDepsE(p;CORE.L) = Ps0..Psn[skipThis0;CORE.L];Ps'0..Ps'n[skipThis0;CORE.L]
    Ps0 = CORE.L.Info.typeDep
    Ps'0 = CORE.L.Info.coherent
    Ps1..Psn = {CORE.L(Cs).Info.typeDep[from This.Cs;p]| Cs in dom(CORE.L)}
    Ps'1..Ps'n = {CORE.L(Cs).Info.coherentDep[from This.Cs;p]| Cs in dom(CORE.L)}
* collectDepsE(p; e0.m( x1=e1 .. xn=en ) )= collectDepsE(p;e0) U..U collectDepsE(p;en) 
* collectDepsE(p;loop e)=collectDepsE(p;throw e)=collectDepsE(p;x :=e)=collectDepsE(p;e)
* collectDepsE(p;P<:class Any)= P;empty
* collectDepsE(p;P<:class P')= P',P;P
    P' != Any
* collectDepsE(p; (Ds Ks e) ) = collectDepsE(p;Ds) U collectDepsE(p;Ks) U collectDepsE(p;e)
* collectDepsE(p;var? T x=e) = collectDepsE(p;catch throw T x e) = collectDeps(T) U collectDepsE(p;e)

* empty[skipThis0;L]=empty;
* This0.Cs,Ps[skipThis0;L]=Ps[skipThis0;L]
  //Note:Cs notin dom(L) the code will give an error
  //Metaprogramming could not still add names in an L in a meth body
* Thisn+1.Cs,Ps[skipThis0;L]=Thisn.Cs,Ps[skipThis0;L]
_______
#define CTz.allSTz(ST) = STz    CTz.allTz(p,ST) = Tz
* ST in CTz.allSTz(p,ST)
* ST' in CTz.allSTz(p,ST) 
    ST1..STn = CTz(ST)
    ST' in CTz.allSTz(p,STi)
* ST' in CTz.allSTz(p,ST.s.i?)
    ST" in CTz.allSTz(ST)
    ST' in  CTz.allSTz(p.solve(ST".s.i?))
* ST' in CTz.allSTz(p,OP STz1..STzn)
    STi in STzi
    ST'i in CTz.allSTz(STi)
    ST' in  CTz.allSTz(p.solve(OP ST'1..ST'n))
//note:
    if S has 2 overloaded for + with both S->A and ToS->B, then
    [S, ToS] y=(S x=S"" catch error ToS y y x)
    [+[S][S],+[S][ToS]] z=myS+y //I.infers into [+[S][S],B] 
    +[S][S] DOES NOT solve/infer to A, since also ToS->B is applicable
    +[S][S] will stay dormient and harmless during I.infer 
   
* CTz.allTz(p,ST)={T | T in CTz.allST(p,ST)}

_______
#define I(mdf? STz) = CORE.T
* I(mdf STz) = I(STz)[mdf=mdf]
* I(STz)=chooseGeneralT(Tz) //assert p.solve(STz)=STz
    Tz={chooseSpecificT(I.CTz.allTz(I.p,ST)) | ST in STz }
_______
#define chooseGeneralT(CORE.Tz) = CORE.T    mostGeneralMdf(mdfz) = mdf     generalEnough(mdfz) = mdfs'
*chooseT(Tz) = mostGeneralMdf(Tz.mdfz) P
  {P} = {T.P| T in Tz and p|-Tz.Pz<=T.P}

* mostGeneralMdf(mdfz) = mdf //the most specific generalEnough.
    mdf in generalEnough(mdfz)
    forall mdf1 in generalEnough(mdfz): mdf <= mdf1

* generalEnough(mdfz) = {mdf | mdf not in {fwd%imm,fwd%mut}, forall mdf1 in mdfz, mdf1<=mdf}
_______
#define chooseSpecificT(CORE.Tz) = CORE.T    mostSpecificMdf(mdfz) = mdf     specificEnough(mdfz) = mdfs'
*chooseSpecificT(Tz) = mostSpecificMdf(Tz.mdfz) P
  {P} = {T.P| T in Tz and p|-T.P<=Tz.Pz}

* mostSpecificMdf(mdfz) = mdf //the most general specificEnough.
    mdf in specificEnough(mdfz)
    forall mdf1 in specificEnough(mdfz): mdf1 <= mdf

* specificEnough(mdfz) = {mdf | mdf not in {fwd%imm,fwd%mut}, forall mdf1 in mdfz, mdf<=mdf1}
_______
#define P.s.i in p.opOptions(OP, CORE.Ts) //note: now the special case for Path is 
* P.s.i in p.opOptions(OP, T0..Tn)        //handled with a 'non op dispatch' desugar
    i in 0..n,
    s = methName(OP_i)(x1..xn)//x1..xn are free variables on purpose
    P1 ... Pn = p(Ti.P)(s).pars.Ps[from Ti.P;p]
    P'1 ... P'n = (T0..Tn\i).Ps
    P = Ti.P
    p|-P'1<=P1 .. p|-P'1<=P1
_______
#define Info0+Info1 = Info
//#Flag+#norm = #norm; #Flag+#Flag = #Flag
//union of all the sets; preserve all boolean flags
