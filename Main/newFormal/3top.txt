_______
#define p ==>p'
* {reuse[URL] Ms};pTail ==> {followURL(URL),Ms};pTail  //(reuse)
* {... Ms};pTail ==> {readFolder(pTail),Ms};pTail //(dots)//note, ... is cached 
* {H CMs};pTail ==> flagTyped(norm({H CMs};pTail);pTail)  //(topNorm)
* p ==> flagTyped({H CMs pâ™¥Docs C=CORE.L Ms};pTail)  //(top)
    p={H CMs Docs C=CMP.e Ms};pTail
    CMP.e not of form CORE.L//e is the first point to execute
    CORE.e=norm(p,CMP.e)
    FV(CORE.e)=empty //not implied by typing: FV check capsules used 1 or 0
    Q=Q[Flag=norm;MH?=empty;p;G=empty;Ts=empty;Ps=Any]
    Q|- CORE.e :T
    coherentClasses(p,CORE.e) // ISAAC: did you mean coherent(p, CORE.e)?
    empty|adapt(CORE.e,T.P) -->p+ _|r
    // ISAAC: is the intention that the following should work?
    // 		{Foo = (Debug(S"Hello") Any x = {} x)}
    // Because based on this definition it does (it will produce {Foo={}}
    // If the intention is that it produces a type-error, and never prints "hello", (as I would expect), you should do a check here:
    // 	T.P in {Library, Void}, or Q |- (CORE.e).#toLibrary() : mdf Library

    CORE.L= refreshUniqueNames(r) //fails if r not of form CORE.L, lifted as compilation error
* {H CMs C=ctxC[LL] FULL.Ms};pTail ==> p.pop(1)   //(enter)
    LL not of form CORE.L
    LL;{H CMP.Ms C=ctxC FULL.Ms};pTail  ==>+  p //Note: p is one level deeper
    p(This0) of form CORE.L // p(This0) is the result of metaprogramming LL
_______
#define adapt(CMP.e,P)
* adapt(CMP.e, Library) = CMP.e
* adapt(CMP.e, Void) = (Void x=CMP.e {}); where x fresh
* adapt(CMP.e, _) = (T x=CMP.e x.#toLibrary()); otherwise, where x fresh
_______
#define flagTyped(p)=p'    LL[Csz=Flag]=LL'
* flagTyped(p) = p.update( p(This0)[typable(p)=typed] )
    forall Cs in typable(p):  |-p.navigate(This0.Cs)

* LL[Cs Csz = Flag]=LL[Cs.Info.Flag=Flag][Csz=Flag] // ISAAC: is LL[Cs.Info.Flag=Flag] defined anywhere? Or should I just use common sense to work out what it means?
* LL[empty=Flag]=LL
_______
#define typable(p)=Csz
* typable(p) = Cs1..Csn
    Cs1..Csn is the largest subset of dom(p(This0)) so that forall i:
    p(This0.Csi) of form CORE.L
    p(This0.Csi).Info.Flag=norm
    p(This0.Csi).depTyped subset {P| p(P).Info.Flag=typed} U This0.Cs1..This0.Csn
_______
#define coherent(p,CORE.e)    coherent(p)     coherent(p;MHs;MH;xz;n?)
* coherent(p,e)
    forall P<:class P' inside e: //assert p(P) and p(P') is CORE.L
    // ISAAC: what does the P<: thing mean?
      either P'=Any
      or coherent(p.navigate(P))

* coherent(p)
    CORE.L=p(This0)
    MHs={MH | MH in CORE.L.MWTs} //thus, abstract
    either CORE.L.interface?=interface
    or class not in MHs.mdfs//no abstract class method
		// ISAAC: the above is broken since "fwd" methods could still be called, e.g.
		// C={fwd imm method Void foo()}
		// X={class method X a(fwd imm C f) class method X b(fwd imm C f)=(f.foo(), a(f))}
		// Z=(X myX=X.b(f: myC) C myC=error void)
    or exists xz  and n? such that:
      forall MH in MHs, coherent(p;MHs;MH;xz;n?)
      
* coherent(p;_;class method T m::n?(T1 x1..Tn xn)_;xz;n?)
    x1..xn=xz
    p|-This0<=T.P
    mdfs=(T1..Tn).mdfs
    T.mdf not in {class, fwd mut, fwd imm}
    if T.mdf in {imm, capsule} then mdfs subseteq {imm, fwd imm, capsule, class}
    if read or lent in mdfs then T.mdf in {read, lent}
    if !trustedClass(p(This0)) then m is of form #$m // ISAAC: did you mean trusted?
    // ISAAC: I will check that this capability stuff is correct latter...
* coherent(p;MHs;mdf' method T m::n?(_)_;_;n?) //by well formedness if n is present is the same, but it may be absent.
    forall class method mdf _(_)_ in MHs:  !(mdf canAlsoBe mdf')
* coherent(p;_;mdf method T #?x::n?(mdf' P' that)_;_,x;n?)
	// ISAAC: why not allow multiple #'s?
    p |- imm Void <= T
    mdf' in {imm, mut, capsule, class}//that is not in {read, lent, fwd mut, fwd imm}
    mdf in {lent, mut}
    if mdf = lent then mdf' != mut
* coherent(p;_;capsule method T #?x::n?(_)_;_,x;n?)
    p |- imm Void <= T //capsule methods are guaranteed to trash the object anywhay...
    // So as long as we can synthesise a return value, the rest of the method is irrevelent
* coherent(p;MHs;mdf method mdf' P' #?x::n?()_;_,x;n?)
    mdf in {imm, mut, capsule, lent, read}//that is not in {class, fwd mut, fwd imm}
    forall P in fieldTypes(MHs, x, mdf).Ps:  p |- P <= P'
    coherentGetMdf(mdf',mdf,
      fieldTypes(MHs,x, mdf).mdfs,
      fieldAccessMdf(MHs,x, mdf))
_______
#define mdf canAlsoBe mdf'    fieldTypes(MHs, x, mdf)=Ts    fieldsAccessMdf(MHs, x, mdf)=mdfs    coherentGetMdf(/*value*/mdf0,/*getter*/mdf1,/*in*/mdfs0,/*out*/mdfs1)
* capsule canAlsoBe mdf, with mdf != class
* mut canAlsoBe mdf, with mdf != class
* lent canAlsoBe mdf, with mdf in {mut,lent, read, fwd mut}
* read canAlsoBe mdf, with mdf in {read,imm, fwd imm}
* imm canAlsoBe mdf, with mdf in {read,imm, fwd imm} //is ok that canAlsoBe is undefined on fwd _ and class
// Note that coherentGetMdf(mdf', _, {mdf, _}, _) implies mdf canAlsoBe mdf', but the converse does not hold (for example, lent canAlsoBe mut, but a lent field can never be read out as a mut.

* T in fieldTypes(MHs, x, mdf)
    either class method mdf' _(_ T x _)_ in MHs
    or mdf' method _ #?x::n?(T that)_ in MHs
    mdf' != capsule //capsule setters are dead code
    mdf' canAlsoBe mdf

* mdf" in fieldAccessMdf(MHs, x, mdf)
    mdf' method mdf" P #?x::n?() in MHs
    mdf' != capsule // We don't care about capsule getters, since another getter can never be called
    mdf' canAlsoBe mdf
    
    
// Note: coherentGetMdf(getterReturnMdf, receiverMdf, fieldTypeMdfs, fieldAccessMdfs)
// Means that the value of a field accesed on a receiverMdf reference can safetly be used as a getterReturnMdf, iff its value came from a fieldTypeMdfs reference (through either a factory or setter), and since then, its value may have previousesly been accesed as a fieldAccessMdfs reference.
* coherentGetMdf(class,_,{class},_)
* coherentGetMdf(read, _, mdfs0,_)
    class not in mdfs0
* coherentGetMdf(imm,imm, mdfs0,_)
    class not in mdfs0
* coherentGetMdf(imm,mdf,mdfs0,mdfs1)
    mdf!=imm
    mdfs0 subseteq {imm, fwd imm,capsule}
    {mut, lent} disjoint mdfs1
* coherentGetMdf(capsule,capsule,mdfs0,mdfs1)
    mdfs0 subseteq {mut, fwd mut, capsule}
    imm not in mdfs1
* coherentGetMdf(lent,mdf,mdfs0,mdfs1)
    mdfs0 subseteq {mut, fwd mut, capsule, lent}
    mdf in {lent, mut, capsule}
    imm not in mdfs1
* coherentGetMdf(mut,mdf,mdfs0,mdfs1)
    mdfs0 subseteq {mut, fwd mut, capsule}
    mdf in {mut, capsule}
    imm not in mdfs1
    
--------------------------END, examples only after this line
/*
class method lent This foo(lent X x, lent X y)
mut method lent X x() // ok?
mut method lent X y() // ok?
*/


lent X method evil(lent X x) = 
    foo(x).x()

    if we can have a lent collection of read objects
or anyway update a read field, we have -capsule visible as read
  lent list=.. //lent method add(read r)
  capsule a=..
  capsule a2=(mut b=a
   list.add(b)
   b)
  a2 and list usable
  
  {
  class method mut This (S x)
  class method imm This (N x)
  mut method S #x()
  read method Any x()
  //mut method x(N that) //enabling this method makes #x not valid for coherence
  }
  
