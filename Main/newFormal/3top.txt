_______
#define p ==>p'
* {reuse[URL] FULL.Ms};pTail ==> {followURL(URL),FULL.Ms};pTail  //(reuse)
* {... FULL.Ms};pTail ==> {readFolder(p),FULL.Ms};pTail //(dots)//consider caching ... to avoid a main writing to source an untrusted main with full capabilities powers
* {H CMs};pTail ==> normAndFlag({H CMs};pTail)  //(topNorm)
* LL;pTail ==> normAndFlag({H CMs C=CORE.L FULL.Ms};pTail)  //(top)
    LL={H CMs C=CMP.e FULL.Ms}
    CMP.e not of form CORE.L//e is the first point to execute
    Q=Q[Flag=norm;MH?=empty;p=(LL;pTail);G=empty;Ts=empty;Ps=dom(p)]
    FV(CMP.e)=empty //not implied by typing: FV check capsules used 1 or 0
    Q|- infer(p,CMP.e) :T
    coherentClasses(p,infer(p,CMP.e))
    empty|adapt(infer(LL;pTail,CMP.e),T.P) -->p+ _|r
    CORE.L= refreshUniqueNames(r) //fails if r not of form CORE.L, lifted as compilation error
* {H CMP.Ms C=ctxC[LL] FULL.Ms};pTail ==> p.pop(1)   //(enter)
    LL not of form CORE.L
    LL;{H CMP.Ms C=ctxC FULL.Ms};pTail  ==>+  p //Note: p is one level deeper
    p(This0) of form CORE.L // p(This0) is the result of metaprogramming LL
_______
#define adapt(CMP.e,P)
* adapt(CMP.e, Library)=CMP.e
* adapt(CMP.e, Void)=(Void x=CMP.e {}); where x fresh
* adapt(CMP.e, _)= (T x=CMP.e x.#toLibrary()); otherwise, where x fresh
_______
#define normAndFlag(FULL.L;pTail)-> CORE.L;pTail    LL[Csz=Flag]=LL'
    p'= p.update({H CMP.Ms C=CORE.L FULL.Ms}) if Ms not empty //can remove this if and will just call topNorm after... IDEAS?
    p'= p.update(norm(p,{H CMP.Ms C=CORE.L})) otherwise
    |- p' -> LL //type all the MCs that can be compiled now, including This0

* normAndFlag(LL;pTail)=LL'[Csz=typed];pTail
    LL'=norm(LL;pTail) if LL.Ms of form CMP.Ms
    LL'=LL otherwise
    typable(LL';pTail)=Csz
    forall Cs in Csz:  |-(LL';pTail).navigate(Cs)
   
* LL[Cs Csz = Flag]=LL[Cs.info.Flag=Flag][Csz=Flag]
* LL[empty=Flag]=LL
_______
#define typable(p)=Csz
* Cs1..Csn=typable(p)
    Cs1..Csn is the largest subset of dom(p(This0)) so that forall i:
    p(This0.Csi) of form CORE.L
    p(This0.Csi).info.Flag=norm
    p(This0.Csi).depTyped subset {P| p(P).info.Flag=typed} U This0.Cs1..This0.Csn
  defined only if forall Cs such that p(This0.Cs)=CORE.L: alive(p,CORE.L.info.dep.depTypes)
_______
#define coherent(p,CORE.e)    coherent(p)     coherent(p;MHs;MH;xz;n?)
* coherent(p,e)
    forall (class P' P) inside e: //assert p(P) and p(P') is CORE.L
      either P'=Any
      or coherent(p.navigate(P))

* coherent(p)
    p(This0).interface?=interface
* coherent(p)
    MHs={MH | MH in p(This0).MWTs} //thus, abstract
    either p(This0).interface?=interface
    or class not in MHs.mdfs//no abstract class method
    or exists xz  and n? such that:
      forall MH in MHs, coherent(p;MHs;MH;xz;n?)
* coherent(p;_;refine? class method T m::n?(T1 x1..Tn xn)_;xz;n?)
    x1..xn=xz
    p|-This0<=T.P
    T.mdf not in {class, fwd mut, fwd imm}
    lent _ not in T1..Tn
    if T.mdf in {imm, capsule} then {mut, fwd mut} disjoint (T1..Tn).mdfs
    if read _ in T1..Tn then T.mdf in {read, lent}
    if !trustedClass(p(This0)) then m is of form #$m
* coherent(p;MHs;refine? mdf method T m::n?(_)_;_;n?) //must 'n?' be the same for well formedness?
    mdf in {lent, mut, capsule}
    forall MH' in MHs: either MH'.mdf!=class
    or MH'.T.mdf not in {lent, mut, capsule}
* coherent(p;_;refine? mdf method T #?x::n?(mdf' P' that)_;_,x;n?)
    p |- imm Void <= T
    mdf' in {imm, mut, capsule, class}//that is not in {read, lent, fwd mut, fwd imm}
    mdf in {lent, mut, capsule}
    if mdf = lent then mdf' != mut
* coherent(p;MHs;refine? mdf method mdf' P' #?x::n?()_;_,x;n?)
    mdf != class
    forall P in fieldTypes(MHs, x, mdf).Ps:  p |- P <= P'
    coherentGetMdf(mdf',mdf,
      fieldTypes(MHs,x, mdf).mdfs,
      fieldAccessMdf(MHs,x, mdf))
_______
#define fieldTypes(MHs, x, mdf)=Ts    fieldsAccessMdf(MHs, x, mdf)=mdfs    coherentGetMdf(/*value*/mdf0,/*getter*/mdf1,/*in*/mdfs0,/*out*/mdfs1)
* T in fieldTypes(MHs, x, mdf)
    either class method mdf" _(_ T x _)_ in MHs
    or mdf" method _ #?x::n?(T that)_ in MHs
    if mdf in {lent, mut, capsule} then mdf" in {lent, mut, capsule}
    //TODO: wrong, if the 'setter' was a method allowed to be abstract because take a mut on imm only class

* mdf' in fieldAccessMdf(MHs, x, mdf)
    mdf" method mdf' P #?x::n?() in MHs
    mdf" != capsule
    if mdf in {lent, mut, capsule} then mdf" in {read, lent, mut, capsule}

* coherentGetMdf(imm,imm, mdfs0,_)
    class not in mdfs0
* coherentGetMdf(imm,mdf,mdfs0,mdfs1)
    mdf!=imm
    mdfs0 subseteq {imm, fwd imm,capsule}
    {mut, lent} disjoint mdfs1
* coherentGetMdf(read, _, mdfs0,_)
    class not in mdfs0
* coherentGetMdf(class,_,{class},_)
* coherentGetMdf(capsule,capsule,mdfs0,mdfs1)
    mdfs0 subseteq {mut, fwd mut, capsule}
    imm not in mdfs1
* coherentGetMdf(lent,mdf,mdfs0,_)
    mdfs0 subseteq {mut, fwd mut, capsule}//TODO: error, lent too? else never happens
    mdf in {lent, mut, capsule}
* coherentGetMdf(mut,mdf,mdfs0,_)
    mdfs0 subseteq {mut, fwd mut, capsule}
    mdf in {mut, capsule}
_______
#define alive(p;Ps)    alive(LL,Cs) //check if P is defined or has some hope of being defined in the future
* alive(p;empty)
* alive(p;Any,Ps)=alive(p;Void,Ps)=alive(p;Library,Ps)=alive(p;Ps)
* alive(p,Thisn.Cs,Ps)=alive(p(Thisn),Cs) and alive(p;Ps)

* alive(LL,Cs) if Cs in dom(LL)
* alive(LL,Cs._) if LL(Cs) not of form LL //implies Cs in dom(LL)

//WHEN AND HOW docs are checked so that the paths inside
//the docs are alive and not 'mispelled'?