
-----------------------------------------------------------
Part 1: 42 top level reduction rules
-----------------------------------------------------------
### reduction rules
ReductionTop:
precondition: at top level we have an L not of form LC.
Rule (top) performs a step of execution, while rule (enter)
propagates the execution inside nested classes and libraries in method bodies.

Flag::= norm |typed 
typed::=uncoherent | coherent

r::=LC| exception v | error v

NC::= Docs C = core(L;Flag;Ps1;Ps2)

(top)
p ==> p.update(p.top()[MCs'])
  where
  p.top()=_[Ps0]{MCs  C:e Ms}//MCs are already compiled
  e not of form core(L)//thus e is the first point to execute
  eC=normalize_p(e) //eC is core
  p|-eC:T
  eC -->p+ r //execute the expression under the program and obtain a result
  L=refreshUniqueNames(r) //may fail if r not of form L, and that would be lifted as compilation error.
  p|- MCs,C=core(L,Norm;collectDeps(L)) ->MCs'

(enter)
p ==> p'.pop()
  where
  p.push(ctxL, L)  ==>+  p'
  p.top()=interface?[Ps]{MCs C=e Ms}
  e not of form core(_)
  e=ctxC[L], L not of form LC
  ctxL=interface?[Ps]{MCs C=ctxC Ms}
  p'.top() of form LC //Note: p' is one level deeper than p,
  // and p'.top() is the LC result of metaprogramming L
 
 
 Need to define:
 normalize_p(e)
 p|-MCs->MCs'
 collectDeps(L)
 alive(p,P) to check for all P at the end of normalize
 //forall P inside MH e?, alive(p,P) //else error here
_______
#define normalize_p(FullE):HalfE
  normalize_p(core(L))=core(L)
  
  normalize_p(reuse [URL]{Ms})=normalize_p({NCs,Ms})
    with followURL(URL)={NCs} //all the NC of form Docs C=core(L)
  //thus, we can not save on an url an interface or method bodies. 
  //this is ok for towels, and for libs we have Load:reuse[URL]{} anyway
  
  normalize_p(LL)=interface?[Ts,(Ts'\p Ts)]{normalize_p'(Ms')}
    LL=interface?[Ts]{Ms0}
    p'=p.push(LL)
    Ts'=collect(p',Ts)
    Ms=expandFields(Ms0)
    forall T in Ts'\p Ps, p'.noUnique(T)
    Ms'=methods(p',This0)\Ms.ss, [methods(p',This0)(M.s)| M in Ms],[C:e| C:e in Ms]
    //the line above use [|] to make sequences nor sets. The order of members is important here.
    //Note: using Ts'\p Ts the docs of any T inside Ts override the one inside Ts'
    
  normalize_p(MH e?)= resolveCs_p(MH) e'?
    where e'?=empty if e?=empty
    otherwise e'?= normalize_p(empty,e?) 

  normalize_p(Docs C:LL) =resolveCs_p(Docs) C: normalize_p.push(C)(LL)
  //cases fields and s e should never happen at this point.

  normalize_p(xP?,e) //in the following:
  
  normalize_p(xP?,...)=readFolder(p)
  normalize_p(xP?,x)=x
  normalize_p(xP?,P)=P
  normalize_p(xP?,void)=void
  normalize_p(xP?,L)=normalize_p(L)
  normalize_p(xP?,B)=hard
  normalize_p(xP?, (T e) )=(T x=normalize_p(xP?,e) x)
  normalize_p(xP?,\)=\
  normalize_p(xP,\x)=xP.x()
  normalize_p(xP?,'PathLit)=normalize_p(xP?,\"PathLit")
  normalize_p(xP?,throw e)=throw normalize_p(xP?,e)
  normalize_p(xP?,loop e)=loop normalize_p(xP?,e)
  normalize_p(xP?,e StrLit)=
    normalize_p(xP?,e).#from(stringLiteral=(
      b=\.#stringLiteralBuilder()
      b.chars0() //one call for each char
      b.#spliceIn(normalize_p(xP?,e1)) //better name??
      b.chars1()
      ..
      b.#spliceIn(normalize_p(xP?,en)) //better name??
      b.charsn()
      b))
    with StrLit= chars0 e1 chars1 .. en charsn
  normalize_p(xP?,~e)=normalize_p(xP?,e).methName(~)()
  normalize_p(xP?,!e)=normalize_p(xP?,e).methName(!)()
  normalize_p(xP?, NumLit e)=normalize_p(xP?, e"NumLit")
  normalize_p(xP?,x updateOp e)=  x:= x toBinOp(updateOp) normalize_p(xP?,e)
  //x +=e == x:=x+e
  normalize_p(xP?, e(.m)?(par))=(x=normalize_p(xP?,e) x.methName(.m?)(normalize_p(x,par))
    if e not of form xP, with x fresh
  normalize_p(xP?, xP(.m)?(par))=normalize_p(xP,xP.methName(.m?)(normalize_p(xP,par))
 
 normalize_p(xP?,e[pars])= ( x=normalize_p(xP?,e) x[normalize_p(x,pars)])
    if e not of form xP, with x fresh
 normalize_p(xP?,xP[pars])= xP[normalize_p(xP,pars)]
 normalize_p(xP?,xP1 op .. op xPn)=xP1 op .. op xPn
 normalize_p(xP?,e1 op .. op en)=(x1=e'1 ..xn=e'n )
    [xP|x=e in x1=e1,..,xn=en, xP in]
    e'1..e'k=[e| e in e1..en, e not of form xP]
    if k!=0, with x1..xn fresh//TOO BORING!!! EASY IN CODE...
 
 | ( Ds Ks Wops? Ds2 e? )  
 | { Ds Ks Wops? Ds2 }
 | if tMatchC* e0? e1 (else e2)? //either tMatchC is empty or e0 is empty
 | while e1 e2
 | for DXes e  
 
 normalize_p(xP,e? xes)=   that=normalize_p(xP,e?) normalize_p(xP,xes)
 normalize_p(xP,x=e)=   x=normalize_p(xP,e)
 
H  ::= interface? [T+]? | reuse [URL]
LL  ::= H{M*}
M  ::= NC | MWT | MI | F 
NC ::= Doc* C = e
MWT::= MH (= e)?
MI ::= s  = e
F  ::= var? T x

 
 
_______
#define collectDeps(L) //core L 
collectDeps(interface?[Ts]{MWT1...MWTn1 NCs})=Ts;empty U collectDeps(MWT1) U .. U collectDeps(MWTn)
collectDeps(C=_)=empty;empty
collectDeps(T f)=T;empty
collectDeps(refine? native[P]? mdf method T0 mOp(T1 x1 ..Tn xn) [Ts] = e?)
= P?,T0..Tn, Ts;empty U collectDepsE(e?)
//what about Docs 

collectDepsE(x)=collectDepsE(void)=empty;empty
collectDepsE(L)=collectDeps(L) U Ps11..Ps1n; Ps21..Ps2n 
  L=interface?[Ts]{MWTs NC1..NCn}
  NCi=core(Li;Flagi;Ps1i;Ps2i)
collectDepsE( (P e0).m( x1=e1 .. xn=en ) )=P U collectDepsE(e0) U..U collectDepsE(en) 
collectDepsE(loop e)=collectDepsE(throw e)=collectDepsE(x :=e)=collectDepsE(e)
collectDepsE((Any P))= P;empty
collectDepsE((P' P))= P',P;P
  where P'!=Any
collectDepsE( (Ds Ks e) ) =collectDepsE(Ds) U collectDepsE(Ks) U collectDepsE(e)
collectDepsE(var? T x=e)=collectDepsE(catch throw T x e)= T;empty U collectDepsE(e)

