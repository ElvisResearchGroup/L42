------------------------------------
Part 1: 42 top level reduction rules
------------------------------------


(reuse)
p ==> p.update(H{followURL(URL),Ms})
  where p.top()=H{reuse [URL] Ms}

(dots)
p ==> p.update(H{readFolder(p),Ms})
    p.top()=H{... Ms}

(topNorm)
p ==> p.update(CORE.L)
  where
  p.top()=H{MCs}=FULL.L //note, all M are of form MC
  |- p.update(p♥FULL.L) -> CORE.L

(top)
p ==> p.update(LL)
  where
  p.top()=H{MCs C=eC Ms}//MCs are already compiled
  eC not of form CORE.L//thus e is the first point to execute
  Y= p;empty,Library,error //Y[p=p,?xP=empty,T?=Library,PType=error]
  p|- Y♥eC :T
  cX(eC)=empty
  adapt(Y♥eC,T.P) -->p+ r //execute the expression under the program and obtain a result
  CORE.L= refreshUniqueNames(r) //may fail if r not of form CORE.L, and that would be lifted as compilation error.
  p'= p.update(H{MCs C=CORE.L Ms}) if Ms not empty //can remove this if and will just call topNorm after... IDEAS?
  p'= p.update(p♥H{MCs C=CORE.L}) otherwise
  |- p' -> LL //type all the MCs that can be compiled now, including This0

(enter)
p ==> p'.pop()
  where
  p.top() = H{MCs C=ctxC[LL] Ms}
  LL not of form CORE.L
  p.push(H{MCs C=ctxC Ms}, L)  ==>+  p' //Note: p' is one level deeper than p
  p'.top() of form CORE.L // and p'.top() is the result of metaprogramming LL
_______
#define adapt(eC,P)
adapt(eC, Library)=eC
adapt(eC, Void)=(Void x=eC {}); where x fresh
adapt(eC, _)= (T x=eC x.#toLibrary()); otherwise, where x fresh

-------------------------------------
Part 2: typing driven by dependencies
-------------------------------------
_______
#define collectDeps(CORE.L)  //we do not collect dependencies from docs
collectDeps(interface?[Ts]{MWT1...MWTn1 NCs})=Ts;empty U collectDeps(MWT1) U .. U collectDeps(MWTn)
collectDeps(C=_)=empty;empty
collectDeps(T f)=T;empty
collectDeps(Docs refine? native[URL]? mdf method T0 mOp(T1 x1 ..Tn xn)[Ts] = e?)
  =T0..Tn, Ts;empty U collectDepsE(e?)

collectDepsE(x)=collectDepsE(void)=empty;empty
collectDepsE(L)=collectDeps(L) U Ps11..Ps1n; Ps21..Ps2n 
  L=interface?[Ts]{MWTs NC1..NCn}
  NCi=core(Li;Flagi;Ps1i;Ps2i)
collectDepsE( (P e0).m( x1=e1 .. xn=en ) )=P U collectDepsE(e0) U..U collectDepsE(en) 
collectDepsE(loop e)=collectDepsE(throw e)=collectDepsE(x :=e)=collectDepsE(e)
collectDepsE((class Any P))= P;empty
collectDepsE((class P' P))= P',P;P
  where P'!=Any
collectDepsE( (Ds Ks e) ) =collectDepsE(Ds) U collectDepsE(Ks) U collectDepsE(e)
collectDepsE(var? T x=e)=collectDepsE(catch throw T x e)= T;empty U collectDepsE(e)
collectDepsE(T x=e)=T;empty U collectDepsE(e)
_______
#define P in typed(p) iff p(P).info.Flag=typed
_______
#define P in coherent(p) iff p(P).info.Flag=coherent
_______
#define typable(p)=Csz
Cs1..Csn=typable(p)
  is the largest subset of dom(p.top()) so that forall i:
    p(This0.Csi) of form CORE.L
    p(This0.Csi).info.Flag=norm
    p(This0.Csi).depTyped subset typed(p) U This0.Cs1..This0.Csn
  defined only if forall CORE.L in {p.top()(Cs) : Cs in dom(p.top())}:
    forall P in CORE.L.info.depTypes:
      alive(p,P) //else compile time error here
_______
#define typableCoherent(p)=Csz
Cs1..Csn=typableCoherent(p,p.top())
  is the largest subset of dom(p.top()) so that forall i:
    p(This0.Csi) of form CORE.L
    p(This0.Csi).Flag=empty
    p(This0.Csi).depCoherent subset coherent(p) U This0.Cs1..This0.Csn 
_______
#define LL[Csz=Flag]=LL'
LL[Cs Csz = Flag]=LL[Cs.info.Flag=Flag][Csz=Flag]
LL[Csz=Flag]=LL
  where dom(LL) not in Csz
_______
#define |- p -> CORE.L'
  |-p -> p.top()[Csz=empty][Csz'=coherent] //are we sure we want to use empty to mean 'justTyped'
    where
    typable(p)=Csz
    forall Cs in Csz:
      if p.top()(Cs)=CORE.L
      then p.navigate(Cs)|-p.top()(Cs) : OK
    Csz'=typableCoherent(p.update(p.top()[Csz=empty])))
    
//WHEN AND HOW docs are checked so that the paths inside
//the docs are alive and not 'mispelled'?
// alive(p,P) to check for all P at the end of normalize ??
//forall P inside MH e?, alive(p,P) //else error here 
_______
#define alive(p,P) //check if P is defined or has some hope of being defined in the future
alive(p,Any),alive(p,Void),alive(p,Library) holds
alive(p,Thisn.Cs)=alive(p(Thisn),Cs) 
alive(CORE.L,Cs)= Cs in dom(CORE.L)
alive(FULL.L,Cs)=
  if FULL.L(C)=LL and alive(LL,Cs)
  or FULL.L(C)=e, e not of form LL
  