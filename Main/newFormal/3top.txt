
-----------------------------------------------------------
Part 1: 42 top level reduction rules
-----------------------------------------------------------
### reduction rules
ReductionTop:
precondition: at top level we have an L not of form LC.
Rule (top) performs a step of execution, while rule (enter)
propagates the execution inside nested classes and libraries in method bodies.

Flag::= norm |typed 
typed::=uncoherent | coherent

r::=LC| exception v | error v

NC::= Docs C = core(L;Flag;Ps1;Ps2)

(top)
p ==> p.update(p.top()[MCs'])
  where
  p.top()=_[Ps0]{MCs  C:e Ms}//MCs are already compiled
  e not of form core(L)//thus e is the first point to execute
  eC=normalize(p,e) //eC is core
  p|-eC:T
  eC -->p+ r //execute the expression under the program and obtain a result
  L=refreshUniqueNames(r) //may fail if r not of form L, and that would be lifted as compilation error.
  p|- MCs,C=core(L,Norm;collectDeps(L)) ->MCs'

(enter)
p ==> p'.pop()
  where
  p.push(ctxL, L)  ==>+  p'
  p.top()=interface?[Ps]{MCs C=e Ms}
  e not of form core(_)
  e=ctxC[L], L not of form LC
  ctxL=interface?[Ps]{MCs C=ctxC Ms}
  p'.top() of form LC //Note: p' is one level deeper than p,
  // and p'.top() is the LC result of metaprogramming L
 
 
 Need to define:
 Y::=p;xP?;T?
 normalize(Y,e) normalize(p,e)
 p|-MCs->MCs'
 collectDeps(L)
 alive(p,P) to check for all P at the end of normalize
 //forall P inside MH e?, alive(p,P) //else error here
_______
#define normalize(p,FullE):HalfE
  normalize(Y,core(L))=core(L)
  
  normalize(p,reuse [URL]{Ms})=normalize(p,{NCs,Ms})
    with followURL(URL)={NCs} //all the NC of form Docs C=core(L)
  //thus, we can not save on an url an interface or method bodies. 
  //this is ok for towels, and for libs we have Load:reuse[URL]{} anyway
  
  normalize(p,LL)=interface?[Ts,(Ts'\p Ts)]{normalize_p'(Ms')}
    LL=interface?[Ts]{Ms0}
    p'=p.push(LL)
    Ts'=collect(p',Ts)
    Ms=expandFields(Ms0)
    forall T in Ts'\p Ps, p'.noUnique(T)
    Ms'=methods(p',This0)\Ms.ss, [methods(p',This0)(M.s)| M in Ms],[C:e| C:e in Ms]
    //the line above use [|] to make sequences nor sets. The order of members is important here.
    //Note: using Ts'\p Ts the docs of any T inside Ts override the one inside Ts'
    
  normalize(p,MH e?)= resolveCs_p(MH) e'?
    where e'?=empty if e?=empty
    otherwise e'?= normalize(p,empty,e?) 

  normalize(p,Docs C:LL) =resolveCs_p(Docs) C: normalize_p.push(C)(LL)
  //cases fields and s e should never happen at this point.

  normalize(Y,e) //in the following:
  
  normalize(Y,...)=readFolder(p)
  normalize(Y,x)=x
  normalize(Y,P)=P
  normalize(Y,void)=void
  normalize(Y,L)=normalize(p,L)
  normalize(Y,B)=hard
  normalize(Y, (T e) )=(T x=normalize(Y[T=T],e) x)
  normalize(Y,\)=\
  normalize(p,xP,\x)=xP.x()
  normalize(Y,'PathLit)=normalize(Y,\"PathLit")
  normalize(Y,throw e)=throw normalize(Y,e)
  normalize(Y,loop e)=loop normalize(Y,e)
  normalize(Y,e StrLit)=
    normalize(Y,e).#from(stringLiteral=(
      b=\.#stringLiteralBuilder()
      b.chars0() //one call for each char
      b.#spliceIn(normalize(Y,e1)) //better name??
      b.chars1()
      ..
      b.#spliceIn(normalize(Y,en)) //better name??
      b.charsn()
      b))
    with StrLit= chars0 e1 chars1 .. en charsn
  normalize(Y,~e)=normalize(Y,e).methName(~)()
  normalize(Y,!e)=normalize(Y,e).methName(!)()
  normalize(Y, NumLit e)=normalize(Y, e"NumLit")
  normalize(Y,x updateOp e)=  x:= x toBinOp(updateOp) normalize(Y,e)
  //x +=e == x:=x+e
  normalize(Y, e(.m)?(par))=(x=normalize(Y,e) x.methName(.m?)(normalize(Y[xP=x,T=\],par))
    if e not of form xP, with x fresh
  normalize(Y, xP(.m)?(par))=normalize(p,xP,xP.methName(.m?)(normalize(Y[xP=x,T=\],par))
 
 normalize(Y,e[pars])= normalize(Y,(x=e x[par1;..;parn]) )
    if e not of form xP, with x fresh
 normalize(Y,xP[pars])= 
   xP.#from(squareBuilder:(
     b=\.#squareBuilder()
     if xP.#shortCircutPass() (     
       b.add(par1) //ok no #, it is a builder, 
       ..
       b.add(parn)
       )
     b))
   
 normalize(Y,xP1 op .. op xPn)=xP1 op .. op xPn
 normalize(Y,e1 op .. op en)=(x1=e'1 ..xn=e'n e1 op .. op en[x1..xk/e'1..e'k])
    if k!=0, with x1..xk fresh//e[xs=es] is boring, but easy in code
 
 normalize(Y,( DEs Ks Wops? DEs2))=normalize(Y,(DEs Ks Wops? DEs2 void))
 normalize(Y,( DEs Ks Wops? DE DEs2 e))=normalize(Y,( DEs Ks Wops? (DE DEs2 e)))
 normalize(Y,( DEs Ks wops T1.nTn e)=
   ( normalize(Y,DEs) normalize(Y,Ks) K1..Kn normalize(Y,e) ) 
   Ki=catch exception Ti xi error xi.#intoErrorAt(that:core({}))
   
 normalize(Y,DEs)
 normalize(Y,e)= void x= normalize(Y[T=empty],e), with x fresh
 normalize(Y,T _=e)= T x= normalize(Y[T=T],e), with x fresh
 normalize(Y,T%%% _=e) =%%%%
 normalize(Y,var T? = e)=var T? = normalize(Y[T=T?],e)
 normalize(Y,T?(var1? T1? x1.. varn?Tn? xn)=e)
   =T? x=e
    var1? T1? x1=x.methNameTrim(x1)() //removes any numberPedex from the end
    ..
    varn? Tn? xn=x.methNameTrim(xn)()
  with x fresh.
 
 normalize(Y,{ DEs Ks Wops? DEs2 }) = (Y.T x=(
   Void x''=normalize(Y[T=Void],(DEs Ks Wops? DEs2 void))
   catch return Y.T x' x'
   error void//unreachable thanks to {return} well formedness   
   )
   x)
   with x,x',x'' fresh
 
 normalize(Y,if e0 e1)=normalize(Y,if e0 e1 else void)
 normalize(Y,if e0 e1 else e2)= (
   x=normalize(Y,e0)
   (x.#checkTrue()
   catch exception Void x' normalize(Y,e2)
   normalize(Y,e1) 
   )) 
   with x, x' fresh
%%%still missing the tMatch cases | if tMatchC* e0? e1 (else e2)? //either tMatchC is empty or e0 is empty
 normalize(Y,while e0 e1)=
   normalize(Y,(loop( (e0.#checkTrue() e1) ) catch exception Void _ void))
   //better if I use normalize inside
   
 normalize(Y,for DXes e)
 | for DXes e  

 
 normalize(Y,e? xes)=   that=normalize(Y,e?) normalize(Y,xes)
 normalize(Y,x=e)=   x=normalize(Y,e)
 
H  ::= interface? [T+]? | reuse [URL]
LL  ::= H{M*}
M  ::= NC | MWT | MI | F 
NC ::= Doc* C = e
MWT::= MH (= e)?
MI ::= s  = e
F  ::= var? T x

 
 
_______
#define collectDeps(L) //core L 
collectDeps(interface?[Ts]{MWT1...MWTn1 NCs})=Ts;empty U collectDeps(MWT1) U .. U collectDeps(MWTn)
collectDeps(C=_)=empty;empty
collectDeps(T f)=T;empty
collectDeps(refine? native[P]? mdf method T0 mOp(T1 x1 ..Tn xn) [Ts] = e?)
= P?,T0..Tn, Ts;empty U collectDepsE(e?)
//what about Docs 

collectDepsE(x)=collectDepsE(void)=empty;empty
collectDepsE(L)=collectDeps(L) U Ps11..Ps1n; Ps21..Ps2n 
  L=interface?[Ts]{MWTs NC1..NCn}
  NCi=core(Li;Flagi;Ps1i;Ps2i)
collectDepsE( (P e0).m( x1=e1 .. xn=en ) )=P U collectDepsE(e0) U..U collectDepsE(en) 
collectDepsE(loop e)=collectDepsE(throw e)=collectDepsE(x :=e)=collectDepsE(e)
collectDepsE((Any P))= P;empty
collectDepsE((P' P))= P',P;P
  where P'!=Any
collectDepsE( (Ds Ks e) ) =collectDepsE(Ds) U collectDepsE(Ks) U collectDepsE(e)
collectDepsE(var? T x=e)=collectDepsE(catch throw T x e)= T;empty U collectDepsE(e)

