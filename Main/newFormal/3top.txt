
-----------------------------------------------------------
Part 1: 42 top level reduction rules
-----------------------------------------------------------
### reduction rules
ReductionTop:
precondition: at top level we have an L not of form LC.
Rule (top) performs a step of execution, while rule (enter)
propagates the execution inside nested classes and libraries in method bodies.

Flag::= norm |typed 
typed::=uncoherent | coherent

r::=LC| exception v | error v

NC::= Docs C = core(L;Flag;Ps1;Ps2)

(top)
p ==> p.update(p.top()[MCs'])
  where
  p.top()=_[Ps0]{MCs  C:e Ms}//MCs are already compiled
  e not of form core(L)//thus e is the first point to execute
  eC=normalize_p(e) //eC is core
  p|-eC:T
  eC -->p+ r //execute the expression under the program and obtain a result
  L=refreshUniqueNames(r) //may fail if r not of form L, and that would be lifted as compilation error.
  p|- MCs,C=core(L,Norm;collectDeps(L)) ->MCs'

(enter)
p ==> p'.pop()
  where
  p.push(ctxL, L)  ==>+  p'
  p.top()=interface?[Ps]{MCs C=e Ms}
  e not of form core(_)
  e=ctxC[L], L not of form LC
  ctxL=interface?[Ps]{MCs C=ctxC Ms}
  p'.top() of form LC //Note: p' is one level deeper than p,
  // and p'.top() is the LC result of metaprogramming L
 
 
 normalize_p(e)
 p|-MCs->MCs'
 collectDeps(L)
 
 
_______
#define collectDeps(L) //core L 
collectDeps(interface?[Ts]{MWT1...MWTn1 NCs})=Ts;empty U collectDeps(MWT1) U .. U collectDeps(MWTn)
collectDeps(C=_)=empty;empty
collectDeps(T f)=T;empty
 
 
 
 
 
 
 
 
_______
#define C.Dep
  C.(Cs=Flag;Ps1;Ps2) =  C.Cs=Flag;Ps1[from This1];Ps2[from This1]


no more
{
method m(){ A= {..} B=A()} //was requiring to compile code in method bodies, like subtraits
}
now the worst is
{
A={..}
B=A()+{ C=A()+{C ...} D=C()}
}

top
|-empty;{A={..},B} --> A=typed;{A=core(L), B}
enter
|-A=typed;{A=core(L), B} -> ...A=typed, B
because 
top1
A=typed|-empty;{ C=A()+{C ...} D=C()}{A=coreL(),B=A()+[]} --> C=typed;{ C={C ...} D:C()}{A=coreL(),B=A()+[]}
top2
A=typed|-C=typed;{ C={C ...} D:C()}{A=coreL(),B=A()+[]} -->C=typed, D=typed;{ C={C ...} D:{}}{A=coreL(),B=A()+[]}


OK
{
A:Trait:{ B f }
B:Class:{ ...}
}

KO
{
MyCode:{A:Trait:{ B f }}
B:Class:{ ...}
}
