
-----------------------------------------------------------
Part 1: 42 top level reduction rules
-----------------------------------------------------------
### reduction rules
ReductionTop:
precondition: at top level we have an L not of form LC.
Rule (top) performs a step of execution, while rule (enter)
propagates the execution inside nested classes and libraries in method bodies.


r::=LC| exception v | error v

(top)
p ==> p.update(p.top()[MCs'])
  where
  p.top()=_[Ps0]{MCs  C:e Ms}//MCs are already compiled
  e not of form core(L)//thus e is the first point to execute
  eC=normalize(Y[p=p,?xP=empty,T?=Library,PType=error],e) //eC is core
  p|-eC:T
  eC'=eC if T.P=Library
  eC'= (Void x=eC {}) if T.P=Void, with x fresh
  eC'=(T x=eC x.#toLibrary()) otherwise, with x fresh
  eC' -->p+ r //execute the expression under the program and obtain a result
  CORE.L=refreshUniqueNames(r) //may fail if r not of form L, and that would be lifted as compilation error.
  p|- MCs,C=CORE.L -> MCs' //type all the MCs that can be compiled now

(enter)
p ==> p'.pop()
  where
  p.push(ctxL, L)  ==>+  p'
  p.top() = H{MCs C=e Ms}
  e not of form core(_)
  e = ctxC[L], L not of form LC
  ctxL = H{MCs C=ctxC Ms}
  p'.top() of form LC //Note: p' is one level deeper than p,
  // and p'.top() is the LC result of metaprogramming L
 
 
 Need to define:
 normalize(Y,e) normalize(p,e)
 p|-MCs->MCs' //this needs to fail if we discover a Path is not alive any more
 collectDeps(L)
 alive(p,P) to check for all P at the end of normalize
 //forall P inside MH e?, alive(p,P) //else error here 
 
_______
#define collectDeps(CORE.L) 
collectDeps(interface?[Ts]{MWT1...MWTn1 NCs})=Ts;empty U collectDeps(MWT1) U .. U collectDeps(MWTn)
collectDeps(C=_)=empty;empty
collectDeps(T f)=T;empty
collectDeps(Docs refine? native[URL]? mdf method T0 mOp(T1 x1 ..Tn xn)[Ts] = e?)
  =T0..Tn, Ts;empty U collectDepsE(e?)
//we do not collect dependencies from docs.

collectDepsE(x)=collectDepsE(void)=empty;empty
collectDepsE(L)=collectDeps(L) U Ps11..Ps1n; Ps21..Ps2n 
  L=interface?[Ts]{MWTs NC1..NCn}
  NCi=core(Li;Flagi;Ps1i;Ps2i)
collectDepsE( (P e0).m( x1=e1 .. xn=en ) )=P U collectDepsE(e0) U..U collectDepsE(en) 
collectDepsE(loop e)=collectDepsE(throw e)=collectDepsE(x :=e)=collectDepsE(e)
collectDepsE((class Any P))= P;empty
collectDepsE((class P' P))= P',P;P
  where P'!=Any
collectDepsE( (Ds Ks e) ) =collectDepsE(Ds) U collectDepsE(Ks) U collectDepsE(e)
collectDepsE(var? T x=e)=collectDepsE(catch throw T x e)= T;empty U collectDepsE(e)
collectDepsE(T x=e)=T;empty U collectDepsE(e)