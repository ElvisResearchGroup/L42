_______
#define metanotation IfNotE, IfErr, IfUndefined 
//note: the simpler interpretation (predicate0 and predicates) or predicate1
//would technically allow free variables in predicate0 to be chosen to falsify it
// Note: the "predicates" include those on subsequent (similarlly indented) lines!
* predicate0 IfNotE(Xs) predicate1 predicates == (predicate0 and predicates) or ((not exists Xs such that predicate0) and predicate1)
* predicate0 IfErr(Xs) predicate1 predicates == (predicate0 and predicates) or (Err in Xs  and predicate1)
* predicate0 IfUndefined predicate1 predicates == (predicate0 and predicates) or (predicate0 undefined and predicate1)
_______
#define firstErr(Rs) = Err
* firstErr(Rs,Err,_) = Err
    Err not in Rs
_______
#define STz notations:
* (ST1 .. STn).s(.i)? = ST1.s(.i)? .. STn.s(.i)?
* (ST1 .. STn)<=HALF.T = ST1<=HALF.T .. STn<=HALF.T
_______
#define top(CTz,p) => PR    topNC(CTz;p;Cs) => PR    sortHeader(p) = p'    sortM(p) = p'    addInfo(p) = p'   
* top(CTz,p) => PR
    p0 = sortHeader(p) IfNotE(p0) PR = headerErr(p)
    MWT1..MWTn, NCs=sortMs(p0) IfNotE(MWT1..MWTn, NCs) PR = implementsErr(p1)
    CTz.add(p0; MWT1; e?1).. .add(p0; MWTn; e?n) = CTz1
    p1=p0.update(p0(This0)[Ms=MWT1,...,MWTn, NCs])
    topNC(CTz1,p1,NCs.Cs) => PR1
    PR1 = CTz2; p2 IfErr(PR1) PR = PR1
    I[C=empty;p2;G=empty;p2.minimize(CTz2)]!e?i => ERi  for i in 1..n
    ER1 = _;e?'1 .. ERn = _;e?'n IfErr(ER1..ERn) PR = firstErr(ER1..ERn) //novel cczs are not captured since no Full.L in e?s
    p3 = p2.update(p2(This0)[MWT1[e?=e?'1]..MWTn[e?=e?'n]])
    p4=flagTyped(addInfo(p3)) IfNotE(p4) PR=illTyped(p3)
    PR = CTz2; p4

* topNC(CTz;p;empty) =>CTz;p
* topNC(CTz;p;C,Cs) => PR
    Y = Y[p;GX=empty;onSlash=imm Library;onSlashX=empty;expectedT=imm Library; onPath=class]
    Y!p(This0)(C) = Half.e; _; _; _
    I[C?=C;p;G=empty;p.minimize(CTz)]!Half.e => ER
    ER = CTz1;CORE.e IfErr(ER) PR = ER
    wellTyped(p,CORE.e) = T IfNotE(T) PR = illTyped(p)
    coherent(p,adapt(CORE.e,T)) IfUndefined PR = incoherent(p)
    reduce(p,empty,adapt(CORE.e,T)) => ER'
    ER' = empty;CORE.L IfErr(ER') PR = ER'
    p' = p.update(p(This0)[C=refreshUniqueNames(CORE.L)])
    flagTyped(p') = p" IfNotE(p") PR = illTyped(p')    
    topNC(CTz1;p";Cs) => PR
    
* sortHeader({reuse[URL] Ms};pTail) = sortHeader({followURL(URL),Ms};pTail) //note, the result must be well formed
* sortHeader({... Ms};pTail) = sortHeader({readFolder(pTail),Ms};pTail) //note, the result must be well formed
* sortHeader({interface? [Ts] Ms};pTail) = {interface? [Ts'],Ms};pTail
    Ts0=p♥Ts
    Ts'=Ts0,(collect(p,Ts0)\Ts0)//gets the transitively implemented interfaces -Any    
    forall imm P in Ts'\Ts0, P not of form Thisk._.C::n._//private interfaces not added

* sortMs(p) = MWTs\ss,[MWTs(s)| s in ss],[NC[Docs=p♥NC.Docs]| NC in p(This0).Ms] //[ ..|..] is like {..|..} but produces a list
    MWTs = methods(p,This0) //all methods
    ss = expandFields(p(This0).Ms).ss //present methods, also including the expanded fields methods

* addInfo(p)={interface? Ts MWTs NCs Info};pTail
    p={interface? Ts MWTs NCs};pTail
    Ps;Ps'=collectDeps(p;Ts) U collectDeps(p;MWTs) U collectDeps(NCs.Docss) //where (Ps0; Ps0') U (Ps1; Ps1') = Ps0, Ps1; Ps0', Ps1'
    Info=#norm{typeDep=Ps,coherentDep=Ps',friendsDep= ??Ps,usedMethDep=??(P.s)s,privateImpl=??Ps}
    //TODO: either here we make all P.#from(stringLiteral=..) and P.m(squareBuilder=..)
    //with no free variables into class methods or in the execution we optimize as 
    //class methods all subexpressions with no free var (and not calling #$s)
_______
#define I!HALF.e? => ER
* I!empty => I.CTz;empty
* I!x => I.CTz;;x
* I!P<:STz => I.CTz;;P<:I(STz)
* I!P<:STz => inferenceFailure(I,STz)
    I(STz) undefined
* I!void => I.CTz;void
* I!FULL.L => ER //undefined if I.C?=empty 
    p=I.p.push(I.C?,FULL.L) 
    top(I.CTz[from This1;p],p) => PR
    PR = CTz';p' IfErr(PR) ER = PR
    ER = CTz'[from This0.(I.C?);p'];p'(This0)//could be optimized since similar to I.CTz
* I!CORE.L => I.CTz;CORE.L //no useful ccz could be here (assuming no CORE.L in the source)
* I!%STz% => I.CTz;I(STz).P
* I!%STz% => inferenceFailure(I,STz)
    I(STz) undefined
* I!e0.m(x1=e1..xn=en) => ER
    I!ei=ERi //e0 is of form xP
    ER0..ERn = CTz0;e'0..CTzn;e'n IfErr(ER0..ERn) ER = firstErr(ER0..ERn)
    ER = CTz0 U..U CTzn;e'0.m(x1=e'1..xn=e'n)
* I!xP0 OP..OP xPn => ER
    I!xPi => ERi
    ER0..ERn = CTz0;xP'0..CTzn;xP'n IfErr(ER0..ERn) ER = firstErr(ER0..ERn)
    Ti = T'i if xP'i = Pi < T'i
    Ti = I.G(x'i) if xP'i = x'i
    {P.m(x1..xn).i}=I.p.opOptions(OP, T0..Tn)
    xP"1..xP"n=xP'0..xP'n\i
    ER = CTz0 U..U CTzn;xP'i.m(x1=xP"1..xn=xP"n)
* I!e0 => ER
    e0 in {throw e, loop e, x:=e}
    I!e => ER'
    ER' = CTz;e' IfErr(ER') ER = ER'
    ER = CTz;e0[e=e']
* I!(Ds K1..Km e) => ER
    xs = FV((Ds K1..Km e))//formally, FV is defined only on CORE.e. Not sure how to handle this
    I!xs;Ds => DsR
    I!Ki => KRi
    DsR = CTz0;D1..Dn IfErr(DsR) ER = DsR
    I[G=I.G,D1.x:D1.T,..,Dn.x:Dn.T]!e => ER'
    KR1..KRn,ER' = CTz1;K'1..CTzm;K'm, CTzm+1;e' IfErr(KR1..KRn,ER) ER = firstErr(KR1..KRn,ER)
    ER = CTz0 U..U CTzm+1;(D1...Dn K'1...K'm e')
_______
#define I!xs;HALF.e? => ER    I!HALF.D => DR    I!HALF.K => KR
* I!xs;empty => I.CTz;empty
* I!xs;var? HALF.T x=e Ds => DsR
    I(HALF.T) = CORE.T IfNotE(CORE.T) DsR = inferenceFailure(I,HALF.T)
    I!e => ER 
    ER = CTz';e' IfErr(ER) DR = ER
    CORE.T' = CORE.T[mdf=imm] if HALF.T=STz, CORE.T.mdf=read and 
      not exists x in FV(e') such that x in dom(I.G) and I.G(x).mdf in {read,lent,mut}
    CORE.T' = CORE.T[mdf=mut] if HALF.T=STz, CORE.T.mdf=capsule and xs=_,x,_,x,_ //2+ usages
    CORE.T' = CORE.T otherwise
    I[G=I.G,x:CORE.T'; CTz=CTz']!Ds => DsR'
    DsR' = CTz;Ds IfErr(DsR') DsR = DsR'
    DsR = CTz;var? CORE.T' x=e',Ds

* I!catch throw HALF.T x e => KR
    I(HALF.T)=CORE.T IfNotE(CORE.T) inferenceFailure(I,HALF.T)
    I!e => ER
    ER = CTz';e' IfErr(ER) KR = ER
    KR = CTz';catch throw CORE.T x e' //assert CORE.T.mdf=imm or throw=return
_______
#define adapt(p,CORE.e,T)
* adapt(p,e,imm Library) = e
* adapt(p,e,imm Void) = (Void x=e {}) where x fresh
* adapt(p,e,T) = (T x=e x.#toLibrary()) otherwise, where x fresh    
_______
#define CTz.add(p; FULL.MWT; HAlf.e?) = CTz' // both CTz' and HALf.e? are computed by this notation
* CTz.add(p; MWT; empty) = CTz
    MWT.e?=empty
* CTz0.add(p; MWT; Half.e) = CTz0 U CTz U STs<=MWT.T
    Y=Y[p=I.p;GX=G^MWT;onSlash=MWT.T;onSlashX=empty;expectedT=MWT.T;onPath=class]
    Y!MWT.e = Half.e; STs; empty; CTz
_______
#define I(HALF.T) = CORE.T    I.coreTof(T)=Tz
* I(mdf STz)=T[mdf=mdf]
    I(STz)=T
* I(ST1..STn)=chooseT(I.coreTof(ST1) U..U I.coreTof(STn))

* T in I.coreTof(T)
* T in I.coreTof(ST)
    ST<=ST' in I.CTz
    T in I.coreTof(ST')
_______
#define collectDeps(p;CORE.MWT)=Ps;Ps'    collectDeps(p;T)=Ps;Ps'    collectDeps(p;Doc)=Ps;Ps'
//collectDeps(sequence)=union of the results of elements of the sequence
* collectDeps(p; Docs mdf method T0 m(T1 x1..Tn xn)[Ts] e?)=
    collectDeps(p; Docs) U collectDeps(p; T0..Tn,Ts) U collectDepsE(p; e?)
* collectDeps(p; T)=T.P;empty U collectDeps(p; T.Docs)
* collectDeps(p; Doc)={P| @P._ inside Doc};empty     
_______
#define collectDepsE(p;CORE.e?)  //collectDepsE(p;L) adds NCs dependencies and relies on cached Info
* collectDepsE(p;empty)=collectDepsE(p;x)=collectDepsE(p;void)=empty;empty
* collectDepsE(p;CORE.L)=Ps0..Psn;Ps'0..Ps'n
    Ps0=CORE.L.Info.typeDep
    Ps'0=CORE.L.Info.coherent
    Ps1..Psn={CORE.L(Cs).Info.typeDep[from This.Cs;p]| Cs in dom(CORE.L)}
    Ps'1..Ps'n={CORE.L(Cs).Info.coherentDep[from This.Cs;p]| Cs in dom(CORE.L)}
* collectDepsE(p; e0.m( x1=e1 .. xn=en ) )= collectDepsE(p;e0) U..U collectDepsE(p;en) 
* collectDepsE(p;loop e)=collectDepsE(p;throw e)=collectDepsE(p;x :=e)=collectDepsE(p;e)
* collectDepsE(p;P<:class Any)= P;empty
* collectDepsE(p;P<:class P')= P',P;P
    P'!=Any
* collectDepsE(p; (Ds Ks e) ) =collectDepsE(p;Ds) U collectDepsE(p;Ks) U collectDepsE(p;e)
* collectDepsE(p;var? T x=e)=collectDepsE(p;catch throw T x e)= collectDeps(T) U collectDepsE(p;e)

//OLD COLLECT. Isaac, can you show me that we still need something like this? now is unused
_______
#define PAcc.collect()=PAcc'
* CT in PAcc.collect()
    CT in PAcc.collect().collect())//is it needed since we have the fixpoint anyway?
* CT in PAcc.collect()
    CT in PAcc.CTz
* PT <= PT" in PAcc.collect()
    PT <= PT', PT' <= PT" in PAcc
* PT <= PT in PAcc.collect()
    PT in PAcc.CTz
* mdf P <= mdf' P' in PAcc.collect() //TODO: explosive, can we make it more computational? can we mix it with solve? 
    p |- mdf P <= mdf' P' // I.e. every subtype relation we know about
    P' != _ Any // Just for consistency with everything else, not important!
* mdf P <= PT in PAcc.collect()// since all classes are final
	PT <= mdf P in PAcc
	p(P).interface = empty 
* T.s <= CORE.T in PAcc.collect()//since they are alias of each other 
    CORE.T <= T.s in PAcc.collect().CTz //why noy simply in PAcc.CTz?
    CORE.T=PAcc.p(T.P)(s).MH.T[from T.P;PAcc.p]//TODO: no, CORE.L(s) works but FULL.L(s) misses on FULL.F and on methods from interfaces. Should we use methods(..)?
* T.s.i <= PT in PAcc.
t()//since method parameter types can not be refined (or since they are aliases?)
    PT <= T.s.i in PAcc.collect().CTz
    PT=PAcc.p(T.P)(s).MH.pari[from T.P;PAcc.p]
* PT.s <= PT'.s in PAcc.collect()
    PT <= PT' in PAcc.CTz
    PT'.s in PAcc.CTz
* PT'.s.i <= PT.s.i in PAcc.collect()
    PT <= PT' in PAcc.CTz
    PT'.s.i in PAcc.CTz
* PT.s.i <= PT'.s.i in PAcc.collect()//since method parameter types can not be refined 
    PT <= PT' in PAcc.CTz
    PT'.s.i in PAcc.CTz
* PT1' <= Origin(s, P2') in PAcc.collect()
    PT1 <= P2', PT1 <= PT1' in PAcc.CTz
    P2'.s in PAcc.CTz
    PT1'.s in PAcc.CTz
