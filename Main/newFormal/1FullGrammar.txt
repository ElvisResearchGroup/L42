_______
#define Abstract syntax and core : CORE, FULL, CMP (=compiled)
  mdf::= imm | mut | lent | read | capsule | fwd mut | fwd imm | class | fwd%imm | fwd%mut 
  throw ::= 'error' | 'exception' | 'return' 
  s ::= m(xs) //mOp is normalized when reified by FULL.MH.s
  P  ::= Thisn.Cs | Any | Void | Library
  CORE.T::= mdf Docs P
  FP::=(idUp idChars (::n)?)(.Cs)? //the first do not have C well formedness; note that C can have ::n too
  CMP/FULL.T::= mdf? Docs FP | '\'
  CMP/FULL.MH ::= (mdf Docs)? method T mOp (T1 x1..Tn xn) [Ts]
  CORE.MH ::= (mdf Docs)? method T m (T1 x1..Tn xn) [Ts]
  CMP/FULL/CORE.H ::= interface?[Ts]  
  CMP/FULL.TLocal ::= T | mdf | empty 
  CORE.e ::= xP | void | L | xP.m(x1=e1..xn=en) | loop e | throw e | x:=e | (Ds Ks e)
  CORE.xP::= x | (T P) | a //a=address, only at runtime
  CORE.D ::= var? T x=e
  CORE.K ::= catch throw T x e
  CORE.L ::= {H MWTs NCs Info Docs}
  CORE.MWT::= Docs MH (= native[URL]? e)?
  CORE.NC::= Docs C = L
  Info::= #Flag{typeDep=Ps,coherentDep=Ps,friendsDep=Ps,usedMethDep=(P.s)s,privateImpl=Ps}//in concrete syntax, labels for emptys are omitted
    //friendsDep are spyed by This:
    //Paths whose unique numbers are used either directly,
    //or in a private nested class or in an L in a method
    //usedMethDep//methods used either directly or in a private nested class or in an L in a method
    //privateImpl: interfaces implemented by a private nested class or in an L in a method
    //may add closed/open class (since private abstract methods may be removed if unused)
    //may add 'have private static methods' (since it can be casted to class P)
  Flag ::= norm | typed
  FULL.L ::= {(H | reuse[URL] | ...)? Ms Docs}
  FULL.M ::= F | MI | MWT | NC
  FULL.F ::= var? T x
  FULL.MI ::= Docs s = CMP.e
  FULL.MWT ::=Docs MH (= native[URL]? CMP.e)? //this prevents FULL.L inside method bodies
  FULL.NC ::= Docs C = e //FULL.L can be inside e
  LL::= FULL.L | CORE.L
  FULL.e ::= FULL.L //combined with line below, CMP.e do not have FULL.L
  CMP/FULL.e ::= x | FP | void | CORE.L | \ | \x | e string | 'PathLit | OPP e
    | e0 OP .. OP en | (T e) | e (.m)?( par ) | e (.m?)[ pars ]
    | ( Ds Ks WOPS? Ds' e? ) | { Ds Ks WOPS? Ds' }
    | loop e | while e0 e1 | for DX0 in e0 .. DX1 in en e
    | throw e | x opUpdate e | if e0 e1 (else e2)? | if match+ e 
  CMP/FULL.D ::= (DX =)? e
  CMP/FULL.WOPS ::= wops T+
  CMP/FULL.K ::= catch throw? T x e | catch throw? T '_' e
  Ldom::=s | Cs
_______
#define auxiliary grammars
  TX ::= CORE.T | X | \
  PT ::= TX | PT.s | PT.s.i
  CC ::= PT <= PT'
  IMap ::= X1:CORE.T1 .. Xn:CORE.Tn
  HALF.xP ::= x | (TX P)
  HALF.e ::= xP | void | CORE.L | \ | xP.m(xes) // OPP is already desugared at this stage
   | xP0 OP..OP xPn | throw e | loop e | x := e | (Ds Ks e)
  HALF.K ::= catch throw TX x e
  HALF.D ::= var? TX x = e
  G ::= var?1 x1:CORE.T1 .. var?n xn:CORE.Tn
  GX ::= x1:PT1 .. xn:PTn
  I ::= I[p;IMap;G;CCz;onSlash=T?]//inference application environment
  Y ::= Y[p; onSlashX=xP?; onReturn=T?; onPath=(classP|TX)]//toCore environment
  PAcc ::= PAcc[p;GX;CCz]//constraints accumulation environment
  v ::= a | P | void | CORE.L
  r ::= CORE.L | exception v | error v
  Obj ::= P(x1=v1..xn=vn) | L as // memory objects. 'as' is the set of mut objects associated to L
  A ::= empty | imm? a->Obj, A | imm? x->v, A  //order is irrelevant
  Q ::= Q[Flag;MH?;p;G;Ts;Ps]//Ts is returns, Ps is exceptions
  MethT ::= CORE.Ts->CORE.T;Ps  
  CORE.ctxV ::= xP.m(xvs x=ctxV xes) | loop ctxV | throw ctxV  | x := ctxV
  CORE.ctx ::= []
    | throw ctx | loop ctx | x := ctx  | ( Ds Ks ctx )
    | xP.m(xes x=ctx xes')
    | (Ds T x=ctx Ds' Ks e)
    | (Ds Ks catch throw T x ctx Ks' e)
  FULL.ctxC::= []
    | throw ctxC | loop ctxC |ctxC(.m)?(FULL.par) 
    | ctxC string |x updateOp ctxC | (T ctxC) 
    | if (CMP.match+ |CMP.e) ctxC (else FULL.e)?
    | CMP.e.m?(ctxC FULL.par) | CMP.e.m?(CMP.par, x=ctxC, FULL.par)
    | ctxC (.m?)[FULL.pars]
    | CMP.e(.m?)[CMP.pars; ctxC, FULL.par;FULL.pars]
    | CMP.e(.m?)[CMP.pars; CMP.par, x=ctxC, FULL.par;FULL.pars]
    | (CMP.e OP)s ctxC (OP FULL.e)s
    | ( CMP.Ds CMP.Ks WOPS? ctxC ) | ( CMP.Ds (DX=)? ctxC FULL.Ds FULL.Ks WOPS? FULL.e? )  
    | ( CMP.Ds CMP.Ks catch throw? T x ctxC FULL.Ks WOPS? FULL.e? )  
    | { CMP.Ds (DX=)? ctxC FULL.Ds1 FULL.Ks WOPS? FULL.Ds2 }
    | { CMP.Ds CMP.Ks catch throw? T x ctxC FULL.Ks WOPS? FULL.Ds }
    | { CMP.Ds1 CMP.Ks WOPS? CMP.Ds2 DX? ctxC FULL.Ds }
    | if ctxC FULL.e (else FULL.e0)?
    | if (CMP.match+ |CMP.e) CMP.e0 else ctxC
    | if CMP.match+ DX=ctxC FULL.match+ FULL.e
    | while ctxC FULL.e | while CMP.e ctxC
    | for CMP.DXes ctxC | for CMP.DXes DX in ctxC FULL.DXes FULL.e
    | CMP.e string[CMP.es ctxC FULL.e] //somehow handles the string case
  FULL.ctxM::= C = ctxC | s = ctxC | MH = ctxC
  CM::= FULL.MWT | CORE.MWT | CORE.NC | FULL.F | FULL.MI
  CoM::= FULL.MWT | CORE.MWT | CORE.NC// Constraint member, member we can extract constriants from
  FULL.ctxL::= {H CMs ctxM Ms} | CORE.ctxL //note: no reuse/dots
  CORE.ctxL ::= {H MWTs1 MH=ctx MWTs2 NCs Info} | {H MWTs NCs1 C =[] NCs2 Info}  
  pTail::= CORE.L | CORE.ctxL | FULL.ctxL
  p::= LL;pTails //representing This0,...,Thisn // where This0.C refers to a class bound in L0, and (This1..ThisN).C to bindings in cxtL1..cxtLn respectively
_______
#define functional notation for LL and ctxL (over the domain Ldom)
  /*...*/ //note, LL(Cs) may return an e not of form LL
_______
#define functional update and '\' (set minus) notation for L, ctxL and LC (over the domain Ldom)
  /*...*/
_______
#define Lexical Syntax
  newline ::= <0x0A> //linefeed only, normalizing away <0x0D>
  CHAR   ::=  <0x20-0x7E> | newline//An Any printable ASCII character, or a newline
  CHARS0 ::= CHAR* -- "
  CHARS(i+1) ::= CHAR* -- STROP(i+1) -- STRCL(i+1)
  STROP0 ::= empty
  STRCL0 ::= empty
  STROP(i+1) ::= [ STROPi
  STRCL(i+1) ::= STRCLi ]
  string ::= STROPi " CHARSi (STROPi e STRCLi CHARSi)* " STRCLi
  number ::= <0-9> ('.'|'_'|'-'|<0-9>)*
  commentChars ::= CHAR* -- '/*' -- '*/'
  comment ::= '//' (CHAR* -- newline) newline | '/*' (commentChars | comment)* '*/'
  whitespace ::= (comment | ' ' | newline| ',')+
  tURL::= /*a trusted url*//*too boring*/
  uURL::= /*an untrusted url*//*too boring*/
  URL:=tURL|uURL
  charsCurly ::= (CHAR* -- '{' -- '}') | charsCurly { charsCurly } charsCurly
  idUp ::= _* (<A-Z> | $) 
  idLow ::= _* <a-z>
  idChar ::= <a-z> |<A-Z> | $ | _ | <0-9>
  n ::= 0 | <1-9> <0-9>*
  x ::=idLow idChar*
  C ::= idUp idChar* (::n)? //well formedness: C not Thisn/Any/Void/Library
  m ::= (#|#$)?x(#x)* (::n)?
  OPP ::= ! | ~ | number  // prefix
  OP0 ::= ^ | : | <- | << | & | '|' // right associative
  OP1 ::= + | - | * | / | ++ | -- | ** | >> | -> // left associative 
  OP2 ::= == | != | < | > | >= | <= // unassiociative
  OP3 ::= => | && | '||' // right associative, will be short circuting
  OP  ::= OP0 | OP1 | OP2 | OP3 
  opUpdate ::=  ':=' | (OP0 -- ':')= | OP1= 
  Cs ::=C(.C)*
  CMP/FULL/CORE.Doc ::= @PathLit | @PathLit?{(charsCurly -- DOC|DOC)*}
  CMP/FULL.PathLit::= FP | FP? s | FP? s.x
  CORE.PathLit::= P | P? s | P? s.x
  mOp ::= empty | m | OP | ~ | !
_______
#define CMP/FULL Expressions priority disambiguation and other details
  CMP/FULL.eAtomic ::= x | P | 'void' | LL | B | (T e) | \  | 'PathLit
  CMP/FULL.ePostfix ::= eAtomic | ePostfix (.m)? '(' par ')' | \x //no space in ePostfix(par) and \x
              | ePostfix (.m)? '[' (par;)* par? ']' | ePostfix string
  CMP/FULL.par ::= e? xe*
  CMP/FULL.eUnary   ::= OPP? ePostfix
  CMP/FULL.eBinary0 ::= eUnary (OP0 eUnary)* //right associative, all ops must be the same
  CMP/FULL.eBinary1 ::= (eBinary0 OP1)* eBinary0 //left associative, all op the same
  CMP/FULL.eBinary2 ::= (eBinary1 OP2)* eBinary1 //unassociative, all op the same, thus a<b<c could be resolved as a.#left#1(center:b,right:c)
  CMP/FULL.eBinary3 ::= (eBinary2 OP3)* eBinary2 //left associative, all op the same
  CMP/FULL.B ::= '(' D* e ')' | '(' D+ K* WOPS? (D* e)? ')' | '{' D* (D K+ WOPS? D*)? '}'
  CMP/FULL.DX ::= var? TLocal x | TLocal '_' | TLocal ( var?0 TLocal0 x0 ..var?n TLocaln xn )
  CMP/FULL.statement  ::= sIf | sWhile | sFor | 'loop' e | throw e | x opUpdate e
  CMP/FULL.sIf ::= 'if' e e ('else' e)? | 'if' match+ e
  CMP/FULL.match ::= T x | T x = e | T?(T?0 x0..T?n xn) = e //where at least one Ti? is not empty //correctly not TLocal
  CMP/FULL.sWhile::= 'while' e e
  CMP/FULL.sFor ::= 'for' (DX in e)* e
  CMP/FULL.e ::= statement | e-binary3
_______
#define grammar well formedness
* CMP/FULL/CORE.D: var T x=e is valid only if T not capsule or fwd.
* s: 'this' notin xs and all x in xs are unique
* mdf: fwd%Imm, fwd%mut not present in any term, will be used internally by the type system
* CMP/FULL/CORE.NC: NC.C not Any, Library, Void, This, Thisn
* C not This, Thisn, Any, Void or Library
* FP: if Cs not empty, then the start can not be Library, Void, Any
* CORE B: in a (Ds1 Ks Ds2 e):
    unique x in dom(Ds1,Ds2)
    FV(Ks) disjoint dom(Ds1,Ds2)
    dom(Ds1,Ds2) disjoint bindings(Ds1.es,Ds2.es,Ks.es,e)
* CMP/FULL.B:
    unique x in dom(B.Ds)//all of the Ds, even if divided in 2 groups
    FV(Ks) disjoint dom(B.Ds)
    dom(B.Ds) disjoint bindings(B.Ds,Ks.es,e)
    if B={ Ds1 Ks WOPS? Ds2} then returning({ Ds1 Ks WOPS? Ds2})
    if B=(Ds1 Ks WOPS? Ds2 e) then forall D in Ds1,Ds2: not returning(D)
    if B=(Ds1 e Ks WOPS?) then forall D in Ds1: not returning(D) 
    if B=(_ D e _), then noBlockNeeded(D.e)
    if B=(_ K e _), then noBlockNeeded(K.e)
* CMP/FULL/CORE.K: K.x notin bindings(e)
* CMP/FULL/CORE.MWT:
    MWT =mdf method T m(T1 x1.. Tn xn)[Ts] e?
    T0 = mdf This0
    if exists i: Ti.mdf=fwdImm then T.mdf in {mut, fwdMut, imm, fwdImm}
    if exists i: Ti.mdf=fwdMut then T.mdf in {mut, fwdMut}
    if T.mdf in {fwdImm,fwdMut} then exists i: Ti.mdf in {fwdImm, fwdMut}
* CORE.MWT: if MWT.e?=e, then
    FV(e)\this,x1..xn = empty    
    for i in 0..n if Ti.mdf=capsule, xi in FV(e) 0 or 1 times
* CMP/FULL.match of form T?(T?0 x0..T?n xn) = e; at least one Ti? is not empty
* FULL.e: all used variables are in scope    
* CMP/FULL.sFor: forall TLocal(var?1 TLocal1 x1.. var?n TLocaln xn) in FULL.sFor.DXs: var1?..varn?=empty
* LL:
    M1, M2 in LL.Ms and dom(M1)=dom(M2) implies M1=M2
    Any notin H.Ts
    Exists at most one n such that exists m::n(xs) where L(m::n(xs))=MWT, and MWT.e? is empty
    if LL.H.interface? = interface, then forall s in dom(L), L(s).e?=empty
    if LL.H.interface? = interface, then forall m::n(xs),  m::n(xs) notin dom(L) //TODO: may be we need private methods in interfaces for the new rename
* CMP/FULL.e: \x only appear in a method parameter expression
* The top level project LL:
    forall LL0, LL1 anywhere inside different places in LL: ns0 disjoint ns1
    where nsi={n| C::n in dom(LLi) or m::n(xs) in dom(LLi) //care when '...' is expanded; while 'reuse URL' will rename the private names
* program p:
  -if p.pop(1) is defined, then p.pop(1) is well formed 
  -CORE.L;pTail is well formed iff
    FULL.L={CORE.L.H CORE.L.Ms}
    normAndFlag(FULL.L;pTail)=CORE.L';pTail //defined in file top
    and CORE.L'.Info<=CORE.L.Info (that is, all the dependencies are a subset, and so on)//TODO: define formally
//Note, when we import an url we should check if the corresponding CORE.L;empty is well formed
* G: var x capsule _ or var x fwd _ or var x fwd% _ not in G
_______
#define noBlockNeeded(CMP/FULL.e):
* noBlockNeeded(B)
* noBlockNeeded(throw e)
* noBlockNeeded(loop e)= 
    noBlockNeeded(if match+ e)=noBlockNeeded(if e0 e)=
    noBlockNeeded(if e0 e1 'else' e)= 
    noBlockNeeded(while e0 e)=noBlockNeeded(for (DX in e)* e)=
    noBlockNeeded(e)
_______
#define bindings(CMP/FULL/CORE.e):xs
* bindings(LL)={}
* bindings(var? T x=e)=bindings(catch throw? T x e)=x U bindings(e)
* bindings(var? _ x)=x
* bindings(_ ( var?1 _ x1 ..var?n _ xn )= x1..xn
* bindings(_ ( var?1 _ x1 ..var?n _ xn )=e = x1..xn  U bindings(e)
* propagates inductivelly in all the other cases
_______
#define FV(CORE.e) //note: FV defined as a sequence instead of a set, and counts occurences of xs
* FV(x)=x
* FV(void)=FV(P)=FV(L)=empty
* FV(throw e)=FV(e)
* FV(loop e)=FV(e),FV(e)  //representing each variable twice is enough to make capsule tests work
* FV(e0.m[T](x1:e1..xn:en) )=FV(e0),..,FV(en)
* FV( (T1 x1=e1.. Tn xn=en k1..km e0[T]) )=ys/x1..xn ,max( (xs0/x1..xn), xs1,..,xsm)
    ys=FV(e1),..,FV(en)
    xsi=FV(ki)
    xs0=FV(e0)
    if Ti=capsule _ then
      xi 0 or 1 times in ys,xs0
_______
#define max(xs1;..;xsn)= zs // as many repetition of each x as in the most repetitive of xs1..xsn
* max(ys)=max(empty,ys)=ys
* max (x xs;ys)=x max(xs;ys) if x not in ys
* max (x xs;ys0,x,ys1)=x max(xs;ys0,ys1)
* max(xs; xs0;..;xsn) = max(max(xs;xs0);xs1;..;xsn)
_______
#define returning(CMP/FULL.e)
* returning({ Ds1 Ks WOPS? Ds2}) iff
    Ds,D=Ds1,Ds2
    returning(D.e)
    forall D' in Ds: not returning(D'.e) //dead code after
    forall K in Ks: returning(K.e)
* returning(loop e)
* returning(throw e)
* returning(loop e)
* returning(if _ e1 else e2) iff 
    returning(e1) and returning(e2)
* returning( (Ds1 Ks WOPS? Ds2 e) ) iff
    returning(e)
    forall K in Ks: returning(K.e)
