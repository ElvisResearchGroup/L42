Full 42 syntax

Notation for grammar:
< ... > indicate character classes
A -- B to mean anything matching A, but with no sub-string matching B

	When there are multiple grammar forms for the core and full, I will prefix them with CORE. and FULL. 
	(On the RHS of a CORE. or FULL. declaration, any unqualified forms should be interpreted as a CORE./FULL. (respectively) where all child-asts conform to their CORE versions)
	// I should explain that better!
--------------------------------------------------------------------------------------

======================================================================================
Part 0: Lexical Syntax
======================================================================================
	NEWLINE ::= <0x0A> //linefeed only, normalizing away <0x0D> (and others?)
A line feed or carriage return
	CHAR   ::=  <0x20-0x7E> | NEWLINE
An Any printable ASCII character, or a newline
// You said "drown" on an english keyboard, and I wasn't sure wether that includes newlines or carriage returns, but unless you don't want Windows users to write 42 code, I think it should include both!

	STR-CHARS0 ::= CHAR* -- "
	STR-CHARS(i+1) ::= CHAR* -- STR-OP(i+1) -- STR-CL(i+1)
	STR-OP0 ::= empty
  STRCL0 ::= empty
	STR-OP(i+1) ::= [ STR-OPi
  STR-CL(i+1) ::= STR-CLi ]
	STRING ::= STR-OPi " STR-CHARSi (STR-OPi e STR-CLi CHARSi)* " STR-CLi

	NUMBER ::= <0-9>+ ("."|"_"|"-"|<0-9>)*

	COMM-CHARS ::= CHAR* -- "/*" -- "*/"
	COMMENT ::= "//" (CHAR* -- NEWLINE) NEWLINE | "/*" (COMM-CHARS | COMMENT)* "*/"

// Note: this allows /* comments to nest
	WHITESPACE ::= (COMMENT | " " | NEWLINE| ",")+
In any grammar form in any subsequent section, WHITESPACE is to be implicitecly allowed between every token, unless I write !WHITESPACE
// (let me know if there are any such places you don't want to allow WHITESPACE)

	URL::= /*too boring*/
// What was the reason for not just saying a URL is an arbitrary string literal (without [e]s of course)?
	
	CHARS-CURLY ::= (CHAR* -- "{" -- "}") | CHARS-CURLY { CHARS-CURLY } CHARS-CURLY
// charsWithBalancedCurly... (this is not a nice way of writing it at all...)

	ID-UP ::= _* (<A-Z> | $) 
	ID-LOW ::= _* <a-z>
	ID-CHAR   ::= <a-z> |<A-Z> | $ | _ | <0-9>

	n ::= 0 | <1-9> <0-9>*
// Assume you don't want people to write This0001 instead of This1

	UNIQUE-NUM ::= _n?
// I really don't like this syntax! //Isaac propose foo.n() and C.n.Bar

	CORE.x ::= ID-LOW ID-CHAR*
	FULL.x ::= CORE.X | "_"
	C ::= ID-UP ID-CHAR* UNIQUE-NUM
  m ::= (#|#$)?x(#x)* UNIQUE-NUM
	m-OP ::= empty | m | OP | OPP
// I'm guessing ! and ~ are meant to be unary operators? What about negation (e.g. -1?) Although I've seen ~ used for this purpose.

	OPP ::= ! | ~ // prefix
// Note: lower numbers denote higher precedence?
	OP0 ::= ^ | : | <- | << | & | '|' // right associative
	OP1 ::= + | - | * | / | ++ | -- | ** | >> | -> // left associative 
	OP2 ::= == | != | < | > | >= | <= // unassiociative
	OP3 ::= => | && | "||" // right associative, will be short circuting
	OP  ::= OP0 | OP1 | OP2 | OP3 
	OP-UPDATE ::=  ":=" | (OP0 -- ":")= | OP1= 
	
	mdf::= empty | mut | lent | read | capsule | fwd WHITESPACE mut | fwd | class | fwd%imm | fwd%mut
	// may be we could define two kinds of mdf 

	throw ::= "error" | "exception" | "return" // How about "except"? I find exception to be quite long (not an important point though)

======================================================================================
Paths and Stuff
======================================================================================
> //for under: This and Thisn are valid C, is just going to be well formedness to avoid issues
	Doc ::= @PathLit | @PathLit?{(CHARS-CURLY -- DOC|DOC)*}
	PathLit::= Cs | Cs? s | Cs? s.x
	s  ::= m-OP(x*)
	Ldom::=s | Cs
	Tx ::= T x

	Cs ::=C(.C)*  
	
	CORE.T  ::= mdf Doc* P //even Docs containing Ps will have Ps from the subset.
	FULL.T  ::= CORE.T | "\"

// Now the Doc comes after? Ok we need to have a proper discussion about this!

	CORE.P  ::= Thisn.Cs? | Any | Void | Library
	FULL.P  ::= Cs  // in the full This, Any,Void,Library are C

==================================================================================================================
Part 2: Expressions:
==================================================================================================================
	CORE.e   ::= x | "(" T P ")" | void | L |  xPP . m "(" xe* ")" | loop e | throw e | x := e | "(" D* K* e ")"
	CORE.xPP  ::= x | (T P)
  xe ::= x = e

	CORE.D   ::= "var"? T x = e
	CORE.K   ::= "catch" throw T x e
	FULL.K   ::= "catch" throw? T x e // TODO: normalise empty throw to exception
FULL:
	e-atomic ::= x | P | "void" | L | block | (T e) | \ | \x | 'PathLit
	e-postfix ::= e-atomic | e-postfix (.m)? !WHITESPACE "(" paramaters ")" 
              | e-postfix (.m)? '[" (paramaters;)* paramaters? "]" | e-postfix STRING
// The !WHITESPACE is apparanetly needed to disambigoute againts e-postfix block
//or, easier to parse: if an expression ends with ')' ']' or '"', and there next character is  '(', then we are in the pe'(' par ')' case, otherwise the pe is terminated.

	paramaters ::= e? xe*
	
	e-unary ::= e-postfix | OPP e-postifx | NUMBER e-postfix
	
	e-binary0 ::= e-unary (OP0 e-unary)* //right associative, all ops must be the same
	e-binary1 ::= (e-binary0 OP1)* e-binary0 //left associative, all op the same
	e-binary2 ::= (e-binary1 OP2)* e-binary1 //unassociative, all op the same, thus a<b<c could be resolved as a.#left#1(center:b,right:c)
	e-binary3 ::= (e-binary2 OP3)* e-binary2 //left associative, all op the same
	
	block   ::= "(" block-body ")" | '{' DE* (DE K+ WOPS? DE*)?  '}'
	block-body ::= DE* e | DE+ K* WOPS? DE* e | DE* e K+ WOPS?

	DE  ::= (DX =)? e
	DX  ::= "var"? T? x | T? "(" ("var"? T? x)+ ")"
	WOPS ::= wops T+

	statement  ::= IF | While | For | "loop" e | "throw" e | x OP-UPDATE e
	IF  ::= "if" e e ("else" e)? | "if" Match+ e
	Match ::= T x | T x = e | T? "(" (T? x)+ ")" = e //where at least one Ti? is not empty

	While::= "while" e e
	For ::= "for" (DX in e)* e

	FULL.e  ::= statement | e-binary3

	ABSTARCT.e ::= statement | (e-atomic -- block)
		| e STRING | OPP e | NUMBER e
		| e (.m)? "(" paramaters ")"
		| e (.m)? "[" pararamaters* "]"
		| e (OP e)+
		| ( DE* K* Wops? DE* e? )  
		| { DE* K* Wops? DE* }
		
==================================================================================================================
Part 3: Libary literals
==================================================================================================================
	FULL.L ::= CORE.L | H { (... | reuse[URL])? M*}
	CORE.L ::= H {Info Doc* MWT* NC*}
Well-Formedness:
    * if C__n in dom(L) or m__n(xs) in dom(L), then for any other L' in the project, C'__n notin dom(L') and m'__n(xs') notin dom(L')
    * unique LDom in dom(L) // what?
    * Any notin H //Library and Void are not interfaces so you will get the normal error from implementing them
    * Exists at most one n such that exists m__n(xs) where L(m__n(xs))=mwt, and mwt.e? is empty
    * if H.interface? = interface, then methods in interfaces have no body and forall m__n(xs),  m__n(xs) notin dom(L)
   
CORE.Well-Formedness: 
        need to mention all the methods of all implemented interfaces, and list all the transitively implemented interfaces.
        
	Info::= [Flag;
  		P*;//typeDep
  		P*;//coherentDep
  		P*;//friendsDep = P* are spyed by This
  		//Paths whose unique numbers are used either directly,
  		//or in a private nested class or in an L in a method
  		P.s*;//usedMethDep//methods used either directly or ...
  		P* //interfaces implemented by a private nested class or in an L in a method: privatly implement
	]
	Flag ::= "norm" | typed
	typed::= "coherent"?

	FULL.M  ::= NC | MWT | MI | F 
	FULL.MI ::= Doc* s = e
Well-Formdness: e can not contain FULL.L, only CORE.L is allowed
// WHY?
	FULL.F  ::= "var"? T x

	CORE.NC ::= Doc* C = L
	FULL.NC ::= Doc* C = e
	
	MWT ::= MH (= e)?
Well-Formedness: e can not contain FULL.L, only CORE.L is allowed

	MH ::= Doc* "refine"? ("native" [ URL ])? mdf "method" T m-OP Doc*(Tx*) [T+]? //the Doc after the '(' is  conceptually on the this type.

	CORE.H ::= "interface"?[T+]?
	FULL.H  ::= CORE.H

-----------------------------------
Part 6: well formedness
-----------------------------------


* BIN:
  if BIN of form DE*1 DE e DE*2 e0, then noBlockNeeded(DE.e)
  if BIN of form DE*1 K* K e DE*2 e0, then noBlockNeeded(K.e)
  if BIN of form DE*1 K* K e, then noBlockNeeded(loop K.e)
  if BIN of form DE*1 DE e, then noBlockNeeded(DE.e)
_______
#define noBlockNeeded(e):
  noBlockNeeded(B)
  noBlockNeeded(b3e)
  noBlockNeeded(S)
   if S is of form 'while e0 e', 'if e0 e', 'for DXe+ e', 'if e0 e1 else e' or 'loop e'
   then e must be of form 'B', 'throw _', 'loop _' or 'void'
   


* DE: var T x=e is valid only if T not capsule or fwd.
  if e = DE, that is,(DX=)?=empty, then e not of form '...', x, P, void, L, core(L), \, \x or 'PathLit
  //none of those would make sense anyway, and it helps with parsing a()()

* s: 'this' notin xs and all x in xs are unique

* MH: 'Any' notin [Ts] //Ts is thrown exceptions //TODO: why??? should we remove this restriciton? 24/10/2018

* mdf: fwd%Imm, fwd%mut not present in any term, will be used internally by the type system

* NC: NC.C not Any, Library, Void, This, Thisn


* loop P, loop x, loop void, loop L, not well formed
* (ds1 ks ds2 e): unique x in dom(ds1,ds2), FV(ks) disjoint dom(ds1,ds2)

* native[P]: P not Any/Void/Library

//C:e :  FV(e)=empty subsumed by next check

* C:e : //checks for capsuleWellFormed and absence of free variables
   cX(e)=empty  //FV(e)=empty this is implied
   //Note: need to be checked again after normalization

* mwt: Ts=parameter types, T=return type
  if exists fwdImm _ in Ts then T.mdf in {mut, fwdMut, imm, fwdImm}
  if exists fwdMut _ in Ts then T.mdf in {mut, fwdMut}
  if T.mdf in {fwdImm,fwdMut} then exists fwdImm _ in Ts or fwdMut _ in Ts

* mwt:  //checks for capsuleWellFormed// normalization can inject a capsule parameter in a "s=e"
  mwt= refine? mdf method T m(T1 x1..Tn xn)[Ts]e
  T0=mdf This0
  FV(e)\ this,x1..xn= empty
  for i in 0..n if Ti=capsule _, xi in cX(e) 0 or 1 times
  //Note: need to be checked again after normalization

* for: in a for header, in the  DX of form T?(var1? T1? x1.. varn?Tn? xn),  var1?..varn?=empty
_______
#define     //note: FV is trivially defined from cX
cX(e)//count occurences of xs
  cX(x)=x
  cX(void)=cX(P)=cX(L)=empty
  cX(throw[T1,T2] e)=cX(e)
  cX(loop e)=cX(e),cX(e)  //representing each variable twice is enough to make capsule tests work
  cX(e0.m[T](x1:e1..xn:en) )=cX(e0),..,cX(en)
  cX(use P check m(x1:e1..xn:en) e0)=cX(e0),..,cX(en)
  cX( (T1 x1=e1..Tn xn=en k1..km e0[T]) )=ys/x1..xn ,max( (xs0/x1..xn), xs1,..,xsm)
    where
    ys=cX(e1),..,cX(en)
    xsi=cX(ki)
    xs0=cX(e0)
    if Ti=capsule _ then
      xi 0 or 1 times in ys,xs0
_______
#define max(xs1,..,xsn)= zs // as many repetition of each x as in the most repetitive of xs1..xsn
  max(ys)=max(empty,ys)=ys
  max (x xs,ys)=x max(xs,ys) if x not in ys
  max (x xs,ys)=x max(xs,removeOne(x,ys))
  max(xs, xs0,..,xsn) = max(max(xs,xs0),xs1,..,xsn)


* B of form { DEs1 Ks WOPS? DEs2} returning({ DEs1 Ks WOPS? DEs2}) must hold
* B of form (DEs1 Ks WOPS? DEs2 e)
    forall DE in DEs1,DEs2: not returning(DE)
* B of form (DE* e K+ WOPS?)
    forall DE DE*: not returning(DE) 
_______
#define returning({ DEs1 Ks WOPS? DEs2})
  returning({ DEs1 Ks WOPS? DEs2})=returning({ DEs1 Ks DEs2})
  returning({ DEs1 Ks DEs2}) iff
    DEs,DE=DEs1,Des2
    returning(DE)
    forall DE' in DEs: not returning(DE') //dead code after
    forall catch throw T x e' in Ks: returning(e')
 returning(loop e)
 returning(throw e)
 returning(loop e)
 returning(if _ e1 else e2) iff 
   returning(e1) and returning(e2)
 returning( (DEs1 Ks WOPS? DEs2 e) ) iff
   returning(e)
   forall catch throw T x e' in Ks: returning(e')
 //forall DE in DEs1,DEs2: not returning(DE) already in block well formedness
 //returning(T x=e) does not hold, so DE must be of form e for returning to hope to hold 


//TODO: alive and similar was well formedness somewhere... recover them
//TODO: Cs and similar may only start for This or Thisn but not have it in the middle. 
