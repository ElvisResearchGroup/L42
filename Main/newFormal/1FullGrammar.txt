Full 42 syntax

-----------------------------------
Part 0: general discussions:
-----------------------------------
only character drown on conventional English keyboards (except 'tab')
can be in the input file.
Comments are normal // and /**/. Comments and are discarded. This changed from last time
Docs have a different syntax, are aware of Paths and are kept and adapted during metaprogramming,
but only exists in few crucial points in the syntax.
"using P check m(xes) e" is now "native P m(xes)[e]"
and is expected to be used directly only during bootstrapping.

Outside of comments and docs; space, newline and ',' are all just spacing characters

-----------------------------------
Part 1: boring part, identifiers and other stuff
-----------------------------------
char   ::=  all the ones drown on English keyboards except 'tab' :-)
StrLit  ::= StrOpi char* (StrIni char*)* StrCli
StrOp0  ::="
StrCl0  ::="
StrOp1  ::=["
StrCl1  ::="]
StrIn1  ::=[ e ]
StrOp2  ::=[["
StrCl2  ::="]]
StrIn2  ::=[[ e ]]
...
StrOpn  ::=[..["
StrCln  ::="]..]
StrInn  ::=[..[ e ]..]

NumLit::= (0..9)+ ((.|_|e|E|-) (0..9)*)*
Doc: empty | @PathLit
PathLit::= (C.)* s | Cs |This | {charsWithBalancedCurly}
//Note, we may need two different PathLit, one for docs and one for '
//in docs we want the free text and the Thisn.Cs
//we also need s.x to reference a s parameter

x ::= LowChar charId* | _ // '_' will be replaced with a fresh name
C ::= UpChar charId* (_n) //the unique number
UpChar ::= _* (A..Z | $) 
LowChar::= _* a..z
charId   ::= a..z |A..Z| $ | _ | 0..9
URL::= /*too boring*/
s  ::= Doc mOp(x*)
Tx ::= T x
mdf::= empty | mut | lent | read | capsule | fwd mut | fwd | class | fwd%Imm | fwd%mut
T  ::= mdf P Doc | mdf Cs Doc 
P  ::= This(n?).Cs | Any | Void | Library
MH ::= Doc refine? mdf method T mOp(Doc Tx*) [T+]? //the Doc after the '(' is conceptually on the this type.
Cs ::=C(.C)*  //Is it the only sequence where we need a separator? 
throw::= error | exception | return
m ::= (# | #$)?x(#x+)* (_n) //the unique number
mOp::= empty | m| op | ! | ~
op0 ::= ^ | : | <- | << | & | '|'
op1 ::= + | - | * | / | ++ | -- | ** | >> | ->
op2 ::= == | != | < | > | >= | <=
op3 ::= => | && | || //will be short circuting
op  ::= op0 | op1 | op2 | op3 
updateOp ::=  := | op0= | op1= // except ':' from op0; op2 and op3 are dangerous to lift to updateOp


-----------------------------------
Part 2: core
-----------------------------------
All metavariables declared here can be used in the full language only inside of a core(..) block.
Now all core expressions are normalized expression

e   ::= x | (D* w) | void | L | e0.m( x1=e1 .. xn=en ) | loop e | throw e | x := e | (D* K* e) | native P m(xes)[e]
D   ::= var? T x=e
K   ::= catch throw T x e
NC  ::= Doc C=L 
MWT ::= MH=e | MH 
M   ::= NC | MWT
L   ::= interface?[T+]?{MWT* NC*}

Core Well formedness:
* the receiver expression e0 must be of form w ::= x | (D* w)
* under a p an L need to mention all the methods of all implemented interfaces,
  and all list all the transitively implemented interfaces.
* P are not of form mdf Cs Doc (that is, without the 'Thisn.')
* Core well formedness also inherits all the well formedness of the full language
   
-----------------------------------
Part 3: full L
-----------------------------------

H  ::= interface? [T+]? | reuse URL
L  ::= H{F* M*}
F  ::= var? T x
M  ::= NC | MWT | MI
NC ::= Doc C ECurly | Doc C =core(L)
MWT::= MH ECurly?
MI ::= s ECurly 

-----------------------------------
Part 4: expressions and statements
-----------------------------------
For Isaac:
I know there are a set of things you will disagree:
  -required parameter names
  -the wops
  -the '={' token
  -the nominal patter matching
  -the 'no space between pe(' rule
  
//atomic expression
ae ::= '...' | x | P | void | L |core(L)| B | \ | \x | 'PathLit // 'stuff == \"stuff"
//post operators expression
pe ::= ae | pe.m'(' par ')' | pe'(' par ')' | pe Square | pe StrLit | pe%T // or pe:T, but then we can not use ':' as binary op
//no space between pe( otherwise it can be parsed as pe B
par::= e? xe*
xe ::= x ECurly
Square::= [ (par;)*par? ] //not sure how else to force the last semicolon to be optional
//unary expression
ue ::= pe | !pe | ~pe | NumLit pe
//binary expressions 
b0e ::= ue0 (op0 ue1 .. op0 uen) //right associative, all op the same
b1e ::= b0e0 (op1 b0e1 .. op1 b0en) //left associative, all op the same
b2e ::= b1e0 (op2 b1e1 .. op2 b1en) //unassociative, all op the same (see desugaring)
b3e ::= b2e0 (op3 b2e1 .. op2 b2en) //left associative, all op the same
//block
B   ::= '(' BIN ')'
BIN ::= DE* e | DE+ K+ WOPS? DE* e | DE* e K+ WOPS?
DE  ::= e | DX ECurly
DX  ::= var? T? x | T?(var1? T1? x1.. varn?Tn? xn)
K   ::= catch throw? T x e
WOPS::= wops T+
Curly::= '={' DE* (DE K+ WOPS? DE*)?  '}' //yes, '={' is a single token, so the parser do not get confused with L
ECurly::= = e | Curly
//statements (just another kind of expression)
S  ::= IF | While | For | loop e | throw e | x updateOp e | native P m'('par')'[e]
IF  ::= if (tMatch+ |e0) e1 (else e2)?
tMatch::= T x | T x=e | T0?(T1? x1..Tn? xn)=e //where at least one Ti? is not empty
While::= while e0 e1
For ::= for DXe+ e
DXe ::= DX in e
e  ::= S | b3e

-----------------------------------
Part 5: well formedness, to complete
-----------------------------------

* MWT: MWT.e can not contain L, only core(L) is allowed

* s=e: e can not contain L, only core(L) is allowed


* BIN:
  if BIN of form DE*1 DE e DE*2 e0, then noBlockNeeded(DE.e)
  if BIN of form DE*1 K* K e DE*2 e0, then noBlockNeeded(K.e)
  if BIN of form DE*1 K* K e, then noBlockNeeded(loop K.e)
  if BIN of form DE*1 DE e, then noBlockNeeded(DE.e)
_______
#define noBlockNeeded(e):
  noBlockNeeded(B)
  noBlockNeeded(b3e)
  noBlockNeeded(S)
   if S is of form 'while e0 e', 'if e0 e', 'for DXe+ e', 'if e0 e1 else e' or 'loop e'
   then e must be of form 'B', 'throw _', 'loop _' or 'void'
   

* L: if C__n in dom(L) or m__n(xs) in dom(L),
  then for any other L' in the project
  C'__n notin dom(L') and m'__n(xs') notin dom(L')

* D: var T x=e is valid only if T not capsule or fwd.

* s: 'this' notin xs and all x in xs are unique

* MH: 'Any' notin [Ts] //Ts is thrown exceptions //TODO: why??? should we remove this restriciton? 24/10/2018

* mdf: fwd%Imm, fwd%mut not present in any term, will be used internally by the type system

* NC: NC.C not Any, Library, Void, This, Thisn

* L: unique LDom in dom(L), Any notin [Ts] //Library and Void are not interfaces so you will get the normal error from implementing them
    Exists 0 or 1 n such that exists m__n(xs) where L(m__n(xs))=mwt, mwt.e? is empty

* L interface:
   methods in interfaces have no body
   forall m__n(xs),  m__n(xs) notin dom(L)

* (ds1 ks ds2 e): unique x in dom(ds1,ds2), FV(ks) disjoint dom(ds1,ds2)

* native P m(xes)[e]: P not Any/Void/Library

//C:e :  FV(e)=empty subsumed by next check

* C:e : //checks for capsuleWellFormed and absence of free variables
   cX(e)=empty  //FV(e)=empty this is implied
   //Note: need to be checked again after normalization

* mwt: Ts=parameter types, T=return type
  if exists fwdImm _ in Ts then T.mdf in {mut, fwdMut, imm, fwdImm}
  if exists fwdMut _ in Ts then T.mdf in {mut, fwdMut}
  if T.mdf in {fwdImm,fwdMut} then exists fwdImm _ in Ts or fwdMut _ in Ts

* mwt:  //checks for capsuleWellFormed// normalization can inject a capsule parameter in a "s=e"
  mwt= refine? mdf method T m(T1 x1..Tn xn)[Ts]e
  T0=mdf This0
  FV(e)\ this,x1..xn= empty
  for i in 0..n if Ti=capsule _, xi in cX(e) 0 or 1 times
  //Note: need to be checked again after normalization

_______
#define     //note: FV is trivially defined from cX
cX(e)//count occurences of xs
  cX(x)=x
  cX(void)=cX(P)=cX(L)=empty
  cX(throw[T1,T2] e)=cX(e)
  cX(loop e)=cX(e),cX(e)  //representing each variable twice is enough to make capsule tests work
  cX(e0.m[T](x1:e1..xn:en) )=cX(e0),..,cX(en)
  cX(use P check m(x1:e1..xn:en) e0)=cX(e0),..,cX(en)
  cX( (T1 x1=e1..Tn xn=en k1..km e0[T]) )=ys/x1..xn ,max( (xs0/x1..xn), xs1,..,xsm)
    where
    ys=cX(e1),..,cX(en)
    xsi=cX(ki)
    xs0=cX(e0)
    if Ti=capsule _ then
      xi 0 or 1 times in ys,xs0
_______
#define max(xs1,..,xsn)= zs // as many repetition of each x as in the most repetitive of xs1..xsn
  max(ys)=max(empty,ys)=ys
  max (x xs,ys)=x max(xs,ys) if x not in ys
  max (x xs,ys)=x max(xs,removeOne(x,ys))
  max(xs, xs0,..,xsn) = max(max(xs,xs0),xs1,..,xsn)


* Curly returning(Curly) must hold
* B of form (DEs1 Ks WOPS? DEs2 e)
    forall DE in DEs1,DEs2: not returning(DE)
* B of form (DE* e K+ WOPS?)
    forall DE DE*: not returning(DE) 
_______
#define returning(Curly)
  returning(={ DEs1 Ks WOPS? DEs2})=returning(={ DEs1 Ks DEs2})
  returning(={ DEs1 Ks DEs2}) iff
    DEs,DE=DEs1,Des2
    returning(DE)
    forall DE' in DEs: not returning(DE') //dead code after
    forall catch throw T x e' in Ks: returning(e')
 returning(loop e)
 returning(throw e)
 returning(loop e)
 returning(if _ e1 else e2) iff 
   returning(e1) and returning(e2)
 returning( (DEs1 Ks WOPS? DEs2 e) ) iff
   returning(e)
   forall catch throw T x e' in Ks: returning(e')
 //forall DE in DEs1,DEs2: not returning(DE) already in block well formedness
 //returning(T x=e) does not hold, so DE must be of form e for returning to hope to hold 
 