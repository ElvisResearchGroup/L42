_______
#define Lexical Syntax
  NEWLINE ::= <0x0A> //linefeed only, normalizing away <0x0D>
  CHAR   ::=  <0x20-0x7E> | NEWLINE//An Any printable ASCII character, or a newline
  STR_CHARS0 ::= CHAR* -- "
  STR_CHARS(i+1) ::= CHAR* -- STR_OP(i+1) -- STR_CL(i+1)
  STR_OP0 ::= empty
  STRCL0 ::= empty
  STR_OP(i+1) ::= [ STR_OPi
  STR_CL(i+1) ::= STR_CLi ]
  STRING ::= STR_OPi " STR_CHARSi (STR_OPi e STR_CLi CHARSi)* " STR_CLi
  NUMBER ::= <0-9> ('.'|'_'|'-'|<0-9>)*
  COMM_CHARS ::= CHAR* -- '/*' -- '*/'
  COMMENT ::= '//' (CHAR* -- NEWLINE) NEWLINE | '/*' (COMM_CHARS | COMMENT)* '*/' // Note: this allows /* comments to nest
  WHITESPACE ::= (COMMENT | ' ' | NEWLINE| ',')+
  URL::= /*too boring*/
  CHARS_CURLY ::= (CHAR* -- '{' -- '}') | CHARS_CURLY { CHARS_CURLY } CHARS_CURLY
  ID_UP ::= _* (<A-Z> | $) 
  ID_LOW ::= _* <a-z>
  ID_CHAR   ::= <a-z> |<A-Z> | $ | _ | <0-9>
  n ::= 0 | <1-9> <0-9>*
  UNIQUE_NUM ::= (::n)?
  FULL.x ::= ID_LOW ID_CHAR* | '_'
  CORE.x ::=ID_LOW ID_CHAR*

  C ::= ID_UP ID_CHAR* UNIQUE_NUM
  m ::= (#|#$)?x(#x)* UNIQUE_NUM
  mOp ::= empty | m | OP | ~ | !
  OPP ::= ! | ~ | NUMBER  // prefix
  OP0 ::= ^ | : | <- | << | & | '|' // right associative
  OP1 ::= + | - | * | / | ++ | -- | ** | >> | -> // left associative 
  OP2 ::= == | != | < | > | >= | <= // unassiociative
  OP3 ::= => | && | '||' // right associative, will be short circuting
  OP  ::= OP0 | OP1 | OP2 | OP3 
  OP_UPDATE ::=  ':=' | (OP0 -- ':')= | OP1= 
  mdf::= empty | mut | lent | read | capsule | fwd WHITESPACE mut | fwd | class | fwd%imm | fwd%mut 
  throw ::= 'error' | 'exception' | 'return' 
  Cs ::=C(.C)*
  FULL/CORE.Doc ::= @PathLit | @PathLit?{(CHARS_CURLY -- DOC|DOC)*}
  FULL.PathLit::= Cs | Cs? s | Cs? s.x
  CORE.PathLit::= P | P? s | P? s.x
  s  ::= mOp(x*)
  Ldom::=s | Cs
  FULL/CORE.Tx ::= T x
  FULL/CORE.MH ::= Doc* 'refine'? ('native' [ URL ])? mdf 'method' T mOp Doc*(Tx*) [T+]? //the Doc before the '(' is  conceptually on the this type.  
  FULL/CORE.H ::= 'interface'?[T+]?
  FULL.T::= mdf Doc* FP | '\'
  CORE.T::= mdf Doc* P
  FP::=Cs
  P  ::= Thisn.Cs | Any | Void | Library //well formedness: C in Cs not Thisn/Any/Void/Library
_______
#define FULL Expressions
  FULL.eAtomic ::= x | P | 'void' | LL | block | (T e) | \ | \x | 'PathLit
  FULL.ePostfix ::= eAtomic | ePostfix (.m)? '(' par ')' //no space in ePostfix(par)
              | ePostfix (.m)? '[' (par;)* par? ']' | ePostfix STRING
  FULL.par ::= e? xe*
  FULL.eUnary   ::= OPP? ePostfix
  FULL.eBinary0 ::= eUnary (OP0 eUnary)* //right associative, all ops must be the same
  FULL.eBinary1 ::= (eBinary0 OP1)* eBinary0 //left associative, all op the same
  FULL.eBinary2 ::= (eBinary1 OP2)* eBinary1 //unassociative, all op the same, thus a<b<c could be resolved as a.#left#1(center:b,right:c)
  FULL.eBinary3 ::= (eBinary2 OP3)* eBinary2 //left associative, all op the same
  FULL.block ::= '(' DE* e ')' | '(' DE+ K* WOPS? (DE* e)? ')' | '{' DE* (DE K+ WOPS? DE*)? '}'
  FULL.DE  ::= (DX =)? e
  FULL.DX  ::= 'var'? T? x | T? '(' ('var'? T? x)+ ')'
  FULL.WOPS ::= wops T+
  FULL.K   ::= catch throw? T x e
  FULL.statement  ::= sIf | sWhile | sFor | 'loop' e | throw e | x OP_UPDATE e
  FULL.sIf  ::= 'if' e e ('else' e)? | 'if' match+ e
  FULL.match ::= T x | T x = e | T? '(' (T? x)+ ')' = e //where at least one Ti? is not empty
  FULL.sWhile::= 'while' e e
  FULL.sFor ::= 'for' (DX in e)* e
  FULL.e  ::= statement | e-binary3
  FULL.L ::= {(H | ... | reuse[URL])? M*}
  LL::= FULL.L | CORE.L
  FULL.M  ::= F | MI | MWT | NC 
  FULL.F  ::= 'var'? T x
  FULL.MI ::= Doc* s = e
  FULL.MWT ::= MH (= e)?
  FULL.NC ::= Doc* C = e
_______
#define Abstract syntax and core
  CORE.e ::= x|(T P)|void|L|xP.m(x1=e1..xn=en)|loop e|throw e|x:=e|(Ds Ks e)
  CORE.xP::= x|(T P)
  CORE.D ::= var? T x=e
  CORE.K ::= catch throw T x e
  CORE.NC::= Docs C = L
  CORE.L ::= {H Docs MWTs NCs Info}
  Info::= [Flag;typeDep=Ps;coherentDep=Ps;friendsDep=Ps;usedMethDep=(P.s)s;privateImpl=Ps]
    //friendsDep are spyed by This:
    //Paths whose unique numbers are used either directly,
    //or in a private nested class or in an L in a method
    //usedMethDep//methods used either directly or ...
    //privateImpl: interfaces implemented by a private nested class or in an L in a method
  Flag ::= 'norm' | typed
  typed::= 'coherent'?
  FULL.e ::= x | P | void | LL | \ | \x  
    | e strLit[e1..en] | 'PathLit | OPP e
    | e0 OP .. OP en | (T e)
    | e .m? ( par ) | e .m? [ pars ]
    | ( DEs Ks Wops? DEs e? ) | { DEs Ks Wops? DEs }
    | loop e | throw e | x OP_UPDATE e
    | if e0 e1 (else e2)? | if match+ e | while e0 e1
    | for DX0 in e0 .. DX1 in en e
  FULL.strLit[e1..en] = STR_OPi' STR_CHARSi STR_OPi e1 STR_CLi CHARSi1 .. STR_OPi en STR_CLi CHARSin 'STR_CLi

-----------------------------------
Part 3: well formedness
-----------------------------------

* block ( DEs Ks Wops? DEs e? )
  if block of form (_ DE e _), then noBlockNeeded(DE.e)
  if block of form (_ K e _), then noBlockNeeded(K.e)
_______
#define noBlockNeeded(e):
  noBlockNeeded(B)
  noBlockNeeded(throw e)
  noBlockNeeded(x OP_UPDATE e)
  noBlockNeeded(loop e)= 
    noBlockNeeded(if match+ e)=noBlockNeeded(if e0 e)=
    noBlockNeeded(if e0 e1 'else' e)= 
    noBlockNeeded(while e0 e)=noBlockNeeded(for (DX in e)* e)=
      noBlockNeeded(e)

* DE: var T x=e is valid only if T not capsule or fwd.
  if e = DE, that is,(DX=)?=empty, then e not of form x, P, void, LL, \, \x or 'PathLit
  //none of those would make sense anyway, sadly do not helps with parsing a()(), immagine a+b (c).

* s: 'this' notin xs and all x in xs are unique

* MH: 'Any' notin [Ts] //Ts is thrown exceptions //TODO: why??? should we remove this restriciton? 24/10/2018

* mdf: fwd%Imm, fwd%mut not present in any term, will be used internally by the type system

* NC: NC.C not Any, Library, Void, This, Thisn

* FULL.Cs: only the first C can be This or Thisn, 
    Cs can contains Library, Void, Any only if Cs=C
* CORE.Cs: not contain Library, Void, Any, This, Thisn

* loop P, loop x, loop void, loop LL, not well formed
* (ds1 ks ds2 e): unique x in dom(ds1,ds2), FV(ks) disjoint dom(ds1,ds2)

  //C=e:  FV(e)=empty subsumed by next check
* C=e: //checks for capsuleWellFormed and absence of free variables
   cX(e)=empty  //FV(e)=empty this is implied
   //Note: need to be checked again after normalization

* MWT: Ts=parameter types, T=return type
  if exists fwdImm _ in Ts then T.mdf in {mut, fwdMut, imm, fwdImm}
  if exists fwdMut _ in Ts then T.mdf in {mut, fwdMut}
  if T.mdf in {fwdImm,fwdMut} then exists fwdImm _ in Ts or fwdMut _ in Ts

* MWT:  //checks for capsuleWellFormed// normalization can inject a capsule parameter in a 's=e'
  MWT= refine? mdf method T m(T1 x1.. Tn xn)[Ts]e
  T0=mdf This0
  FV(e)\ this,x1..xn= empty
  for i in 0..n if Ti=capsule _, xi in cX(e) 0 or 1 times
  //Note: need to be checked again after normalization

* for: in a for header, in the  DX of form T?(var1? T1? x1.. varn?Tn? xn),  var1?..varn?=empty
_______
#define     //note: FV is trivially defined from cX
cX(e)//count occurences of xs
  cX(x)=x
  cX(void)=cX(P)=cX(L)=empty
  cX(throw[T1,T2] e)=cX(e)
  cX(loop e)=cX(e),cX(e)  //representing each variable twice is enough to make capsule tests work
  cX(e0.m[T](x1:e1..xn:en) )=cX(e0),..,cX(en)
  cX(use P check m(x1:e1..xn:en) e0)=cX(e0),..,cX(en)
  cX( (T1 x1=e1.. Tn xn=en k1..km e0[T]) )=ys/x1..xn ,max( (xs0/x1..xn), xs1,..,xsm)
    where
    ys=cX(e1),..,cX(en)
    xsi=cX(ki)
    xs0=cX(e0)
    if Ti=capsule _ then
      xi 0 or 1 times in ys,xs0
_______
#define max(xs1,..,xsn)= zs // as many repetition of each x as in the most repetitive of xs1..xsn
  max(ys)=max(empty,ys)=ys
  max (x xs,ys)=x max(xs,ys) if x not in ys
  max (x xs,ys)=x max(xs,removeOne(x,ys))
  max(xs, xs0,..,xsn) = max(max(xs,xs0),xs1,..,xsn)


* \x only appear in a method parameter expression
* block of form { DEs1 Ks WOPS? DEs2}: returning({ DEs1 Ks WOPS? DEs2}) must hold
* block of form (DEs1 Ks WOPS? DEs2 e):
    forall DE in DEs1,DEs2: not returning(DE)
* block of form (DE* e K+ WOPS?):
    forall DE in DE*: not returning(DE) 
_______
#define returning({ DEs1 Ks WOPS? DEs2})
  returning({ DEs1 Ks WOPS? DEs2})=returning({ DEs1 Ks DEs2})
  returning({ DEs1 Ks DEs2}) iff
    DEs,DE=DEs1,Des2
    returning(DE)
    forall DE' in DEs: not returning(DE') //dead code after
    forall catch throw T x e' in Ks: returning(e')
 returning(loop e)
 returning(throw e)
 returning(loop e)
 returning(if _ e1 else e2) iff 
   returning(e1) and returning(e2)
 returning( (DEs1 Ks WOPS? DEs2 e) ) iff
   returning(e)
   forall catch throw T x e' in Ks: returning(e')

* e: an e that is a body of a method cannot contain FULL.L.

* L:
  * if C::n in dom(L) or m::n(xs) in dom(L), then for any other L' in the project, C'::n notin dom(L') and m'::n(xs') notin dom(L')
  * M1, M2 in dom(L) and dom(M1)=dom(M2) implies M1=M2
  * Any notin H
  * Exists at most one n such that exists m::n(xs) where L(m::n(xs))=MWT, and MWT.e? is empty
  * if H.interface? = interface, then forall s in dom(L), L(s).e?=empty
  * if H.interface? = interface, then forall m::n(xs),  m::n(xs) notin dom(L) //TODO: may be we need private methods in interfaces for the new rename
   
TODO: CORE.L:
  *difficult: need to be normalized, but that depends on a program p...
  So, is ti well formedness on a project?
  We can not ask that if a LL is a CORE.L then all the dependencies are core.
  What about checking during type checking? so a CORE.L would be not well typed but well formed...
  