Full 42 syntax

-----------------------------------
Part 0: general discussions:
-----------------------------------
only character drown on conventional English keyboards (except 'tab')
can be in the input file.
Comments are normal // and /**/. Comments and are discarded. This changed from last time
Docs have a different syntax, are aware of Paths and are kept and adapted during metaprogramming,
but only exists in few crucial points in the syntax.

Outside of comments and docs; space, newline and ',' are all just spacing characters

-----------------------------------
Part 1: boring part, identifiers and other stuff
-----------------------------------
char   ::=  all the ones drown on English keyboards except 'tab' :-)
chars0 ::= all chars sequences excluding "
charsi ::= all chars sequences excluding StrOpi and StrCli", for i!=0
StrOp0 ::=empty
StrCl0 ::=empty
StrOpi+1 ::= [StrOpi
StrCli+1 ::= StrOCl]
StrLit  ::= StrOpi" charsi (StrOpi e StrCli charsi)* "StrCli

NumLit::= (0..9)+ ((.|_|-) (0..9)*)*

//for under: This and Thisn are valid C, is just going to be well formedness to avoid issues
Doc ::= @PathLit | @PathLit?{charsWithBalancedCurly}
PathLit::= Cs | (C.)* s | (C.)* s.x

x ::= LowChar charId* | _ // '_' will be replaced with a fresh name
C ::= UpChar charId* (_n) //the unique number
UpChar ::= _* (A..Z | $) 
LowChar::= _* a..z
charId   ::= a..z |A..Z| $ | _ | 0..9
URL::= /*too boring*/
s  ::= Doc* mOp(x*)
Ldom::=s|Cs
Tx ::= T x
mdf::= empty | mut | lent | read | capsule | fwd mut | fwd | class | fwd%Imm | fwd%mut
T  ::= mdf P Doc* | \
P  ::= Cs | Any | Void | Library //Thisn can be a C
MH ::= Doc* refine? (native[URL])? mdf method T mOp(Doc* Tx*) [T+]? //the Doc after the '(' is conceptually on the this type.
Cs ::=C(.C)*  //Is it the only sequence where we need a separator? 
throw::= error | exception | return
m ::= (# | #$)?x(#x+)* (_n)? //the unique number, the '_' is not the concrete syntax, we need to find a better one
mOp::= empty | m| op | ! | ~
op0 ::= ^ | : | <- | << | & | '|'
op1 ::= + | - | * | / | ++ | -- | ** | >> | ->
op2 ::= == | != | < | > | >= | <=
op3 ::= => | && | || //will be short circuting
op  ::= op0 | op1 | op2 | op3 
updateOp ::=  := | op0= | op1= // except ':' from op0; op2 and op3 are dangerous to lift to updateOp


-----------------------------------
Part 2: core
-----------------------------------
All metavariables declared here can be used in the full language only inside of a core(..) block.
Now all core expressions are normalized expression
P  ::= Thisn.Cs | Any | Void | Library //here we mean that Ps and Ts in the core are a subset of the Ps,Ts in the full.
T  ::= mdf P Doc* //even Docs containing Ps will have Ps from the subset.
e   ::= x | (T P) | void | L |  xPP.m( x1=e1 .. xn=en ) | loop e | throw e | x := e | (D* K* e)
xPP  ::=x|(T P)
D   ::= var? T x=e
K   ::= catch throw T x e //of course e is a core(e)
NC  ::= Doc* C=L 
MWT ::= MH=e | MH 
L   ::= interface?[T+]?{Info Doc* MWT* NC*}
Info::=[Flag;
  P*;//typeDep
  P*;//coherentDep
  P*;//friendsDep
  //Paths whose unique numbers are used either directly,
  //or in a private nested class or in an L in a method
  P.s*;//usedMethDep//methods used either directly or ...
  P* //interfaces implemented by a private nested class or in an L in a method
  ]
Flag::= norm |typed 
typed::=uncoherent | coherent

Core Well formedness:
* under a p an L need to mention all the methods of all implemented interfaces,
  and all list all the transitively implemented interfaces.
* P are not of form mdf Cs Doc (that is, without the 'Thisn.')
* Core well formedness also inherits all the well formedness of the full language
   
-----------------------------------
Part 3: full LL
-----------------------------------

H  ::= interface? [T+]? | reuse [URL]
LL  ::= H{M*}
M  ::= NC | MWT | MI | F 
NC ::= Doc* C = e
MWT::= MH (= e)?
MI ::= s  = e
F  ::= var? T x

-----------------------------------
Part 4: expressions and statements
-----------------------------------
  
//atomic expression
L::=LL|core(L)
ae ::= '...' | x | P | void | L | B | (T e) | \ | \x | 'PathLit // 'stuff == \"stuff"
//post operators expression
pe ::= ae | pe(.m)?'(' par ')' | pe'(' par ')' | pe(.m)?[ (par;)*par? ] | pe StrLit
//no space between pe( otherwise it can be parsed as pe B
//or, easier to parse: if an expression ends with ')' ']' or '"', and there next character is 
'(', then we are in the pe'(' par ')' case, otherwise the pe is terminated.
par::= e? xe*
xe ::= x = e
//unary expression
ue ::= pe | !pe | ~pe | NumLit pe
//binary expressions 
b0e ::= ue0 (op0 ue1 .. op0 uen) //right associative, all op the same
b1e ::= b0e0 (op1 b0e1 .. op1 b0en) //left associative, all op the same
b2e ::= b1e0 (op2 b1e1 .. op2 b1en) //unassociative, all op the same, thus a<b<c could be resolved as a.#left#1(center:b,right:c)
b3e ::= b2e0 (op3 b2e1 .. op2 b2en) //left associative, all op the same
//block
B   ::= '(' BIN ')' | '{' DE* (DE K+ WOPS? DE*)?  '}'
BIN ::= DE* e | DE+ K+ WOPS? DE* e | DE* e K+ WOPS?
DE  ::= (DX=)? e
DX  ::= var? T? x | T?(var1? T1? x1.. varn?Tn? xn)
K   ::= catch throw? T x e
WOPS::= wops T+
//statements (just another kind of expression)
S  ::= IF | While | For | loop e | throw e | x updateOp e
IF  ::= if e0 e1 (else e2)? | if tMatch+ e
tMatch::= T x | T x=e | T0?(T1? x1..Tn? xn)=e //where at least one Ti? is not empty
While::= while e0 e1
For ::= for DX0 in e0 .. DXn in en e
e  ::= S | b3e

-----------------------------------
Part 5: full grammar abstract syntax
-----------------------------------
For Isaac: is the following equivalent to the full grammar (Part4), except for precedence enforcements?
In this version, more friendly for formalism, we omit '[' and ']' around implemented interfaces and thrown exceptions.
We also omit '=' before method bodies.
_______
#define FullE

DE::= (DX=?) e
e::= ... | x | P | void | L  | (T e) | \ | \x | 'PathLit
 | throw e | loop e | e StrLit | ~e |!e 
 | NumLit e | x updateOp e 
 | e(.m)?(par)
 | e[pars]
 | e1 op ..op en
 | ( DEs Ks Wops? DEs2 e? )  
 | { DEs Ks Wops? DEs2 }
 | if e0 e1 (else e2)?
 | if tMatch+  e
 | while e1 e2
 | for DX0 in e0 .. DXn in en e


-----------------------------------
Part 6: well formedness, to complete
-----------------------------------

* MWT: MWT.e can not contain LL, only core(L) is allowed

* s=e: e can not contain LL, only core(L) is allowed


* BIN:
  if BIN of form DE*1 DE e DE*2 e0, then noBlockNeeded(DE.e)
  if BIN of form DE*1 K* K e DE*2 e0, then noBlockNeeded(K.e)
  if BIN of form DE*1 K* K e, then noBlockNeeded(loop K.e)
  if BIN of form DE*1 DE e, then noBlockNeeded(DE.e)
_______
#define noBlockNeeded(e):
  noBlockNeeded(B)
  noBlockNeeded(b3e)
  noBlockNeeded(S)
   if S is of form 'while e0 e', 'if e0 e', 'for DXe+ e', 'if e0 e1 else e' or 'loop e'
   then e must be of form 'B', 'throw _', 'loop _' or 'void'
   

* L: if C__n in dom(L) or m__n(xs) in dom(L),
  then for any other L' in the project
  C'__n notin dom(L') and m'__n(xs') notin dom(L')

* DE: var T x=e is valid only if T not capsule or fwd.
  if e = DE, that is,(DX=)?=empty, then e not of form '...', x, P, void, L, core(L), \, \x or 'PathLit
  //none of those would make sense anyway, and it helps with parsing a()()

* s: 'this' notin xs and all x in xs are unique

* MH: 'Any' notin [Ts] //Ts is thrown exceptions //TODO: why??? should we remove this restriciton? 24/10/2018

* mdf: fwd%Imm, fwd%mut not present in any term, will be used internally by the type system

* NC: NC.C not Any, Library, Void, This, Thisn

* L: unique LDom in dom(L), Any notin [Ts] //Library and Void are not interfaces so you will get the normal error from implementing them
    Exists 0 or 1 n such that exists m__n(xs) where L(m__n(xs))=mwt, mwt.e? is empty

* L interface:
   methods in interfaces have no body
   forall m__n(xs),  m__n(xs) notin dom(L)

* loop P, loop x, loop void, loop L, not well formed
* (ds1 ks ds2 e): unique x in dom(ds1,ds2), FV(ks) disjoint dom(ds1,ds2)

* native[P]: P not Any/Void/Library

//C:e :  FV(e)=empty subsumed by next check

* C:e : //checks for capsuleWellFormed and absence of free variables
   cX(e)=empty  //FV(e)=empty this is implied
   //Note: need to be checked again after normalization

* mwt: Ts=parameter types, T=return type
  if exists fwdImm _ in Ts then T.mdf in {mut, fwdMut, imm, fwdImm}
  if exists fwdMut _ in Ts then T.mdf in {mut, fwdMut}
  if T.mdf in {fwdImm,fwdMut} then exists fwdImm _ in Ts or fwdMut _ in Ts

* mwt:  //checks for capsuleWellFormed// normalization can inject a capsule parameter in a "s=e"
  mwt= refine? mdf method T m(T1 x1..Tn xn)[Ts]e
  T0=mdf This0
  FV(e)\ this,x1..xn= empty
  for i in 0..n if Ti=capsule _, xi in cX(e) 0 or 1 times
  //Note: need to be checked again after normalization

* for: in a for header, in the  DX of form T?(var1? T1? x1.. varn?Tn? xn),  var1?..varn?=empty
_______
#define     //note: FV is trivially defined from cX
cX(e)//count occurences of xs
  cX(x)=x
  cX(void)=cX(P)=cX(L)=empty
  cX(throw[T1,T2] e)=cX(e)
  cX(loop e)=cX(e),cX(e)  //representing each variable twice is enough to make capsule tests work
  cX(e0.m[T](x1:e1..xn:en) )=cX(e0),..,cX(en)
  cX(use P check m(x1:e1..xn:en) e0)=cX(e0),..,cX(en)
  cX( (T1 x1=e1..Tn xn=en k1..km e0[T]) )=ys/x1..xn ,max( (xs0/x1..xn), xs1,..,xsm)
    where
    ys=cX(e1),..,cX(en)
    xsi=cX(ki)
    xs0=cX(e0)
    if Ti=capsule _ then
      xi 0 or 1 times in ys,xs0
_______
#define max(xs1,..,xsn)= zs // as many repetition of each x as in the most repetitive of xs1..xsn
  max(ys)=max(empty,ys)=ys
  max (x xs,ys)=x max(xs,ys) if x not in ys
  max (x xs,ys)=x max(xs,removeOne(x,ys))
  max(xs, xs0,..,xsn) = max(max(xs,xs0),xs1,..,xsn)


* B of form { DEs1 Ks WOPS? DEs2} returning({ DEs1 Ks WOPS? DEs2}) must hold
* B of form (DEs1 Ks WOPS? DEs2 e)
    forall DE in DEs1,DEs2: not returning(DE)
* B of form (DE* e K+ WOPS?)
    forall DE DE*: not returning(DE) 
_______
#define returning({ DEs1 Ks WOPS? DEs2})
  returning({ DEs1 Ks WOPS? DEs2})=returning({ DEs1 Ks DEs2})
  returning({ DEs1 Ks DEs2}) iff
    DEs,DE=DEs1,Des2
    returning(DE)
    forall DE' in DEs: not returning(DE') //dead code after
    forall catch throw T x e' in Ks: returning(e')
 returning(loop e)
 returning(throw e)
 returning(loop e)
 returning(if _ e1 else e2) iff 
   returning(e1) and returning(e2)
 returning( (DEs1 Ks WOPS? DEs2 e) ) iff
   returning(e)
   forall catch throw T x e' in Ks: returning(e')
 //forall DE in DEs1,DEs2: not returning(DE) already in block well formedness
 //returning(T x=e) does not hold, so DE must be of form e for returning to hope to hold 


//TODO: alive and similar was well formedness somewhere... recover them
//TODO: Cs and similar may only start for This or Thisn but not have it in the middle. 
