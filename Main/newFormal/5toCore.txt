_______
#define p♥CMP.M = HALF.M //assert never happens p♥C:Full.L or p♥s e
* p♥MH = MH 
* p♥MH e = MH Y[p=p,onSlashX=empty,onReturn=MH.T,onPath=MH.T]♥e
* p♥CORE.NC = CORE.NC 
_______
#define Y♥CMP.e = HALF.e //unicode characters to disambiguate equals and parenthesis =() ⚌❪❫ ᙿ≝≖᐀ //what is the best =?
* Y♥x = x
* Y♥void = void
* Y♥CORE.L = CORE.L
* Y♥\ = \ 
    Y.onSlashX != empty
* Y♥\ = T
    Y.onSlashX = empty
    Y.onReturn = T
* Y♥\x = (Y.onSlashX).x() //do we also need a 'disambiguation dot'?
* Y♥P = (Y.onPath Y.p.resolveCs(P))
    Y.onPath of form TX
* Y♥P = (class P' P')
    Y.onPath=classP
    P'=Y.p.resolveCs(P)
* Y♥(T P) = ( Y.p.resolveCs(T)  Y.p.resolveCs(P) )
* Y♥(T e) = ❪T' x≖Y[onReturn=T']♥e x ❫ //do we see an improvement using unicode?
    T'=Y.p.resolveCs(T)
    e not of form P
* Y♥'PathLit = Y♥\"PathLit"
* Y♥NumLit e = Y♥e"NumLit"
* Y♥throw e = throw Y[onReturn=empty;onPath=classP]♥e //we set onReturn=empty to avoid 'return {}'
    //We can never return class Any anyway, or we could catch return class P on a non coherent P
* Y♥loop e = loop Y[onReturn=imm Void;onPath=classP]♥e
* Y♥~e = Y[onPath=classP]♥e.methName(~)()
* Y♥!e = Y[onPath=classP]♥e.methName(!)()
* Y♥ x updateOp e =  Y♥toBinOp(x, updateOp) e)
* Y♥e(.m)?(par) = Y♥(x=e x.methName(m?)(par))
    e not of form xP
    x fresh
* Y♥xP(.m)?(par) = Y[onPath=classP]♥xP.methName(.m?)( Y'♥par )
    Y'=Y[onSlashX=x;onReturn=\;onPath=\]
* Y♥e1 OP3 e2= (x=Y♥e1 Y♥x OP3 e2 )
    e1 not of form xP //OP3: &&, || and => are not static-dispatch, to have short circuit 
* Y♥xP op3 e= Y♥(
      x=Y(xP.#shortCircut'OP3'())  //here and and under, using ' to generate method names in some standard way
      if x.#shortResult() else x.#shortProcess(Y♥e2) )
    x fresh
* Y♥e0 op .. op en = (Ds e0' op .. op en')
    Yi = Y[onReturn=\;onPath=Xi]//TODO: would this help? using the same fresh X for many P?
    Ds = [xi=Yi♥ei| Yi♥ei not of form xP]
    ei' = Yi♥ei if Yi♥ei of form xP
    ei' = xi otherwise
    x1..xn,X1..Xn fresh
    op not of form op3
    n >= 1
* Y♥( DEs Ks Wops? DEs2) = Y♥(DEs Ks Wops? DEs2 void)
* Y♥( DEs Ks Wops? DE DEs2 e)) = Y♥( DEs Ks Wops? (DE DEs2 e))
* Y♥( DEs Ks wops T1..Tn e) = ( Y♥DEs Y♥Ks K1..Kn Y♥e ) 
    Ki=catch exception Y.p.resolveCs(Ti) xi error xi.#intoErrorAt(that={Info=empty})//so that we can recover the position   
* Y♥{ DEs Ks Wops? DEs2 } = Y0♥(
      (DEs Ks Wops? DEs2 void)
      catch return Y.T x x
      error void )//unreachable thanks to {return} well formedness   
    Y0=Y[onReturn=empty;onPath=classP]//and the value of onPath should never matter 
    x fresh
* Y♥e(.m)?[pars]= Y♥e.m?(squareBuilder:(if \.#shortCircutSquare() (
        b=\.#squareBuilder()     
        b.#add(par1) .. b.#add(parn)) //so \ and \x are about the builder
      b))
    b fresh
* Y♥e StrLit= Y♥
      e.#from(stringLiteral=(
        b=\.#stringLiteralBuilder()
        b.methName(chars0)()//one call for each char
        b.#splice(e1)
        b.methName(chars1)()
        ..
        b.#splice(en)
        b.methName(charsn)()
        b))
    StrLit= chars0 e1 chars1 .. en charsn
* Y♥if e0 e1 = Y♥if e0 e1 else void
* Y♥if e0 e1 else e2 = Y♥( x=e0 if x e1 else e2 )
    e0 not of form xP
* Y♥if xP e1 else e2 = Y♥(
      Void x=xP.#if().#checkTrue()
      catch exception Void x' e2
      e1)
    x, x' fresh
* Y♥if match match+ e = Y♥if match if match+ e
* Y♥if T x e = Y♥if T x'= x e[x=x']
    x' fresh
* Y♥if T x = e e' = Y♥( x'=e if T x= x' e')
    e not of form xP
* Y♥if T x= xP e= (
      T x=(return xP catch return T x1 x1 error void)
      catch return T.mdf Any x2 void
      Y♥e)  
* Y♥if T(T?1 x1 ..T?n x1)=e e0 = Y♥if T x=e ( (x1, ..., xn)=x e1)
    x fresh, Txs=[Ti xi | T?i != empty]
    e1=e0   if Txs=empty
    e1= 'if Txs e0'  otherwise
* Y♥if (T?1 x1 .. T?2 xn)=e e0) = Y♥( (x1 .. xn)=e if Tx e0)
    x fresh
    Tx=[Ti xi | T?i != empty]
* Y♥while e0 e1 = (
      Void x=loop Y♥(e0.#checkTrue() e1)
      catch exception Void x'
      void))
    x,x' fresh
* Y♥for DX1 in e1..DXn in en e = Y♥(
      c1=e1.iterator'var1?'(); .. cn=en.iterator'varn?'();//varIterator if var x in..
      var i1=c1.indexZero() .. var in=cn.indexZero()
      while c1.hasElem(i1) &&..&& cn.hasElem(in) && ( c1.incomplete(i1) ||..||cn.incomplete(in)) (
        DX1 = c1.elem(i) .. DXn = cn.elem(i);
        e[replaceUnOp DX1.x;i1;c1]..[replaceUnOp DXn.x;in;cn]
        i1:=i1.succ() .. in:=in.succ() )
      c1.close(i1) .. cn.close(in))
    c1..cn, i1..in fresh
_______
#define Y♥CMP.par = (x=HALF.e)s    Y♥CMP.DE = HALF.D
* Y♥e xes=  that=Y♥e,Y♥xes
* Y♥x1=e1 .. xn=en=  x1=Y♥e1 .. xn=Y♥en

* Y♥DE= Void x= Y[T=empty]♥e, with DE=e, x fresh //so that ({..return void ..} {.. return void ..}) is a mistake
* Y♥T? _=e= T? x=e
    x fresh
* Y♥var? T? x = e = var? TX x =Y[onReturn=TX,onPath=TX]♥e
    TX=Y.p.resolveCs(T?)
* Y♥T?(var1? T1? x1.. varn?Tn? xn)=e = 
      Y♥T? x=e
      Y♥var1? T1? x1=x.methNameTrim(x1)() //removes any numberPedex from the end
      ..
      Y♥varn? Tn? xn=x.methNameTrim(xn)()
    x fresh

* Y♥catch throw? T '_' e = Y♥catch throw? T x e
    x fresh
* Y♥catch T x e = Y♥catch exception T x e
* Y♥catch throw T x e = catch throw Y.p.resolveCs(T) x Y♥e
_______
#define toBinOp(x,Op=) // convenience method to desugar updateOps
* toBinOp(x, :=) = x :=
* toBinOp(x, OP=) = x := x OP 
_______
#define CMP.e[replaceUnOp x;x0;x1]
* e[replaceUnOp x;x0;x1]=e
    not x updateOp _ inside e
* ctxC[x updateOp e][replaceUnOp x;x0;x1]=
    ctxC[(toBinOp(x, updateOp) e' x1.update(x0, x))][replaceUnOp x;x0;x1]