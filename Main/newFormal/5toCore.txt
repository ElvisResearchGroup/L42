_______
#define p♥CoM = HALF.M //assert never happens p♥C:Full.e or p♥s e
* p♥MH = MH
* p♥MH CMP.e = MH Y[p=p,onSlashX=empty,onReturn=MH.T,onPath=MH.T]♥CMP.e
    CMP.e not of form CORE.e
* p♥CORE.MWT=CORE.MWT//can happen when checking CORE.L well formedness
* p♥CORE.NC = CORE.NC
_______
#define p♥CMP/FULL.TLocal=TX   p♥CsP=P,  p♥CMP/FULL.Docs=CORE.Docs,  p♥CMP/FULL.MH=CORE.MH
* p♥empty=X with fresh X
* p♥(Docs mdf CsP)=p♥Docs mdf p♥CsP
* p♥\ = T
* p♥mdf = mdf X with fresh X 
* p♥P=p.minimize(P)//this also handles CsP starting for Any/Void/Library/Thisn
* p♥C.Cs=p.minimize(Thisn.C.Cs) //not already minimized
    where n is the smallest number such that either
      C in dom(p.get(n))
      or @{__STOP_SCOPE__} in p.get(n).Docs
      or p.get(n+1) undefined

* p♥FULL.Docs =CORE.Docs where all the CsP are replaced with p♥CsP

*p♥FULL.MH propagates on the structure
_______
#define Y♥CMP.e = HALF.e //unicode characters to disambiguate equals and parenthesis =() ⚌❪❫ ᙿ≝≖᐀ //what is the best =?
* Y♥x = x
* Y♥void = void
* Y♥CORE.L = CORE.L
* Y♥\ = \ 
    Y.onSlashX != empty
* Y♥\ = T.P //is this already a P and not a CsP?
    Y.onSlashX = empty
    Y.onReturn = T
* Y♥\x = (Y.onSlashX).x() //do we also need a 'disambiguation dot'?
* Y♥CsP = (Y.onPath Y.p♥CsP)
    Y.onPath of form TX
* Y♥CsP = (class P' P')
    Y.onPath=classP
    P'=Y.p♥CsP
* Y♥(T CsP) = ( Y.p♥T  Y.p♥CsP )
* Y♥(T e) = ❪T' x≖Y[onReturn=T']♥e x ❫ //do we see an improvement using unicode?
    T'=Y.p♥T
    e not of form CsP
* Y♥'PathLit = Y♥\"PathLit"
* Y♥NumLit e = Y♥e"NumLit"
* Y♥throw e = throw Y[onReturn=empty;onPath=classP]♥e //we set onReturn=empty to avoid 'return {}'
    //We can never return class Any anyway, or we could catch return class P on a non coherent P
* Y♥loop e = loop Y[onReturn=imm Void;onPath=classP]♥e
* Y♥~e = Y[onPath=classP]♥e.methName(~)()
* Y♥!e = Y[onPath=classP]♥e.methName(!)()
* Y♥ x updateOp e =  Y♥toBinOp(x, updateOp) e)
* Y♥e(.m)?(par) = Y♥(x=e x.methName(m?)(par))
    e not of form xP
    x fresh
* Y♥xP(.m)?(par) = Y[onPath=classP]♥xP.methName(.m?)( Y'♥par )
    Y'=Y[onSlashX=x;onReturn=\;onPath=\]
* Y♥e1 OP3 e2= (x=Y♥e1 Y♥x OP3 e2 )
    e1 not of form xP //OP3: &&, || and => are not static-dispatch, to have short circuit 
* Y♥xP OP3 e= Y♥(
      x=xP.#shortCircut'OP3'()  //here and and under, using ' to generate method names in some standard way
      if x x.#shortResult'OP3'() else xP.#shortProcess'OP3'(x,other=e2) )
    x fresh  
//    T && X= if !T F else X//shortResult&& is false, shortCircut&& is !this
//    T || X= if T T else X//shortResult|| is true, shortCircut|| is this
//    T => X= if !T T else X//shortResult=> is true, shortCircut=> is !this
//Path=>classAny= if false err else X//shortResult=> is error, shortCircut=> false
* Y♥e0 op .. op en = (Ds e0' op .. op en')
    Yi = Y[onReturn=\;onPath=Xi]//TODO: would this help? using the same fresh X for many P?
    Ds = [xi=Yi♥ei| Yi♥ei not of form xP]
    ei' = Yi♥ei if Yi♥ei of form xP
    ei' = xi otherwise
    x1..xn,X1..Xn fresh
    op not of form op3
    n >= 1
* Y♥( DEs Ks Wops? DEs2) = Y♥(DEs Ks Wops? DEs2 void)
* Y♥( DEs Ks Wops? DE DEs2 e)) = Y♥( DEs Ks Wops? (DE DEs2 e))
* Y♥( DEs Ks wops T1..Tn e) = ( Y♥DEs Y♥Ks K1..Kn Y♥e ) 
    Ki=catch exception Y.p♥Ti xi error xi.#intoErrorAt(that={Info=empty})//so that we can recover the position   
* Y♥{ DEs Ks Wops? DEs2 } = Y0♥(
      (DEs Ks Wops? DEs2 void)
      catch return Y.T x x
      error void )//unreachable thanks to {return} well formedness   
    Y0=Y[onReturn=empty;onPath=classP]//and the value of onPath should never matter 
    x fresh
* Y♥e(.m)?[pars]= Y♥e.m?(squareBuilder:(if \.#shortCircutSquare() (
        b=\.#squareBuilder()     
        b.#add(par1) .. b.#add(parn)) //so \ and \x are about the builder
      b))
    b fresh
* Y♥e StrLit= Y♥
      e.#from(stringLiteral=(
        b=\.#stringLiteralBuilder()
        b.methName(chars0)()//one call for each char
        b.#splice(e1)
        b.methName(chars1)()
        ..
        b.#splice(en)
        b.methName(charsn)()
        b))
    StrLit= chars0 e1 chars1 .. en charsn
* Y♥if e0 e1 = Y♥if e0 e1 else void
* Y♥if e0 e1 else e2 = Y♥( x=e0 if x e1 else e2 )
    e0 not of form xP
* Y♥if xP e1 else e2 = Y♥(
      Void x=xP.#if().#checkTrue()
      catch exception Void x' e2
      e1)
    x, x' fresh
* Y♥if match match+ e = Y♥if match if match+ e
* Y♥if T x e = Y♥if T x'= x e[x=x']
    x' fresh
* Y♥if T x = e e' = Y♥( x'=e if T x= x' e')
    e not of form xP
* Y♥if T x= xP e= (
      T x=(return xP catch return T x1 x1 error void)
      catch return T.mdf Any x2 void
      Y♥e)  
* Y♥if T(T?1 x1 ..T?n x1)=e e0 = Y♥if T x=e ( (x1, ..., xn)=x e1)
    x fresh, Txs=[Ti xi | T?i != empty]
    e1=e0   if Txs=empty
    e1= 'if Txs e0'  otherwise
* Y♥if (T?1 x1 .. T?2 xn)=e e0) = Y♥( (x1 .. xn)=e if Tx e0)
    x fresh
    Tx=[Ti xi | T?i != empty]
* Y♥while e0 e1 = (
      Void x=loop Y♥(e0.#checkTrue() e1)
      catch exception Void x'
      void))
    x,x' fresh
    
* Y♥for (DX in x)s DX in e (DX in e)s e = (x=e Y♥for (DX in x)s DX in x (DX in e)s e)    
* Y♥for DX1 in x1..DXn in xn e = Y♥(
      c1=x1.iterator(); .. cn=xn.iterator();
      var i1=x1.indexZero() .. var in=xn.indexZero()
      while c1.hasElem(i1) &&..&& cn.hasElem(in) && ( c1.incomplete(i1) ||..||cn.incomplete(in)) (
        DX1 = elemOf(DX1,c1,i1) .. DXn = elemOf(DXn,cn,in)
        e[replaceUnOp DX1;i1;c1]..[replaceUnOp DXn;in;cn]
        i1:=i1.succ() .. in:=in.succ() )
      c1.close(i1) .. cn.close(in))
    c1..cn, i1..in fresh
_______
#define Y♥CMP.par = (x=HALF.e)s    Y♥CMP.DE = HALF.D
* Y♥e xes=  that=Y♥e,Y♥xes
* Y♥x1=e1 .. xn=en=  x1=Y♥e1 .. xn=Y♥en

* Y♥DE= Void x= Y[T=empty]♥e, with DE=e, x fresh //so that ({..return void ..} {.. return void ..}) is a mistake
* Y♥TLocal _=e= Y.p♥TLocal x=Y'♥e
    TX=Y.p♥TLocal
    Y'=Y[onReturn=TX,onPath=TX]
    x fresh
* Y♥var? TLocal x = e = var? TX x =Y'♥e
    TX=Y.p♥TLocal
    Y'=Y[onReturn=TX,onPath=TX]
* Y♥TLocal(var1? TLocal1 x1.. varn? TLocaln xn)=e = 
      Y♥TLocal x=e
      Y♥var1? TLocal1 x1=x.methNameTrim(x1)() //removes any numberPedex from the end
      ..
      Y♥varn? TLocaln xn=x.methNameTrim(xn)()
    x fresh

* Y♥catch throw? T '_' e = Y♥catch throw? T x e
    x fresh
* Y♥catch T x e = Y♥catch exception T x e
* Y♥catch throw T x e = catch throw Y.p♥T x Y♥e
_______
#define toBinOp(x,Op=) // convenience method to desugar updateOps
* toBinOp(x, :=) = x :=
* toBinOp(x, OP=) = x := x OP 
_______
#define CMP.e[replaceUnOp DX;x0;x1]
* e[replaceUnOp DX;x0;x1]=e
    DX.x undefined or not DX.x updateOp _ inside e
* ctxC[DX.x updateOp e][replaceUnOp DX;x0;x1]=
    ctxC[(toBinOp(DX.x, updateOp) e' updateOf(DX,x1,x0))][replaceUnOp DX;x0;x1]
_______
#define elemOf(DX,c,i)=e    updateOf(DX,c,i)=e
* elemOf(DX,c,i) = c.methName('elem',mdf?)(that=i)
    mdf? = DX.TLocal.mdf if DX.TLocal.mdf defined
    mdf? = empty otherwise  

* updateOf(DX,c,i) = c.methName('update',mdf?)(that=i,val=DX.x)
    mdf? = DX.TLocal.mdf if DX.TLocal.mdf defined
    mdf? = empty otherwise  