All notations:
Common for all parts:
[from P]
p operations
function notations
inside
MH/MWT notations
cX/FV
p|-T0<=T1, p|-P0<=P1, p|-T<=Tz  
trustedClass(CORE.L)
----
__________________
top level notation (file top)
p ==> p'
  adapt(CORE.e,P)
  followUrls
  readFolder
  refreshUniqueNames(CORE.L)
  |- p -> LL
    typable(p)=Csz
    LL[Csz=Flag]=LL'
uses major
  coherentClasses(p,CORE.e)
  p|-CORE.e :CORE.T
  |- p
  Y♥C.e/p♥C.M
  norm(p,C.L)
  e -->p e'  

__________________
check coherence: (file top)
coherentClasses(p,CORE.e)
  coherent(p)
  coherentGetMdf(mdf0,mdf1,mdfs0,mdfs1)
    fieldTypes(MHs,x, mdf)
    fieldAccessMdf(MHs,x, mdf)

__________________
expression type system 
p|-CORE.e :CORE.T

__________________
normalization (file norm)
norm(p,C.L)
  collectDeps(CORE.L)
    collectDepsE(CORE.e)
  expandFields(Ms)
  collect(p,Ts)
  methods(p,P0)
  alive(p,P)


_________________________
inference //HERE: i'm checking what inference is using
infer(p,FULL.Ms)=CORE.Ms
  solve(p, CCz)
    commonSuperT(p,Tz)=Tz'
    chooseT(CCz;Tz)=T
      mostSpecific(Tz) = T
  unsatisfiable(CCz)
      origin(s; P)
  PAcc operations: .fixInfer(HALF.Ms) =CCz and .collect()=PAcc'
uses major
  Y♥C.e/p♥C.M
  
 
Main concepts:

-most important grammatic forms:
FULL.e: the expressive syntax for expressions used by the programmer
CORE.e: the minimal syntax used as internal representation and convenient for metaprogramming.
FULL.L: library literal with expressive syntax.
CORE.L: library literal with minimal syntax.
LL: either a FULL.L or a CORE.L
p: a program; similar to a stack of LL to represent nested scopes.
P: a path
CORE.T/FULL.T: types
ctxC: forall ctxC, all LL top-left of the hole are of form CORE.L
  The compilation context, e=ctxC[LL] selects an LL where
  all of the former LLs are CORE.L
  The context does not enter into libraries

-most important operations:
p(P):
  extract a library from a program
p==>p'
  top level reduction
e-->p e'
  expression reduction. It can uses native code to call functionalities
  outside of L42. Some of those are 'trusted and internally implemented'.
  All other ones are properly sandboxed.
norm(p,LL)
  reduces some libraries in the top of the program to core. 
p|-e:T
  expression well typed.
|-p->LL
  type some libraries in the top of the program and annotate them as 'typed'
  or 'coherent'; that is, executable. 


PAcc, I, Y: record contexts for normalization

execution flow:
  'L42 name' works as follow:
    -reads a file called either name.L42 or name/This0.L42.
      The file is parsed according to grammar LL
    -syntactic well formedness is checked
    -rules p==>p' are applied until the result is a well typed CORE.L
      Such rules may require to 
        -read code from urls; such code must be typed CORE.L. It could be cached locally.
        -read code from files, this will be parsed and integrated in the execution.
        -p♥Full.L
        -p:e:T
        -|-p->LL
        
Program p discussion:
Program-specific grammar is needed to represent the position
in the project (top level Library) that we are reducing.
For example, if our 42 project is
{ A=... B=This0.A.second({ method Library m(){C=This2.A.first({})} }) }
we first need to reduce "A.first({})"
In order to explicitly denote the meaning of "Thisn", we split the project
into the 3 part program
p={C=This2.A.first({})};{ method Library m()[]};{ A=... B=This0.A.second([]) }
Note that the first component is an L, while the others have a hole, [],
so they are of form ctxL.
Note how the first component uses This2.A in order to skip two levels
and refer to A in the outer most layer of our project.

It is possible to see the program as a stack, with a top() and a pop() operation.
Given a program is always possible to reconstruct the project
by doing a series of pop operations.
Since the top of the stack is of a different kind with respect to the other elements,
pop replaces the [] with the stack top to forge an L
push, the opposite of pop, extracts a piece of the top to forge a new top.
To do so, it takes in input the split form of the old head.
Finally, notice how in this model updating the top  can not be emulated with pop() + push()

Methods and collect discussion
methods(p,P0)=MWTs //methods returns a set: the order of the methods is not relevant
//methods(), applied to a CORE.L will just return the MWTs;
//applied to a FULL.L, will return a merge of the methods retrieved directly from the L and methods types declared
//in its implemented interfaces. It chooses a type in case of different refines in interface diamond implementations
//In this model cases like
//    A=  interface {refine method A m()}
//    B= [A]{ method A m()}
//are ok wrt B but fail for A

Collect performs a depth first but we avoid duplicates by keeping the rightmost occurrence.
We check absence of circularity by diverging
an implementation could keep a list of visited P instead of diverging; mathematically it is the same

        
--------------------------------------------
3 Multiple method types   T0..Tn-> T';Ps in methTypes(p,P,s)
--------------------------------------------
The main idea giving flexibility to the 42 type system is that
methods have many types, where only the modifiers change.
It can be seen as a form of polymorphism of the method types.
We here express the methodTypes set with metarules,
but a finite/predictable sequence of applications is always sufficient,
as shown later
  