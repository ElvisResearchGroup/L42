Motivation for the current design: since A.B,A.C may still be in need of being resolved,
Consider the  following:
  Res={method A.B foo()} + {method A.C foo()}
  A=Something.foo()
What should Res be?  {method A.B foo()} or {method A.C foo()}?
Both solution are ok w.r.t. meta level soundness.
But if we swap the line, then we would have either A.B>A.C or vice versa (or error)
thus swapping the line may change the result of the sum, and I do not like that.
Thus,we do not even look in A.B/A.C; and if a method is already beating another type, then it is
ok to chose the more refined version. But only using this local reasoning inside the bubble.

Note: interfaces can watch if they have private nested classes that are watching.
Note: interfaces can be watched if they have private nested classes that are watched.

PLUS::=PLUS[p;C;topLeft;topRight;Cs;Cs1->Pz1..Czn->Pzn]
iMWT::=interface?MWT
_______
#define p;C|- CORE.L1 + CORE.L2 = CORE.L3
* p;C|- L1 + L2 = L  //note: implicitly requires well formedness of the resulting L
    Cs1->Csz1 .. Csn->Cszn =transitiveMap(L1,L2) 
    forall Cs in allHiddenSupertypes(L1): L2(Cs)>L1(Cs) does not hold
    forall Cs in allHiddenSupertypes(L2): L1(Cs)>L2(Cs) does not hold
    PLUS=PLUS[p;C;topLeft=L1;topRight=L2;Cs1->Pz1 .. Csn->Pzn]
    L = L1 PLUS L2
_______
#define singleMap(L1,L2)=Cs->Csz    transitiveMap(L1,L2)=Cs->Csz
* Cs' in singleMap(L1,L2)(Cs)
    Cs and Cs' has no unique n
    {1,2}={i,j}
    Cs in dom(Li)
    This0.Cs' in Li(Cs).Ts.Ps[from Cs;{}]
    Lj(Cs')>Li(Cs')
* Cs" in singleMap(L1,L2)(Cs)
    Cs' in singleMap(L1,L2)(Cs)
    This0.Cs" in L1(Cs').Ts.Ps[from Cs;{}] U L2(Cs').Ts.Ps[from Cs;{}]

* Cs' in transitiveMap(L1,L2)(Cs)
    Cs' in singleMap(L1,L2)(Cs)
* Cs" in transitiveMap(L1,L2)(Cs)
    Cs' in transitiveMap(L1,L2)(Cs)
    Cs" in singleMap(L1,L2)(Cs')
_______
#define Cs/Cs'=P// make Cs' as it should be when minimized into Cs
* Cs.C1..Cn/Cs = Thisn
* Cs/Cs.C1..Cn = This0.C1..Cn
* Cs.C1..Cn/Cs.C'1..C'k = Thisn.C'1..C'k
    C1!=C'1 
_______
#define CORE.L1 PLUS CORE.L2 = CORE.L3    Ts1+Ts2=Ts3
* L1 PLUS L2 = L3
  PLUS.map(PLUS.Cs)=Cs1..Csn //empty if map undefined for Cs
  Li={Hi MWTsi NCsi Doci Infoi}
  H3=(H1 PLUS H2) H1.Ts + H2.Ts+PLUS.Cs/Cs1+..+PLUS.Cs/Csn 
  LDoms=empty if L1.interface?=L2.interface?
  LDoms={LDom | i in {1,2}, Li.interface?=empty LDom in dom(Li) and LDom have uniqueNum} otherwise//private domain of the non interface Li
  iMWTs=implemented(PLUS.topLeft,PLUS.Cs)[MWTs1\LDoms]
    U implemented(PLUS.topRight,PLUS.Cs)[MWTs2\LDoms]
    U MWTs1 U MWTs'1 U..U MWTsn U MWTs'n
  p=PLUS.p.push(PLUS.C,PLUS.topLeft).navigate(Cs) or PLUS.p.push(PLUS.C,PLUS.topRight).navigate(Cs)
  Cs=C1..Ck
  MWTsi=PLUS.topLeft(Csn).MWTs[from p.minimize(Thisk.Csn);p]//and removing all the docs
  MWTs'i=PLUS.topRight(Csn).MWTs[from p.minimize(Thisk.Csn);p]//and removing all the docs
  MWTs3=PLUS(iMWTs)
  NCs3=NCs1\LDoms PLUS NCs2\LDoms
  Doc3=Doc1,Doc2
  Info=Info1+Info2 but if one header is made interface the watched and the coherentDep from that side are discarded
  Info3=Info[refined+=dom((iMWTs3..iMWTsn).MWTs) typeDep+=Ps]
  Ps=paths(PLUS.topLeft(Cs1),..,PLUS.topLeft(Csn))[from p.minimize(Thisk.Csn);p],
       paths(PLUS.topRight(Cs1),..,PLUS.topEight(Csn))[from p.minimize(Thisk.Csn);p]

*  Ts1 + Ts2= Ts1,Ts2/Ts1 //using T.P for set minus removal
_______
#define NCs1 PLUS NCs2 = NCs3    PLUS(L)=L'    paths(L)=Ps
* (Docs C=L NCs1) PLUS NCs2 = Docs C=PLUS[Cs=PLUS.Cs,C](PLUS.topLeft,L) (NCs1 PLUS NCs2)
    C not in dom(NCs2)
* empty PLUS NC1..NCn =NC1'..NCn' 
    NCi'[L=PLUS[Cs=PLUS.Cs,NCi.C](PLUS.topRight,NCi.L)]
* Docs1 C=L1 NCs1 PLUS NCs Docs2 C=L2 NCs2 = Docs1,Docs2 C=L1 PLUS[Cs=PLUS.Cs,C] L2 (NCs1 PLUS NCs NCs2)

* PLUS(L0,L) = L
    PLUS.Cs notin dom(PLUS.map)
* PLUS(L0,L) = L[Ts=Ts,MWTs=PLUS(iMWTs) info.typeDep+=Ps]
    PLUS.map(PLUS.Cs)=Cs1..Csn
    p=either PLUS.p.push(PLUS.C,PLUS.topLeft).navigate(Cs) or PLUS.p.push(PLUS.C,PLUS.topRight).navigate(Cs)
    //at least one of the two is defined, and they would both from identically 
    Cs=C1..Ck
    Ps=paths(PLUS.topLeft(Cs1),..,PLUS.topLeft(Csn))[from p.minimize(Thisk.Csn);p],
         paths(PLUS.topRight(Cs1),..,PLUS.topEight(Csn))[from p.minimize(Thisk.Csn);p]
    Ts=L.Ts+PLUS.Cs/Cs1+..+PLUS.Cs/Csn
    iMWTs=implemented(L0,PLUS.Cs)[L.MWTs] U MWTs1 U MWTs'1 U..U MWTsn U MWTs'n
    MWTsi=PLUS.topLeft(Csn).MWTs[from p.minimize(Thisk.Csn);p]//and removing all the docs
    MWTs'i=PLUS.topRight(Csn).MWTs[from p.minimize(Thisk.Csn);p]//and removing all the docs
* P in paths(L) if P in L.Ts.Ps
* P in paths(L) if P in (T0..Tn,Ts).Ps and mdf method T0 m(T1 x1..Tn xn)[Ts] in L//and docs
//TODO: what happens for interfaces with both private and public methods?
_______
#define interface?[MWTs]=iMWTs
* interface?[MWT1..MWTn] = interface? MWT1 .. interface? MWTn
_______
#define PLUS(iMWTs) = MWTs3
* PLUS(interface? MWT, iMWTs)= MWT PLUS(iMWTs)
    MWT.s not in dom(iMWTs2.MWTs)
* PLUS(iMWT1, iMWTs1, iMWT2, iMWTs2)= PLUS(iMWT, iMWTs1, iMWTs2)
    iMWT1.s=iMWT2.s
    iMWT=iMWT1 PLUS iMWT2
_______
#define interface?1 MWT1 PLUS interface?2 MWT2 = interface?3 MWT3
* interface?1 MWT1 PLUS interface?2 MWT2 = {interface?1,interface?2} MWT1[accDocs MWT2]
    MWT1==MWT2 //except docs
    MWT1.e?=MWT2.e?=empty
* interface?1 MWT1 PLUS interface?2 MWT2 =interface?i MWTi[accDocs MWTj]//assert {interface?1,interface?2}=interface?1
    {i,j}={1,2}
    MWTj.e?=empty//implemented can not lose
    either MWTi.MH==MWTj.MH //except docs
    or interface?j=empty and loseSafeUnique(PLUS.topLeft,PLUS.topRight,Cs,MWTi,MWTj)//interface can not lose
_______
#define PLUS.loseSafeUnique(iMWT,MH)    loseSafe(L,Cs,MWT,MH)    
* PLUS.loseSafeUnique(iMWT,MH)
    loseSafe(PLUS.topLeft,PLUS.Cs,iMWT.S,MH) or loseSafe(PLUS.topRight,iMWT.S,MH)
    iMWT.e?!=empty or iMWT.interface?!=empty//implemented or interface can not lose
* PLUS.loseSafeUnique(iMWT,MH)
    loseSafe(PLUS.topLeft,PLUS.Cs,iMWT.S,MH) or PLUS.loseSafe(PLUS.topRight,iMWT.S,MH)
    iMWT.e?=empty and iMWT.interface?=empty
    not PLUS.loseSafe(PLUS.topLeft,MH.S,iMWT.MH)
    not PLUS.loseSafe(PLUS.topRight,MH.S,iMWT.MH)
    
* PLUS.loseSafe(L,S,MH)
    S in L(PLUS.Cs).Info.refined,
    P in L(PLUS.Cs).Ts.Ps
    p=PLUS.p.push(PLUS.C,L).navigate(PLUS.Cs)
    L'=p(P)
    L'(S).MH[from P;p]==MH //exept docs
_______
#define allWatched(L) = Csz
* Cs in allWatched(L) if Cs in L(Cs').Info.watched[from This0.Cs';{}] and Cs' not of form _._::n._
_______
#define allRequiredCoherent(L) = Csz
* Cs in allRequiredCoherent(L) if 
    Cs in L(Cs').Info.coherentDep[from This0.Cs';{}] U L(Cs').Info.metaCoherentDep[from This0.Cs';{}] 
    and Cs' not of form _._::n._
_______
#define allHiddenSupertypes(L) = Csz
* Cs in allHiddenSupertypes(L) if Cs in L(Cs').Info.hiddenSupertypes[from This0.Cs';{}] and Cs' not of form _._::n._
_______
#define interface?1 PLUS interface?2 = interface?3
* empty PLUS empty = empty
    either PLUS.topLeft(PLUS.Cs).Info.closed undefined
    or PLUS.topRight(PLUS.Cs).Info.closed undefined
* interface PLUS interface = interface
    PLUS.topLeft(PLUS.Cs).Info.closed undefined
    PLUS.topRight(PLUS.Cs).Info.closed undefined
* empty PLUS interface=interface
    PLUS.Cs notin allRequiredCoherent(PLUS.topLeft)
    PLUS.Cs notin allWatched(PLUS.topLeft)
    forall MWT in PLUS.topLeft(PLUS.Cs).MWTs://all public methods are abstract
      if MWT.s not of form _::n(_) then MWT.e?=empty
    //no public impl methods (thus since not watched, privates can be trashed)
* interface PLUS empty=interface//same but reversed
    PLUS.Cs notin allRequiredCoherent(PLUS.topRight)
    PLUS.Cs notin allWatched(PLUS.topRight)
    forall MWT in PLUS.topRight(PLUS.Cs).MWTs: if MWT.s not of form _::n(_) then MWT.e?=empty
_______ 
#define L1 > L2    implemented(L,Cs)=interface?
* L1 > L2
  L2 is interface
  either L1.Ts\L2.Ts!=empty
  or dom(L1.MWTs)\dom(L2.MWTs)!=empty
  
* implemented(L,Cs)=empty //all public Cs' do not implement Cs
    forall Cs' in dom(L) where Cs' not of form _._::n._:
      This0.Cs notin L(Cs').Ts.Ps[from This0.Cs';{}]
      This0.Cs notin L(Cs').Info.hiddenSupertypes[from This0.Cs';{}]
* implemented(L,Cs)=interface otherwise

-------------------------------------------------------
  Rename MAP
-------------------------------------------------------
N::= Cs|P|Cs.s|empty
|>::= -> | =>
Map::= N1|>N1'..Nn|>Nn'  
_______
#define earlyCheck(Core.L,Map)  earlyCheck(Core.L,N|>N')
* earlyCheck(L,Map)
    forall N|>N' in Map, earlyCheck(L,N|>N')
    if  Cs=>P in Map, s in dom(L(Cs)) and s has no unique n
      then L(Cs)(s).e?=empty
    if  Cs=>P in Map, s has no unique n and This0.Cs' in collectDeps({};L(Cs)(s))[from Cs;{}] //L(Cs)(s) is abstract from the check above
      then Cs'=>P' in Map
    if  Cs1=>P1..Csn=>Pn in Map 
      then none of Cs1..Csn in allWatched(L\Cs1..Csn)//all watched without considering Cs1..Csn
    if Cs in dom(map) U cod(map)
      then Cs.s not in dom(map) U cod(map)
    if Cs|>Cs' in map
      then Cs"|>Cs' not in map
    if Cs.s|>Cs'.s' in map
      then Cs".s"|>Cs'.s' not in map
    Map is a map, thus no two tuples with the same key
    
* earlyCheck(L,N|>N')
    N not of form empty
    if N of Cs.s then N' of form Cs.s or empty
    if N of Cs then N' of form Cs or P or empty
    N,N' do not have unique numbers
    if N|>N'of form Cs->_
      then Cs not in allWatched(L) 
    if N of form Cs, then  Cs in dom(L)
    if N of form Cs.s, then  Cs in dom(L) and s in dom(L(Cs))
    if N|>N'of form Cs.s->empty
      then L(Cs)(s).e?!=empty
    if N|>N'of form Cs.s=>_
      then s notin L(Cs).info.refined
    if N|>N'of form Cs.s->_
      then L(Cs).interface?=empty
    if N|>N'of form Cs.s|>Cs'.s'
      then patternOk(L,Cs.s,Cs'.s')
    if N|>N'of form Cs.s=>Cs'.s', and either Cs!=Cs' or size(s.xs)!=size(s'.xs)
      then L(Cs).interface=empty//may be this can be relaxed, and with the double delegate the interface may be closed.
    if N|>N'of form Cs.s->Cs'.s' and then L(Cs').interface=interface  
      then L(Cs)(s).e?=empty

AddMap::=Cs1->L1..Csn->Ln Cs'1->mwt1..Cs'k->mwtk
Rename::=Rename[p;Cs;Map]

* LOf(AddMap)=...

* applyMap(p;Map)= L'+LOf(AddMap) //simpler then normal sum, at least can skip normaizing unique numbers
    earlyCheck(p.top,Map)
    Rename[p;empty;Map] => L';AddMap

* Rename[p;Cs;Map] => L';AddMap,AddMap',AddMap1..AddMapn //both L0 and L1 get produced
    p.top(Cs)={interface? Ts mwts ncs info}
    C1..Cn in dom(p.top(Cs))
    Rename[p;Cs.C1;Map]=>L'1;AddMap1..Rename[p;Cs.Cn;Map]=>L'n;AddMapn
    Rename mwts => mwts';AddMap
    Rename ncs => ncs';AddMap'
    L'={interface? Ts mwts' ncs' info}//info??

* Rename empty => empty;empty
* Rename(mwt mwts) => mwts' mwts";AddMap,AddMap'
    Rename mwt => mwts';AddMap
    Rename mwts => mwts";AddMap'
* Rename(nc ncs)=> ncs' ncs";AddMap,AddMap'
    Rename nc => ncs';AddMap
    Rename ncs => ncs";AddMap'
* Rename mwt => (Rename usages mwt);empty
    Cs.(mwt.s) notin dom(Map)
---//on interface methods, -> is never allowed; everywhere when we write Cs we mean Rename.Cs
* Rename mwt =mwt[n1], mwts[n2]; Cs'->delegate(mwt,s',Cs,n1)
    Cs.(mwt.s) =>Cs'.s' in Map
    p(Cs).interface?=interface//assert Cs' not interface
    size(s.xs)=size(s'.xs)+1
    n1,n2=freshPrivate(p)
    TODO somehow the interface info becomes close
* Rename mwt =mwt[n1], mwts[n2,Cs'.s']; empty//if mwt was implemented, n2 must delegate to Cs'.s.
    Cs0.(mwt.s) =>Cs'.s' in Map
    This0.Cs0 in p(Cs).Ts.Ps[from Cs;{}]
    size(s.xs)=size(s'.xs)+1
    n1,n2=freshPrivate(p)//must be the same of the former rule.. so connected with the map entry?
    TODO somehow is Cs is interface, the info becomes close
    //the patter: a becomes a::1=e? a::2=dest? and dest->a::1
    
* Rename mwt = ??;AddMap
    Cs.(mwt.s) =>Cs'.s' in Map
    p(Cs).interface?=interface
    size(s.xs)=size(s'.xs)-1
    TODO//embed a method in an interface? thus all the implementations do the same thing?
* Rename mwt = ??;AddMap
    Cs.(mwt.s) =>empty in Map
    p(Cs).interface?=interface
    size(s.xs)=size(s'.xs)
    TODO**--**//make an interface method private
* Rename mwt = empty;Cs->(Rename usages mwt[s=s'])
    Cs.(mwt.s) =>Cs.s' in Map
    p(Cs).interface?=interface
    size(s.xs)=size(s'.xs)
    //simplest interface case  //mwt[s=s'] also changes the local variable usages
* Rename mwt = empty;Cs->(Rename usages mwt[s=s'])
    Cs'.(mwt.s) =>Cs'.s' in Map
    This0.Cs' in p(Cs).Ts.Ps[from Cs;{}]
    size(s.xs)=size(s'.xs)
 ------------------
* Rename mwt = ??;AddMap
    Cs.(mwt.s) ->Cs'.s' in Map
    p(Cs).interface?=empty
    size(s.xs)=size(s'.xs)+1
    TODO
* Rename mwt = ??;AddMap
    Cs.(mwt.s) ->empty in Map
    p(Cs).interface?=empty
    size(s.xs)=size(s'.xs)+1
    TODO
* Rename mwt = ??;AddMap
    Cs.(mwt.s) =>Cs'.s' in Map
    p(Cs).interface?=empty
    size(s.xs)=size(s'.xs)+1
    TODO
* Rename mwt = ??;AddMap
    Cs.(mwt.s) =>empty in Map
    p(Cs).interface?=empty
    size(s.xs)=size(s'.xs)+1
    TODO**
* Rename mwt = ??;AddMap
    Cs.(mwt.s) ->Cs'.s' in Map
    p(Cs).interface?=empty
    size(s.xs)=size(s'.xs)-1
    TODO
* Rename mwt = ??;AddMap
    Cs.(mwt.s) ->empty in Map
    p(Cs).interface?=empty
    size(s.xs)=size(s'.xs)-1
    TODO
* Rename mwt = ??;AddMap
    Cs.(mwt.s) =>Cs'.s' in Map
    p(Cs).interface?=empty
    size(s.xs)=size(s'.xs)-1
    TODO
* Rename mwt = ??;AddMap
    Cs.(mwt.s) =>empty in Map
    p(Cs).interface?=empty
    size(s.xs)=size(s'.xs)-1
    TODO**--
* Rename mwt = ??;AddMap
    Cs.(mwt.s) ->Cs'.s' in Map
    p(Cs).interface?=empty
    size(s.xs)=size(s'.xs)
    Cs!=Cs'
    TODO
* Rename mwt = ??;AddMap
    Cs.(mwt.s) ->empty in Map
    p(Cs).interface?=empty
    size(s.xs)=size(s'.xs)
    TODO
* Rename mwt = ??;AddMap
    Cs.(mwt.s) =>Cs'.s' in Map
    p(Cs).interface?=empty
    size(s.xs)=size(s'.xs)
    Cs!=Cs'
    TODO
* Rename mwt = ??;AddMap
    Cs.(mwt.s) =>empty in Map
    p(Cs).interface?=empty
    size(s.xs)=size(s'.xs)
    TODO**--**
* Rename mwt = ??;AddMap
    Cs.(mwt.s) ->Cs.s' in Map
    p(Cs).interface?=empty
    size(s.xs)=size(s'.xs)
    TODO
* Rename mwt = ??;AddMap
    Cs.(mwt.s) =>Cs.s' in Map
    p(Cs).interface?=empty
    size(s.xs)=size(s'.xs)
    TODO **********
----
* Rename C=L = C=(Rename[Cs=Cs.C] usages L);empty
    Cs.C notin dom(Map)
* Rename Docs C=L = Docs C=L[toAbstract];Cs'-> C'=(Rename[Cs=Cs.C] usages L[noNesteds])[from Cs;p]
    Cs.C -> Cs'.C' in Map
    p=Rename.p.navigate(Cs'.C)//Cs' may not be in dom(p)
    Cs.C notin allWatched(L)    
* Rename Docs C=L = Docs C=L[toAbstract];empty
    Cs.C -> empty in Map
    Cs.C notin allWatched(L)    
* Rename Docs C=L = (C=L)[onlyNesteds];Cs'-> Docs C'=(Rename[Cs=Cs.C] usages L[noNesteds])[from Cs;p]
    p=Rename.p.navigate(Cs'.C)//Cs' may not be in dom(p)
    Cs.C => Cs'.C' in Map
* Rename Docs C=L = (C=L)[onlyNesteds],Docs C::1=(Rename[Cs=Cs.C] usages L[noNesteds]);empty
    Cs.C => empty in Map
* Rename C=L = (C=L)[onlyNesteds];empty
    Cs.C => P in Map

    
      
      
//Double delegate pattern: to move a call to another class:
original(a,b,c)->destination(b,c,a)
original(a,b,c)=e--> original::1(a,b,c)=e//needed only if original not abstract
                 --> original::2(a,b,c)=destination(b=b,c=c,a=a)//needed only if there are usages
                 --> destination(b,c,a)=original::1(a=a,b=b,c=c)//body needed only if original not abstract
//In patterns: if parNum equal, then is rename, no shuffling
//if parNum +1 then is lifting with shuffling
//if parNum -1 then is embedding with shuffling
* patternOk(_,Cs.m(x1..xn),Cs.m'(x'1...x'n))
//example A.foo(a,b)=>A.bar(c,d); the method is renamed and body is adapted to use new par names
* patternOk(_,Cs.m(x1..xn),Cs'.m'(x'1...x'n))
    Cs!=Cs'
    L(Cs)(m(x1..xn)).mdf=class
//example A.foo(a,b)=>B.bar(c,d); now B watches A
//delegate B.bar(c,d)=A.foo::1(a=c,b=d), double delegate for usages
//example A.foo(a,b)=>B.bar(a,c); now B watches A 
//delegate B.bar(a,c)=c.foo::1(a=a,b=this)    foo::2(a,b)=b.bar(a=a,c=this) 
* patternOk(L,Cs.m(x1..xn),Cs'.m'(xs))
    reorder(xs)=x,x1..xn
//example A.foo(a,b)=>B.bar(a,self,b); now B watches A
//delegate B.bar(a,self,b)=self.foo::1(a=a,b=b)    foo::2(a,b)=B.bar(a=a,self=this,b=b)    
* patternOk(L,Cs.m(x1..xn),Cs'.m'(xs))
    reorder(x1..xn)=xi,xs //xi will become the new 'this'
    Cs'=L(Cs)(m(x1..xn)).pari.P[from Cs;{}]
    L(Cs)(m(x1..xn)).mdf==class
//example A.foo(a,self,b)=>B.bar(a,b); now B watches A
//delegate B.bar(a,b)=A.foo::1(a=a,self=this,b=b)    foo::2(a,self,b)=self.bar(a=a,b=b)    

/*NOPE,* patternOk(_,Cs.m(x1..xn),Cs'.m'(xs))//Shuffling need to be implemented with delegation, otherwise may be unsound wrt multi method types
    reorder(xi,xs)=x0 x1..xn //xi is the new 'this' and x0 is the old 'this'
    //HARD!!how to distinguish this from first/second case? 
*/

applyMap:
  collect all watched
  make a map for all renamed interface methods
  all individual mappings are ok
    -methods maps in methods, Cs maps in Cs or P//E
    -no private names//E
    -all dom(map) exists in dom(L)//L
    -no hide abs methods//L
    -no abstr or -> watched Cs//E
    -no rename=> of refined methods//L
    -no rename-> of interface methods//L
    -meth rename=> follow one of the 4+1 patterns. Only the base pattern is ok with interface methods//E+L
    -meth rename-> can follow one of the 4+1 patterns and is not an interface method//E+L
  global mapping is ok:
    -redirected stuff is all transitivelly redirected//E or L? 
    -redirected stuff is redirected to OK targets//L, just before trashing such class?
    -Cs in dom(map) U cod(map), then Cs.m not in dom(map) U cod(map)//E
    -Cs|>Cs' in map, then Cs"|>Cs' not in map//E
    -Cs.s|>Cs'.s' in map, then Cs".s"|>Cs'.s' not in map//E
    -is a map, thus no two tuples with the same key//E
  //what to test early? what to test late? what to test again for better error message in the lazyMsg?
  
method renamed in the same class can be directly sum, while method renamed outside will be placed in the map N->body
  
  Redirect and undefined Ps:
the target P was typed, thus all the reachable Ps are typed.
If a P in the source does not exists, we can just 'accept is a good subtype\supertype for the corresponding P in the destination
  
  //renames:
  renaming an interface method in private:
    if it was state and implemented is public: error: the class must be close first
    if implemented is private, state was already private, thus, the interface meth is not state anyway
  rename only names not nesteds; to request renaming also nested, use 'Foo* or similar
  operations:
    Remove+ Cs remove the methods and the interface? and the docs. If no nested, remove also the box
    Remove- Cs remove all the implementation of the methods and all the private stuff. Must be not watched.
    References: Cs->P rename all the usages of Cs into P (if P is This0.Cs' is for rename, otherwise for redirect)
    EmptyRename Cs->Cs' take Cs (no nested) from L, create another L where such content is in Cs' (properly frommed) 
    InnerSum: apply PLUS on the tweaked L and one extracted EmptyRename L
  This looks like can be easly done in bulk:
  Cs=>Cs' = Remove+ Cs, EmptyRename CS->Cs', References Cs->Cs'
  Cs->Cs' = Remove- Cs, EmptyRename CS->Cs',
  Cs=>P = Remove+ Cs, References Cs->P
  //we have 12 options
  1 R+ E R //full rename  =>
  2 R- E   //restrict (or super)  ->
  3 R+ R  //redirect  =>
  4 //R+ E (identical to R+ E R when possible)
  5 //R+ (identical to R+ R when possible)
  6 R- E R //strong rename but leave skeleton
  7 R- R //redirect but leave skeleton
  8 R- //make abstract (invoked by Cs->_)  ->_
  9 E R//copy code and move refs
  10 E//copy code
  11 R//redirect but leave full source
  12//empty op... ok
  -------
  More formally
  
L[Remove+ Csz,Remove- Csz',References (Cs->P)z]=L0
L[MovedContent (Cs->Cs')z,References (Cs->P)z]=L1,..Ln //EmptyRename
Sum L0+..+Ln //normal sum? but the input is broken
check refine single

Split+Sum
Split:
  L[References (Cs->P)z,MovedContent (Cs->Cs')z,Remove+ Csz,Remove- Csz']=L0,L1
Sum=L0+L1 and can be normal sum? can skip normalizing unique numbers

Split is a cloneVisitorWithProgram, that also collects a map from Cs->L and Cs.s->MWT
//Should we merge the map directly without a sum? could be a performance optimization later

Source dom is a tree
Dest dom is a tree (except for Thisn+1.Csz)

MovedContent map:
  Cs in dom/cod, then Cs.m not in dom/cod
  Cs->Cs' in map, then Cs"->Cs' not in map //same for Cs.m
  Cs->Cs' in map, then Cs->Cs" not in map //same for Cs.m
Remove set:
  +/-Csz, +/-Cs.sz
  if Cs in Csz, then Cs.s not in Cs.sz
Reference map:
  Cs->P is a map with Cs domain
-----
rename meth:
 -no refine
 -if moves between classes, must use a delegation pattern to avoid exposing ::0
 -if not class, then either
    -extra arg and becomes class
    -argument swap (exactly one arg MUST have a different name)
 -if is class, then either
    -same arg and stay class
    -argument less and get embedded
growing maps:
  for rename meth =>: add all the refined version of this. Note: is ok if it is privately implemented, but need some care
    In particular, if is implemented in a library literal in a meth body
hide meth:
 -no abstract methods
abs class, or just Cs->Cs'
 -no watched
-In all the cases is an error if Cs(.s)? do not exists or is private


-------------------
ThreadPool{
  method void computeTasksUntil(lock x) {
    while(!x.tryLock()){
      Task t=this.tryTask();//find a more efficient version
      if(t!=null){t.compute();}//can loop on lazy if another Eager loops :(
      }
  ThreadPool(int size){
    class Worker extends Thread{
      public void run(){while (true){tp.getTask().compute();}}
      }
    for(i in size){new Worker().start();}
    }
  }

@Catch.Lazy method T y() = e//L42 version
T y(){//Java version
    Object localy = this.y
    if(localy instanceof Lock){
      tp.computeTasksUntil((Lock)localy);
      //rentrant non blocking
      try{if(y instanceof Lock){y=e;}}
      catch(L42Throwable t){y=t;}
      finally{localy.release();}
      }
    return returnOrThrow(y);
    }
Foo(){
  this.fff=ff//is this safe to read in e?//ok if submit is syncronized?
  tp.submit(()->y()) // for eagers
  }
---------------------------------------------
Another solution, that repeats some tasks
---------------------------------------------------

assumptions:
every lazy/eager have an associated FutureLock(FL) with the following methods:
-isReady():Bool //true only after a tryPerfom was successfull
-getOrThrow():T or throws //and may throw an invalid usage if not isReady()
-tryPerform():Bool
  //either sequentially do the job in the local worker and res=true or 
  //the job is being done by another worker and res=false
-beingDone():Bool //true if tryPerform has ever been called
-perform():Void //run the lambda, 
  //lambda exceptions would be stored and not progragated
-join():T //top level method
----
tryPerform(){ //see ct:CT=current thread and tp:TP=thread pool
  //if this in ct.current error self circular?
  if this.ready() {return true;}
  if this.beingDone() {return false;}
  ct.current.add(this)
  try{this.beingDone=true;this.perform();this.read=true;}
  catch(Suppressed s){if(s.fl!=this){throw s;}}//completed by others
  ct.current.remove()//this can throw a Suppressed if the caller contex 
  //has been already resolved with repetition
  return true;
  }

join(){
  ct.current.addDep([fl]);
  fl.countRequested++;
  while !fl.tryPerform() {
    if tp.hasFreeWorkers {wait; continue;}
    fl0=tasks.tryAcquire()
    if(fl0!=null){unused=fl0.join();}
    if ct.current matches _,fl[fl1],fl1,_,
      where fl1.isReady() and fl.isRequested() {
      throw new Suppressed(fl1)
      }
    else{
      flRepeatable=tp.getRepeatable()//select an fl near the start of
      //a CT.current queue where the corresponding [fl'] is already computed
      //such [fl'] is changed to throw a new Suppressed(flRepeatable) when 
      //the stack goes back to such ct.current.remove()
      if(flRepeatable==null){wait;continue;}
      {unused=flRepeatable.join();}
      }
    if(tp.leastBusy!=ct){wait;continue;}
    }
  fl.countRequested--;
  ct.current.RemoveDep();
  return fl.getOrThrow()
  }


S::=FL|FL[FL']
Current::=S*,FL
CT={Current current;}

-----------------------------