Note: interfaces can watch if they have private nested classes that are watching.
Note: interfaces can be watched if they have private nested classes that are watched.
TODO: sum class+interface, ok if class not in coherent of anything in the bubble
PLUS::=PLUS[topLeft;topRight;Cs;Cs1->Pz1..Czn->Pzn]
iMWT::=interface?MWT
_______
#define p;C |- CORE.L1 + CORE.L2 = CORE.L3
* p;C |- L1 + L2 = L
    //Pz= growing interfaces 
    Pz = { This0.Cs | Cs in dom(L1) intersect dom(L2), Cs has no unique ns and (L2(Cs)>L1(Cs) or L1(Cs)>L2(Cs))}
    //classes implementing growing interfaces, note that any Pzi must be not empty
    Cs1->Pz1 .. Csn->Pzn = 
      {Cs->collect(L1,L2,Cs) | Cs in dom(L1)U dom(L2), collect(L1,L2,Cs)!=empty}
    PLUS=PLUS[topLeft=L1;topRight=L2;Cs1->Pz1 .. Csn->Pzn]
    L = L1 PLUS L2
    //  where the Cs/Pzi is used to grow the Ts (in the bottom, no docs)
    //  and topLeft(Pzi).mwts U topRight(Pzi) are plussed to the mwts (without the docs)
    forall Cs in allHiddenSupertypes(L): This0.Cs not in Pz
_______//collects the "novel" transitive implementations of Cs
#define collect(Pz,L1,L2,Cs)=Cs' //Pz is This0 starting growing interfaces
* Cs" in collect(Pz,L1,L2,Cs)
    This0.Cs' in Li(Cs).Ts.Ps[from This0.Cs;{}] intersect Pz// assert Cs' has no unique ns (since intersect Pz)
    This0.Cs" in Lj(Cs').Ts.Ps[from This0.Cs;{}] \ Li(Cs).Ts.Ps[from This0.Cs;{}]
    i in {1,2}
    j in {1,2}
    Cs" has no unique ns
* Cs" in collect(Pz,L1,L2,Cs)
    This0.Cs' in Li(Cs).Ts.Ps[from This0.Cs;{}] intersect Pz
    Cs" in collect(Pz,L1,L2,Cs')
    i in {1,2}
_______
#define Cs/P=P'// make P as it should be when minimized in Cs
* Cs.C._/This0.Cs.C'.C1..Cn= This(n+1).C'.C1..Cn
    C!=C' 
_______
#define CORE.L1 PLUS CORE.L2 = CORE.L3
* L1 PLUS L2 = L3
  Li={Hi MWTsi NCsi Doci Infoi}
  H3=(H1 PLUS H2) H1.Ts,(H2.Ts\H1.Ts)
  LDoms=empty if L1.interface?=L2.interface?
  LDoms={LDom| i in {1,2}, Li.interface?=empty LDom in dom(Li) and LDom have uniqueNum} otherwise//private domain of the non interface Li
  iMWTs1=implemented(PLUS.topLeft,PLUS.Cs)[MWTs1\LDoms]
  iMWTs2=implemented(PLUS.topRight,PLUS.Cs)[MWTs2\LDoms]
  PLUS(PLUS.Cs)=This0.Cs3..This0.Csn
  iMWTsi=empty[PLUS.topLeft(Csi).MWTs U PLUS.topRight(Csi).MWTs] //topXX(Cs).MWTs=empty if undefined
  //iMWTs3..iMWTsn are stripped from their docs
  MWTs3=(iMWTs1 PLUS .. PLUS iMWTsn).MWTs
  NCs3=NCs1\LDoms PLUS NCs2\LDoms
  Doc3=Doc1,Doc2
  Info=Info1+Info2 but if one header is made interface the watched and the coherentDep from that side are discarded
  Info3=Info[refined+=dom((iMWTs3..iMWTsn).MWTs)]
_______
#define NCs1 PLUS NCs2 = NCs3
* (Docs C=L NCs1) PLUS NCs2 = Docs C=L (NCs1 PLUS NCs2)
    C not in dom(NCs2)
* empty PLUS NCs2 = NCs2
* Docs1 C=L1 NCs1 PLUS NCs Docs2 C=L2 NCs2 = Docs1,Docs2 C=L1 PLUS[Cs=PLUS.Cs,C] L2 (NCs1 PLUS NCs NCs2)
_______
#define interface?[MWTs]=iMWTs
* interface?[MWT1..MWTn] = interface? MWT1 .. interface? MWTn
_______
#define iMWTs1 PLUS iMWTs2 = iMWTs3
* interface? MWT iMWTs1 PLUS iMWTs2 = interface? MWT (iMWTs1 PLUS iMWTs2)
    MWT.s not in dom(iMWTs2.MWTs)
* _ empty PLUS iMWTs = iMWTs
* interface?1 MWT1 iMWTs1 PLUS iMWTs interface?2 MWT2 iMWTs2 = 
    (interface?1 MWT1 PLUS interface2? MWT2) (iMWTs1 PLUS iMWTs iMWTs2)
      MWT1.s=MWT2.s
_______
#define interface?1 MWT1 PLUS interface?2 MWT2 = interface?3 MWT3
_______
#define interface?1 MWT1 PLUS interface?2 MWT2 = interface?3 MWT3
* interface?1 MWT1 PLUS interface?2 MWT2 = {interface?1,interface?2} MWT1[accDocs MWT2]
    MWT1==MWT2 //except docs
    MWT1.e?=MWT2.e?=empty
* interface?1 MWT1 PLUS interface?2 MWT2 =interface?i MWTi[accDocs MWTj]//assert {interface?1,interface?2}=interface?1
    {i,j}={1,2}
    MWTj.e?=empty//implemented can not lose
    interface?j=empty //interface can not lose
    either MWTi.MH==MWTj.MH //except docs
    or MWTi.S in PLUS.topLeft(Cs).Info.refined,
       This0.Cs' in PLUS.topLeft(Cs).Ts.Ps[from This0.Cs;{}]
       PLUS.topLeft(Cs')(MWTi.S).MH==MWTj.MH //exept docs
    or ...the same for PLUS.topRight...
_______
#define allWatched(L) = Csz
* Cs in allWatched(L) if Cs in L(Cs').Info.watched[from This0.Cs';{}] and Cs' not of form _._::n._
_______
#define allRequiredCoherent(L) = Csz
* Cs in allRequiredCoherent(L) if Cs in L(Cs').Info.coherentDep[from This0.Cs';{}] and Cs' not of form _._::n._
_______
#define allHiddenSupertypes(L) = Csz
* Cs in allHiddenSupertypes(L) if Cs in L(Cs').Info.hiddenSupertypes[from This0.Cs';{}] and Cs' not of form _._::n._
_______
#define H1 PLUS H2
* interface? PLUS interface? = interface?
    either PLUS.topLeft(PLUS.Cs).Info.closed undefined
    or PLUS.topRight(PLUS.Cs).Info.closed undefined
* empty PLUS interface=interface
    PLUS.Cs notin allRequiredCoherent(PLUS.topLeft)
    PLUS.Cs notin allWatched(PLUS.topLeft)
    forall MWT in PLUS.topLeft(PLUS.Cs).MWTs://all public methods are abstract
      if MWT.s not of form _::n(_) then MWT.e?=empty
    //no public impl methods (thus since not watched, privates can be trashed)
* interface PLUS empty=interface//same but reversed
    PLUS.Cs notin allRequiredCoherent(PLUS.topRight)
    PLUS.Cs notin allWatched(PLUS.topRight)
    forall MWT in PLUS.topRight(PLUS.Cs).MWTs: if MWT.s not of form _::n(_) then MWT.e?=empty
_______ 
#define L1 > L2    implemented(L,Cs)=interface?
* L2 > L1
  L1 is interface
  either L2.Ts\L1.Ts!=empty
  or dom(L2.MWTs)\dom(L1.MWTs)!=empty
  
* implemented(L,Cs)=empty //all public Cs' do not implement Cs
    forall Cs' in dom(L) where Cs' not of form _._::n._:
      This0.Cs notin L(Cs').Ts.Ps[from This0.Cs';{}]
      This0.Cs notin L(Cs').Info.hiddenSupertypes[from This0.Cs';{}]
* implemented(L,Cs)=interface otherwise

  //DO NOT READ AFTER THIS POINT
  //renames:
  renaming an interface method in private:
    if it was state and implemented is public: error: the class must be close first
    if implemented is private, state was already private, thus, the interface meth is not state anyway
  rename only names not nesteds; to request renaming also nested, use 'Foo* or similar
  operations:
    Remove+ Cs remove the methods and the interface? and the docs. If no nested, remove also the box
    Remove- Cs remove all the implementation of the methods. Must be not watched.
    References: Cs->P rename all the usages of Cs into P (if P is This0 is for rename, otherwise for redirect)
    EmptyRename Cs->Cs' take Cs (no nested) from L, create another L where such content is in Cs' (properly frommed) 
    InnerSum: apply PLUS on the tweaked L and one extracted EmptyRename L
  This looks like can be easly done in bulk:
  Cs=>Cs' = Remove+ Cs, EmptyRename CS->Cs', References Cs->Cs'
  Cs->Cs' = Remove- Cs, EmptyRename CS->Cs',
  Cs >P = Remove+ Cs, References Cs->P
  //we have 12 options
  1 R+ E R //full rename
  2 R- E   //restrict
  3 R+ R  //redirect
  4 //R+ E (identical to R+ E R when possible)
  5 //R+ (identical to R+ R when possible)
  6 R- E R //strong rename but leave skeleton
  7 R- R //redirect but leave skeleton
  8 R- //make abstract (invoked by Cs->_)
  9 E R//copy code and move refs
  10 E//copy code
  11 R//redirect but leave full source
  12//empty op... ok
  -------
  
  mdf method imm P methName(imm P1 x1.. imm Pn xn)=
    native{trusted:cached}
    methBody
  //this will cache the result and return the cached
  //after the first call
  mdf method imm Void clearCache()=native{trusted:clearCache} error void
  //this will clear all the cache for the current object
  
  Option 1 may work:a class with any trusted:cached method need to be with closed state
  and with extra well formedness stuff.
  Option 2 would not work: a class with trusted:cached just do what it said, without any guarantees
  of correctness of the caching process. The caches introduced by Data will be correct by construction,
  but there is no guarantee of the caches introduced in other ways (if the receiver is not imm)
  Option 2 would allow for a function recognizing identities on imms. That in turn can be use to 
  distinguish if a "correct" caching is returning the same or different identities.

  In this way, Data can create trusted:cached;
  correct cache invalidation and Eager caching are just a feature of data
  calling clearCache and (possibly) recalling the cached methods directly after.
  calling clearCache() and or 
  ------
  @FlushCache
  @Cached
  @EagerCached
  FlushCache={#norm{nativeKind=flushCache}}
  
When typing a method MWT in p with a Doc with a P
where p(P).Info.nativeUrl=Url
then (even if the method is abstract)
nativeExtraTypingDecl(Url,p,MWT)
When typing a method call e calling P.s
  where P' in p(P)(s).Docs 
  and p(P'[from P;p]).Info.nativeUrl=Url
nativeExtraTypingCall(Url,p,G,e)

In this way we can typeckeck invariant capsule fields: (with Url=flushCache)
-abs methods must look like an exposer
-implemented method are mut, use 'this' only once, par types and ret types are not mut/lent/read.
on nativeExtraTypingCall(Url,p,G,e) for abstract methods:
  they have a private number and the receiver is exactly 'this'
with Url=cached or eagerCached
-the class only have imm/caps parameters

  
  
