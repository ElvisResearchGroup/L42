Note: interfaces can watch if they have private nested classes that are watching.
Note: interfaces can be watched if they have private nested classes that are watched.
TODO: sum class+interface, ok if class not in coherent of anything in the bubble
PLUS::=PLUS[topLeft;topRight;Cs;Cs1->Pz1..Czn->Pzn]
iMWT::=interface?MWT
_______
#define |- CORE.L1 + CORE.L2 = CORE.L3
* |- L1 + L2 = L
    Cs1->Csz1 .. Csn->Cszn =transitiveMap(L1,L2) 
    PLUS=PLUS[topLeft=L1;topRight=L2;Cs1->Pz1 .. Csn->Pzn]
    L = L1 PLUS L2
    forall Cs in allHiddenSupertypes(L1): L2(Cs)>L1(Cs) does not hold
    forall Cs in allHiddenSupertypes(L2): L1(Cs)>L2(Cs) does not hold
_______
#define singleMap(L1,L2)=Cs->Csz    transitiveMap(L1,L2)=Cs->Csz
  * Cs' in singleMap(L1,L2)(Cs)
    Cs and Cs' has no unique n
    {1,2}={i,j}
    Cs in dom(Li)
    Cs notin dom(Lj)
    This0.Cs' in Li(Cs).Ts.Ps[from Cs;{}]
    Lj(Cs')>Li(Cs')

  * Cs' in transitiveMap(L1,L2)(Cs)
      Cs' in singleMap(L1,L2)(Cs)
  * Cs" in transitiveMap(L1,L2)(Cs)
      Cs' in transitiveMap(L1,L2)(Cs)
      Cs" in singleMap(L1,L2)(Cs')

_______//UNUSED?
#define Cs/P=P'// make P as it should be when minimized in Cs
* Cs.C._/This0.Cs.C'.C1..Cn= This(n+1).C'.C1..Cn
    C!=C' 
_______
#define CORE.L1 PLUS CORE.L2 = CORE.L3
* L1 PLUS L2 = L3
  Li={Hi MWTsi NCsi Doci Infoi}
  H3=(H1 PLUS H2) H1.Ts,(H2.Ts\H1.Ts)
  LDoms=empty if L1.interface?=L2.interface?
  LDoms={LDom | i in {1,2}, Li.interface?=empty LDom in dom(Li) and LDom have uniqueNum} otherwise//private domain of the non interface Li
  PLUS.map(PLUS.Cs)=This0.Cs1..This0.Csn
  iMWTs=implemented(PLUS.topLeft,PLUS.Cs)[MWTs1\LDoms]
    U implemented(PLUS.topRight,PLUS.Cs)[MWTs2\LDoms]
    U PLUS.topLeft(Cs1).MWTs U PLUS.topRight(Cs1).MWTs//removing all the docs
    ..
    U PLUS.topLeft(Csn).MWTs U PLUS.topRight(Csn).MWTs//removing all the docs
  MWTs3=PLUS(iMWTs)
  NCs3=NCs1\LDoms PLUS NCs2\LDoms
  Doc3=Doc1,Doc2
  Info=Info1+Info2 but if one header is made interface the watched and the coherentDep from that side are discarded
  Info3=Info[refined+=dom((iMWTs3..iMWTsn).MWTs)]
  //TODO:also, check well formedness of refine relation, implicit in formalism but TODO: in code
_______
#define NCs1 PLUS NCs2 = NCs3
* (Docs C=L NCs1) PLUS NCs2 = Docs C=L (NCs1 PLUS NCs2)
    C not in dom(NCs2)
* empty PLUS NCs2 = NCs2
* Docs1 C=L1 NCs1 PLUS NCs Docs2 C=L2 NCs2 = Docs1,Docs2 C=L1 PLUS[Cs=PLUS.Cs,C] L2 (NCs1 PLUS NCs NCs2)
_______
#define interface?[MWTs]=iMWTs
* interface?[MWT1..MWTn] = interface? MWT1 .. interface? MWTn
_______
#define PLUS(iMWTs) = MWTs3
* PLUS(interface? MWT, iMWTs)= MWT PLUS(iMWTs)
    MWT.s not in dom(iMWTs2.MWTs)
* PLUS(iMWT1, iMWTs1, iMWT2, iMWTs2)= PLUS(iMWT, iMWTs1, iMWTs2)
    iMWT1.s=iMWT2.s
    iMWT=iMWT1 PLUS iMWT2
_______
#define interface?1 MWT1 PLUS interface?2 MWT2 = interface?3 MWT3
* interface?1 MWT1 PLUS interface?2 MWT2 = {interface?1,interface?2} MWT1[accDocs MWT2]
    MWT1==MWT2 //except docs
    MWT1.e?=MWT2.e?=empty
* interface?1 MWT1 PLUS interface?2 MWT2 =interface?i MWTi[accDocs MWTj]//assert {interface?1,interface?2}=interface?1
    {i,j}={1,2}
    MWTj.e?=empty//implemented can not lose
    either MWTi.MH==MWTj.MH //except docs
    or interface?j=empty and loseSafeUnique(PLUS.topLeft,PLUS.topRight,Cs,MWTi,MWTj)//interface can not lose
_______
#define PLUS.loseSafeUnique(iMWT,MH)    loseSafe(L,Cs,MWT,MH)    
* PLUS.loseSafeUnique(iMWT,MH)
    loseSafe(PLUS.topLeft,PLUS.Cs,iMWT.S,MH) or loseSafe(PLUS.topRight,PLUS.Cs,iMWT.S,MH)
    iMWT.e?!=empty or iMWT.interface?!=empty//implemented or interface can not lose
* PLUS.loseSafeUnique(iMWT,MH)
    loseSafe(PLUS.topLeft,PLUS.Cs,iMWT.S,MH) or loseSafe(PLUS.topRight,PLUS.Cs,iMWT.S,MH)
    iMWT.e?=empty and iMWT.interface?=empty
    not loseSafe(PLUS.topLeft,PLUS.Cs,MH.S,iMWT.MH)
    not loseSafe(PLUS.topRight,PLUS.Cs,MH.S,iMWT.MH)
    
* loseSafe(L,Cs,S,MH)
    S in L(Cs).Info.refined,
    This0.Cs' in L(Cs).Ts.Ps[from This0.Cs;{}]
    L(Cs')(S).MH==MH //exept docs
_______
#define allWatched(L) = Csz
* Cs in allWatched(L) if Cs in L(Cs').Info.watched[from This0.Cs';{}] and Cs' not of form _._::n._
_______
#define allRequiredCoherent(L) = Csz
* Cs in allRequiredCoherent(L) if Cs in L(Cs').Info.coherentDep[from This0.Cs';{}] and Cs' not of form _._::n._
_______
#define allHiddenSupertypes(L) = Csz
* Cs in allHiddenSupertypes(L) if Cs in L(Cs').Info.hiddenSupertypes[from This0.Cs';{}] and Cs' not of form _._::n._
_______
#define H1 PLUS H2
* interface? PLUS interface? = interface?
    either PLUS.topLeft(PLUS.Cs).Info.closed undefined
    or PLUS.topRight(PLUS.Cs).Info.closed undefined
* empty PLUS interface=interface
    PLUS.Cs notin allRequiredCoherent(PLUS.topLeft)
    PLUS.Cs notin allWatched(PLUS.topLeft)
    forall MWT in PLUS.topLeft(PLUS.Cs).MWTs://all public methods are abstract
      if MWT.s not of form _::n(_) then MWT.e?=empty
    //no public impl methods (thus since not watched, privates can be trashed)
* interface PLUS empty=interface//same but reversed
    PLUS.Cs notin allRequiredCoherent(PLUS.topRight)
    PLUS.Cs notin allWatched(PLUS.topRight)
    forall MWT in PLUS.topRight(PLUS.Cs).MWTs: if MWT.s not of form _::n(_) then MWT.e?=empty
_______ 
#define L1 > L2    implemented(L,Cs)=interface?
* L2 > L1
  L1 is interface
  either L2.Ts\L1.Ts!=empty
  or dom(L2.MWTs)\dom(L1.MWTs)!=empty
  
* implemented(L,Cs)=empty //all public Cs' do not implement Cs
    forall Cs' in dom(L) where Cs' not of form _._::n._:
      This0.Cs notin L(Cs').Ts.Ps[from This0.Cs';{}]
      This0.Cs notin L(Cs').Info.hiddenSupertypes[from This0.Cs';{}]
* implemented(L,Cs)=interface otherwise

  //DO NOT READ AFTER THIS POINT
  //renames:
  renaming an interface method in private:
    if it was state and implemented is public: error: the class must be close first
    if implemented is private, state was already private, thus, the interface meth is not state anyway
  rename only names not nesteds; to request renaming also nested, use 'Foo* or similar
  operations:
    Remove+ Cs remove the methods and the interface? and the docs. If no nested, remove also the box
    Remove- Cs remove all the implementation of the methods. Must be not watched.
    References: Cs->P rename all the usages of Cs into P (if P is This0 is for rename, otherwise for redirect)
    EmptyRename Cs->Cs' take Cs (no nested) from L, create another L where such content is in Cs' (properly frommed) 
    InnerSum: apply PLUS on the tweaked L and one extracted EmptyRename L
  This looks like can be easly done in bulk:
  Cs=>Cs' = Remove+ Cs, EmptyRename CS->Cs', References Cs->Cs'
  Cs->Cs' = Remove- Cs, EmptyRename CS->Cs',
  Cs >P = Remove+ Cs, References Cs->P
  //we have 12 options
  1 R+ E R //full rename
  2 R- E   //restrict
  3 R+ R  //redirect
  4 //R+ E (identical to R+ E R when possible)
  5 //R+ (identical to R+ R when possible)
  6 R- E R //strong rename but leave skeleton
  7 R- R //redirect but leave skeleton
  8 R- //make abstract (invoked by Cs->_)
  9 E R//copy code and move refs
  10 E//copy code
  11 R//redirect but leave full source
  12//empty op... ok
  -------
  
  mdf method imm P methName(imm P1 x1.. imm Pn xn)=
    native{trusted:cached}
    methBody
  //this will cache the result and return the cached
  //after the first call
  mdf method imm Void clearCache()=native{trusted:clearCache} error void
  //this will clear all the cache for the current object
  
  Option 1 may work:a class with any trusted:cached method need to be with closed state
  and with extra well formedness stuff.
  Option 2 would not work: a class with trusted:cached just do what it said, without any guarantees
  of correctness of the caching process. The caches introduced by Data will be correct by construction,
  but there is no guarantee of the caches introduced in other ways (if the receiver is not imm)
  Option 2 would allow for a function recognizing identities on imms. That in turn can be use to 
  distinguish if a "correct" caching is returning the same or different identities.

  In this way, Data can create trusted:cached;
  correct cache invalidation and Eager caching are just a feature of data
  calling clearCache and (possibly) recalling the cached methods directly after.
  calling clearCache() and or 
  ------
  @FlushCache
  @Cached
  @EagerCached
  FlushCache={#norm{nativeKind=flushCache}}
  
When typing a method MWT in p with a Doc with a P
where p(P).Info.nativeUrl=Url
then (even if the method is abstract)
nativeExtraTypingDecl(Url,p,MWT)
When typing a method call e calling P.s
  where P' in p(P)(s).Docs 
  and p(P'[from P;p]).Info.nativeUrl=Url
nativeExtraTypingCall(Url,p,G,e)

In this way we can typeckeck invariant capsule fields: (with Url=flushCache)
-abs methods must look like an exposer
-implemented method are mut, use 'this' only once, par types and ret types are not mut/lent/read.
on nativeExtraTypingCall(Url,p,G,e) for abstract methods:
  they have a private number and the receiver is exactly 'this'
with Url=cached or eagerCached
-the class only have imm/caps parameters

  
  
