PLUS::=PLUS[p;topLeft;topRight;Cs]
_______
#define p;C|-CORE.L1 + CORE.L2 = CORE.L3
* p |- L1 + L2 = L
    L=L3[Cs1+=p Pz1]..[Csn+=p Pzn]
    L3=(L1 PLUS[p.push(C,L);topLeft=L1;topRight=L2;empty] L2)
    //Pz= growing interfaces 
    Pz={ This0.Cs| Cs in dom(L1) intersect dom(L2) and Cs |-L2>L1 or Cs |-L2>L1}
    //classes implementing growing interfaces
    Cs1;Pz1 .. Csn;Pzn={Cs;P0..Pn | Cs in dom(L3) and P0..Pn = L3(Cs).Ts.Ps intersect Pz}
    forall Cs in allPrivateImplements(L): This0.Cs not in Pz
_______
#define CORE.L1 PLUS CORE.L2 = CORE.L3
* L1 PLUS L2 = L3
  Li={Hi MWTsi NCsi Doci}
  H3=(H1 PLUS H2) H1.Ts,(H2.Ts\H1.Ts)
  LDoms=empty if L1.interface?=L2.interface?
  LDoms={LDom| i in {1,2}, Li.interface?=empty LDom in dom(Li) and LDom have uniqueNum} otherwise
  MWTs3=L1.interface? MWTs1 PLUS L2.interface? MWTs2\LDoms
  NCs3=NCs1 PLUS NCs2\LDoms
  Doc3=Doc1,Doc2
  //Csz: growing interfaces 
  Pz={ This0.Cs| Cs in dom(L1) intersect dom(L2) and Cs |-L2>L1 or Cs |-L2>L1}
  //classes implementing growing interfaces
  Cs1;Pz1 .. Csn;Pzn={Cs;P0..Pn | Cs in dom(L3) and P0..Pn = L3(Cs).Ts.Ps intersect Pz}
_______
#define NCs1 PLUS NCs2 = NCs3
* (Docs C=L NCs1) PLUS NCs2 = Docs C=L (NCs1 PLUS NCs2)
    C not in dom(NCs2)
* empty PLUS NCs2 = NCs2
* Docs1 C=L1 NCs1 PLUS NCs Docs2 C=L2 NCs2 = Docs1,Docs2 C=L1 PLUS[Cs=PLUS.Cs,C] L2 (NCs1 PLUS NCs NCs2)
_______
#define interface?1 MWTs1 PLUS interface?2 MWTs2 = MWTs3
* interface?1 (MWT MWTs1) PLUS interface?2 MWTs2 = MWT (interface?1 MWTs1 PLUS interface?2 MWTs2)
    MWT.s not in dom(MWTs2)
* _ empty PLUS _ MWTs2 = MWTs2
* interface?1 MWT1 MWTs1 PLUS interface?2 MWTs MWT2 MWTs2 = MWT3 (interface?1 MWTs1 PLUS interface?2 MWTs MWTs2)
    {i,j}={1,2}
    p.navigate(This0.PLUS.Cs)|-MWTi.MH<=MWTj.MH
    MWT3=MWTi with Docs obtained by the corresponding MWT1.Docs+MWT2.Docs
    MWTj.e?=empty//implemented can not lose
    interface?j=empty//interface can not lose
_______
#define allWatched(L) = Csz
* Cs in allWatched(L) if Cs in L(Cs').Info.watched[from This0.Cs']
_______
#define allPrivateImplemented(L) = Csz
* Cs in allPrivateImplemented(L) if Cs in L(Cs').Info.allPrivateImplemented[from This0.Cs']
_______
#define H1 PLUS H2
* interface PLUS interface = interface
* empty PLUS interface=interface
    PLUS.topLeft(PLUS.Cs).Info.hasClassMethods undefined
    PLUS.Cs notin allWatched(PLUS.topLeft)//no other Cs in topLeft watches over current Cs
    forall MWT in PLUS.topLeft(PLUS.Cs).MWTs://all public methods are abstract
      if MWT.s not of form _::n(_) then MWT.e?=empty
    //no public impl methods (thus since not watched, privates can be trashed)
* interface PLUS empty=interface//same but reversed
    PLUS.topRight(PLUS.Cs).Info.hasClassMethods undefined
    PLUS.Cs notin allWatched(PLUS.topRight)
    forall MWT in PLUS.topRight(PLUS.Cs).MWTs: if MWT.s not of form _::n(_) then MWT.e?=empty
_______ 
#define Cs |- L2 > L1    L[Cs+=p Pz]=L'
* Cs |- L2 > L1
  L1(Cs) is interface
  either L2(Cs).Ts\L1(Cs).Ts!=empty
  or dom(L2(Cs).MWTs)\dom(L1(Cs).MWTs)!=empty

* L[Cs0+=p This0.Cs1..This0.Csn] = L[Cs0=L']
  L' = L(Cs0)[L(Cs0).MWTs+p ..+p L(Csn).MWTs]
  
  //renames:
  rename only names not nesteds; to request renaming also nested, use 'Foo* or similar
  operations:
    Remove+ Cs remove the methods and the interface? and the docs. If no nested, remove also the box
    Remove- Cs remove all the implementation of the methods. Must be not watched.
    References: Cs->P rename all the usages of Cs into P (if P is This0 is for rename, otherwise for redirect)
    EmptyRename Cs->Cs' take Cs (no nested) from L, create another L where such content is in Cs' (properly frommed) 
    InnerSum: apply PLUS on the tweaked L and one extracted EmptyRename L
  This looks like can be easly done in bulk:
  Cs=>Cs' = Remove+ Cs, EmptyRename CS->Cs', References Cs->Cs'
  Cs->Cs' = Remove- Cs, EmptyRename CS->Cs',
  Cs >P = Remove+ Cs, References Cs->P
  //we have 12 options
  1 R+ E R //full rename
  2 R- E   //restrict
  3 R+ R  //redirect
  4 //R+ E (identical to R+ E R when possible)
  5 //R+ (identical to R+ R when possible)
  6 R- E R //strong rename but leave skeleton
  7 R- R //redirect but leave skeleton
  8 R- //make abstract (invoked by Cs->_)
  9 E R//copy code and move refs
  10 E//copy code
  11 R//redirect but leave full source
  12//empty op... ok
  
  @FlushCache
  @Cached
  @EagerCached
  FlushCache={#norm{nativeKind=flushCache}}
  
When typing a method MWT in p with a Doc with a P
where p(P).Info.nativeUrl=Url
then (even if the method is abstract)
nativeExtraTypingDecl(Url,p,MWT)
When typing a method call e calling P.s
  where P' in p(P)(s).Docs 
  and p(P'[from P;p]).Info.nativeUrl=Url
nativeExtraTypingCall(Url,p,G,e)

In this way we can typeckeck invariant capsule fields: (with Url=flushCache)
-abs methods must look like an exposer
-implemented method are mut, use 'this' only once, par types and ret types are not mut/lent/read.
on nativeExtraTypingCall(Url,p,G,e) for abstract methods:
  they have a private number and the receiver is exactly 'this'
with Url=cached or eagerCached
-the class only have imm/caps parameters

  
  