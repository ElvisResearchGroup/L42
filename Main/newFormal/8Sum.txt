PLUS::=PLUS[p;topLeft;topRight;Cs]
iMWT::=interface?MWT
_______
#define p;C |- CORE.L1 + CORE.L2 = CORE.L3
* p |- L1 + L2 = L
    PLUS=PLUS[p.push(C,L);topLeft=L1;topRight=L2;empty]
    L3 = L1 PLUS L2
    L = L3[Cs1 PLUS Pz1]..[Csn PLUS Pzn]
    //Pz= growing interfaces 
    Pz = { This0.Cs | Cs in dom(L1) intersect dom(L2) and Cs|-L2>L1 or Cs|-L1>L2}
    //classes implementing growing interfaces, note that P0..Pn must be not empty
    Cs1;Pz1 .. Csn;Pzn = {Cs;P0..Pn | Cs in dom(L3) and P0..Pn = L3(Cs).Ts.Ps intersect Pz}
    forall Cs in allHiddenSupertypes(L): This0.Cs not in Pz
_______
#define CORE.L1 PLUS CORE.L2 = CORE.L3
* L1 PLUS L2 = L3
  Li={Hi MWTsi NCsi Doci}
  H3=(H1 PLUS H2) H1.Ts,(H2.Ts\H1.Ts)
  LDoms=empty if L1.interface?=L2.interface?
  LDoms={LDom| i in {1,2}, Li.interface?=empty LDom in dom(Li) and LDom have uniqueNum} otherwise//private domain of the non interface Li
  iMWTs1=implemented(PLUS.p,PLUS.topLeft,PLUS.Cs)[MWTs1\LDoms]
  iMWTs2=implemented(PLUS.p,PLUS.topRight,PLUS.Cs)[MWTs2\LDoms]
  MWTs3=iMWTs1 PLUS iMWTs2
  NCs3=NCs1 PLUS NCs2
  Doc3=Doc1,Doc2
_______
#define NCs1 PLUS NCs2 = NCs3
* (Docs C=L NCs1) PLUS NCs2 = Docs C=L (NCs1 PLUS NCs2)
    C not in dom(NCs2)
* empty PLUS NCs2 = NCs2
* Docs1 C=L1 NCs1 PLUS NCs Docs2 C=L2 NCs2 = Docs1,Docs2 C=L1 PLUS[Cs=PLUS.Cs,C] L2 (NCs1 PLUS NCs NCs2)
_______
#define interface?[MWTs]=iMWTs
* interface?[MWT1..MWTn] = interface? MWT1 .. interface? MWTn
_______
#define iMWTs1 PLUS iMWTs2 = iMWTs3
* interface? MWT iMWTs1 PLUS iMWTs2 = interface? MWT (iMWTs1 PLUS iMWTs2)
    MWT.s not in dom(iMWTs2.MWTs)
* _ empty PLUS iMWTs = iMWTs
* interface?1 MWT1 iMWTs1 PLUS iMWTs interface?2 MWT2 iMWTs2 = 
    (interface?1 MWT1 PLUS interface2? MWT2) (iMWTs1 PLUS iMWTs iMWTs2)
      MWT1.s=MWT2.s
_______
#define interface?1 MWT1 PLUS interface?2 MWT2 = interface?3 MWT3
* interface?1 MWT1 PLUS interface?2 MWT2 = interfacej? MWT3
    {i,j}={1,2}
    p.navigate(This0.PLUS.Cs)|-MWTi.MH<=MWTj.MH
    MWT3=MWTi with Docs obtained by the corresponding MWT1.Docs+MWT2.Docs
    MWTj.e?=empty//implemented can not lose
    interface?j=empty//interface can not lose
_______
#define allWatched(L) = Csz
* Cs in allWatched(L) if Cs in L(Cs').Info.watched[from This0.Cs']
    and Cs' not of form _._::n._
_______
#define allHiddenSupertypes(L) = Csz
* Cs in allHiddenSupertypes(L) if Cs in L(Cs').Info.hiddenSupertypes[from This0.Cs'] and Cs' not of form _._::n._
_______
#define H1 PLUS H2
* interface? PLUS interface? = interface?
    either PLUS.topLeft(PLUS.Cs).Info.closed undefined
    or PLUS.topRight(PLUS.Cs).Info.closed undefined
* empty PLUS interface=interface
    PLUS.topLeft(PLUS.Cs).Info.hasClassMethods undefined
    PLUS.Cs notin allWatched(PLUS.topLeft)//no other Cs in topLeft watches over current Cs
    forall MWT in PLUS.topLeft(PLUS.Cs).MWTs://all public methods are abstract
      if MWT.s not of form _::n(_) then MWT.e?=empty
    //no public impl methods (thus since not watched, privates can be trashed)
* interface PLUS empty=interface//same but reversed
    PLUS.topRight(PLUS.Cs).Info.hasClassMethods undefined
    PLUS.Cs notin allWatched(PLUS.topRight)
    forall MWT in PLUS.topRight(PLUS.Cs).MWTs: if MWT.s not of form _::n(_) then MWT.e?=empty
_______ 
#define Cs |- L2 > L1    L[Cs PLUS Pz]=L'    implemented(p,L,Cs)
* Cs |- L2 > L1
  L1(Cs) is interface
  either L2(Cs).Ts\L1(Cs).Ts!=empty
  or dom(L2(Cs).MWTs)\dom(L1(Cs).MWTs)!=empty

* L[Cs0 PLUS This0.Cs1..This0.Csn] = L[Cs0=L']
  Cs0=C1..Ck
  interface?i=interface if implemented(PLUS.p,L,Csi)
  iMWTsi=interface?0[L(Csi).MWTs[from PLUS.p.minimize(Thisk.Csi);PLUS.p]]
  L' = L(Cs0)[iMWTs0 PLUS .. PLUS iMWTsn]

* implemented(p,L,Cs)
    forall Cs' in dom(L):
      Cs' not of form _._::n._, P in L(Cs').Ts.Ps This0.Cs !=P[from Cs';p]

  //DO NOT READ AFTER THIS POINT
  //renames:
  rename only names not nesteds; to request renaming also nested, use 'Foo* or similar
  operations:
    Remove+ Cs remove the methods and the interface? and the docs. If no nested, remove also the box
    Remove- Cs remove all the implementation of the methods. Must be not watched.
    References: Cs->P rename all the usages of Cs into P (if P is This0 is for rename, otherwise for redirect)
    EmptyRename Cs->Cs' take Cs (no nested) from L, create another L where such content is in Cs' (properly frommed) 
    InnerSum: apply PLUS on the tweaked L and one extracted EmptyRename L
  This looks like can be easly done in bulk:
  Cs=>Cs' = Remove+ Cs, EmptyRename CS->Cs', References Cs->Cs'
  Cs->Cs' = Remove- Cs, EmptyRename CS->Cs',
  Cs >P = Remove+ Cs, References Cs->P
  //we have 12 options
  1 R+ E R //full rename
  2 R- E   //restrict
  3 R+ R  //redirect
  4 //R+ E (identical to R+ E R when possible)
  5 //R+ (identical to R+ R when possible)
  6 R- E R //strong rename but leave skeleton
  7 R- R //redirect but leave skeleton
  8 R- //make abstract (invoked by Cs->_)
  9 E R//copy code and move refs
  10 E//copy code
  11 R//redirect but leave full source
  12//empty op... ok
  -------
  
  mdf method imm P methName(imm P1 x1.. imm Pn xn)=
    native{trusted:cached}
    methBody
  //this will cache the result and return the cached
  //after the first call
  mdf method imm Void clearCache()=native{trusted:clearCache} error void
  //this will clear all the cache for the current object
  
  Option 1 may work:a class with any trusted:cached method need to be with closed state
  and with extra well formedness stuff.
  Option 2 would not work: a class with trusted:cached just do what it said, without any guarantees
  of correctness of the caching process. The caches introduced by Data will be correct by construction,
  but there is no guarantee of the caches introduced in other ways (if the receiver is not imm)
  Option 2 would allow for a function recognizing identities on imms. That in turn can be use to 
  distinguish if a "correct" caching is returning the same or different identities.

  In this way, Data can create trusted:cached;
  correct cache invalidation and Eager caching are just a feature of data
  calling clearCache and (possibly) recalling the cached methods directly after.
  calling clearCache() and or 
  ------
  @FlushCache
  @Cached
  @EagerCached
  FlushCache={#norm{nativeKind=flushCache}}
  
When typing a method MWT in p with a Doc with a P
where p(P).Info.nativeUrl=Url
then (even if the method is abstract)
nativeExtraTypingDecl(Url,p,MWT)
When typing a method call e calling P.s
  where P' in p(P)(s).Docs 
  and p(P'[from P;p]).Info.nativeUrl=Url
nativeExtraTypingCall(Url,p,G,e)

In this way we can typeckeck invariant capsule fields: (with Url=flushCache)
-abs methods must look like an exposer
-implemented method are mut, use 'this' only once, par types and ret types are not mut/lent/read.
on nativeExtraTypingCall(Url,p,G,e) for abstract methods:
  they have a private number and the receiver is exactly 'this'
with Url=cached or eagerCached
-the class only have imm/caps parameters

  
  
