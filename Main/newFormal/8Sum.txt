_______
#define CORE.L1 +p CORE.L2 = CORE.L3
* L1 +p L2 = L3[Cs1+=p Pz1]..[Csn+=p Pzn]
  Li={Hi MWTsi NCsi Doci}
  H3=H1+H2
  MWTs3=MWTs1+MWTs2
  NCs3=NCs1+NCs2
  Doc3=Doc1+Doc2
  //Csz: growing interfaces 
  Pz={ This0.Cs| Cs in dom(L1) intersect dom(L2) and Cs |-L2>L1 or Cs |-L2>L1}
  //classes implementing growing interfaces
  Cs1;Pz1 .. Csn;Pzn={Cs;P0..Pn | Cs in dom(L3) and P0..Pn = L3(Cs).Ts.Ps intersect Pz}


#allWatched(L) = Csz
* Cs in alWatched(L) if Cs in L(Cs').Info.watched[from This0.Cs']

#define checkInterface(Cs,L1,Csz1,L2,Csz2)
* checkInterface(Cs,L1,Csz1,L2,Csz2)=interface
    L1.interface?=L2.interface?=interface
* checkInterface(Cs,L1,Csz1,L2,Csz2)=checkInterface(Csz,L2,Csz2,L1,Csz1)
    L1.interface?=interface
* checkInterface(Cs,
    {[_]MWTs1 NCs1 Info1},Csz1,{interface[_] MWTs2 NCs2 Info2},Csz2)=interface
  Info1.closed undefined //thus no private abstract
  Cs notin Csz1//no other Cs in L1 watches over current Cs
  forall MWT in MWTs1 where MWT.e?=e, MWT.s not of form _::n(_)
  //no public impl methods (thus since not watched, privates can be trashed)
  Info1.hasClassMethods undefined


Cs1 implements Csz1 in L3 and Csz1 growns

A implements I1 I2
A;I1,I2  A;I1  A;I2
//{i,j}={1,2} and Cs|-Li>Lj

 
* Cs |- L2 > L1
  L1(Cs) is interface
  either L2(Cs).Ts\L1(Cs).Ts!=empty
  or dom(L2(Cs).MWTs)\dom(L1(Cs).MWTs)!=empty

* L[Cs0+=p This0.Cs1..This0.Csn] = L[Cs0=L']
  L' = L(Cs0)[L(Cs0).MWTs+p ..+p L(Csn).MWTs]

/**<pre>#define L1 ++p L2 = L0
  L1 ++p L2 = L0
    with L0=L1 +(p.evilPush(L0)) L2
    and ssv(p.evilPush(L1),p.evilPush(L2),p.evilPush(L0))
  //note, we need to refresh the private names here

</pre>*/void compose();

/**<pre>#define ssv((p1, p2)?, p0), ssv(p,e), refined(p,s,Ps)=Ps'
//subtle subtype violation error function, p1,p2 parameters can be absent/empty

ssv((p1, p2)?, p0):
  collect(p0, p0.top().Ps) subsetEq p0.top().Ps//using p0.equiv
  dom(p0.top().mwts) == dom(methods(p0,This0))
  forall {i,j}={1,2}, s in dom(pi.top()) \ dom(pj.top())//TODO: discuss: we may limit this test to s that are "refine" in p0
    ps0=refined(p0,s,p0.top().Ps),
    psi=refined(pi,s,pi.top().Ps)
    and ps0 subsetEq psi //using p0.equiv //that is, there is some 'surprisingly added' stuff in ps0
  if (p1, p2)? =empty
    int=empty,
  otherwise
    int=dom(p1.top()) intersection dom(p2.top())//that is, present in both p1 and p2

  forall C in int:                    ssv(p1.push(C),p2.push(C),p0.push(C))
  forall C in dom(p0.top())\int:      ssv(p0.push(C))
  forall refine? mt e in p0.top():    ssv(p0,e)

ssv(p,e):
  forall L such that e=ctxC[L]:  ssv(p.evilPush(L))

refined(p,s,Ps)={P |P in Ps and s in dom(p(P)) }
  //note: if p(P) is undefined, then not s in dom(p(P))
</pre>*/void ssv();

/**<pre>#define L1 +p L2 = L0
{interface?1 implements Ts mwts ncs} +p {interface?2 implements Ts' mwt1..mwtn nc1..nck}
   ={ (interface?1 mwts + interface?2 + mwt1..mwtn)
      implements (Ts\Ts',Ts')
      (mwts\dom(mwt1..mwtn) mwt1[mwts] * mwt1 .. mwtn[mwts] * mwtn)
      (ncs\dom(nc1..nck) nc1[ncs] * nc1 .. nck[ncs] * nck) }
  with x * y=  (interface?1,x)  +p  (interface?2,y)
</pre>*/void innerCompose();

/**<pre>#define interface?,M? +p interface?1,M1 = M2
interface?,empty +p interface?1,M = M //M is the metavariable for member, introduced in notation and grammar
interface?1,C:L1 +p interface?2,C:L2 = C: L1 +(p.push(C)) L2
interface?1,refine?1 mh1 e?1 +p interface?2,refine?2 mh2 e?2 = {refine?1,refine?2} mhi e?i
//we originally chose that allowing refine+non refine sum was more evil than good,
//but we want to implement interface methods without mentioning such interface, so we relaxed it
  where {i,j}={1,2} such that:
    p |- mhi<=mhj and e?j=empty,
    if interface?j=interface then p|-mhj<=mhi//that is mhi equiv mhj
//interface can not loose, implemented can not loose.
</pre>*/void sumMember();


/**<pre>#define interface?1 mwts1 + interface?2 mwts2=interface?
interface mwts1+interface mwts2=interface
interface?1 mwts1 + mwts2 = mwts2 + interface?1 mwts1
mwts1 + interface mwts2=interface
  where
  mwts1.e?s = {empty}
  "class" notin mwts1.mhs.mdfs
  mwts1.mss do not have number names (that is are not of form m__n(xs) )
mwts1 +mwts2=empty
  with size({n| refine? mh in (mwts1,mwts2), mh.s= m__n(xs)})<=1//note, since is not "mh e" we are asking for the abstract methods only

</pre>*/void isSumResultInterface();

/**<pre>#define p|-mh1<=mh2  //remember that p.equiv( P,P) hold even if p( P) undefined
p|-mh1<=mh2
  where p|-mh1.T<=mh2.T and parameters and exceptions are equiv, and mdfs are equal
  //similar to mh1[with T=mh2.T]=mh2
</pre>*/void methodTypeSubtype();

/**<pre>#define M[Ms]=M?
nc[nc1..ncn]=nci if nci.C=nc.C
mwt[mwt1..mwtn]=mwti if mwti.s=mwt.s
otherwise=empty
</pre>*/void selectMember();
}
