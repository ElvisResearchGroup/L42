_______
#define infer(p,HALF.Ms)=CORE.Ms  //TODO:next is informal
* infer(p,M'1..M'n)=I(M1)..I(Mn)
    I=I[p;IMap=solve(p,CCz);G=empty;CCz;onSlash=empty]
    M1..Mn=p♥M'1 .. p♥M'n
    n = max {n | p.get(n) is defined }
    p.get(i)={Hi MCsi Mi _}, where Mi not of form Mc
    var CCz = p|Ccz +> MCs1[from This1] +>..+> MCsn[from Thisn]
    while CCz changes:
    	CCz = collect(p, (p|Ccz +>M1+>..+>Mn).CCz)
_______
#define I(HALF.M) = CORE.M,  I(HALF.e) = CORE.e//TODO: this is incomplete
* I(CORE.M) = CORE.M
* I(MH e) = MH I[G=G^MH;onSlash=MH.T](e)
* I(\) = I.onSlash.P //undefined if it is empty
* I((Ds Ks e)) = (I[Ds](Ds) I(Ks) I[Ds](e))
* I((TX CORE.P)) = (iType(I,TX) CORE.P)
* I(xP.m(x1=e1 .. xn=en)) = I(xP).m(x1=I'(e1) .. xn=I'(en))
    I'=I[onSlash=I.IMap(I.G(xP))]
* I(xP0 op..op xPn)=I(e)
    Ti=I.IMap(I.G(xPi))
    selectedOptions(I.CCz, I.p, op, T0..Tn, xPs)=PT,s,i
    xP'1..xP'n=xP0..xPn/i
    e=xPi.m(x1=xP'1 .. xn=xP'n)  if s=methName(OP)_i(x1..xn)
    e=(class PT PT).#apply(x1=xP'1 .. xn=xP'n)  if s=#apply(x1..xn)
* I(e)=e' propagates on the structure for 
    x, void, CORE.L, throw e, loop e, x := e
_______
#define I[DS] = I',  I(HALF.D) = CORE.D,  I(HALF.K) = CORE.K
* I[TX1 x1=_ .. TXn xn=_]=I[G=I.G,x1:iType(I,TX1),..,xn:iType(I,TXn)]

* I(TX x=e) = iType(I,TX) x=(e[IMap;G;T]) 

* I(catch \ x e)[IMap;G;T]=catch T x (e[IMap;G;T])
_______
#define iType(I,TX)=CORE.T
* iType(I,T)=T
* iType(I,X)=I.IMap(X)
* iType(I,\)=I.onSlash
_______
#define p|CCz +> CORE.Ms = p|CCz',    p|CCz +> CORE.M = p|CCz'
p|CCz +> M1..Mn =p|CCz +> M1 +> .. +> Mn 
//assert never happens p|CCz +> C = FULL.L 
p|CCz +> C = CORE.L = p|CCz +> L.Ms[from This0.C]
p|CCz +> H { Info; M1 ... Mn } = p|CCz +> M1 +> ... +> Mn
p|CCz +>MH =p|CCz
p|CCz +>MH e = p|CCz',PT<=MH.T
  p|G^MH|CCz +> e:PT  = p|_|CCz'
_______
#define HALF.e[\ = PT]
\[\ = mdf? PP] = PP
(\ x = e)[\ = PT] = PT x = (e[\ = PT])
(catch throw \ e)[\ = PT] ::= catch throw PT (e[\ = PT])
otherwise propagate on D, K, e
_______
#define G | CCz |- HALF.e : CORE.T | CCz
// TODO: Add ps //WHAT IS ps??? 

    G|CCz +> e : PT'   = _|CCz'
--------------------------------------
   (G|CCz +> PT x = e) = G|CCz',PT' <= PT


   G, x->PT | CCz +> e : PT' = _|CCz'
--------------------------------------
   G | CCz +> catch throw PT x e : X = G|CCz',PT' <= X


   (G(D1..Dn) | CCz) +> D1 +> .. +> Dn +> (e : PT) = _|CCz'
   (G | CCz',PT <= X) +> (K1 : X) +> .. +> (Kk : X) = _|CCz''
--------------------------------------------------------
   G | CCz +> (D1..Dn K1..Kk e) : X = G|CCz''


---------------------------------
  G | CCz +> (x : G(x)) = G | CCz


-------------------------------------
  G | CCz +> (TP P : TP) = G | CCz, class P <= TP

  
  s = m(x1 ... xn)
  G | CCz +> (e0 : PT0) >+> (e1 : PT0.s.1) +par> .. +par> (en : PT0.s.n) = _| CCz'
-------------------------------------------------------------------
  G | CCz +> (e0.m(x1 = e1, ..., xn = en) : PT0.s) = G | CCz'


  G | CCz +> e[\ := PT.s.i] : PT' = _ | CCz'
---------------------------------------------------- //+par> is the parameter accumulation
  G | CCz +par> e : PT.s.i = G | CCz',PT' <= PT.s.1


  G | CCz +>  e : PT  = _| CCz'
--------------------------------------------------
  G | CCz +> x := e : Void = G | CCz', PT <= G(x)


  G | CCz +> e : PT = _ | CCz'
----------------------------------------------- for fresh X
  G | CCz +> throw e : X  = G | CCz',PT<=X


  G | CCz +> e : PT = _ | CCz'
------------------------------------------------
  G | CCz +> loop e : Void | CCz', PT <= Void

    P, s, i=selectedOption(CCz,p,OP, PT0..PTn, xP0..xPn)
    G | CCz0 +> (xP0 : PT0) +> ... +> (xPn : PTn) = _|CCz'
	PT'1 ... PT'n = PT0 ... PTn \ i
---------------------------------------------------------------------------------------------------
    G | CCz0 |- xP0 OP ... OP xPn : PTi.s | CCz', PT'1 <= P.s.1 ... PT'n <= P.s.n
_______
#define PT,s,i in opOptions(CCz, p, OP, PTs, xPs)
PT,s,i in opOptions(CCz, p, OP, PT0..PTn, xP0..xPn)
  where
  i in 0..n,
  P'1 ... P'n = (PT0..PTn\i).PPs
  !unsatisfiable(collect(P'1 <= P1, ..., P'n <= Pn, CCz))//TODO: discuss cachability of collect
  either
    s = methName(OP)_i(x1..xn)
    P1 ... Pn = paramaterPaths(PTi, CCz, s)
    PT=PTi
  or
    xPi = (PT P')
    P = P'.$methName(OP)_i
    s = #apply(x1..xn)
    P1 ... Pn = p[P.s].Ps
_______
#define selectedOption(CCz, p, OP, PTs, xPs)= PT,s,i
selectedOptions(CCz, p, OP, PTs, xPs)=PT,s,i
  {PT,s,i}=opOptions(CCz,p,OP, PTs, xPs)
selectedOptions(CCz,p,OP, PTs, xP0..xPn)=(xPi.P).$methName(OP)_i, s, i
  (xPi.P).$methName(OP)_i, s, i in opOptions(CCz,p,OP, PTs, xP0..xPn)
  forall (xPj.P).$methName(OP)_j, s', j in opOptions(CCz,p,OP, PTs, xP0..xPn)
    i=j, s=s'
    
====================OLD RULES, Isaac, check is the same as above

    { s } = { s | *forall x1..xn, forall {i}={0..n} where,
        s = methName(OP)_i(x1..xn)
        P1 ... Pn = paramaterPaths(PTi, CCz, s)
*        P'1 ... P'n = (PT0..PTn\i).PPs
*        !unsatisfiable(collect(P'1 <= P1, ..., P'n <= Pn, CCz)) }
    forall j,x1..xn forall (PT P) in xP0..xPn:
      p(P.$methName(OP)_j)(#apply(x1..xn)) undefined
*    G | CCz0 +> (xP0 : PT0) +> ... +> (xPn : PTn) = _|CCz'
*	PT'1 ... PT'n = PT0 ... PTn \ s.i
---------------------------------------------------------------------------------------------------
    G | CCz0 |- xP0 OP ... OP xPn : PT(s.i).s | CCz', PT'1 <= PTi.s.1 ... PT'n <= PTi.s.n


    { P'.s } = { P'.s | forall x1..xn, forall {i}={0..n} where,
    	P' = P.$methName(OP)_i
    	s = #apply(x1..xn)
        xPi = (PT P)
        P1 ... Pn = p[P'.s].Ps
        P'1 ... P'n = (PT0..PTn\i).PPs
        !unsatisfiable(collect(P'1 <= P1, ..., P'n <= Pn, CCz)) }
	G | CCz0 +> (xP0 : PT0) +> ... +> (xPn : PTn) = _|CCz'
    PT'1 ... PT'n = PT0 ... PTn \ s.i
---------------------------------------------------------------------------------------------------
    G | CCz0 |- xP0 OP ... OP xPn : PT(s.i).s | CCz', PT'1 <= P'.s.1 ... PT'n <= P'.s.n
 
=========================================================================================


//OLD------------

foo(class Any that)
foo((\ P) + 3Num)

P + ...
(T P) + ... // will call .$
// nothing ells will!
((T P))
(T (P))
(P)
(T x = P x) + ...  
(class Any P) + x // may call .$, will not call .#
(P) +x may cakk .# will not call .$
((class Any P)) + x will not call anything on P
