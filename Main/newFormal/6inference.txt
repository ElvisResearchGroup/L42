_______
#define infer(p,FULL.Ms)=CORE.Ms
* infer(p,M1..Mn)=I(p♥M1)..I(p♥M1)
    k = max {k | p(Thisk) is defined }
    p(Thisi)={Hi C/CORE.Msi FULL.Mi _}, where FULL.Mi not of form CORE.M
    C.Msi={C.M| C.M in C/CORE.Msi}[from Thisi]
    PAcc=PAcc[p;GX=empty;CCz=empty].add(C.Ms1 .. C.Msk).collect()
    CCz=PAcc.fixInfer(p♥M1..p♥Mn)//TODO: unsure... why we fix only on the new ones?
    I=I[p;IMap=solve(p,CCz);G=empty;CCz;onSlash=empty]
_______
#define PAcc.fixInfer(HALF.Ms) =CCz
* PAcc.fixInfer(Ms)=PAcc.CCz
    PAcc.add(Ms).CCz=PAcc.CCz
* fixInfer(PAcc;Ms)=PAcc.add(Ms).collect().fixInfer(Ms)
    otherwise
_______
#define PAcc.collect()=PAcc'
* CC in PAcc.collect()
    CC in PAcc.collect().collect())//is it needed since we have the fixpoint anyway?
* CC in PAcc.collect()
    CC in PAcc.CCz
* PT <= PT" in PAcc.collect()
    PT <= PT', PT' <= PT" in PAcc
* PT <= PT in PAcc.collect()
    PT in PAcc.CCz
* mdf P <= mdf' P' in PAcc.collect() //TODO: explosive, can we make it more computational? can we mix it with CollectSolution? 
    p |- mdf P <= mdf' P' // I.e. every subtype relation we know about
    P' != _ Any // Just for consistency with everything else, not important!
* mdf P <= PT in PAcc.collect()// since all classes are final
	PT <= mdf P in PAcc
	p[P].interface = empty 
* T.s <= PT in PAcc.collect()//since they are alias of each other 
    PT <= T.s in PAcc.collect().CCz //why noy simply in PAcc.CCz?
    PT=p[T.s].T
* T.s.i <= PT in PAcc.collect()//since method parameter types can not be refined (or since they are aliases?)
    PT <= T.s.i in PAcc.collect().CCz
    PT=p[T.s].Ti
* PT.s <= PT'.s in PAcc.collect()
    PT <= PT' in PAcc.CCz
    PT'.s in PAcc.CCz
* PT'.s.i <= PT.s.i in PAcc.collect()
    PT <= PT' in PAcc.CCz
    PT'.s.i in PAcc.CCz
* PT.s.i <= PT'.s.i in PAcc.collect()//since method parameter types can not be refined 
    PT <= PT' in PAcc.CCz
    PT'.s.i in PAcc.CCz
* PT1' <= Origin(s, P2') in PAcc.collect()
    PT1 <= P2', PT1 <= PT1' in PAcc.CCz
    P2'.s in PAcc.CCz
    PT1'.s in PAcc.CCz
_______
#define I(HALF.M) = CORE.M,  I(HALF.e) = CORE.e
* I(CORE.M) = CORE.M
* I(MH e) = MH I[G=G^MH;onSlash=MH.T](e)

* I(\) = I.onSlash.P //undefined if it is empty
* I((Ds Ks e)) = (I[Ds](Ds) I(Ks) I[Ds](e))
* I((TX CORE.P)) = (iType(I,TX) CORE.P)
* I(xP.m(x1=e1 .. xn=en)) = I(xP).m(x1=I'(e1) .. xn=I'(en))
    I'=I[onSlash=I.IMap(I.G(xP))]
* I(xP0 op..op xPn)=I(e)
    Ti=I.IMap(I.G(xPi))
    selectedOption(I.CCz, I.p, op, T0..Tn, xPs)=PT,s,i
    xP'1..xP'n=xP0..xPn/i
    e=xPi.m(x1=xP'1 .. xn=xP'n)  if s=methName(OP)_i(x1..xn)
    e=(class PT PT).#apply(x1=xP'1 .. xn=xP'n)  if s=#apply(x1..xn)
* I(e)=e' propagates on the structure for 
    x, void, CORE.L, throw e, loop e, x := e
_______
#define I[DS] = I',  I(HALF.D) = CORE.D,  I(HALF.K) = CORE.K
* I[TX1 x1=_ .. TXn xn=_]=I[G=I.G,x1:iType(I,TX1),..,xn:iType(I,TXn)]

* I(TX x=e) = iType(I,TX) x=I(e) 

* I(catch TX x e)[IMap;G;T]=catch iType(I,TX) x I(e)
_______
#define iType(I,TX)=CORE.T
* iType(I,T)=T
* iType(I,X)=I.IMap(X)
* iType(I,\)=I.onSlash
_______
#define PAcc[CCz]=PAcc'    PAcc[GX]   PAcc[D1..Dn]
* PAcc[CCz]=PAcc[CCz=PAcc.CCz,CCz]

* PAcc[GX]=PAcc[GX=PAcc.GX,GX]

* PAcc[D1..Dn]=PAcc[D1.x:D1.TX .. Dn.x:Dn.TX]
_______
#define PAcc.add(HALF.Ms) = PAcc'   PAcc.add(HALF.M) = PAcc'
* PAcc.add(M1..Mn) = PAcc.add(M1).. .add(Mn) //assert never happens PAcc.add(C = FULL.L) 
* PAcc.add(C = CORE.L) = PAcc.add(CORE.L.Ms)[from This0.C]

* PAcc.add(MH) =PAcc
* PAcc.add(MH e) = PACCp[G^MH].add(e:PT)[PT<=MH.T]
_______
#define HALF.e[\ = PT]
* \[\ = mdf? PP] = PP
* (\ x = e)[\ = PT] = PT x = (e[\ = PT])
* (catch throw \ e)[\ = PT] ::= catch throw PT (e[\ = PT])
* otherwise propagate on D, K, e

_______
#define PAcc.addD(HALF.D : PT) = PAcc'    PAcc.addK(HALF.K : PT) = PAcc'   PAcc.addPar(e:PT) = PAcc'
* PAcc.addD(D: PT) = PAcc.add(D.e : PT)[PT <= D.PT]

* PAcc.addK(K : X) = PAcc.add(K.e: PT)[PT <= X]

* PAcc.addPar(e:PT.s.i) = PAcc.add(e:PT')[PT' <= PT.s.i]
_______
#define PAcc.add(HALF.e : CORE.T) = PAcc'
// TODO: Add ps //WHAT IS ps??? 
* PAcc.add( (D1..Dn K1..Kk e):X ) = PAcc'[PT <= X].add(K1:X).. .add(Kk:X)
    PAcc'=PAcc[D1..Dn].addD(D1).. .addD(Dn).add(e:PT)
* PAcc.add(x:PAcc.GX(x)) = PAcc
* PAcc.add( (TP P):TP) = PAcc[class P <= TP]
* PAcc.add(e0.m(x1=e1..xn=en):PT0.s) = PAcc.add(e0:PT0).addP(e1:PT0.s.1).. .addP(en:PT0.s.n)
    s = m(x1..xn)
* PAcc.add(x := e : Void) = PAcc.add(e:PT)[PT <= PAcc.GX(x)]
* PAcc.add(throw e : X) = PAcc.add(e:PT)[PT <= X]
    fresh X
* PAcc.add(loop e : Void) = PAcc.add(e:PT)[PT <= Void]
* PAcc.add(xP0 OP ... OP xPn : PTi.s) = PAcc.add(xP0:PT0).. .add(xPn:PTn)[PT'1 <= P.s.1]..[PT'n <= P.s.n]
    P, s, i=selectedOption(CCz,p,OP, PT0..PTn, xP0..xPn)
    PT'1 ... PT'n = PT0 ... PTn \ i
_______
#define PT,s,i in opOptions(CCz, p, OP, PTs, xPs)
* PT,s,i in opOptions(CCz, p, OP, PT0..PTn, xP0..xPn)
    i in 0..n,
    P'1 ... P'n = (PT0..PTn\i).PPs
    !unsatisfiable(collect(P'1 <= P1, ..., P'n <= Pn, CCz))//TODO: discuss cachability of collect
    either
      s = methName(OP)_i(x1..xn)
      P1 ... Pn = paramaterPaths(PTi, CCz, s)
      PT=PTi
    or
      xPi = (PT P')
      P = P'.$methName(OP)_i
      s = #apply(x1..xn)
      P1 ... Pn = p[P.s].Ps
_______
#define selectedOption(CCz, p, OP, PTs, xPs)= PT,s,i
* selectedOptions(CCz, p, OP, PTs, xPs)=PT,s,i
    {PT,s,i}=opOptions(CCz,p,OP, PTs, xPs)
* selectedOptions(CCz,p,OP, PTs, xP0..xPn)=(xPi.P).$methName(OP)_i, s, i
    (xPi.P).$methName(OP)_i, s, i in opOptions(CCz,p,OP, PTs, xP0..xPn)
    forall (xPj.P).$methName(OP)_j, s', j in opOptions(CCz,p,OP, PTs, xP0..xPn)
      i=j, s=s'
    
====================OLD RULES, Isaac, check is the same as above

    { s } = { s | *forall x1..xn, forall {i}={0..n} where,
        s = methName(OP)_i(x1..xn)
        P1 ... Pn = paramaterPaths(PTi, CCz, s)
*        P'1 ... P'n = (PT0..PTn\i).PPs
*        !unsatisfiable(collect(P'1 <= P1, ..., P'n <= Pn, CCz)) }
    forall j,x1..xn forall (PT P) in xP0..xPn:
      p(P.$methName(OP)_j)(#apply(x1..xn)) undefined
*    G | CCz0 +> (xP0 : PT0) +> ... +> (xPn : PTn) = _|CCz'
*	PT'1 ... PT'n = PT0 ... PTn \ s.i
---------------------------------------------------------------------------------------------------
    G | CCz0 |- xP0 OP ... OP xPn : PT(s.i).s | CCz', PT'1 <= PTi.s.1 ... PT'n <= PTi.s.n


    { P'.s } = { P'.s | forall x1..xn, forall {i}={0..n} where,
    	P' = P.$methName(OP)_i
    	s = #apply(x1..xn)
        xPi = (PT P)
        P1 ... Pn = p[P'.s].Ps
        P'1 ... P'n = (PT0..PTn\i).PPs
        !unsatisfiable(collect(P'1 <= P1, ..., P'n <= Pn, CCz)) }
	G | CCz0 +> (xP0 : PT0) +> ... +> (xPn : PTn) = _|CCz'
    PT'1 ... PT'n = PT0 ... PTn \ s.i
---------------------------------------------------------------------------------------------------
    G | CCz0 |- xP0 OP ... OP xPn : PT(s.i).s | CCz', PT'1 <= P'.s.1 ... PT'n <= P'.s.n
 
=========================================================================================
NOTE: the following syntax is now unused
  PX ::=  P | X
  PP ::= PX | PX.s | PX.s.i


//OLD------------

foo(class Any that)
foo((\ P) + 3Num)

P + ...
(T P) + ... // will call .$
// nothing ells will!
((T P))
(T (P))
(P)
(T x = P x) + ...  
(class Any P) + x // may call .$, will not call .#
(P) +x may cakk .# will not call .$
((class Any P)) + x will not call anything on P
