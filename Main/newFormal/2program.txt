_______
#define p(P)=LL //functional notation
* (LL;_)(This0.Cs)=LL(Cs)
* p(Thisn+1.Cs)=p.pop(n+1)(This0.Cs)
* p(Any)=interface{}
* p(Void)=p(Library)={}
_______
#define p.pop(n)= p'
* p.pop(0)=p
* (LL;ctxL;ctxLs).pop(n+1)=(ctxL[LL];ctxLs).pop(n)
* (LL;CORE.L;ctxLs).pop(n+1)=(CORE.L;ctxLs).pop(n)
_______
#define p.push(ctxL,LL)=p', p.push(C)=p'
* (p;ctxL').push(ctxL,LL)=p.push(ctxL,LL);ctxL'
* (p;CORE.L).push(ctxL,LL)=p.push(ctxL,LL);CORE.L
* ctxL[LL].push(ctxL,LL) = LL;ctxL

* p.push(C)=p.push(ctxL,LL) //in the code, do not relies push(ctxL,LL)
    p(This0)=ctxL[LL]
    ctxL(C)=[]
_______
#define p.update(LL)=p'
* (p;ctxL).update(LL)=p.update(LL);ctxL
* (p;CORE.L).update(LL)=p.update(LL);CORE.L
* (LL';ctxLs).update(LL) = LL
_______
#define p.minimize(P)=P'   p.reducePath(P)=P' //assert defined only if p(This0) of form C/CORE.L
*p.minimize(P) = P
   p.reducePath(P) undefined
* p.minimize(P) = p.minimize(p.reducePath(P))
* p.minimize(P) = P
    P in {Any,Void,Library}

* p.reducePath(This(n+1).C.Cs)=Thisn.Cs
    p.pop(1).reducePath(Thisn.C.Cs) is defined
* (CORE.L;ctxL;_).reducePath(This1.C.Cs)=This0.Cs
    ctxL(C)=HasHole //Note:ctxL(C)=[] would be more restrictive, for example
   //preventing A:Data<><{method A (..)} to be summed with the constructor.
_______
#define p.equiv(P0,P1)
 p.equiv(P0,P1) = p.minimize(P0)==p.minimize(P1)
_______
#define p.navigate(Cs)=p'    p.navigate(P)=p'
* p.navigate(C1..Ck)=p.push(C1)...push(Ck)

* p.navigate(Thisn.Cs)=p.pop(n).navigate(Cs)
_______
#define p.noUnique(P)
*p.noUnique(P) = p.minimize(P) not of form Thisk._.C::n._
_______
#define p.resolveCs(FULL.T?)=TX
* p.resolveCs(empty)=X with fresh X// case FULL.T defined below
_______
#define p.resolveCs(FULL.T)=CORE.T,   p.resolveCs(FP)=CORE.P,  p.resolveCs(FULL.Docs)=CORE.Docs,  p.resolveCs(FULL.MH)=CORE.MH
* p.resolveCs(docs mdf P)=p.resolveCs(Docs) mdf p.resolveCs(P)

* p.resolveCs(CORE.P)=p.minimize(CORE.P)//this also handles FP starting for Any/Void/Library/Thisn
* p.resolveCs(C.Cs)=p.minimize(Thisn.C.Cs) //not already minimized
    where n is the smallest number such that either
      C in dom(p.get(n))
      or p.get(n)={@{__STOP_SCOPE__} _}
      or p.get(n+1) undefined

* p.resolveCs(FULL.Docs) =CORE.Docs where all the FP are replaced with p.resolveCs(FP)

*p.resolveCs(FULL.MH) propagates on the structure
   Docs0 refine? native[URL]? mdf method T0 mOp Docs1 (T1 x1 .. Tn xn)[Ts]
_______
#define P0[from P1]=P2 e[from P]=e' e[from P]n=e'  //TODO: minimize and from? should from minimize?
* Thisn.Cs[from Thism.C1..Ck]=Thism.C1..C(k-n).Cs if n<=k
* Thisn.Cs[from Thism.C1..Ck]=This(m+n-k).Cs if n>k
* Any[from _]=Any, Library[from _]=Library, Void[from _]=Void

* e[from P] propagate on the structure, and L[from P] = L[ from P]0

* {H Ms}[from P]j = {H[Ps=H.Ps[from P]j+1] Ms[from P]j+1}
* This(j+n).Cs0[from P]j=This(j+k).Cs1
    Thisn.Cs0[from P]=Thisk.Cs1
* Thisn.Cs[from P]j=Thisn.Cs with n<j
* All cases for other expressions/terms propagate to submembers, including docs  
_______
#define MH notations, MWT notations just inherits them,
with MH=refine? native? mdf method T m(T1 x1..Tn xn) 
* MH.T=T
* MH.Ts=Ts
* G^MH= this:mdf This0, x1:T1..xn:Tn
* MH.Ti = Ti
* MH.s=m(x1..xn)
_______
#define p|-T <= Tz    p|-T0 <= T1    p|-P0 <= P1    mdf0<=mdf1
* p|-T <= T0..Tn  iff  p|-T <= T0,..,p|-T <= Tn

 *p |- mdf0 P0<=mdf1 P1
    mdf0<=mdf1
    p |- P0<=P1

* p |- P0<=P1  
    P1 in P0 U (p(P0).Ts.Ps[from P0]) U Any
    assert p.normalize(Pi)=Pi

* capsule<=mut,imm,lent,read,fwd%Mut,fwdMut,fwd%Imm, fwdImm
* imm<=read,fwd%Imm,fwdImm
* mut<=lent,fwd%Mut,read,fwdMut
* lent<=read
* fwd%Mut<=fwdMut
* fwd%Imm<=fwdImm
_______
#define toRead(T)   toRead(G)
* toRead(T) //used in gamma and in return type getter
    toRead(fwdMut P)=toRead(fwd%Mut P)=undefined
    toRead(fwdImm P)=toRead(fwd%Imm P)=undefined
    toRead(lent P)=toRead(mut P)=toRead(capsule P)=read P
    otherwise toRead(T)=T//mdf in imm,read,class

* toRead(G)
    toRead(G)(x)=toRead(G(x))[with var?=empty] //thus undefined where toRead undefined

------------TAIL, probably not needed
-p.location()=P // Where we are in the program
 (LL).location()=This0
 (LL, ctxL, ctxLs).location() = This(k+1).Cs.C
    ctxL(C) = HasHole // We are in C
    (ctxL[LL], ctxLs).location() = Thisk.Cs