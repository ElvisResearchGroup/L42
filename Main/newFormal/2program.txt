
program primitive operations:

-p.top()=LL
 (LL,_).top()=LL

-p.pop()=p'
 (LL,interface?[Ps]{Ms C_evil:[]},ctxLs).pop()=interface?[Ps]{Ms},ctxLs
 otherwise // we have C_evil not in dom(ctxL)
 (LL,ctxL,ctxLs).pop()=ctxL[LL],ctxLs

-p.push(ctxL,LL)=p'
 (ctxL[LL],ctxLs).push(ctxL,LL)=LL,ctxL,ctxLs

-p.update(LL)=p' //this is the only one that can detect evilPush
 (LL,ctxLs).update(LL')=LL',ctxLs

-p.reducePath(P)=P' //assert defined only if p.top() of form LC
 p.reducePath(This(n+1).C.Cs)=Thisn.Cs
   where p.pop().reducePath(Thisn.C.Cs) is defined
 (CORE.L,ctxL,_).reducePath(This1.C.Cs)=This0.Cs
   where ctxL(C)=HasHole //Note:ctxL(C)=[] would be more restrictive, for example
   //preventing A:Data<><{method A (..)} to be summed with the constructor.
-p.location()=P // Where we are in the program
 (LL).location()=This0
 (LL, ctxL, ctxLs).location() = This(k+1).Cs.C
    ctxL(C) = HasHole // We are in C
    (ctxL[LL], ctxLs).location() = Thisk.Cs

program derived operations:

-p.get(n)=LL
 p.get(0)=p.top()
 p.get(n+1)=p.pop().get(n)

-p.navigate(Cs)=p'
 p.navigate(C1..Ck)=p.push(C1)...push(Ck)

-p.navigate(P)=p'
 p.navigate(Thisn.Cs)=p.pop()...pop().navigate(Cs) //with n pops

-p.minimize(P) = P
  where p.reducePath(P) undefined
 p.minimize(P) = p.minimize(p.reducePath(P))

-p.equiv(P0,P1)
 p.equiv(P,P)
 p.equiv(P0,P1)=p.equiv(P1,P0)
 p.equiv(Thisn.Cs,This(n+k).C1..Ck.Cs)=p.minimize(Thisk.C1..Ck)=This0

-p.noUnique(P) holds if p.minimize(P) not  of form Thisk._.C__n._

-p(P)=LL //functional notation
 p(Thisn.Cs)=p.get(n)(Cs)
 p(Any)=interface{}
 p(Void)=p(Library)={}
 
-p.push(C)=p'
 p.push(C)=p.push(ctxL,LL)
 where ctxL[LL]=p.top() and ctxL(C)=[]

-p.evilPush(CORE.L)=p'// TODO: in code make sure we only call on CORE.L
 ({interface? Ps Ms},ctxLs).evilPush(CORE.L)=CORE.L,{interface? Ps Ms C_evil:[]},ctxLs
 with C_evil reserved C name.
 A well-formed project (top level L) can not have C_evil anywhere.
_______
#define MWT.T=T MWT.Ti 
MWT.T = MWT.mt.T
MWT.Ti = Ti  where T1..Tn=MWT.mt.Ts
 

------------TAIL

 //Note: p.push(LL)=p' (ie searching p.top() for a library that matches LL)
 // is not used in the code since it would be very slow and not expressive enough.
 // p.push(LL)=p.push(ctxL,LL) with ctxL[LL]=p.top()
