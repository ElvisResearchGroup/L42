-----------------------------------------------------------
Part 1: grammars for auxiliary data and contexts
-----------------------------------------------------------
LC::= //an L is LC if forall C in dom(L), L(C).e is of form CORE.L
eC,parC,... ::= //an e is eC if all the L inside are of form LC, similarly for parC etcetera

LL::= FULL.L | CORE.L

FULL.wrapE::= throw [] | loop [] |[](.m)?( par) |[]Square | []StrLit |x updateOp [] |(T []) 
      | '(' DEs Ks WOPS? [] ')' | while e [] | for DXes []
      | if (MatchC+ |e) [] (else e0)?     
wrapEC::= wrapE but has all subexps as eC

FULL.ctxC::=[]
 | wrapEC[ctxC]
 | eC.m?(ctxC par)
 | eC.m?(parC, x=ctxC, par)
 | eC[parCs; ctxC, par;pars]
 | eC[parCs; parC, x=ctxC, par;pars]
 | (eC op)s ctxC (op e)s
 | ( DECs DX? ctxC DEs Ks WOPS? e? )  
 | ( DECs KCs catch throw? T x ctxC Ks WOPS? e? )  
 | { DECs DX? ctxC DEs Ks WOPS? DEs2 }
 | { DECs KCs catch throw? T x ctxC Ks WOPS? DEs2 }
 | { DECs1 KCs WOPS? DECs2 DX? ctxC DEs }
 | if ctxC e (else e0)?
 | if (MatchC+ |eC) eC0 else ctxC
 | if MatchC+ DX=ctxC Match+ e
 | while ctxC e
 | for DXeCs DX in ctxC DXes e

Thus if e=ctxC[L] where L not of form LC, all other L more top-left are of form LC
The compilation context, e=ctxC[L] selects an L where
all of the former Ls are LC.
The context does not enter into libraries

CORE.wrapE::= throw [] | loop [] | x := []  | '(' Ds Ks [] ')'
CORE.ctx ::= []
 | wrapE[ctx]
 | xPP.m( xes x=ctxCore xes' )
 | (Ds T x=ctx Ds' Ks e)
 | (Ds Ks catch throw T x ctx Ks' e)

FULL.ctxM::= C = ctxC |s = ctxC | MH = ctxC
FULL.ctxL::= interface? Ts{MCs ctxM Ms} | CORE.ctxL
CORE.ctxL ::= interface? Ts{MWTs NCs1 C =[] NCs2} |interface? Ts{MWTs1 MH=ctx MWTs2 NCs}  

_______
#define functional notation for L, ctxL and LC (over the domain Ldom)

-----------------------------------------------------------
Part 2: program
-----------------------------------------------------------
Program-specific grammar is needed to represent the position
in the project (top level Library) that we are reducing.
For example, if our 42 project is
{ A=... B=This0.A.second({ method Library m(){C=This2.A.first({})} }) }
we first need to reduce "A.first({})"
In order to explicitly denote the meaning of "Thisn", we split the project
into the 3 part program
p={C=This2.A.first({})};{ method Library m()[]};{ A=... B=This0.A.second([]) }
Note that the first component is an L, while the others have a hole, [],
so they are of form ctxL.
Note how the first component uses This2.A in order to skip two levels
and refer to A in the outer most layer of our project.

It is possible to see the program as a stack, with a top() and a pop() operation.
Given a program is always possible to reconstruct the project
by doing a series of pop operations.
Since the top of the stack is of a different kind with respect to the other elements,
pop replaces the [] with the stack top to forge an L
push, the opposite of pop, extracts a piece of the top to forge a new top.
To do so, it takes in input the split form of the old head.
Finally, notice how in this model updating the top  can not be emulated with pop() + push()

p::= LL;FULL.ctxLs //representing This0,...,Thisn // where This0.C refers to a class bound in L0, and (This1..ThisN).C to bindings in cxtL1..cxtLn respectively

program primitive operations:

-p.top()=LL
 (LL,_).top()=LL

-p.pop()=p'
 (LL,interface?[Ps]{Ms C_evil:[]},ctxLs).pop()=interface?[Ps]{Ms},ctxLs
 otherwise // we have C_evil not in dom(ctxL)
 (LL,ctxL,ctxLs).pop()=ctxL[LL],ctxLs

-p.push(ctxL,LL)=p'
 (ctxL[LL],ctxLs).push(ctxL,LL)=LL,ctxL,ctxLs

-p.update(LL)=p' //this is the only one that can detect evilPush
 (LL,ctxLs).update(LL')=LL',ctxLs

-p.reducePath(P)=P' //assert defined only if p.top() of form LC
 p.reducePath(This(n+1).C.Cs)=Thisn.Cs
   where p.pop().reducePath(Thisn.C.Cs) is defined
 (CORE.L,ctxL,_).reducePath(This1.C.Cs)=This0.Cs
   where ctxL(C)=ctxC //Note:ctxL(C)=[] would be more restrictive, for example
   //preventing A:Data<><{method A (..)} to be summed with the constructor.
-p.location()=P // Where we are in the program
 (LL).location()=This0
 (LL, ctxL, ctxLs).location() = This(k+1).Cs.C
    ctxL(C) = ctxC // We are in C
    (ctxL[LL], ctxLs).location() = Thisk.Cs

program derived operations:

-p.get(n)=LL
 p.get(0)=p.top()
 p.get(n+1)=p.pop().get(n)

-p.navigate(Cs)=p'
 p.navigate(C1..Ck)=p.push(C1)...push(Ck)

-p.navigate(P)=p'
 p.navigate(Thisn.Cs)=p.pop()...pop().navigate(Cs) //with n pops

-p.equiv(P0,P1)
 p.equiv(P,P)
 p.equiv(P0,P1)=p.equiv(P1,P0)
 p.equiv(Thisn.Cs,This(n+k).Cs')=p.equiv(Thisn.Cs,p.reducePath(This(n+k).Cs'))

-p.minimize(P) = P
  where p.reducePath(P) undefined
 p.minimize(P) = p.minimize(p.reducePath(P))

-p.noUnique(P) holds if p.minimize(P) not  of form Thisk._.C__n._

-p(P)=LL //functional notation
 p(P)=p.navigate(P).top()//but some implementation could be faster

-p.push(C)=p'
 p.push(C)=p.push(ctxL,LL)
 where ctxL[LL]=p.top() and ctxL(C)=[]

-p.evilPush(CORE.L)=p'// TODO: in code make sure we only call on CORE.L
 ({interface? Ps Ms},ctxLs).evilPush(CORE.L)=CORE.L,{interface? Ps Ms C_evil:[]},ctxLs
 with C_evil reserved C name.
 A well-formed project (top level L) can not have C_evil anywhere.

------------TAIL

 //Note: p.push(LL)=p' (ie searching p.top() for a library that matches LL)
 // is not used in the code since it would be very slow and not expressive enough.
 // p.push(LL)=p.push(ctxL,LL) with ctxL[LL]=p.top()

 _______
#define eC' inside eC //INCOMPLETE... but... is it needed now?
- eC' inside eC if eC=ctxC[eC']
- P inside ( _ DX _) if P=T.P
- P inside ( _ catch throw T x _ _) if P=T.P
- P inside M holds iff P inside M.e //called CollectPaths0.of(P)
 or M.mh= refine? T0 m(T1 x1..Tn xn) exception Ps
 and Ti= _ P or P in Ps //or P is in the method docs
 