failing tests
-----------------------
refactor.TestInvariantClose 1,2,3,4,6
repl.CachingTest 
newReduction.TestL42F 0,5,6,7,9
testAux.TestPassingPrograms //check and remove?
widgetGui.TestTests SafeMovable
--------------

mut T bar = ...
mut T foo = IMList[mutelems: bar];

read T _ = foo.getRead(0); // ok
mut T _ = foo.getMut(0);
imm T _ = foo.getImm(0); // runtime error

imm T ifoo = foo;

imm T _ = ifoo.getRead(0); // ok
//mut T _ = ifoo.getMut(0); // type error
imm T _ = ifoo.getImm(0); // runtime error

read T rfoo=ifoo.norm();
imm T _ = rfoo.getImm(0); // runtime error

ifoo.iterator()

ifor x in e ()
==>
mfor x in e.iter() ()
nfor x in ifoo() => for x in ifoo.imIter();


for x in ifoo.vals() (/* x is imm*/)
for x in foo.vals() (/* x is read*/)
for var x in foo.#vals() (/* x is read but updetable*/)
for x in foo.#vars() (/* x is mut*/)
for x in rfoo (/* x is read*/)


delimiters: {} () [] :; ''  "" ..
or even a language to define user defined delimiters



Trait X = {
  S: {}
  T: { S foo(); }
}

X<T = Bar>

CA<A extends CA<B>,B extend CB<A>>{ B m(B b); }
CB<A extends CA<B>,B extend CB<A>>{ A m(A a); }
CC<A extends CA<A,B>,B extend CB<A,B>> { ...}


trait CA { 
  type B: CB<A = Self>;
  B m(B b); 
}
trait CB {
  type A: CA<B = Self>;
  A m(A b); 
}

trait CC<A: CA<B = B>, B: CB<A = A>> {
  ...
}
trait CC {
  type A: CA<B = Self::B>
  type B: CB<A = Self::A>
}

C<A extends CA<B>,B extend CB<A>> { ...}\

CC: {
  A: { B m(B); }
  B: { A m(A); }
  ...
}<A=MyA, B=MyB>





-capsule visible as read

e1 (caps/imm/class) can always be in parallel
e2 (read)

if we can have a lent collection of read objects
or anyway update a read field, we have -capsule visible as read
  lent list=.. //lent method add(read r)
  capsule a=..
  capsule a2=(mut b=a
   list.add(b)
   b)
  a2 and list usable
  

-------------------------------

name->name
name=>name

iname arrow name
-if method left is method right

A: {
  B: {method Void bar() e}
  C: {method Void bar() e'}
  method Void foo(B)
}[B ~~> C]
[ B=>F][B->C][F->B]


A: {
  User:{method Void call(B that)}
  B: {method Void bar() User.call(this)}
  method Void foo(B b)
}

A: {
  B: {method Void bar()}
} +  {
  User:{method Void call(C that)}
  C: {method Void bar() User.call(this)}
  method Void foo(C b)
}





A: {
  B: {method Void bar()}
  User:{method Void call(C that)}
  C: {method Void bar() User.call(this)}
  method Void foo(C b)
}

A: {
  User:{method Void call(B that)}
  I: {interface method B m() }
  B: {implements I refine method This m()( User.call(this) this) }
}
=> [extract B into C]
A: {
  User:{method Void call(B that)}
  I: {interface method B m() }
  B: {implements I refine method This m()( User.call(this) this) }
  C: {implements I refine method B m() }
}
=> [moveImpl B into C]
A: {
  User:{method Void call(C that)}
  I: {interface method C m() }
  //B: {implements I refine method C m()}
  C: {implements I refine method C m()( User.call(this) this)  }
}

A: {
  I: {interface method C m() }
  B: {implements I refine method This0 m() }
  C: {implements I refine method This0 m() }
}

A: {
  D: {
    B: {}
    method Void foo(This0.B)
  }
}[D.B -> C]

==>
A: {
  D: {
    method Void foo(This1.C)
  }
    C: {}
}[D.B -> C]

A: {
  User:{method Void call(C that)}
  B: {method B bar()}
  C: {method C bar() this}
  method Void foo(B b)
}


L[B => C]
===>
L[toAbstract][only B] + L[B -> C]


L[B =+> C]
===>
L[B -> C] + L[only B]

-> move code and references
=> move code and leave abstract behind
-!> extract abstract signature in a new place
~~>old code stay, move reference and instert new abstract if needed
//marco belive ~~> not needed

A: {
  User:{method Void call(B that)}
  I: {interface method B m() }
  B: {implements I refine method This m()( User.call(this) this) }
}

iname=Cs.s | Cs | trash
class method
  Cs.s -> Cs'.s' = rename // need to rename this -> Cs, This->Cs
  Cs.s -> P'.s' = redirect? // all the signature is external Paths
  Cs.s => Cs'.s' = rename but not reference//this -> Cs, This->Cs
  Cs.s ~~> Cs'.s'= make sense and is derived 
  Cs.s ~~> P.s'= make sense, redirect can be derived from this
  Cs.s -!> Cs'.s'= what happens to class method This foo() ? This=Cs or Cs'? for consistency This=Cs for cases like This.C=Cs.C


nested class =>, ~~>, -!> not work or work strange
  iname -> iname = rename
  iname -> ename = redirect
  //iname => iname = toAbstract + code copied if no trash
  //iname => ename 
class instance method
refined method
interface instance method /class
class method

state method
private class
private method



Q1:SQL"abc #1 d #2"

C: {This1.C m()} +> { This0 m()}


Operators:
-----------
1
close Cs:
  add to a coherent Cs a private version of all the
  state methods, and implement all abstract methods by
  delegating to the corresponding private abstract state method.
  As an option, can take a name of an invariant method, and
  in that case it properly add the invariant checks and do 
  all the needed checks to see if the invariant is valid.
Errors:
  -Cs does not exists or is private
  -Cs is not coherent
  -provided selector for invariant does not exists or is private
  -some invariant restrictions are violated.
2
Lib1 + Lib2:
  ...we know...
3
refactor L[Rs]:
a list of rename and move as defined below
=> rename
->move (move implementation)
R::= Cs(.s)? -> Cs'(.s)?' |Cs(.s)? -> _ | //move, toAbstract
     Cs(.s)? => Cs'(.s)?' |Cs(.s)? => _ | //rename, hide
     Cs(.s)? => P(.s)?'                   //redirect

-In all the cases is an error if Cs(.s)? do not exists or is private

Methods: 
- if an abstract state method is hidden, then the class if first
  automatically closed.
Class method
The simplest case is when the target is a class method:
  Conditions:  L(Cs), L(Cs') not interface, L(Cs.s) class and not refine
  -> leave the abstract signature in place;
     sum to L(Cs') the method, where all the occurences
     of 'This' and 'this' are replaced with Thisn.Cs 
     (with Cs=C1..Cn)
  => as for ->, but also rename all the references to Cs.s.
     Remove the abstract signature in Cs.s

Instance method
  Conditions:  Cs=Cs', L(Cs), not interface, 
               L(Cs.s)not class and not refine
  -> leave the abstract signature in place;
     sum to L(Cs') the method
  => as for -> but also rename all the refernece to Cs.s
     Remove the abstract signature in Cs.s
--
 *a refine method can not be renamed '=>'
  but can be moved '->' normally.
 *If an instance method is specified, but Cs!=Cs', then
 automatic lifting is applied:
 the method body is tweeked so that is turned in a class method that takes 'this' as first argument. The class method is then handled as before.
 *if an interface is specified, some issues may arise and are solved as follow:
 -> does not makes sense. If it was allowed it would add an abstract
    method to the interface, thus making private nested classes
    implementing it non coherent, thus ill formed.
 => propagate the rename to all the classes and interfaces implementing it. If a class have another implemented method in place of the destination, such method is first hidden.
 if another interface method is in place of the destination,
 implementations of such method are discarded (a reasoning on contracts may justify this controversial design)
 *if an interface method need to be lifted at the class level,
  a body can be syntetised by collecting in a switch all the bodies
  of the classes implementing it. Then a last method work as a default. For example
  {
  I:{interface method Void foo()}
  A:{implements I method foo()Debug(S"A")} 
  B:{implements I method foo()Debug(S"B")}
  C:{implements I }//foo()  abstract
  D_$_1:{implements I method foo()Debug(S"D")}
  }[I.foo()=>K.bar(that)]
  =
  {
  I:{interface}
  A:{implements I method Void foo()Debug(S"A")} 
  B:{implements I method Void foo()Debug(S"B")}
  C:{implements I method Void foo()}//foo()  abstract
  D_$_1:{implements I method foo()Debug(S"D")}//private D
  K:{class method bar(I that)={
      if A that return that.foo()
      if B that return that.foo()
      if C that return that.foo()
      if D_$_1 that return that.foo()
      return This.foo(that)}
    class method Void foo(I that)//abstract
  }
  ------
  If the specified s' have the same name of s, then the body is not built and the result is just the abstract method Void foo(I that)

  All the references to myI.foo() are now replaced with K.foo(myI),
  however, what should we do with myA.foo() ? it is relevant for
  the next step of metaprogramming.
  
----
  Nested classes: 
  Cs => Cs' works as rename now, I think is also ok for interfaces.
  Cs => _ need to check that Cs is consistent
  Cs =>P wors like redirect now, thus can expand the mapping.

  Cs -> _ works as toAbstract now, thus can raise privacy coupuled.
    It would be nice if we had a 'type' for Cs so that is can be
    seen as privacy coupuled or not without trying to abstract it.
  Cs ->Cs'
    In addition of all the privacy coupuled issues, we also need
    to considered refined methods and uses of 'this' as discussed
    last time. Also here we may have a 'type' for Cs, like
    'this free' to give the information that the code do not use
    this/This in ways that prevent moving the implementation away.
    This could be much easier to support than privacy coupuled.

Have I forgot some other cases?

{
I:{foo()}
B:{implements I refine foo()a}
}[I.foo()=>I.bar()]
={
I:{bar()}
B:{implements I refine bar()a}
}

{
I:{foo()}
B:{implements I refine foo()a    bar()b}
}[I.foo()=>I.bar()]
=
{
I:{bar()}
B:{implements I refine bar()a    bar_$_1()b}
}


{
I1:{interface foo() bar()}
B_$_1:{implements I1 refine foo()a    refine bar()b}
}[I1.foo()=>I1.bar()]
=
{
I1:{interface bar()}
B_$_1:{implements I1 refine bar()a }
}


{
I1:{interface foo()}
I2_$_2:{interface bar()}
B_$_1:{implements I1,I2_$_2 refine foo()a    refine bar()b}
C:{implements I2_$_2 refine bar() c}
}[I1.foo()=>I1.bar()]
//ok, bar in C is refined. Thus we know is a bar from interface
and it need renaming.
Thus: when reneming an interface method, all interface method with the same name need to be renamed. If the user do not specify, a numeric pedex is generated.
user need to give a new name to all the bars, those are consistently renamed.
-lifting if s have 1 extra arg, embedding if s have 1 less arg (and the first arg type match This0)
-how to embed in an interface?


Cs can be
  interface
  proper
  proper close
  interface privately implemented
proper classes
  rename them is ok,
  moving them is ok.
interfaces
  rename them is ok,
  moving them is ok,
    while summing them: subtile subtype violation

  {
  A:{interface method a()} B:{interface method b()}
  C_$_1:{implements A refine method a()}
  }[B=>A] //or also for [B->A]
  =
  {
  A:{interface method a() method b()}
  C_$_1:{implemens A  refine method a()}//refine method b()
  }=SubtypeClash
//A is privatly implemented and operation add method b()

refine methods:
  nope, never a good target
interface methods:
  local rename them is ok,
    //NObut the target name need to be globally renamed
    on default is renamed in the implemented classes, and is error
    to hide a refine method.
    Can be tuned by [rename I.foo()=>I.bar(), B.bar()=>B.foo()]
    to insert delegation methods B.foo()=this.bar().
  L[Cs.s=>Cs.s'] //ok if refine s' never appear public
  moving them makes no sense.
  lifting them is ok, behaviour is syntetised with switch.
  class methods can be lifted as well.
  L[Cs.m(xs)=>Cs'.m'(_this,xs)]
    ok if Cs' proper class,
    class method T m(Cs _this, Ts xs)={if T1 _this return...}
    class method T m'(Cs _this, Ts xs)

  embedding a method in an interface method makes no sense.
  non-local rename or move makes no sense.
class methods of proper classes
  all renames and move works.
  lifting them makes no sense.
  can be embedded in a proper class.

given an extend map m:
close Csz; Rs
1 apply all the closes
2 forall the Cs.s=>Cs'.s' and Cs=>Cs'rename the references
3 forall Cs =>.. mapping remove the Cs,
  forall Cs ->.. mapping remove the Cs body,
  forall Cs.s=>.. remove the method declaration
  forall Cs.s->.. remove the method body
4 forall  ..->Cs or ..=>Cs mapping sum the moved class bodies
  forall method mapping move the methods declarations 


principles:
  all visible names should be renamable


private interfaces have all methods private
private class need to have closed state
well formedness a class with private abstract methods need to have those coherent on their own
private abstract refine are not well formed


{
  I: {interface method T foo() }
  B: {implements I
    class method factory(T foo)
    refine method T foo()
    method bar()
  }
[rename I.foo => I.bar]
[close B(???)]
[E.eq=>_; C.eq->C.eq]

{
  I: {interface method T foo() }
  B: {implements I
    class method factory(T foo) factory_1(foo)
    class method factory_1(T foo) 
    refine method T foo() foo_1()
    method T foo_1()
    method bar() // try to close bar, fail as not part of constructor
  }

//ok since B would public open state not coherent
[rename I.foo => _]
//B public with coherent close state, unexpected?
May be:
  if one is hiding a set of abstract methods, it check that the hidden one is coherent on its own.

what Close should do since multiple constructors exists

/*
1. Implement interface somewhere else (not inside class decl)
2. Implement interface multiple times (have a different 'default', or allow manual selecting at each point (I1)A)  (I)(I1)myA != (I)(I2)myA
3. Only 'see' some methods of implemented interfaces, in different contexts...(((I)A).foo !=> A.foo)
4. Conflicting name support (implementing interfaces with methods of the same name, having non refine methods with the same name, etc..)
5. One implementation, for multiple classes at the same time.../automatic implementation
6. Self type
-----------
Guarantees:
1. One way casting ( (I)(A)a !=> (A)(I)a )
2. Final methods (we know what (I)a.foo will do.., but maybye not (I)a.bar)
3. more control on who can and can't implement....
*/


subtype
semantic indepentent from types
a.foo() ===(  T x=a, x.foo())

interface I { foo }
class A: I { foo = e1 } // option 1, myA.foo == ((I)myA).foo == e1
class B: I { foo = e1; I.foo = e2 } // option 2 myA.foo == e1, ((I)myA).foo == e2
class B: I { I.foo = e2 } // ! myA.foo , ((I)myA).foo = e2

class C: { 
  void foo() { return e1; } }
class B: C {
  /*new*/ void foo() { return e2; } }
// myB.foo() == e2, ((C)myC).foo() == e1


myC = { bar() this.foo()  foo() 1 }
myB = myC + { foo() 2 }

myB.foo() == 2, myC.bar() = 1


without 4
{
I1:{foo()}
I2:{bar()}
B:{A_1:{implements I1 I2
  foo()=e1
  bar()=e2
  }}
}[rename I2.bar => I2.foo]
with 4
{
I1:{foo()}
I2:{foo()}
B:{A_1:{implements I1 I2
  I1.foo()=e1
  I2.foo()=e2
  }}
}[rename I1=>I2]

{
  I1:{foo()}
  I2:{bar()}
  B:{A_1:{implements I2 bar()=e1}}
}[rename I1=>I2]
since B privatly implements I2
  I2 can not get more methods

B privatly implements I1,I2
B friend of A

{I:{inteface Foo foo()}
B:{implements I
  refine Foo foo()
  class method This (Foo foo)
  }
}[hide I.foo()]
=
{I:{inteface Foo foo_1()}
B:{implements I
  refine Foo foo_1()
  class method This (Foo foo)
  }
}
===
{I:{inteface Foo foo_1()}
B:{implements I
  Foo foo()this.foo_1()
  refine foo_1() //this.foo()
  class method This (Foo foo)
  }
}[hide I.foo()]

-------------------------
{I:{inteface Foo foo()}
B:{implements I
  refine Foo foo() e
  }
}//[hide I.foo()]
[rename I.foo()=>I.bar()]//[rename I.foo()=>I.bar(), B.bar()=>B.foo()]
=
{I:{inteface Foo bar()}
B:{implements I
  refine Foo bar() this.foo() //refine Foo bar() e
  Foo foo()e //
  }
}

B: {
  Foo foo() e
}[foo ~> bar] // forward body to bar (insert sig if neccesary)
-------
B: {
  Foo foo() this.bar()
  Foo bar() e
}
[foo => bar, bar ~> foo]


{I:{inteface Foo bar()}
 B:{implements I refine Foo bar() e}
}[rename I.foo()=>I.bar()]


{I:{inteface Foo foo_1()}//case1 //consistent with rename
B:{implements I  refine Foo foo_1() e } } //bad because no request to mod B
{I:{inteface Foo foo_1()}//case2 //worst
B:{implements I  Foo foo() this.foo_1()  refine Foo foo_1() e } }
{I:{inteface Foo foo_1()}//case3 //good for state/abstract foo()
B:{implements I  Foo foo() e  refine Foo foo_1() this.foo() } }

{I:{inteface Foo bar()}
B:{implements I  refine Foo bar() e } } //bad because no request to mod B


today
each Lib has ns
if Lib declare non-refined member with n, n in owned ns
if L1,L2 in project, L1 has n, L2 has n implies L1==L2


project has ns mentioned
reuse URL refresh ns with non mentioned ones
A+B refresh private numbers
rule top
B=....
A=EvilLib.makePrivateCall(B, "m")

X:{
  B={class method foo_1() }
  A=Evil(B) --> {class method bar() B.foo_1()}
}

A=Trait({B={ foo()}
 bar()B.foo()
 })
A[hide B.foo()]
={B={ foo_1()}
 bar()B.foo_1()
 }

X:{
  B={ foo() }
  A={ bar() B.foo()}
}[unhide B.foo]

{A: {TAF foo, TAB bar} B: {TBF foo TBB bar}}
[A=>B, A.foo=>A.bar, B.bar=>B.foo]

A=>B, B.C => A
B.C => A, A=>B
==
A=>B'; B.C => A; B' => B

A=>B, A.C => D
==
A => B'; B'.C => D; B' => B

L[Cs1=>Cs1', Cs2=>Cs2']

L[Cs1' = L[Cs1] + L[Cs1'],
  Cs2' = L[Cs2] + L[Cs2']]






{A:{C:{}} B:{C:{foo}}}
A=>B, B.C=>D
{B:{} D:{foo}}

{A:{C:{}} B:{C:{foo}}}
A.C=>D A=>B
{D:{} B:{C:{foo}}}


Option1:
{A: {TAF+TAB bar} B: {TBF+TBB foo}}
{B: {TAF+TAB bar      TBF+TBB foo}}

Option2:

{B: {TAF+TBF foo      TAB+TBB bar}}
{B: {TAF+TBF bar      TAB+TBB foo}}


Option1:
{A: {TAF bar, TAB foo} B: {TBF bar, TBB foo}}
{B: {TAF+TBF bar, TAB+TBB foo}}

Option2: 
{B: {TAF+TBF bar, TAB+TBB foo}}



(D = {};).evilPush(L)

p = (C = L, D={})

p.push(D) == D,p


p(This0) = L
p.minimize(This1.C) = This0
p(This1.C)



if the error can move, no hope for error messages

A:B:{code1} //7   { K:{}  S m(K x)= x.bla(x.foo())}

C:...A.B.code1 +{ K{ method blaa()}}



D:C.foo() // method bla in line 7: x.bla(), bla() non defined on x


Library foo(Library l) { 
  return l<X => S> }

This generalized from, handle moving of code literals:
For example { A:{method This2.B }}
{{{  Thisn.Cs  }}}

{{{  Thisn.Cs  }}}



method #$foo()= use Path ....
mut method foo()= use Path ... #$foo()


read


C=e  .#$

method Num foo()
read method Bool invariant()


method ... this.foo=0; x.bar(this) ...

invariant
  forall wi in widgets.... wi.getX()

5 widgets
4 direction
77
50mill


 $#$foo(e1,e2,e3)
e1.foo0(e2,e3)
e2.foo0(e1,e3)
e3.foo0(e1,e1)
e1.foo1(e2,e3)
e2.foo1(e1,e3)
e3.foo1(e1,e1)


a/b

{..}+foo



This(n+j).Cs.from(Thism.Cs', j) = Thisn.Cs.from(This(m+j).Cs')


C = {E:{} D:{This2.C.E m()}}[D=ED]
C = {E:{} D:{This1.E m()}}[]


C = {This0 m() thi} <+ {This1.C m()}

getRight(L1, L2) = L2


[a:A->B b:()->A]x={a: e1 b:e2 }
[a:A->B ]y=x

D::= enum T { KK }
KK::=K{(T id)s}
e ::= x | |x : T| e | K{(id:e)s} | match e { cases }
case ::= case K{(id:id')s} => e

e.id == match e { case [e]{id:r} => r } // only if e: T with a single case T
//more flexible: case ?{id:r} works if the matched type have an id


x = typeof(y! := e) in e'
  // typechecks/compiles e to et, 
  // defines in e':
  //    x to be the type of et
  //    y! compiles/expands to et

x #= typeof(y := e); e'
  ===>
      x #= T;
      T y := e;
      e'
// where it guesses T somehow...
let x y=()->e in e'

a' y := 3;
a z := y;
print(a');

x #= typeof(y := 3);
x z := y; // works!
print(x); // prints 'int'




from!(x, in: myList, where: x > 3, select: foo(x))
  
--> T y = myList.where(x -> x>3).select(x -> foo(x));


  T := typeof(y := foo(x)); e' // fails! x is not in scope
  a' _=lambda!(x,x->select)
  ret[a] 
  //myList.where(x -> x>3).select(x -> foo(x))

x #= typeof(y := 3);

returnBlock!(body: e[return! e])
-->

x #= typeof(y);
  ...
  x y := e;
...



e.x == case e 

type T= T a:A->B b: ()->A
x=T a:e1 b:e2
type I= I a:A->B
I y=I a:x.a



converter[T, I] = ....


x=e| e.f | {(f:e)s} | x->e
x.f=3 === x=x[f=3]
x[i]=3 === x=x[i=3]

(x.f).g=3
===
x.f=x.f[g=3]
===
x=x[f=x.f[g=3]]

2 questions?
  do we no the exact type of everything?
  do we have shared (mutable) memory?

e.f = e' === e = T(e.f0, ..., e', ..., e.fn)
x={f: 1};
y = &x;
x.f = 4;
y->f == 1;


x={f: 1};
// &x ==> {get: -> x, set: x' -> x = x'};
// *e ==> e.get()
// *e = e' ==> e.set(e')
// e == e' !!!
// T* ....
// foo(myVar: {get : ()->T, set: T->T})
// foo(int* b) { *b = 3; }

Get<T>{
  Get(()->T f){check(f);this.f=f;}
  final f:()->T
  }

T x=...
()->T &x === ()->x
Get<T> &x === Get<T>(f:()->x)
Set<T> &&x == y->x=y

Get<T> restriced form of ()->T
e:Ts1 -> e':Ts2
if e:Ts1 then e:Ts2
e:Ts2
NOT THE CASE that if e' : Ts2
  there exists e : Ts1 such that e -> e'


module foo(x1, ..., xn):
   e

==>
foo := QQ[|
  mody = (e; (x1, ..., xn));
  x1 := mody.0;
  ...
  xn = mody.n;
|]

// import foo; e ==>
DE-QQ(foo); e


type x[x']: e; e'

type x[x'] : e; e'
newtype x = e; e'


x' y:e0; 
e1
x' y=e0
e1

// reduces e to v
// creates a new-type with fresh key-name k,
//  returns e'[x := TYPE(k), x' := k]
//  Where TYPE(k) is the type that k unlocks
//  (there is a one to one correspondence between k and TYPE(k))
// Key<TYPE(k), v> 
//

type x[x']: int; e'
x' :: KEY<TYPE(k), int>

KEY-TYPE(TYPE(k)).lock(e) // e :: v


class Key{
  Object unlock(Box b){ b.val;}
  static class Box{ private Object val;}
  }


T,v    ::= x | TT | T -> T  | Int | n | t | box T v | DD
e      ::= x | TT | e -> e' | Int | n | t | T x : e | e(e') | newtype e | unbox T e | box T e | DD[e] | T ~ e
m      ::= x | TT | m -> m' | Int | n | t | T x : m | m(m') | newtype m | unbox T m | box T m | ...
         | x #= m; m'

// isaacss lang
sigma |- sigma(k) :: TT
----------------------
sigma |- type(k) :: TT

sigma | newtype T --> sigma, k -> T | {Type(k), DD[k]}

...
-------------------------
sigma |- Key(T, T') :: TT

----------------------------------------
sigma |- k :: Key(Type(k), sigma(k)) // 2 syntactic-forms + 2  type rules
                                     // you, + 1 more complex reduction rule, + RTE concept

// your lang

sigma |- sigma(t) :: TT
-----------------------------
sigma | t :: TT

sigma | newtype T --> sigma, t -> T | {t, DD (t x -> unbox t x),  DD (t x -> box t x)}

MagicFunction --> (T, aT)
MagicFunction --> (T, _)
-----------------------
MagicFunction :: T, aT




TT kt#=newtype*
kt k=box kt TT//somehow check box kt happens only one time?
Int->(kt->Int) hide =
  fun Int v =fun(kt ki){return v}

newtype v-> T, box: v, unbox

<TT, t-> > {t, box,unbox}=newtype Int

unbox (box t 3)->3

----------------------------------------fresh(t)
newtype Int -> {t, Int x: box t x, t x: unbox x}

3 points:
  1. optimisation (a newtype T is at least as 'good' as a T)
  2. alias-reasoning (by following the 'k', you can reason as to how the newtype is used, and optimise accordingly)
  3. Privacy (if you have a 't', you know nothing about it, except identity, and that it is a 't')

x #= newtype Int;
  x myX = box x 3; // box x e typechecks iff e is an Int
  Int my3 = unbox myX; // tychecks iff myX is a 't'

x #= TT->Int;
  x myX = TT tt : 3; // box x e typechecks iff e is an Int
  Int my3 = myX(TT); // tychecks iff myX is a 't'


// Now I have that, I can make:

makeTT #= TT t : t -> t;
II #= makeTT(Int); // tt is the same as Int -> Int
II->Int stupid := (II t : t(3)); // equivalent to: (Int -> Int t : t(3))
...



(Ref, get, object-ref!, field-ref!) := ( // library code
  type Ref[k] : () -> Int;
  get := Ref r -> k.unlock(r)();
  //object-ref := T x -> k.lock(()-> x);
  macro field-ref!(Expr e, Nat n) = (x = e; k.lock(()-> x.n));
  (Ref, get, object-ref!, field-ref!)
)
// user code CANNOT directly use 'k' (it's not in scope)
// but object-ref! and field-ref! are (and use k)


x := e; // can refer to x'
T x' =: e'; // can refer to x and x'
e'' // same here


circularList #= <Int, circularList>;
circularList x := {1, {2, x}}; x
->
p -> <Int, p> | p x := {1, {2, x}}; x : p



sigma |- e : T[p := sigma(p)]
<------------------------------->
sigma |- e : T


----------------------------------------
p -> <Int, p> , x->p|- {1, x} : p
p -> <Int, p> , x->p |- x : p
---------------------------------------------
p -> <Int, p> |- p x := {1, {2, x}}; x : p


-----------------------

T x =: v === v[x := (T x =: v)]

x = e; // x' is in scope
T x' := e'; // nothin extra in scope
e''; // x and x' are in scope

TT c =: <Int, c> ===  <Int, TT c =: <Int, c>>



p |-> <Int, p> | e[circularList := p]
               |- p x := {1, {2, x}}; x
...., x |- p   |- {1, {2, x}} : p

e :: p





// in 42, (x := e; T x' := e'; e'')

