mut T bar = ...
mut T foo = IMList[mutelems: bar];

read T _ = foo.getRead(0); // ok
mut T _ = foo.getMut(0);
imm T _ = foo.getImm(0); // runtime error

imm T ifoo = foo;

imm T _ = ifoo.getRead(0); // ok
//mut T _ = ifoo.getMut(0); // type error
imm T _ = ifoo.getImm(0); // runtime error

read T rfoo=ifoo.norm();
imm T _ = rfoo.getImm(0); // runtime error

ifoo.iterator()

ifor x in e ()
==>
mfor x in e.iter() ()
nfor x in ifoo() => for x in ifoo.imIter();


for x in ifoo.vals() (/* x is imm*/)
for x in foo.vals() (/* x is read*/)
for var x in foo.#vals() (/* x is read but updetable*/)
for x in foo.#vars() (/* x is mut*/)
for x in rfoo (/* x is read*/)


delimiters: {} () [] :; ''  "" ..
or even a language to define user defined delimiters



Trait X = {
  S: {}
  T: { S foo(); }
}

X<T = Bar>

CA<A extends CA<B>,B extend CB<A>>{ B m(B b); }
CB<A extends CA<B>,B extend CB<A>>{ A m(A a); }
CC<A extends CA<A,B>,B extend CB<A,B>> { ...}


trait CA { 
  type B: CB<A = Self>;
  B m(B b); 
}
trait CB {
  type A: CA<B = Self>;
  A m(A b); 
}

trait CC<A: CA<B = B>, B: CB<A = A>> {
  ...
}
trait CC {
  type A: CA<B = Self::B>
  type B: CB<A = Self::A>
}

C<A extends CA<B>,B extend CB<A>> { ...}\

CC: {
  A: { B m(B); }
  B: { A m(A); }
  ...
}<A=MyA, B=MyB>





-capsule visible as read

e1 (caps/imm/class) can always be in parallel
e2 (read)

if we can have a lent collection of read objects
or anyway update a read field, we have -capsule visible as read
  lent list=.. //lent method add(read r)
  capsule a=..
  capsule a2=(mut b=a
   list.add(b)
   b)
  a2 and list usable
  

-------------------------------

name->name
name=>name

iname arrow name
-if method left is method right

A: {
  B: {method Void bar() e}
  C: {method Void bar() e'}
  method Void foo(B)
}[B ~~> C]
[ B=>F][B->C][F->B]


A: {
  User:{method Void call(B that)}
  B: {method Void bar() User.call(this)}
  method Void foo(B b)
}

A: {
  B: {method Void bar()}
} +  {
  User:{method Void call(C that)}
  C: {method Void bar() User.call(this)}
  method Void foo(C b)
}





A: {
  B: {method Void bar()}
  User:{method Void call(C that)}
  C: {method Void bar() User.call(this)}
  method Void foo(C b)
}

A: {
  User:{method Void call(B that)}
  I: {interface method B m() }
  B: {implements I refine method This m()( User.call(this) this) }
}
=> [extract B into C]
A: {
  User:{method Void call(B that)}
  I: {interface method B m() }
  B: {implements I refine method This m()( User.call(this) this) }
  C: {implements I refine method B m() }
}
=> [moveImpl B into C]
A: {
  User:{method Void call(C that)}
  I: {interface method C m() }
  //B: {implements I refine method C m()}
  C: {implements I refine method C m()( User.call(this) this)  }
}

A: {
  I: {interface method C m() }
  B: {implements I refine method This0 m() }
  C: {implements I refine method This0 m() }
}

A: {
  D: {
    B: {}
    method Void foo(This0.B)
  }
}[D.B -> C]

==>
A: {
  D: {
    method Void foo(This1.C)
  }
    C: {}
}[D.B -> C]

A: {
  User:{method Void call(C that)}
  B: {method B bar()}
  C: {method C bar() this}
  method Void foo(B b)
}


L[B => C]
===>
L[toAbstract][only B] + L[B -> C]


L[B =+> C]
===>
L[B -> C] + L[only B]

-> move code and references
=> move code and leave abstract behind
-!> extract abstract signature in a new place
~~>old code stay, move reference and instert new abstract if needed
//marco belive ~~> not needed

A: {
  User:{method Void call(B that)}
  I: {interface method B m() }
  B: {implements I refine method This m()( User.call(this) this) }
}

iname=Cs.s | Cs | trash
class method
  Cs.s -> Cs'.s' = rename // need to rename this -> Cs, This->Cs
  Cs.s -> P'.s' = redirect? // all the signature is external Paths
  Cs.s => Cs'.s' = rename but not reference//this -> Cs, This->Cs
  Cs.s ~~> Cs'.s'= make sense and is derived 
  Cs.s ~~> P.s'= make sense, redirect can be derived from this
  Cs.s -!> Cs'.s'= what happens to class method This foo() ? This=Cs or Cs'? for consistency This=Cs for cases like This.C=Cs.C


nested class =>, ~~>, -!> not work or work strange
  iname -> iname = rename
  iname -> ename = redirect
  //iname => iname = toAbstract + code copied if no trash
  //iname => ename 
class instance method
refined method
interface instance method /class
class method

state method
private class
private method



Q1:SQL"abc #1 d #2"

C: {This1.C m()} +> { This0 m()}


Operators:
-----------
1
close Cs:
  add to a coherent Cs a private version of all the
  state methods, and implement all abstract methods by
  delegating to the corresponding private abstract state method.
  As an option, can take a name of an invariant method, and
  in that case it properly add the invariant checks and do 
  all the needed checks to see if the invariant is valid.
Errors:
  -Cs does not exists or is private
  -Cs is not coherent
  -provided selector for invariant does not exists or is private
  -some invariant restrictions are violated.
2
Lib1 + Lib2:
  ...we know...
3
refactor L[Rs]:
a list of rename and move as defined below
=> rename
->move (move implementation)
R::= Cs(.s)? -> Cs'(.s)?' |Cs(.s)? -> _ | //move, toAbstract
     Cs(.s)? => Cs'(.s)?' |Cs(.s)? => _ | //rename, hide
     Cs(.s)? => P(.s)?'                   //redirect

-In all the cases is an error if Cs(.s)? do not exists or is private

Methods: 
- if an abstract state method is hidden, then the class if first
  automatically closed.
Class method
The simplest case is when the target is a class method:
  Conditions:  L(Cs), L(Cs') not interface, L(Cs.s) class and not refine
  -> leave the abstract signature in place;
     sum to L(Cs') the method, where all the occurences
     of 'This' and 'this' are replaced with Thisn.Cs 
     (with Cs=C1..Cn)
  => as for ->, but also rename all the references to Cs.s.
     Remove the abstract signature in Cs.s

Instance method
  Conditions:  Cs=Cs', L(Cs), not interface, 
               L(Cs.s)not class and not refine
  -> leave the abstract signature in place;
     sum to L(Cs') the method
  => as for -> but also rename all the refernece to Cs.s
     Remove the abstract signature in Cs.s
--
 *a refine method can not be renamed '=>'
  but can be moved '->' normally.
 *If an instance method is specified, but Cs!=Cs', then
 automatic lifting is applied:
 the method body is tweeked so that is turned in a class method that takes 'this' as first argument. The class method is then handled as before.
 *if an interface is specified, some issues may arise and are solved as follow:
 -> does not makes sense. If it was allowed it would add an abstract
    method to the interface, thus making private nested classes
    implementing it non coherent, thus ill formed.
 => propagate the rename to all the classes and interfaces implementing it. If a class have another implemented method in place of the destination, such method is first hidden.
 if another interface method is in place of the destination,
 implementations of such method are discarded (a reasoning on contracts may justify this controversial design)
 *if an interface method need to be lifted at the class level,
  a body can be syntetised by collecting in a switch all the bodies
  of the classes implementing it. Then a last method work as a default. For example
  {
  I:{interface method Void foo()}
  A:{implements I method foo()Debug(S"A")} 
  B:{implements I method foo()Debug(S"B")}
  C:{implements I }//foo()  abstract
  D_$_1:{implements I method foo()Debug(S"D")}
  }[I.foo()=>K.bar(that)]
  =
  {
  I:{interface}
  A:{implements I method Void foo()Debug(S"A")} 
  B:{implements I method Void foo()Debug(S"B")}
  C:{implements I method Void foo()}//foo()  abstract
  D_$_1:{implements I method foo()Debug(S"D")}//private D
  K:{class method bar(I that)={
      if A that return that.foo()
      if B that return that.foo()
      if C that return that.foo()
      if D_$_1 that return that.foo()
      return This.foo(that)}
    class method Void foo(I that)//abstract
  }
  ------
  If the specified s' have the same name of s, then the body is not built and the result is just the abstract method Void foo(I that)

  All the references to myI.foo() are now replaced with K.foo(myI),
  however, what should we do with myA.foo() ? it is relevant for
  the next step of metaprogramming.
  
----
  Nested classes: 
  Cs => Cs' works as rename now, I think is also ok for interfaces.
  Cs => _ need to check that Cs is consistent
  Cs =>P wors like redirect now, thus can expand the mapping.

  Cs -> _ works as toAbstract now, thus can raise privacy coupuled.
    It would be nice if we had a 'type' for Cs so that is can be
    seen as privacy coupuled or not without trying to abstract it.
  Cs ->Cs'
    In addition of all the privacy coupuled issues, we also need
    to considered refined methods and uses of 'this' as discussed
    last time. Also here we may have a 'type' for Cs, like
    'this free' to give the information that the code do not use
    this/This in ways that prevent moving the implementation away.
    This could be much easier to support than privacy coupuled.

Have I forgot some other cases?

{
I:{foo()}
B:{implements I refine foo()a}
}[I.foo()=>I.bar()]
={
I:{bar()}
B:{implements I refine bar()a}
}

{
I:{foo()}
B:{implements I refine foo()a    bar()b}
}[I.foo()=>I.bar()]
=
{
I:{bar()}
B:{implements I refine bar()a    bar_$_1()b}
}


{
I1:{interface foo() bar()}
B_$_1:{implements I1 refine foo()a    refine bar()b}
}[I1.foo()=>I1.bar()]
=
{
I1:{interface bar()}
B_$_1:{implements I1 refine bar()a }
}


{
I1:{interface foo()}
I2_$_2:{interface bar()}
B_$_1:{implements I1,I2_$_2 refine foo()a    refine bar()b}
C:{implements I2_$_2 refine bar() c}
}[I1.foo()=>I1.bar()]
//ok, bar in C is refined. Thus we know is a bar from interface
and it need renaming.
Thus: when reneming an interface method, all interface method with the same name need to be renamed. If the user do not specify, a numeric pedex is generated.
user need to give a new name to all the bars, those are consistently renamed.
-lifting if s have 1 extra arg, embedding if s have 1 less arg (and the first arg type match This0)
-how to embed in an interface?


Cs can be
  interface
  proper
  proper close
  interface privately implemented
proper classes
  rename them is ok,
  moving them is ok.
interfaces
  rename them is ok,
  moving them is ok,
    while summing them: subtile subtype violation

  {
  A:{interface method a()} B:{interface method b()}
  C_$_1:{implements A refine method a()}
  }[B=>A] //or also for [B->A]
  =
  {
  A:{interface method a() method b()}
  C_$_1:{implemens A  refine method a()}//refine method b()
  }=SubtypeClash
//A is privatly implemented and operation add method b()

refine methods:
  nope, never a good target
interface methods:
  local rename them is ok,
    but the target name need to be globally renamed
  L[Cs.s=>Cs.s'] //ok if refine s' never appear public
  moving them makes no sense.
  lifting them is ok, behaviour is syntetised with switch.
  class methods can be lifted as well.
  L[Cs.m(xs)=>Cs'.m'(_this,xs)]
    ok if Cs' proper class,
    class method T m(Cs _this, Ts xs)={if T1 _this return...}
    class method T m'(Cs _this, Ts xs)

  embedding a method in an interface method makes no sense.
  non-local rename or move makes no sense.
class methods of proper classes
  all renames and move works.
  lifting them makes no sense.
  can be embedded in a proper class.

given an extend map m:
close Csz; Rs
1 apply all the closes

2 forall the Cs.s=>Cs'.s' and Cs=>Cs'rename the references
3 forall Cs =>.. mapping remove the Cs,
  forall Cs ->.. mapping remove the Cs body,
  forall Cs.s=>.. remove the method declaration
  forall Cs.s->.. remove the method body
4 forall  ..->Cs or ..=>Cs mapping sum the moved class bodies
5 forall method mapping rename the methods declarations 

{A: {TAF foo, TAB bar} B: {TBF foo TBB bar}}
[A=>B, A.foo=>A.bar, B.bar=>B.foo]

A=>B, B.C => A
B.C => A, A=>B
==
A=>B'; B.C => A; B' => B

A=>B, A.C => D
==
A => B'; B'.C => D; B' => B

L[Cs1=>Cs1', Cs2=>Cs2']

L[Cs1' = L[Cs1] + L[Cs1'],
  Cs2' = L[Cs2] + L[Cs2']]






{A:{C:{}} B:{C:{foo}}}
A=>B, B.C=>D
{B:{} D:{foo}}

{A:{C:{}} B:{C:{foo}}}
A.C=>D A=>B
{D:{} B:{C:{foo}}}


Option1:
{A: {TAF+TAB bar} B: {TBF+TBB foo}}
{B: {TAF+TAB bar      TBF+TBB foo}}

Option2:

{B: {TAF+TBF foo      TAB+TBB bar}}
{B: {TAF+TBF bar      TAB+TBB foo}}


Option1:
{A: {TAF bar, TAB foo} B: {TBF bar, TBB foo}}
{B: {TAF+TBF bar, TAB+TBB foo}}

Option2: 
{B: {TAF+TBF bar, TAB+TBB foo}}



(D = {};).evilPush(L)

p = (C = L, D={})

p.push(D) == D,p


p(This0) = L
p.minimize(This1.C) = This0
p(This1.C)



if the error can move, no hope for error messages

A:B:{code1} //7   { K:{}  S m(K x)= x.bla(x.foo())}

C:...A.B.code1 +{ K{ method blaa()}}



D:C.foo() // method bla in line 7: x.bla(), bla() non defined on x


Library foo(Library l) { 
  return l<X => S> }

This generalized from, handle moving of code literals:
For example { A:{method This2.B }}
{{{  Thisn.Cs  }}}

{{{  Thisn.Cs  }}}



method #$foo()= use Path ....
mut method foo()= use Path ... #$foo()


read


C=e  .#$

method Num foo()
read method Bool invariant()


method ... this.foo=0; x.bar(this) ...

invariant
  forall wi in widgets.... wi.getX()

5 widgets
4 direction
77
50mill


 $#$foo(e1,e2,e3)
e1.foo0(e2,e3)
e2.foo0(e1,e3)
e3.foo0(e1,e1)
e1.foo1(e2,e3)
e2.foo1(e1,e3)
e3.foo1(e1,e1)


a/b

{..}+foo



This(n+j).Cs.from(Thism.Cs', j) = Thisn.Cs.from(This(m+j).Cs')


C = {E:{} D:{This2.C.E m()}}[D=ED]
C = {E:{} D:{This1.E m()}}[]


C = {This0 m() thi} <+ {This1.C m()}

getRight(L1, L2) = L2
