
How, on the inside of plugin methods we would call 
a service class giving us access to 
"at least" the program and the resources?
if a method require a IResource as first argument,
this is provided by the PlgWrapper??
-write here the model of PlgWrapping/calling
Old is:
plgExecutor("PathName",p,new plgName(),
  (plF,xsF)->plF. 
  MnameEncoded£xn1£xn2(xsF[0],..,xsF[n]),
  ()->transl(e),transl(e0),..,transl(en));




  ----------
  1--42 to Java:
  use P check m(_this:e0, _javaFullNameParType1:e1.._javaFullNameParTypen:en)
  if no _this, it must be static.
  if m=#x, we want the PData//note this have nothing to do with the 42 header #m in step 2 
  **given a using, I can get the class and the method
  **and generate the PlgWrapper
  **method called "new" refers to constructors
  -----------------
  PlgWrapperGeneration input: using, translated e te, translated expressions tes
  we will write `` to embed result of expressions in the code
variables:
  T1..Tn obtained from using.xs
  if static meth
    tes=e1..en
    parRec=null
    rec=plgName
  else
    tes=e0..en
    parRec=e0
    rec=plF
  
  if Meth par1 of type PData
    opt=`Resource.pData(),`
  else
    opt=``
plgExecutor("`PathName`",p,(plgName)`parRec`,
  (plF,xsF)->{
    `T1` _1;..`Tn` _n;
    try{_1=(`T1`)xsF[0];.._n=(`Tn`)xsF[n-1];}
    catch(ClassCastException cce){assert false; throw DoNotAct;}
    return plgName.name(`opt` _1,..,_n);
    },
  ()->`te`,`te1`,..,`ten`);

  



  2--Java to 42:
  2a-given a class I can get all the methods and group them on
  methName/parameterCount
  Then, I can generate all the plugin method selectors,
  and for each group I sort them lexicographically.
  **Result of 2a is Map<name/num,List<ms>>
  2b-I expect the user to provide headers in the form
  (#(num?))?x
  where x is the meth name in Java and #num count elements in each group.
    then, given header in 42 and using selector in 42
    I can generate meth impl in 42.
  
Challenges:

-a single plugin should map multiple mutually recursive java classes
to 42 classes.
-metaprogramming should be able to generate the 42 classes from the plugin only

void ->Void
int,String,... ->Library
exceptions?

class it.bla.a.A{
  int a()
  B toB()
  }
class it.bla.b.B{
  int b()
  A toA()
  static void print(A a)
  }

A:PlgGen<<{/*@plugin it.bla/a.A*/} //plugin is it.bla, a.A is pluginPart 
B:PlgGen<<{/*@plugin it.bla/b.B*/}
//TODO> no, the plugin part should REPEAT the whole path to the class
//this would allow a standard java class to be included in a plugin.


//the primitive plugin will need to know
1 the pluging wrapper interface
2 the plugin error message
I the method headers are repeated, that is all?

PlgGen({
//@PlgWrapper @PluginMethodUnresponsive
//@int @Size
})
//NOTE: we can not use @Size before is (meta-)defined
//Thus B toB() will not be generated
//if the method name has less £x then parameters, additional parameters are
going to have their number as name 


plgPart calling:
if P plugin is plgUrl/plgPart
then plugin(p,P,m(xs))=plg, T0,T1..Tn
plugin(p,P,m(xs),vs, e)
types: 
locate Java meth plgPart.m
void is Void
ast.Ast.Path is class Any
anything else is Library
if meth is static, no _0 arg

oncall:
wrapper with all Object,
 try-cast and catch retrow message
  

expected PlgWrapper: {
  class method
  mut This0 from(Library plgLibrary)
  read method
  Library plgLibrary()
  class method
  Void exceptionIf(Library plgLibrary) exception This
    {
    use This check specialName(plgLibrary:plgLibrary)
    exception This.from(plgLibrary:plgLibrary)
    }


  mdf method Ret m(Par1 p1, Par2 p2)//provided
    Ret.from(plgLibrary:
      use This0 check m(_0:this.plgLibrary(), _1:p1.plgLibrary(), _2:p2.plgLibrary())
      error PluginMethodUnresponsive.from(plgLibrary:{/*plugin it.bla/a.A.m(p1,p2)*/}"
      )
  class method Void m(Par1 p1, Par2 p2)//provided
    use This0 check m(_1:p1.plgLibrary(), _2:p2.plgLibrary())
    error PluginMethodUnresponsive.from(plgLibrary:{/*plugin it.bla/a.A.m(p1,p2)*/}"
  }

PlgWrapper:{interface 
  class method
  mut This0 from(Library plgLibrary)//is PlgWrapper from outside
  read method
  Library plgLibrary()
  }
  
A:{/*@plugin it.bla/a.A*/
  implements PlgWrapper
  
  refine class method
  mut This0 from(Library plgLibrary)//refined to return This0
  
  refine read method//as normalization already add
  Library plgLibrary()
  
  read method Size a()
    Size.from(plgLibrary:
      use This0 check a(_0:this.plgLibrary())
      error PluginMethodUnresponsive"plugin it.bla/a.A.a(_0)"
      )
/*method B toB()//not generated
    B.from(plgLibrary:
      use This0 check toB(_0:this.plgLibrary())
      error PluginMethodUnresponsive"plugin it.bla/a.A.toB(_0)"      
      )*/
  }

However, we can just write the header and force generation
B:PlgGen<<{/*@plugin it.bla/b.B*/ 
  method A toA()
  class method Void print(A a) 
  }
  
B:{/*@plugin it.bla/b.B*/
  implements PlgWrapper
  
  refine class method
  mut This0 from(Library plgLibrary)//refined to return This0

  read Size b()
    Size.from(plgLibrary:
      use This0 check b(_0:this.plgLibrary())
      error PluginMethodUnresponsive"plugin it.bla/a.B.b(_0)"
      )
      
  method A toA()
    A.from(plgLibrary:
      use This0 check toA(_0:this.plgLibrary())
      error PluginMethodUnresponsive"plugin it.bla/a.B.toA(_0)"      
      )
      
  class method Void print(A a) //also this header is needed, to know "A" as parameter type, plus is giving the parameter the name "a"
    use This0 check print(_1:a.plgLibrary())
    error PluginMethodUnresponsive"plugin it.bla/a.B.print(_1)"      
      )
  class method Void exceptionIf(Library plgLibrary) exception This{
    use PlgUtils check ifValidDo(plgLibrary:plgLibrary for:{/*@StringRepr\npluginUrl*/})
    exception This.from(plgLibrary:plgLibrary)
    //well, better 2 methods for making This?? should we check or not
    //plg return valid stuff? 
    }
  }
  
  
  How to handle mut plugins?
  
class System42{
  void out(String s)
  String in()
  }
 
System42:PlgWrapper.$<<{
  //@plugin it.bla/system.System42
  mut method Void out(S s)//we have to repeat the header and add mut..
  mut method S in()//should we just always require headers?
  }
  
  How to handle exceptions

System42:PlgWrapper.$<<{
  //@plugin it.bla/system.System42
  mut method S readFile(S s) exception IOE SecurityE
    (
    res=S.from(plgLibrary:
      use This0 check readFile(_0:this.plgLibrary(),_1:s.plgLibrary())
      error PluginMethodUnresponsive"plugin .."      
      )
    catch error Library x (
      IOE.exceptionIf(plgLibrary:x)
      SecurityE.exceptionIf(plgLibrary:x)
      error x
      )
    res
    )
  }

  