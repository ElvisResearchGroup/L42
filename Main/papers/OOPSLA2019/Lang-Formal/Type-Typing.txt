e  ::= x | e.m(es) | T.m(es) | e.x | new T(es)
L  ::= {K; Tz; Mz}
K  ::= interface | abstract | Txs
M  ::= static? T m(Txs) e? | D
E  ::= L | t | E1<+E2 | E<R>
R  ::= Cs1=T1 .. Csn=Tn

T  ::= C| T.C
Tx ::= T x
D  ::= private? id = E
id ::= C | t
v  ::= new T(vs)

Well formedness:
- An L marked as an 'interface' cannot have an M which is static or implemented (i.e. have an e as its body).
- An M cannot be of the form private? t = E, i.e. it must not declare a trait.
- In a Txs each x (i.e. field or parameter name) must be distinct, and not named 'this'. 
- A 'static' method cannot contain 'this' in its body.
- Method names (m) and class names (C) inside the Mz of a code-literal (L) must be distinct. Thus we will use the notations Mz(m) and Mz(C) to extract the (unique) M in Mz declared with name m or C (respectively).
- The names of the top-level declarations (Ds) provided in the source code must all be distinct, and not 'This', in addition they cannot have the 'private' modifier.
- In an R, each Cs must be distinct. Thus an R is a (partial) function from Cs to T, as such we will use the usual functional R(Cs) to get the T corresponding to the given Cs.
	

# Auxiliary Notations
============================================================

DF ::= id = LF
LF ::= {K; Tz; MFz}
MF ::= static? T m(Txs) e? | private? C = LF
p  ::= DFz;Ds

// top::= Ds e // WHY?
-----------------------------------------------------
Define M in L: 
	M in {_;_;M,Mz}
-----------------------------------------------------
Define E(Cs) = E':
  E(empty)=E
  {_;_;Mz, private? C=L}(C.Cs) = L(Cs)
-----------------------------------------------------------------
Define: fields({T1 x1 .. Tn xn;_;_}) = T1 x1 .. Tn xn
-----------------------------------------------------
Define L[T := T'] = L, by propagating in the usual way to T"[T := T']
T.Cs[T := T'] = T'.Cs
T[T' = T"] = T, otherwise 
-----------------------------------------------------

-----------------------------------------------------
Define C^id = C'
	C^C = C and C^t = This
Define T^p = T:
	T^(DFz; id=E private?1 C1=E1..private?n Cn=En)=C^id.C1..Cn
-----------------------------------------------------
Define p(T) = E:
	sameStart(private? C=E,Ds; C.Cs)
	(C=L,DFz;Ds)(C.Cs)=L(Cs) where !Ds.sameStart(Cs)
	(DFz;id=E, private?1 C1=E1 .. private?n Cn=En,Ds)(C^id.C1..Cn.Cs)=En(Cs) where !Ds.sameStart(Cs)
-----------------------------------------------------

# Compilation Rules
top
    DFz subseteq DFs
             |- DFz:Ok
    DFz;id=E |-E=>E'
    ---------------------------
    DFs id=E Ds => DFs id=E' Ds

Ctx-F
    DFz;Ds,id=E|-E=>E'
    ----------------------------
    DFz;Ds,id=_|-CtxF[E]=>CtxF[E']


enter
    DFz;Ds,C=E|-E=>E'
    ----------------------------
    DFz;Ds|-{K;Tz;private? C=E,Mz}=>{K;Tz;private? C=E',Mz}

trait
    ----------------------
    t = LF, DFz; Ds |-t=>LF[This=T^p]

sum
	LF1 <+ LF2.refreshPrivate(T^p) = LF3
	-------------------------------------
	p |- LF1 <+ LF2 => LF3
	
redirect
    Csz = LF.redirectSet(T^p;R0)
    LF.redirectable(Csz)
    R = p.bestMap(LF, R0) // check that this still makes sense (else redefine it)
    Tz = p.transitiveSignature(range(R))
    forall T in Tz:p.accessible(T^p;T)
    T^p = C._
    forall C.Cs in Tz: p.validImplemntation(p(T),p.supertypes(T))
    ----------------------------
    p|-LF<R0>=> R_T^p[LF.remove(Csz)]
    
CtxF::=[]| CtxF <+ E | LF <+ CtxF | CtxF<R> 

-----------------------------------------------------
Define: complete(Ds)
complete(D1..Dn)=complete(D1)..complete(Dn)
complete(t = L)
complete(C = {Tz;K; Mz})
  K !=abstract
  forall C = L in Mz: complete(C = L)
  if static? _ m(_) in Mz, then K =interface  
----------------------------------------------------------------------------------------------------------
Define: p.accessible(T1,T2)
p.accessible(T._,T) 
p.accessible(T._,T.C.Cs) if p(T.C).public(Cs)
----------------------------------------------------------------------------------------------------------
Define: L.public(Cs)
L.public() holds
{Tz;K;C=L,_}.public(C.Cs)=L.public(Cs)
-------------------------------------------------------------------------------------------------
Define: p.exportable(T)
p.exportable(T.Cs') if T^p=T._ and Dz(T).public(Cs') //implies accessible
p.exportable(C.Cs) if  p(C).public(Cs)
p.exportable(T.C'.Cs) if T^p=T.C_, Dz(T.C').public(Cs) and not p(T).public(C)
//p.exportable(T1..Tn) = p.exportable(T1) .. p.exportable(Tn) //not needed, usual expansion
---------------------------------------------------------------------------------

---------------------------------------------------------------------------------
Define p.transitiveSignature(Tz):
T in p.transitiveSignature(T,_) 
T in p.transitiveSignature(Tz) 
  where
  T in p.transitiveSignature(T')
  T' in p.transitiveSignature(Tz)
T in p.transitiveSignature(T0,_) if T in 	(p(T0))
---------------------------------------------------------------------------------
Define signature(L)
signature({Tz; K; Mz})= Tz U signature(Mz)
signature(static? T0 m(T1 x1 ... Tn xn) e?)=T0..Tn
signature(C=E)=empty
---------------------------------------------------------------------------------
Define p.validImplemntation(L), p.validImplemntation(L,T)
p.validImplemntation(L,T1..Tn)=p.validImplemntation(L,T1)..p.validImplemntation(L,Tn)
p.validImplemntation(L,T)
  where forall static? T0' m(T1 _  ... Tn _) _ in L,
    static? T0  m(T1 _ ... Tn _) _ in p(T)
    p |- T0 <= T0'
----------------------------------------------------------
Define: L[R_T]
  replace all the T syntactically in L with T[R_T]
T.Cs[R_T]=R(Cs)
T'[R_T]=T' otherwise 
========================================================================================================


==============================================================
Define: L.redirectSet(T;R)
T.T1 in L.redirectSet(T;T1=_,R)
T.T2 in L.redirectSet(T;R)
  T.T1 in L.redirectSet(T;R)
  T.T2 in signature(L(T1))
==============================================================
Define: L.redirectable(Tz)
L.redirectable(Tz)
  T subsetEq dom(L)
  forall T in Tz, L.public(T)
  forall T.C in Tz, T in Tz
==============================================================
Define: p.supertypes(T)
p.supertypes(T)=T U p.supertypes(T1) U .. U p.supertypes(Tn)
  where
  p(T)={_;T1..Tn}, forall i in 1..n p(Ti)={interface;_;_} and p.accessible(T,Ti)
==============================================================
Define: L.remove(Tz)
L.remove(T1..Tn)=L.remove(T1).. L.remove(Tn)
{K;Tz;Mz,private? C=L}.remove(C)={K;Tz;Mz}
{K;Tz;Mz,private? C=L}.remove(C.Cs)={K;Tz;Mz,private? C=L.remove(Cs)}
==============================================================
Define: p.bestMap(L,R)=p.stableMostSpecific(L,R,validMaps)
==============================================================
Define: p.stableMostSpecific(L,R,f)=R', with p.f(L,R)=Rz
  where
  forall p' > p :  p.mostSpecificMap(p.f(L,R))=R'
==============================================================
Define: Dz' > Dz
Dz,_;Ds >Dz;Ds
p1>p3 iff p1>p2, p2>p3
Dz,C=L;Ds>Dz,C=L.remove(Tz);Ds  if !sameStart(Ds,C)
Dz;Ds1, private? C=L, Ds2 >Dz;Ds1, private? C=L.remove(T), Ds2  
  if !sameStart(Ds2,T)

==============================================================
Define: R' in p.validMaps(L,R) iff
  R' in p.possibleMaps(L,R)
  forall T in dom(R'), p|- R'(T) <= L(T)[R'_T^p]  //note: L(T)[R'_T^p] == L[R'_T^p](T)

==============================================================
Define: R' in p.possibleMaps(L,R)
  R subsetEq R'
  dom(R') = L.redirectSet(T^p,R)
  forall T in range(R') :
    p.accessible(T^p,T) and p.validImplemntation(p(T),p.supertypes(T))
==============================================================
Define: p.mostSpecificMap(R1..Rn)=R1
  where forall T in dom(R1) :
    R1(T)=p.mostSpecific(R1(T) .. Rn(T))
==============================================================
Define: p.mostSpecific(T,Tz)=T
  where p.supertypes(T)=Tz,_
==============================================================
Define subtyping notations: p|-T<=T', p|- M<=M' and p|-T<=L
p|-T<=T' if T' in p.supertypes(T)

p|-static? T0 m(T1 x1..Tn xn) e? <= static? T0' m(T'1 x'1, .. T'n x'n=e?'
  p|-T0<=T'0 and p|-T'1<=T'1 .. p|-T'n<=T'n

p|-T0<={K1; Tz1; Mz1}
  p(T0)={K0;Tz0;Mz0}
  forall T in Tz1 : p.supertypes(T) subseteq p.supertypes(T0)
  forall m in dom(Mz1), p|-Mz0(m)<=Mz1(m)
  if K0=interface then K1=interface
  if K0=inteface then forall m in dom(Mz1), p|-Mz1(m)<=Mz0(m)

==============================================================
==============================================================

(|- DFz e) // this is the main rule for our type-system it checks DFz and e
========================================================================================================
    |- DFz
    DFz; Empty |- e : T
    complete(DFz)   //doing it in the typing of the D was wrong, was called in traits
    ---------------------------------------
    |- DFz e

(|- DFz) // this rule checks the entire DFz
=======================================================================================================
    DF1, ..., DFn; Empty |- DF1 
    ... 
    DF1, ..., DFn; Empty |- DFn                
    ------------------------------------------
               DF1, ..., DFn |- DFz
 
(p |- DF)  (p |- L)  (p |- M)
// these rules check that DF (or nested class) (which was found in T) is well-typed, assuming everything else in Dz is
====================================================================================================
	   Dz; Ds,private? id = L |- L
    ------------------------------------
    Dz; Ds|- private? id = L


(p |- L) // this rule checks that L is well-typed (assuming everything else in p is)
===================================
    forall M in L:  p |- M
    p.exportable(signature(L))
    p.validImplemntation(L,p.supertypes(T^p))
    forall T _ in fields(L): p.accessible(T^p,T)
    -------------------
	   p |-  L


(p |- M) // check that M is well-typed, where M was found in T
==============================================================
    if e? = e  p; this:T^p, x1:T1,  ...., xn:Tn |- e : T0   
    ---------------------------------------------------------------
    p |- static? T0 m(T1 x1 ... Tn xn) e?
