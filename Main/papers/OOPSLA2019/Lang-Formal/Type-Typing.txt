Auxilary rule: (see if you can simplify)
-----------------------------------------------------
// S! is defined in the latex, as is T^n, such that S!n is basically just Thisn
// and S_T is defined such that (S_T)! = S, i.e. it is like S.naviagate(T)

// translation to thisn/p form:
//     S_T ==> p.naviagate(T)
//     S! ==> This0
//     S!n ==> Thisn
//     S[] ==> p.top()
//     S[Cs] ==> p(This0.Cs)
//     S(T) ==> p(T)
//     S ==> p
//     S! == empty ==> p = empty; Dz // I.e. p is just a set of top-level declarations, and so p(This0) will be undefined, but p(This0.C) may not be

// complete(X) checks that X is sufficiently implemented
complete(t = LF) // traits are always complete
complete(C = LF) // class declaration
	where LF = {K; M; _}
	forall C' in dom(LF): complete(C' = LF(C'))
	if K not in {interface, abstract}: forall m in dom(LF): complete(LF(m))
complete(static? T m(Txs) e) // implemented methods are complete
----------------------------------------------------------------------------------------------------------
//S.accessible(T) means that T is accessible in the current location of S
S.accessible(T) where S! = empty // i.e. we are in the main expression
S.accessible(S!n.C?)
S.accessible(S!n.Cs.C) if S.accessible(Cs) and S(Cs).public(C)
---------------------------------------------------------------------------------

// The typing rules bellow will be entered in three ways:
//     DFz |- e will be called after flattening, but before the main expression is executed
//     Dz; empty; empty |- DF will be called on a trait before we try and use it
//     S; empty |- T' will be called for each target of a redirect
// (As shorthand, I will omit '; empty' )

(S; Tz |- T) // what was once valid type, is now a type-system judgement!
// here Tz is a list of types that are assumed to be well-typed
// S is the current state (where S! may be empty if we are type-checking the main expression)
// T is the type we are trying to access
===============================================================================
T in Tz or Tz |- S_T                // Tz[from T] |- p.navigate(T)
----------------------------------- if D = S then S.accessible(T) 
S; Tz |- T


(DFz |- e) // this rule checks that the main expression e is valid, as are all the declarations in DFz
================================================================================================================
DFz; Empty |- DF1 ... DFz; Empty |- DFn
complete(DF1) ... complete(DFn)
DFz; Empty; Empty |- e : T              // I don't care what type the main expression has
--------------------------------------- DFz = DF1 ... DFn
DFz |- e

(S; Tz |- DF) // these rules check that DF (which was found in S!) is well-typed (assuming the Tz are)
==============================================================================================================================

S; Tz |- S!.C
------------------------------------ // assumes S[C] = LF
S; Tz |- private? C = LF


   Tz |- (This = LF, S)_This  // Tz[from This0.C] |- t = LF, p // for fresh C
---------------------------------
S; Tz |- t = LF


(Tz |- S) // this rule checks that the declaration for S! is well-typed, under the assumption that each Tz is well-typed
===================================
S; Tz,S! |- M1 ... S; Tz,T |- Mn
forall T' in S.superTypes(S!) \ {S!}
	forall m in dom(Dz(T'))
		Dz(T')(m) = static? T_0' m(Txs)
		Dz(T)(m)  = static? T_0 m(Txs) e?
		S |- T_0 <= T_0'

if K = T'1 x1 ... T'm xm then S; Tz,S! |- T'1 .... S; Tz,S! |- T'm
------------------------------------------------------------------ S[] = {K; Tz; M1 ... Mn}
Dz; Tz |- T


(S; Tz |- M) // check that M is well-typed, where M was found in S!, and each Tz is well typed
=============================================
S; Tz |- T0, ..., S; Tz |- Tn
----------------------------------------------- // abstract method
S; Tz |- static? T0 m(T1 x1 ... Tn xn)


S; Tz |- T0, ..., S; Tz |- Tn
S; Tz; T this, T1 x1,  ...., Tn xn |- e : T0
--------------------------------------------------------- // implemented instance method
S; Tz |- T0 m(T1 x1 ... Tn xn) e


S; Tz |- T0, ..., S; Tz |- Tn
S; Tz; T1 x1,  ...., Tn xn |- e : T0
----------------------------------------------- // implemented static method
S; Tz |- static T0 m(T1 x1 ... Tn xn) e
