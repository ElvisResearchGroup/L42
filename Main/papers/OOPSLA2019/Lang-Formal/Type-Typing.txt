Auxilary rule: (see if you can simplify)
-----------------------------------------------------
// S! is defined in the latex, as is T^n, such that S!n is basically just Thisn
// and S_T is defined such that (S_T)! = S, i.e. it is like S.naviagate(T)

// translation to thisn/p form:
//     S_T ==> p.naviagate(T)
//     S! ==> This0
//     S!n ==> Thisn
//     S[] ==> p.top()
//     S[Cs] ==> p(This0.Cs)
//     S(T) ==> p(T)
//     S ==> p
//     S! == empty ==> p = empty; Dz // I.e. p is just a set of top-level declarations, and so p(This0) will be undefined, but p(This0.C) may not be

// complete(X) checks that X is sufficiently implemented
complete(t = LF) // traits are always complete
complete(C = LF) // class declaration
    where LF = {K; M; _}
    forall C' in dom(LF): complete(C' = LF(C'))
    if K not in {interface, abstract}: forall m in dom(LF): complete(LF(m))
complete(static? T m(Txs) e) // implemented methods are complete
----------------------------------------------------------------------------------------------------------
//Dz.accessible(T, T') means that T is accessible from within T'
Dz.accessible(T.Cs, T.C?)
Dz.accessible(T.Cs, T.Cs'.C) if Dz.accessible(T.Cs) and Dz(T.Cs).public(C)
---------------------------------------------------------------------------------

(|- DFz e) // this is the main rule for our type-system it checks DFz and e
================================================================================================================
    |- DFz
    DFz; Empty |- e : T
    ---------------------------------------
    |- DFz e

(|- DFz) // this rule checks the entire DFz
==================================================================================================================
    DFz; Empty |- DF1 
    ... 
    DFz; Empty |- DFn                          complete(DF1) ... complete(DFn)
    ------------------------------------------ DFz = DF1, ..., DFn
               |- DFz
 
(S |- DF) (S |- M) // these rules check that DF (or nested class) (which was found in S!) is well-typed
==============================================================================================================================
    S |- S!.C
    ------------------------------------ // assumes S[C] = LF
    S |- private? C = LF


    |- (This = LF, S)_This
    ---------------------------------
    S |- t = LF


(|- S) // this rule checks that the declaration for S! is well-typed
===================================
    S |- M1
    ...
    S |- Mn             S[] = {_; _; M1 ... Mn}
    ------------------- S.transitiveTypes() is defined
      |- S



(S |- M) // check that M is well-typed, where M was found in S!
============================================================
    if e? = e  S; T -> this, T1 -> x1,  ...., Tn -> xn |- e : T0
    ------------------------------------------------------------ // method
    S; Tz |- static? T0 m(T1 x1 ... Tn xn) e?
