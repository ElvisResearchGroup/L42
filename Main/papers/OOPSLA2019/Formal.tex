\section{Formalism}
\subsection{Language Grammar and Well-Formedness}
\noindent
\newlength{\gramwidth}
\setlength{\gramwidth}{\dimexpr\textwidth-1em}
\begin{minipage}[t]{0.6\gramwidth}
\begin{grammar}
	\produ{e}{x \mid{} \ec{e}{m}{es} \mid{} \ec{T}{m}{es} \mid{} \ef{e}{x} \mid{} \en{T}{es}}{expression}
	\produ{L}{\cl{K}{\Tz}{\Mz}}{code literal}
	\produ{K}{\Q{interface} \mid{} \Q{abstract} \mid{} \Txs}{kind}
	\produ{M}{\meth{T}{m}{\Txs}{e\q} \mid{} \ncdd{D}}{member}
	\produ{E}{L \mid{} t \mid{} \summ{E_1}{E_2} \mid{} \red{E}{R}}{code expression}
	\produ{R}{\redm{Cs_1}{T_1}\ddd\redm{Cs_n}{T_n}}{redirect map}
\end{grammar}
\end{minipage}\hfil
\begin{minipage}[t]{0.4\gramwidth}
\begin{grammar}
	\produ{T}{C \mid T\.C}{type}
	\produ{\Tx}{T\ x}{parameter/field}
	\produ{D}{\cd{\id}{E}}{declaration}
	\produ{Id}{C \mid{} t}{class/trait ID}
	\produ{v}{\en{T}{vs}}{value}
	\\
\end{grammar}
\end{minipage}

We additionally impose the following well-formedness constraints:
\begin{itemize}
	\item An $L$ marked as an \Q{interface} cannot have an $M$ which is \Q{static} or implemented (i.e. have an $e$ as its body).
	\item An $M$ cannot be of the form \ncd{t}{E}, i.e. it must not declare a trait.
	\item In a $\Txs$ each $x$ (i.e. field or parameter name) must be distinct, and not named \Q{this}. 
	\item A \Q{static} method cannot contain \Q{this} in its body.
	\item Method names ($m$) and class names ($C$) inside the $\Mz$ of a code-literal ($L$) must be distinct. Thus we will use the notations $\Mz(m)$ and $\Mz(C)$ to extract the (unique) $M$ in $\Mz$ declared with name $m$ or $C$ (respectively).
	
	\item The names of the top-level declarations ($\Ds$) provided in the source code must all be distinct, and not \This.
	\item In an $R$, each $Cs$ must be distinct. Thus an $R$ is a (partial) function from $Cs$ to $T$, as such we will use the usual functional $R(Cs)$ to get the $T$ corresponding to the given $Cs$.
\end{itemize}


\subsection{Auxiliary Notations}
\begin{grammar}
	\produ{DF}{\cd{\id}{LF}}{flattened declaration}
	\produ{LF}{\cl{K}{\Tz}{\MFz}}{flattened code literal}
	\produ{MF}{\meth{T}{m}{\Txs}{e\q} \mid{} \ncd{C}{LF}}{program}
	\produ{p}{\DFz; \Ds}{program}
\end{grammar}
\\\\
\begin{defs}
	\defit{M \in \cl{\_}{\_}{M,\Mz}}{method in class}
	\defis
	\defi{E(\Empty)}{E}{get the body of a (transitively) nested class}
	\defi{\cl{\_}{\_}{Mz, \ncd{C}{L}}(C\.Cs)}{L(Cs)}{}
	\defis
	%\defi{\cl{K}{\Tz}{\Mz, \ncd{C}{L}}[C\.Cs=E]}{\cl{K}{\Tz}{\Mz, \ncd{C}{L[Cs=E]}}}{update nested class}
	\defi{\fop{fields}{\cl{\Txs}{\_}{\_}}}{\Txs}{get the fields of a class}
	\defi{\fop{fields}{\cl{K}{\_}{\_}}}{\Empty \otherwise}{class has no fields}
\end{defs}
\\\\
\begin{defs}
	\defi{T\.Cs[T \coloneqq T']}{T'\.Cs}{substitute type (prefix)}{}
	\defi{T[T' \coloneqq T'']}{T\otherwise}{}
	\defii{L[T \coloneqq T']}
\end{defs}
\\\\
\begin{defs}
	\defi{\T[(\DFz; \cd{\id}{E}, \cd{C_1}{E_1}, \ldots, \cd{C_n}{E_n})]}{C\.C_1\ldots C_n}{current type}
	\defic{\text{where if } \id \text{ is of form } t \text{, then } C=\Q{This} \text{, otherwise } C = \id}{}
	\defis
	\defit{\mop{(\cd{C}{E},\Ds)}{sameStart}{C\.Cs}}{the $\Ds$ and $T$ start with the same $C$}	
	\defi{(\cd{C}{L},\DFz; \Ds)(C\.Cs)}{L(Cs)\where \neg\mop{\Ds}{sameStart}{Cs}}{get flattened class declaration}
	\defi{(\DFz; \cd{\id}{E}, \cd{C_1}{E_1}, \ldots, \cd{C_n}{E_n}, \Ds)(C\.C_1\ldots C_n\.Cs)}{E_n(Cs)}{}
	\defic{\wwhere \text{not } \mop{\Ds}{sameStart}{Cs} \text{ and if } \id \text{ is of form } t \text{, then } C=\Q{This} \text{, otherwise } C=\id}
	{}
%	Define p(T) = E:
%	(C=L,\DFz;\Ds)(C.Cs)=L(Cs) where !sameStart(\Ds,Cs)
%	(\DFz;t=E0,C1=E1..Cn=En,\Ds)(This.C1..Cn.Cs)=En(Cs) where !sameStart(\Ds,Cs)
%	(\DFz;C0=E0..Cn=En,\Ds)(C0..Cn.Cs)=En(Cs) where !sameStart(\Ds,Cs)
%	sameStart(private? C=E,\Ds;C.Cs)
%	(\DFz; t=E C1=E1..Cn=En)=This.C1..Cn
\end{defs}
\\\\
\begin{irules}
	\irule{Top}{
		\DFz \subseteq \DFs\\\\
		\vdash \DFz\\\\
		\DFz; \id = E \vdash E \Rightarrow E'
	}{
		\DFs\ \cd{\id}{E}\ \Ds \Rightarrow \DFs\ \cd{\id}{E'}\ \Ds
	}
	\irule{Ctx-F}{
		\DFz; \Ds,\id=E \vdash E \Rightarrow E'\\\\
	}{
		\DFz; \Ds, id = \_ \vdash \ctx{F}[E] \Rightarrow \ctx{F}[E']\\\\
	}
	
	\iruleSep
	\begin{array}{cc}
		\irule{Trait}{
		}{
			\cd{t}{LF}, \DFz; \Ds \vdash t \Rightarrow LF[\This \coloneqq T]
		}&
		\multirow{1}{*}{
				\irule{Redirect}{	
				Csz = \mop{LF}{redirectSet}{\T, R}\\\\
				\mop{LF}{redirectable}{\Csz}\\\\
				\mop{p}{validTargets}{\ran{R}}\\\\
				R' = \mop{p}{bestMap}{LF, R}
			}{
				p \vdash \red{LF}{R} \Rightarrow \reda{\mop{LF}{remove}{\Csz}}{R'}{T}
			}
		}\\\\
		\irule{Sum}{
			\summ{LF_1}{\mop{LF_2}{refreshPrivate}{\T}} = LF_3
		}{
			p \vdash \summ{LF_1}{LF_2} \Rightarrow LF_3
		}
	\iruleSep
	\end{array}\\
	\irule{Enter}{	
		\DFz; \Ds, C = E \vdash E \Rightarrow E'
	}{
		\DFz; \Ds \vdash \cl{K}{Tz}{\ncd{C}{E},\Mz} \Rightarrow \cl{K}{Tz}{\ncd{C}{E'}, \Mz}
	}
\end{irules}

\subsection{The Sum Operator}
\begin{defs}
\defi{\summ{L_1}{L_2}}{\cl{\summ{K_1}{K_2}}{\Tz_1 \cup \Tz_2}{(\summ{\Mz}{\Mz'}),\Mz_1,\Mz_2}}{sum the two code literals}
\defic{\wwhere L_1=\cl{K_1}{\Tz_1}{\Mz,\Mz_1},\quad L_2=\cl{K_2}{\Tz_2}{\Mz',\Mz_2}}{}
\defic{\text{if}\ K = \Q{interface}\  \text{then}\ \{m \in \dom{L_1}\}= \{m \in \dom{L_2}\}}{}
\defis
\defi{\summ{\Q{interface}}{\Q{interface}}}{\Q{interface}}{interfaces must match}
\defi{\summ{\Q{abstract}}{\Q{abstract}}}{\Q{abstract}}{keep abstract classes}
\defi{\summ{\Q{abstract}}{\Txs}}{\summ{\Txs}{\Q{abstract}} \coloneqq K}{allow adding state to an abstract class}
\defis
\defi{\summ{M_1 \ldots M_n}{M'_1 \ldots M'_n}}{(\summ{M_1}{M'}) \ldots (\summ{M_n}{M'_n})}{sum members pairwise}
\defi{\summ{\meth{T}{m}{\Txs}{e\q}}{\meth{T}{m}{\Txs}{e}}}{\meth{T}{m}{\Txs}{e}}{override method}
\defi{\summ{\meth{T}{m}{\Txs}{e\q}}{\ameth{T}{m}{\Txs}}}{\meth{T}{m}{\Txs}{e\q}}{non-override}
\defi{\summ{(\cd{C}{L})}{(\cd{C}{L'})}}{\cd{C}{(\summ{L}{L'})}}{recursively sum public classes}
\end{defs}

\subsection{Type System Notations}
\begin{defs}
	\defit{\mop{L}{public}{\Empty}}{a class is public to itself}
	\defip{\mop{\cl{\_}{\_}{\cd{C}{L},\_}}{public}{C\.Cs}}{\mop{L}{public}{Cs}}{public nested class}
	\defis	
	\defip{\mop{p}{exposable}{T\.\_, T\.Cs}}{\mop{p(T)}{public}{Cs}}{outer class}
	\defip{\mop{p}{exposable}{T\.C\.\_, T\.C'\.Cs}}{
		\mop{p(T\.C')}{public}{Cs} \text{ and not }
		\mop{p(T)}{public}{C}}{nested inside an outer}
	\defip{\mop{p}{exposable}{\_, C\.Cs}}{\mop{p(C)}{public}{Cs}}{globally public class}	
	\defis
	\defip{\mop{p}{accessible}{T, T'}}{\mop{p}{exposable}{T, T'}}{exposable class}
	\defip{\mop{p}{accessible}{T\.\_, T\.C\.Cs}}{\mop{p(T\.C)}{public}{Cs}}{nested of an outer}
\end{defs}
\\\\
\begin{defs}
	\defi{\mop{p}{superTypes}{T}}{
		T,\mop{p}{superTypes}{T_1}, \ldots, \mop{p}{superTypes}{T_n}}{}
	\defic{\wwhere p(T) = \cl{\_}{T_1\ldots T_n}{\_} \text{ and } 
		\ForAll{i \in \{1,\ldots,n\}}{p(T_i) = \cl{\Q{interface}}{\_}{\_}}}{}
	\defis
	\defi{\fop{exposedTypes}{\cl{K}{\Tz}{\Mz}}}{\Tz, \fop{exposedTypes}{\Mz}}{}
	\defi{\fop{exposedTypes}{\meth{T_0}{m}{T_1\ x_1 \ldots T_n\ x_n}{\_}}}{T_0, \ldots, T_n}{types in method signature}
	\defi{\fop{exposedTypes}{\ncdd{D}}}{\EmptyZ}{ignore nested classes}
	\defis
	\defip{T \in \mop{p}{reachableTypes}{T',\_}}{T \in T', \fop{exposedTypes}{p(T')}}{}
	\defip{T \in \mop{p}{reachableTypes}{\Tz}}{T \in 
		\mop{p}{reachableTypes}{T'}\where T' \in \mop{p}{reachableTypes}{Tz}}{}

\end{defs}
\\\\
\begin{defs}
\defip{\mop{p}{validImpls}{T}}{%
	\mop{p}{validImpls}{T, T_1} \text{ and } \ldots \text{ and } \mop{p}{validImpls}{T, T_n}%
}{}
	\defic{\wwhere \mop{p}{superTypes}{T} = T1, \ldots, Tn}{}
	\defip{\mop{p}{validImpls}{T, T'}}{\forall \meth{T'_0}{m}{T_1\ \_\ldots T_n\ \_}{\_} \in p(T')}{}
	\defic{\meth{T_0}{m}{T_1\ \_\ldots T_n\ \_}{\_} \in p(T) \text{ and } p \vdash T_0 \leq T'_0}{}	
	\defis
	
	\defit{\fop{complete}{\cd{t}{L}}}{}
	\defip{\fop{complete}{\cd{C}{\cl{K}{\_}{\Mz}}}}{K \neq \Q{abstract} \text{ and }}{}
	\defic{\ForAll{\ncdd{D}\in\Mz}{\fop{complete}{D}}}{}
	\defic{\text{if } \ameth{\_}{m}{\_} \in \Mz \text{ then } K = \Q{interface}}{}
\end{defs}
\\\\
\begin{defs}
\defip{p \vdash T \leq T'}{T' \in \mop{p}{superTypes}{T}}{subtyping}
\defip{p \vdash \meth{T_0}{m}{T_1\ \_\ \ldots\ T_n\ \_}{\_} \leq \meth{T_0'}{m}{T_1'\ x_1'\ \ldots\ T_n'\ x_n'}{\_}}{}{method subtyping}
\defic{p \vdash T_0 \leq T_0' \text{ and } p \vdash T_1' \leq T_1\ \text{ and } \ldots \text{ and } p \vdash T_n' \leq T_n }{}
\defip{p \vdash T \leq \cl{K'}{\Tz'}{Mz'}}{p(T) = \cl{K}{Tz}{Mz}}{structural subtyping}
\defic{\ForAll{T'\in\Tz'}{p \vdash T \leq T'}}{}
\defic{\ForAll{m \in \dom{Mz'}}{p \vdash Mz(m) \leq Mz'(m)}}{}
\defic{\text{if } K = \Q{interface} \text{ then } K' = \Q{interface}}{}
\defic{\text{if } K = \Q{interface} \text{ then } \ForAll{m \in \dom{Mz} }{p \vdash Mz'(m) \leq Mz(m)}}{}
\end{defs}

\subsection{The Redirect Operator}

\begin{defs}
	\defip{Cs \in \mop{L}{redirectSet}{T,R}}{Cs \in \dom{R}}{}
	\defip{Cs \in \mop{L}{redirectSet}{T,R}}{T\.Cs \in \fop{exposedTypes}{L(Cs')} \where Cs'\in\mop{L}{redirectSet}{T,R}}{}	
\end{defs}
\\\\
\begin{defs}
	\defip{\mop{L}{redirectable}{Csz}}{\forall Cs \in \Csz}{}
	\defic{Cs \neq \Empty}{}
	\defic{Cs \in \dom{L}}{}
	\defic{\mop{L}{public}{Cs}}{}
	\defic{\ForAll{ \cd{C}{L'} \in L(Cs)}{Cs\.C \in \Csz}}{}
\end{defs}
\\\\
\begin{defs}
	\defip{\mop{p}{validTargets}{Tz}}{\mop{p}{validTarget}{T_1} \text{ and } \ldots \text{ and } \mop{p}{validTarget}{T_n}}{}
	\defic{\wwhere{\mop{p}{reachableTypes}{Tz} = T_1 \ldots T_n}}{}
	
	\defip{\mop{(\cd{C}{L}, \DFz; \Ds)}{validTarget}{C\.Cs}}{\mop{L}{public}{Cs}}{}
	\defip{\mop{p}{validTarget}{T}}{\mop{p}{validImpls}{T} \text{ and } \mop{p}{accessible}{\T, T}}{}
	\defic{\wwhere p = \DFz; Ds \text{ and } T \in \dom{\EmptyZ; \Ds}}{}
\end{defs}
\\\\
\begin{defs}
	\defi{\reda{T\.Cs}{R}{T}}{R(Cs)}{}
	\defi{\reda{T'}{R}{T}}{T'\otherwise}{($T'$ is external, or not in $R$)}
	\defii{\reda{L}{R}{T}}
	
	\defis
	\defi{\mop{L}{remove}{Cs_1\ldots Cs_n}}{
		\mop{L}{remove}{Cs_1}\mop{{}_{\ldots}}{remove}{Cs_n}}{remove each class in an arbitrary order}
	\defi{\mop{\cl{K}{\Tz}{\Mz, \ncd{C}{L}}}{remove}{C}}{\cl{K}{\Tz}{\Mz}}{}
	\defi{\mop{\cl{K}{\Tz}{\Mz, \ncd{C}{L}}}{remove}{C\.Cs}}{\cl{K}{\Tz}{\Mz, \ncd{C}{\mop{L}{remove}{Cs}}}}{}
\end{defs}
\\\\
\begin{defs}
	\defip{R' \in \mop{p}{validMaps}{L,R}}{}{}
	\defic{R \subseteq R'}{it is an extension of $R$}
	\defic{\dom{R'} = \mop{L}{redirectSet}{\T, R}}{it completes the redirect map}
	\defic{\mop{p}{validTargets}{\ran{R}}}{all the targets are valid}
	\defic{\ForAll{Cs \in \dom{R'}}{p \vdash R'(Cs) \leq \reda{L(Cs)}{R'}{\T}}}{the map preserves structural subtyping}
\end{defs}
\\\\
\begin{defs}
	\defi{\mop{p}{bestMap}{L,R}}{R_1\where \forall p' \succ p}{for all bigger programs}
	\defic{\mop{p}{validMaps}{L, R} = R_1, \ldots, R_n}{$R_1$ is a valid map}
	\defic{\ForAll{Cs \in \dom{R_1}}{\{R_1(Cs), \ldots, R_n(Cs)\} \subseteq \mop{p}{superTypes}{R_1(Cs)}}}{$R_1$ choses the least subtype}
	\defis
	\defip{p' \succ p}{\T[p'] = \T \text{ and } \ForAll{T \in \dom{p}}{\Exists{\Csz}{p(T) = \mop{p'(T)}{remove}{\Csz}}}}{}
%$\S'$ has more nested classes}
	%MostSpecific(p; Pz) = P
	%P in p.minimize(Pz)
	%p.minimize(Pz) subseteq SuperClasses(p; P)
	
	
	%define MostSpecificMap(p; R,Rz) = R
	%forall Cs:
	%// forall is limited since R(Cs) is undefined if none of the R,Rz define it
	%R(Cs) = MostSpecific(p; {R'(Cs) | R' in R,Rz})
	
	
	%  BestMap(p; R) = StableMostSpecific(p; R; ValidMaps)
	%StableMostSpecific(p; R; f) = R' iff:
	%forall p' in SimilarPrograms(p): MostSpecificMap(p'; f(p', R)) = R'
	%with f a function (p,R)->Rz
\end{defs}