{reuse L42.is/AdamTowel02

// A striped down version of Data.invariant
Invariant: {
  class method Library <><(Library right) (
    Library that = Use.Over[right]<>< {
      read method Bool #1#invariant()
      read method Void #invariant()
        if !this.#1#invariant() (error Data.Invariant.Fail"invalid object detected!")
    }
    res = Data.Invariant.PlgInvariantClose.closeJ(path:Path"This", top:that, mode:0Size)
    catch exception Any x error x
    res)
}

// Note: Size is the equivalent of Spec#'s int type

// Also, we are not encoding pre & post-conditions that are unrelated to invariant checking
// pages 41 - ...

// page 42
Reader: {interface implements Concept.Base // needed for toS etc. to work
    mut method Size getChar()
}

CharList: Collections.vector(of: Size)
// page 43
ArrayReader: Data <>< {implements Reader
  var capsule CharList src
  var Size n
  read method Bool #invariant()
    0Size <= this.n() & this.n() <= this.src().size()

  class method mut ArrayReader(capsule CharList source)
    This(src: source, n: 0Size)

  method getChar() (
    var Size ch = 0Size
    if this.n() == this.src().size() (
      ch := Size"-1")
    else (
      ch := this.src().val(this.n())
      this.n(this.n() + 1Size))
    ch)
}

OReader:Option(Reader)
// page 44
Lexer: Invariant <>< {
  mut OReader rd // Ok, the ctor takes a capsule
  read method Bool #invariant() this.rd().isPresent()

  class method mut This(capsule OReader rd) // The real constructor
  class method mut Lexer(capsule Reader reader)
    This(rd: OReader(reader))
  
  mut method Size getToken() (
    var Size t = 0Size
    var Size ch = Size"0"
    while ch != Size"-1" (
      ch := this.#rd().#get().getChar()
      t := t + ch
      )
    t
  )

  // page 45
  // Note: this method ensures that the Lexer can never be used again
  // wheras the Spec# version allows it to be, provided it is made valid again
  capsule method capsule Reader relinquishReader() this.#rd().#get()

  class method This #immK(OReader rd) // workaround for bug in the artifact
}

// 42 does not support subclassing, a similar effect can be achieved with traits
// however, theres no way to use the type system to ensure that a certain specific invariant on an object holds
// unless that object has a final class type.
// Wheras in Spec#, you can know that all super-class invariants hold (along with subclass ones, which you don't statically know)
FileListT: Trait({
  var Strings names
  var Size selection
  read method Bool _invariant()
    0Size <= this.selection() & this.selection() < this.names().size()
  read method Bool isSelectionADirectory()
})

Bools:Collections.vector(of:Bool)
DirFileList:FileListT & {
  Bools isDirectory
  read method Bool #invariant()
    this._invariant() & this.isDirectory().size() == this.names().size()
  method Bool isSelectionADiretory() 
    this.isDirectory().val(this.selection())
}

Main: (
  // Trick to force compilation & typechecking of each of the above types
  var class Any x = Reader
  x := Lexer
  x := DirFileList
  ExitCode.normal() 
)
}
