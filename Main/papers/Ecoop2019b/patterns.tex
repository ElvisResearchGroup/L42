\section{Patterns}
\label{s:patterns}
\lstset{morekeywords={invalid}}
In Section~\ref{s:case-study} and Appendix~\ref{s:MoreCaseStudies} we showed how the box pattern can be used to write invariants over cyclic mutable object graphs, the later also shows how a complex mutation can be done in a an `atomic' way, with a single invariant check. However the box pattern is much more powerful. Suppose we want to pass a temporarily `broken' object to other code as well as perform multiple field updates with a single invariant check. Suppose we added another type-modifier \Q!invalid! (denoting an object whose invariant need not hold), and an \Q!expose! statement like Spec\#:
\begin{lstlisting}
interface Person {
  mut method Bool accept(read Account a, read Transaction t); }

interface Transaction { 
  // Here ImmList<T> represents a list of immutable Ts.
  mut method ImmList<Transfer> compute(); }

class Transfer { Int money;
  // gain some money, or lose some money
  method Void execute(mut invalid Account that) {
         if (this.money > 0) { that.income   += money; }
    else if (this.money < 0) { that.expenses -= money; }}}

class Account {
  UInt income; UInt expenses; mut Person holder;
  read method Bool invariant() {
    return this.income > this.expenses; }
    
  mut method Void transfer(mut Transaction ts) {
    if (this.holder.accept(this, ts)) {
      expose(this) {
        for (Transfer t : ts.compute()) { t.execute(this); }
     } // check the invariant here
}}}
\end{lstlisting}
The idea here is that \Q!transfer(ts)! will first check to see if the account holder wishes to accept the transaction, it will then compute the full transaction (which could cache the result and/or do some I/O), and then execute each element of the transaction. We specifically want to allow an individual \Q!Transfer! to raise the \Q!expenses! field by more than the \Q!income!, however we dont want a \Q!Transaction! to do this. This is what the Spec\# style expose block is expression: during the \Q!for! loop we dont know/care if \Q!this.invariant()! is \Q!true!, but after the loop it will be checked. For this to make sense, we explicitly annotate \Q!Transfer.execute! to take an \Q!invalid Account!: it cannot assume that the invariant of \Q!that! holds, and it is allowed to modify its fields without needing to check it. Adding support for such code in our invariant protocol would likely require making the type system significantly more complicated as well as burdening it with more core syntactic forms. This however is unnecessary, as we can use our box pattern to achieve the same result:
\begin{lstlisting}
class Transfer { Int money;
  method Void execute(mut AccountBox that) {
   // same as before
         if (this.money > 0) { that.income   += money; }
    else if (this.money < 0) { that.expenses -= money; }}}

class AccountBox { UInt income; UInt expenses; }
class Account {
  capsule AccountBox box; mut Person holder;
  read method Bool invariant() {
    return this.box.income > this.box.expenses; }
    
  mut method Void transfer(mut Transaction ts) {
    if (this.holder.accept(this, ts)) {
	  t.transferInner(ts.compute()); }}

  // capsule mutator
  private mut method Void transferInner(ImmList<Transfer> ts) {
     mut AccountBox b = this.box;
     for (Transfer t : ts) { t.execute(b); }
     // check the invariant here
}}
     
\end{lstlisting}
An \Q!AccountBox! now acts like an \Q!invalid Account!, and the capsule mutator, \Q!transferInner!, behaves like an \Q!expose! block. In particular, the above code demonstrates that our system can:
\begin{itemize}
\item Have useful objects that are not entirely encapsulated: the \Q!Person holder! is a \Q!mut! field, this is fine since it is not mentioned in the invariant of \Q!invariant!.
\item Perform multiple state updates with only a single invariant check: the loop in \Q!transferInner! method can perform multiple field updates of \Q!income! and \Q!expenses!, however the \Q!invariant! will only be checked at the end of the loop.
\item Temporarily break an invariant: it is fine if during the \Q!for! loop, \Q!expenses > income!, provided that this is fixed before it terminates.
\item Pass state of an `invalid' object around in a safe manner: an \Q!AccountBox! contains the state of \Q!Account!, but not it's invariant: if you have an \Q!Account!, you can be sure that it's \Q!income > expenses!, but not if you have an \Q!AccountBox!.
\item Wrap normal methods over capsule mutators: in the above code \Q!transfer! is not a capsule mutator, so it can use \Q!this! multiple times and take a \Q!mut! parameter.
\end{itemize}

Though capsule mutators can be used to perform batch operations like the above, since they can only take immutable objects, this means that they can perform no non-deterministic I/O (due to our OC system), and other externally accessible objects (such as a \Q!mut Transaction!) cannot be mutated during such an operation.

\subheading{The Transform Pattern}
\IO{Recall the GUI case study in Section~\ref{s:case-study}, where we had a \Q!Widget! interface and a \Q!SafeMovable! (with an invariant) that implements it.}
% A capsule mutator method is essentially a mutation of a field, which is guaranteed to not see the \Q@this@ object.
% Thus, if \Q@this@ is made invalid during  the method's execution, we could not observe it until after the method completes.
Suppose we want to \IO{allow} \IODel{scale a} \Q@Widget@\IO{s to be scaled}, we could add \Q@mut@ setters for \Q@width@, \Q@height@, \Q@left@, and \Q@top@ in the \Q@Widget@ interface. However, if we also wish to scale its children we have a problem, since \Q@Widget.children@ returns a \Q@read Widgets@, which does not allow mutation. We could of course add a \Q@mut@ method \Q@zoom@ to the \Q@Widget@ interface, however this does not scale if more operations are desired. If instead \Q@Widget.children@ returned a \Q@mut Widgets@, it would be difficult for \Q@Widget@ implementations, such as \Q@SafeMovable@, 
\IO{to mention their \Q!children! in their \Q!invariant!} \IODel{to keep control of their ROGs}.

% In the above \Q@SafeMovable@ we only had one capsule mutator: \Q@dispatch@. However suppose a \Q@Widget@ wants to directly mutate it's descendents, however it can't do that since \Q@Widget.children@ returns a \Q@read Widgets@, if it returned a \Q@mut Widgets@ then \Q@SafeMovable@ could not be implement, as it's children are contained inside a capsule-field. 
% At first glance, it may seem that capsule mutators allow only very limited kinds %of mutation.
% This is however not the case. 
% Consider the following
% simple pattern to allow flexible use of encapsulated content: define a

A simple and practical solution would be to define a \Q@transform@ method in \Q@Widget@, and a \Q@Transformer@ interface 
like so:\footnote{A more general transformer could return a generic \Q@read R@.}
\begin{lstlisting}[escapechar=\%]
interface Transformer<T> { method Void apply(mut T elem); }
interface Widget { ...
  // setter%\IODel{s}% for immutable data
  mut method Void top(Int that);
  // transformer for possibly encapsulated data
  mut method read Void transform(Transformer<Widgets> t);
}

class SafeMovable { ...
  // A well typed capsule mutator
  mut method Void transform(Transformer<Widgets> t) {
   return t.apply(this.box.c); }}
\end{lstlisting}\saveSpace
% Note that the code above does not access a capsule field but merely calls a method that does; thus  it is \emph{not} a capsule mutator method, so it is not constrained by the restrictions on them. Code like the above would also allow one to mutate multiple capsule fields in one method.
%Our pattern cooperates with the language’s restrictions to ensure each mutation is completed as a separate operation, that is perceived by the rest of the system %as if it was atomic.%
%,  i.e. they can't see or update the other capsule fields.
The \Q@transform@ method offers an expressive power similar to \Q@mut@ getters, but prevents \Q@Widgets@ from leaking out.  With a \Q@Transformer@, a \Q@zoom@ function could be simply \IO{written as}:
\begin{lstlisting}
static method Void zoom(mut Widget w) {
  w.transform(ws -> { for (wi : ws) { zoom(wi,scale); }});
  w.width(w.width() / 2); ..; w.top(w.top() / 2); }
\end{lstlisting}

% One of the advantages of this approach is that a the \@zoom@ method can be written by anyone anywhere

% \begin{lstlisting}[escapechar=\%]
%// Lambda Expression that creates a new Transformer<...>
%this.transform(l -> l.add(new MyWidget(..)))
%\end{lstlisting}
%//`i' is captured by the closure.
%// `imm' and `capsule' varaibles can be captured.

%    %\Comment{}%this.items.add(i);
%    // Cant instead capture `this': it can't be typed %as `imm'
%    // since `ItemTransformer.transform()' is an %`imm' method
%  })
%}
%  // instead of:
%\Comment{}%this.exposeItems().add(i)

%Note that the code above does not access a capsule field but merely calls a method that does; thus
%it is \emph{not} a capsule mutator method, so it is not constrained by the restrictions on them. Code like the above would also allow one to mutate multiple capsule fields in one method.
%Our pattern cooperates with the language’s restrictions to ensure each mutation is completed as a separate operation, that is perceived by the rest of the system
%as if it was atomic.%
%,  i.e. they can't see or update the other capsule fields.