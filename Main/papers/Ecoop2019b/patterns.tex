\section{Patterns}
\label{s:patterns}

In Section~\ref{s:case-study} and Appendix~\ref{s:MoreCaseStudies} we showed how the box pattern can be used to write invariants over cyclic mutable object graphs, the later also shows how a complex mutation can be done in a an 'atomic' way, with a single invariant check. However the box pattern is much more powerful, we can use it to pass temporarily `broken' objects to other code as well as perform multiple field updates with a single invariant check.

Consider
\begin{lstlisting}
class Person {
	mut method Bool needsMoney(read Account that) { 
		return that.balance < 5;
	}
	mut method Void spend(read /*possibly broken*/ Account that) { 
		// Note that the invariant of that might not hold at this point!
		that.expenses += 5; // just spend some money for no reason!
	}
}

class Account {
	UInt income, expenses, balance;
	mut Person owner; // dosn't need to be encapsulated!

	read method Bool invariant() {
		return this.income > this.expenses && this.balance == this.income - this.expenses;
	}
	
	mut method Void update() {
		if (this.owner.needsMoney()) {
			expose (this) { // unpack this, allowing it's invariant to be violated
				this.income += 5; // violate the invariant!
				// pass the now broken 'this'
				this.owner.spend(this); // give them a chance to spend it
				this.balance = income - expenses;
			} // If I spent too much money above, an invariant violation will now be thrown!
		}
	}
	...
}
\end{lstlisting}


\begin{lstlisting}
class Person {
mut method Bool needsMoney(read Account that) { 
return that.balance < 5;
}
mut method Void spend(read /*possibly broken*/ Account that) { 
// Note that the invariant of that might not hold at this point!
that.expenses += 5; // just spend some money for no reason!
}
}

class Account {
UInt income, expenses, balance;
mut Person owner; // dosn't need to be encapsulated!

read method Bool invariant() {
return income > expenses && balance == income - expenses;
}

mut method Void update() {
if (this.owner.needsMoney()) {
expose (this) { // unpack this, allowing it's invariant to be violated
this.income += 5; // violate the invariant!
// pass the now broken 'this'
this.spend(this); // give them a chance to spend it
this.balance = income - expenses;
} // If I spent too much money above, an invariant violation will now be thrown!
}
}
...
}
\end{lstlisting}

\subheading{The Transform Pattern}
% A capsule mutator method is essentially a mutation of a field, which is guaranteed to not see the \Q@this@ object.
% Thus, if \Q@this@ is made invalid during  the method's execution, we could not observe it until after the method completes.
Suppose we want to scale a \Q@Widget@, we could add \Q@mut@ setters for \Q@width@, \Q@height@, \Q@left@, and \Q@top@ in the \Q@Widget@ interface. However, if we also wish to scale its children we have a problem, since \Q@Widget.children@ returns a \Q@read Widgets@, which does not allow mutation. We could of course add a \Q@mut@ method \Q@zoom@ to the \Q@Widget@ interface, however this does not scale if more operations are desired. If instead \Q@Widget.children@ returned a \Q@mut Widgets@, it would be difficult for \Q@Widget@ implementations, such as \Q@SafeMovable@, to keep control of their ROGs.

% In the above \Q@SafeMovable@ we only had one capsule mutator: \Q@dispatch@. However suppose a \Q@Widget@ wants to directly mutate it's descendents, however it can't do that since \Q@Widget.children@ returns a \Q@read Widgets@, if it returned a \Q@mut Widgets@ then \Q@SafeMovable@ could not be implement, as it's children are contained inside a capsule-field. 
% At first glance, it may seem that capsule mutators allow only very limited kinds %of mutation.
% This is however not the case. 
% Consider the following
% simple pattern to allow flexible use of encapsulated content: define a

A simple and practical solution would be to define a \Q@transform@ method in \Q@Widget@, and a \Q@Transformer@ interface 
like so:\footnote{A more general transformer could return a generic \Q@read R@.}
\begin{lstlisting}
interface Transformer<T> { method Void apply(mut T elem); }
interface Widget { ..
mut method Void top(Int that); // setters for immutable data
mut method read Void transform(Transformer<Widgets> t);
} // transformers for possibly encapsulated data
class SafeMovable { ..
mut method Void transform(Transformer<Widgets> t) {
return t.apply(this.box.c); }} // Well typed capsule mutator
\end{lstlisting}\saveSpace
% Note that the code above does not access a capsule field but merely calls a method that does; thus  it is \emph{not} a capsule mutator method, so it is not constrained by the restrictions on them. Code like the above would also allow one to mutate multiple capsule fields in one method.
%Our pattern cooperates with the language’s restrictions to ensure each mutation is completed as a separate operation, that is perceived by the rest of the system %as if it was atomic.%
%,  i.e. they can't see or update the other capsule fields.
The \Q@transform@ method offers an expressive power similar to \Q@mut@ getters, but prevents \Q@Widgets@ from leaking out.  With a \Q@Transformer@, a \Q@zoom@ function could be simply:
\begin{lstlisting}
static method Void zoom(mut Widget w) {
w.transform(ws -> { for (wi : ws) { zoom(wi,scale); }});
w.width(w.width() / 2); ..; w.top(w.top() / 2); }
\end{lstlisting}

% One of the advantages of this approach is that a the \@zoom@ method can be written by anyone anywhere

% \begin{lstlisting}[escapechar=\%]
%// Lambda Expression that creates a new Transformer<...>
%this.transform(l -> l.add(new MyWidget(..)))
%\end{lstlisting}
%//`i' is captured by the closure.
%// `imm' and `capsule' varaibles can be captured.

%    %\Comment{}%this.items.add(i);
%    // Cant instead capture `this': it can't be typed %as `imm'
%    // since `ItemTransformer.transform()' is an %`imm' method
%  })
%}
%  // instead of:
%\Comment{}%this.exposeItems().add(i)

%Note that the code above does not access a capsule field but merely calls a method that does; thus
%it is \emph{not} a capsule mutator method, so it is not constrained by the restrictions on them. Code like the above would also allow one to mutate multiple capsule fields in one method.
%Our pattern cooperates with the language’s restrictions to ensure each mutation is completed as a separate operation, that is perceived by the rest of the system
%as if it was atomic.%
%,  i.e. they can't see or update the other capsule fields.