We would like to thank all four reviewers for their insightful reviews!

======================================================================
We start by addressing the four crucial points raised by Reviewer D.
======================================================================

- convince me the restrictions are not so severe
------------------------------------------------

Our system is designed to be used together with the Box and the Transform pattern.
Using those, we believe that the restrictions of our systems are not so severe.
For example, the following concerns:

1 "there is no shortage of code knowingly violating invariants"(and fixing them later)
2 "they batch invariant checking in order to do it less often"
3 "to implement a binary tree" "use a separate wrapper"
4 "spec# can (with user guidance) check only once"
5 "in a simulation step"

Can all be resolved by using the Box pattern: a separate wrapper object storing data
whose invariant is only meaningful when checked together.
At the end of this response, we include code examples demonstrating how to address points 1-2-3-4-5.

In general, we expect the Box pattern to replace the "expose" block of Spec#.
Where Spec# provides special syntax, we instead require adding new methods/wrapper
objects. In this way we get a level of control very similar to the one of Spec# but without the need of adding (and formalizing, and proving correct) special syntax/features.

- why the children() call in the GUI typechecks
-----------------------------------------------

This point is connected to the other comments: "leak out a mut alias to the capsule field", "differs in such important ways"

We agree that our explanation of capsule fields is indeed lacking.

Capsule local variables are basically identical in Pony and Microsoft and L42.
Pony and Microsoft capsule fields are not identical to local variables, since they are implemented with destructive reads.

Capsule fields in L42 are also very different from capsule local variable.
Formally, they do not exists: all fields are either mut or imm.
However, the syntactic sugar allows to annotate a field as a capsule:
it is just a private (mut) field that is only
accessible in restricted ways and is only updated/initialised using a capsule.
Those fields are usually referred to as capsule fields.
We will cite "Flexible recovery of uniqueness and immutability" 
pg 169 doi:10.1016/j.tcs.2018.09.001 where these patterns are discussed.

The restrictions on capsule mutators are one such restricted way to access capsule fields.

**We will improve the paper by explaining the difference between capsule fields and capsule local variables better.**

About "read method read Widgets children(){return this.box.c;}":

this.box is a mut field whose usage is restricted;
in this case it will return a read reference and this.box.c can also be typed as read.
Note that this.box inside of a capsule mutator does return a mut reference instead.

L42 have two different syntax expressions for the two cases: this.box() returns a read
and this.#box() return a mut, and can only be used in a capsule mutator.
We tried to avoid talking about the specific syntax of L42 to focus on the type problems,
but we may have instead created more confusion.

- there is more generality to the GUI case study
------------------------------------------------

The GUI case study is just an application of the Composite programming pattern - one of the most common programming pattern in OO.
We also included more case studies in the appendix, of course you are not required to read the appendix,
but their existence shows that we can support more than just the GUI.
In particular, we compare with some examples offered by Spec# papers, showing clearly what
we can and cannot check ("if the limitations of a system aren't encountered in an evaluation, why not?").

- inheritance and syntactic checks in invariant bodies
------------------------------------------------------

A simple solution to support conventional inheritance would be to require the invariant to only
access final and private methods (plus the syntactic checks already required).

Allowing overriding over methods called by the invariant can be very confusing.
Consider the following example:

class A{
  Int f;
  read method int f(){return this.f;}
  read method Bool invariant(){this.f()>0;}
}
class B extends A {
  method int f(){return -this.f;}
}

Class B is changing the meaning of the invariant method in A because it overrides f().
Is this intentional? Preventing such behaviour seems like a reasonable precaution.

======================================================================
We now give answers to the two explicit questions raised by Reviewer C.
======================================================================

- Does Boogy/Spec# rely on object immutability as well?
-------------------------------------------------------

Yes, they have a concept of immutable classes, and invariants can access instances of
immutable classes and owned objects. In the following article they expand Spec# to also
consider immutable instances of classes allowing both mutable and immutable instances: "TODO"

- Why do we care for reducing checks
------------------------------------

As shown in the GUI example, the number of checks in visible state semantics can explode
exponentially, making the code unusable even for the debugging purposes.
On the other hand, if we can keep the cost of runtime checks sufficiently low,
it becomes feasible to keep those checks running in production,
and to capture invariant failure exceptions and provide alternative behaviour.
This could have great implications for security.
For example, if all the objects able to perform Database actions had invariants,
our system statically ensures that Database methods are only called from objects whose invariant holds.
If we could prove that the invariant only allows for valid DB transaction, we would have a system
that never performs a wrong transaction.

Additional Note
---------------
We agree with Reviewer C that we should have clarified more that our model essentially imposes the Box and the Transform patterns.

======================================================================
We now provide our responses to the other comments by Reviewer D.
======================================================================

- There are no redundant checks in the capsule mutators:
----------------------------------------------------------------------------------------

 since 'this' is used only once, 'this' cannot also appear in the form 'this.x=e' (thus a second invariant check cannot be triggered)

- "invariant can only access capsule and imm fields":
-----------------------------------------------------

Spec# also restricts what data can be accessed in the invariant, and is basically limited
to owned and immutable fields too. (TODO: ISAAC CHECK!!!)


-line 685 and capsule fields access:
line 685 contains the definition of the method makeBox().
The parameter is a capsule, the result is mut, thus the method perform recovery and produces a capsule.
The method do not involve any capsule field, so we are unsure we understand the comment of RevD

- reference capability
----------------------

If the reviewers think it is more appropriate,
we will change the terminology to use reference capability.
We were not intentionally attempting to change the terminology used by the field.

-externally unique
Neither the work of Microsoft, Pony or L42 supports external uniqueness.
Externally Unique objects allow outgoing (but not incoming!) references from inside the reachable object graph (ROG)
of the externally unique reference.
Isolated and capsule objects disallow any references, including outgoing ones, from the reachable object graph,
thus providing a much stronger encapsulation guarantee.

A good explanation of this common misconception can be found in
Capabilities for Uniqueness and Borrowing, Philipp Haller and Martin Oderskypg 360 fig3,
where the arrow 's' is allowed in external uniqueness but not in separate uniqueness.


- prevent any clear class of these pathologies
----------------------------------------------

We are not sure what the reviewer means here: L42 has no 'null' and if an invariant call
somehow throws an error (unchecked exception) then according to our definition,
such invariant does not hold, but the invariant implementation is not 'wrong'.
We would expect the user to throw personalised error messages instead of just returning false
in order to produce better error messages.

- how this allows for an invariant to be violated for a non trivial period of time
----------------------------------------------------------------------------------

The invariant must hold for all the objects involved in execution.
If an object is not in the ROG of any parameter (including this) of the current method,
clearly such object is not involved in the execution and its invariant can be freely broken.

See the code snippet for cases 1-2 at the end of this response.


- soundness concerns:
---------------------


In the formal calculus all errors are "unchecked exceptions".

SES requires that if a try catch captures an unchecked exception then the body of the try
is type-checked using "read" instead of "mut" for all the local variables.
To transfer this knowledge from local variables to object locations, we annotate the try with
the set of preserved locations.

Thus, if "l" was visible from outside, then it could not be mutated, thus l.f=v would not typecheck.
On the other hand, if l.f=v type checked, it means that l is not visible outside.

Then, having that constraint as a syntactic well-formedness or as a typing requirement just moves 
where the proof has to take care of it: progress (in our case) or subject reduction
(in the variant proposed by the reviewer).

This reasoning is hidden in the paper under Assumption 1 (progress), since any type system
supporting Assumption 1 would have to take care of this detail.

- the system can no longer be used for concurrency
--------------------------------------------------

Concurrency support leverages on capsule and immutable local variables.
Concurrency does not leverage on capsule fields in both L42 and the language of Microsoft.
We are unsure about Pony: their actor model may internally implement the mailbox as a list of capsules.



The destructive reads of Microsoft make it easier to call concurrent operations using input
from isolated fields, but when concurrency starts, it does it over isolated/capsule references, not fields.


======================================================================
We now provide our responses to the other comments by Reviewer B.
======================================================================

Firstly, we thank the reviewer for their positive comments of our paper and that "it will make a nice addition to Ecoop".
Answering some of their particular points: 

"y=this x=this y.f=x" is allowed by our system and the resulting object would have a circular object graph.
Such object can be promoted as imm, and the whole ROG would be immutable.
(L42 has no static fields)

Object capabilities control non determinism and I/O. They are essential in the discussion after line 530


======================================================================
Code examples showing how to handle points 1-5
======================================================================

1,2: violating invariants and fixing it later, or executing the invariants in batch

class ABox{int a;int b;}
class A{
 capsule ABox box;
 read method Bool invariant(){this.box.a>this.box.b;}
 mut method Void play(){
   mut ABox inner=this.box;
   inner.a=5;///may break invariant
   inner.b=3;///fix invariant
   //invariant checked here
   }}
   
3: binary trees; note how the invariant can reason on the overall shape of the TreeBox:

class TreeBox{mut TreeBox left, mut TreeBox right}
class Tree{capsule TreeBox box; 
  read method Bool invariant(){... this.box ...}}
Note that Spec# allows to specify methods able to take objects whose invariant is not known to hold.
The box pattern also emulate that behaviour: in this example the Tree 
correspond to a Spec# Tree where the invariant
is known to hold, while the TreeBox correspond to a Spec# Tree where the invariant is not known to hold.

4:in spec# the user may write 

    Void a() {doA() expose{doB(); doC();} doD()}

in L42 they would need to write the more verbose

    mut method Void a() {doA(this.state) this.capsuleMutator(); doD(this.state);}
    mut method Void capsuleMutator() {mut Box box=this.state; doB(box); doC(box);}
    
Where this.state is the field of the box pattern.
As you can see, the user can still guide the invariant checking, but it uses programming patterns
instead of a dedicated syntax.
5:About 5, consider the Family example of Appendix C: the box pattern triggers the
invariant only after a complete simulation step.