%\subsection{Expressiveness}
%\noindent\textit{Expressiveness:}
%Finally, in our this third case study we 
%shown that even if we do not aim to expressiveness, but to simplicity, soundness and efficiency, we are still able to express a reasonable amount of cases.
%We encoded in L42 all the examples present in papers~\cite{??}.
%We can express all the examples except ....
%Again, we quantify the annotation burden and we discover....

%\subsection{The transform pattern}


%\begin{lstlisting}[escapechar=\%]
%class List {
%  mut List prev;
%  mut List next;
%  Object elem;  
%  read method Bool ok() {
%    return this.next.prev==this && this.prev.next==this &&..;}
%  read method Int size(){
%    if(next==this){return 1;} return next.size()+1;}}
%\end{lstlisting}
%Clearly the \Q@mut@ fields of \Q@List@ cannot be marked as \Q@capsule@.
%However, only \Q@capsule@ and \Q@imm@
%fields can be accessed in \validate.
%Thus, \Q@.innerValidate()@ can not be the \Q@invariant@ method for \Q@List@.
%The solution is to use a `box' over our \Q@List@, and to validate our `box':

%\loseSpace\loseSpace\loseSpace
%\begin{lstlisting}[escapechar=\%]
%class ListBox { 
%  capsule List inner;
%  read method imm Bool invariant() {return this.inner.ok();}
%  read method Int size(){ return this.inner.size();}
%\end{lstlisting}
%\saveSpace
%Encoding this example in Spec\# would be much more verbose (see case study XX) and still require
%a \Q@ListBox@ object,
%while the visible state semantic of Eiffel or D would cause an large amount of \Q@invariant@ checks
%if the list had any recursive method; consider for example the \Q@size@ method:
%if there was an invariant with visible state semantic on \Q@List@, calling \Q@List.size()@ would require 
%calling \Q@List.invariant()@ before and after the method execution. If the list has more then one element, the recursive \Q@size@ call would also call the invariant twice.
%We would also want to create forwarding methods in \Q@ListBox@ for all public methods defined in \Q@List@. This approach allows the validation of many interesting and practically useful data-structures.
%However the limitations of capsule mutator methods mean that any \Q@mut@ methods in \Q@ListBox@ taking \Q@read@ or \Q@mut@ parameters, or returning \Q@mut@, cannot be trivially forwarded.
%% since they necessitate mutating a \Q@capsule@, instead complicated and involved forwarding would be needed, if it is even possible.
%Our example is about a list of immutable objects.
%To instead validate a list of \Q@mut@ objects we would need to use our box pattern not just around the list,
%but around a section of data encapsulating both the list and all the contained elements.
%This is because our simple \Q@capsule@ modifier requires the whole ROG to be encapsulated.
%Conceptually, it would be better for the list (of mutable objects) to be validated by its
%head, since the behaviour of the contained objects is transparent to the validation criteria. 
%Our limitation relates to full encapsulation and contrasts with flexible encapsulation as in 
%ownership~\cite{ClarkeEtAl98}. However, neither traditional flexible encapsulation/ownership, nor our language are capable of verifying that \Q@List.elem@ is not (indirectly) referenced within \Q@ListBox.validate()@.


%\subsection{Family, a worst case scenario for L42}
%\noindent\textit{Family, a worst case scenario for L42}
%For our second case study, we wished to make an example where the performance of L42 and the conventional approach was similar. We forged an example when a \Q@Family@ has a list of parents and a list of children;
%all the children need to be younger then their parents and every \Q@Person@ need to have a non empty name and a positive age.  
%We model the pass of time with a \Q@processDay@ method, and we simulate $3$ years of life (that is, $3\times365$ days) of a family of $4$.
%The age of a \Q@Person@ grow when its birthday is processed.
%Notably, \Q@processDay@ is a \Q@mut@ method that can potentially mutate any person in the system, thus
%L42 have to run a lot of invariant checks. The object graph here is very shallow: the \Q@Family@ holds the \Q@Person@s and that is it.
%However, even in this case we get about $9$ times less invariant calls: $19403$ with visible state semantic  and $2210$ in L42.
%Also the \Q@Family@ example uses the box pattern.

%\subsection{Family}
%We wished to make an example where the performance of L42 and the conventional approach 
%was similar. We forged an example when a Family has a list of parents and a list of children;
%all the childrens need to be younger then their parents and every Person need to have a non empty name and a positive age.  
%We model the pass of time with a \Q@processDay@ method, and we simulate 3 years of life (that is, 3*365 days) of a family of 4.
%The age of a Person grow when its birthday is processed.
%Notably, \Q@processDay@ is a mut method that can potentially mutate any person in the system, thus
%L42 have to run a lot of invariant checks. The object graph here is very shallow: the Family holds the Persons and that is it.
%However, even in this case we get about 10 times less invariant calls: Num in the conventional approach and Num in L42.

%\subsection{Spec\# 2papers}
%Our goal in this third case study was to show that even if we do not aim to expressiveness, but to simplicity, soudness and efficiency, we are still able to express a reasonable amount of cases.
%We can express all the examples except ....
%Again, we quantify the annotation burden and we discover....

%\section{Stack overflow and Out of memory}
%For our system to be sound,
%Stack overflow and Out of memory errors need to be modeled specially.
%If they are just (unchecked) exceptions then they could be catched to 
%generate non deterministic behaviour inside invariant code.

%However, it is possible to use capaility objects to capture them as special system events/signals.
%In this way we can maintain the soundness of our system even in this corner case.
%Of course, another option would be to make them into unrecoverable fatal errors.

\section{More Case Studies}

\subsection{Family}
The following test case was designed to produce a worst case in the number of invariant checks. We have a \Q!Family! that (indirectly) contains a list of \Q!parents! and \Q!children!. The \Q!parents! and \Q!children! are of type \Q!Person!. Both \Q!Family! and \Q!Person! have an invariant, the invariant of \Q!Family! depends on its contained \Q!Person!s.

% TODO: Talk to mark about code style

% TODO: Swap parent/child updates in aritifact
\begin{lstlisting}
class Person { 
  final String name;
  Int daysLived;
  final Int birthday;
  Person(String name, Int daysLived, Int birthday) { .. }
  mut method Void processDay(Int dayOfYear) {
  	this.daysLived += 1;
    if (this.birthday == dayOfYear) {
    	Console.print("Happy birthday " + this.name + "!");}}
  read method Bool invariant() {
    return !this.name.equals("") && this.daysLived >= 0 &&
      this.birthday >= 0 && this.birthday < 365; }
}
class Family { 
  static class Box { 
    mut List<Person> parents;
    mut List<Person> children;
    Box(mut List<Person> parents, mut List<Person> children){..}
    mut method Void processDay(Int dayOfYear) {
      for(Person c : this.children){c.processDay(dayOfYear);}
      for(Person p : this.parents){p.processDay(dayOfYear);}
    }
  }
  capsule Box box;
  Family(capsule List<Person> ps,capsule List<Person> cs) {
    this.box = new Box(ps, cs); }
  mut method Void processDay(Int dayOfYear) { 
    this.box.processDay(dayOfYear); }
  mut method Void addChild(capsule Person child) { 
    this.box.children.add(child); }
  read method Bool invariant() {
    for (Person p : this.box.parents) {
      for (Person c : this.box.children) {
        if (p.daysLived <= c.daysLived) { 
          return false; }}}
    return true; }
}
\end{lstlisting}
Note how we created a \Q!Box! class to hold the \Q!parents! and \Q!children!.
Thanks to this pattern, the invariant only needs to hold at the end of \Q!Family.processDay!, after all the \Q!parents! and \Q!children! have been updated. Thus \Q!Family.processDay! is atomic: it updates all its contained \Q!Person!s together.
%This capture the intention of consistently calling \Q@Person.processDay@ once for all the persons as an atomic operation.
%This capture the intention of atomically and consistently calling \Q@Person.processDay@ once for all the persons.
Had we instead made the \Q!parents! and \Q!children! \Q!capsule! fields of \Q!Family!, the invariant would be required to also hold between modifying the two lists. This could cause problems if, for example, a child was updated before their parent.

\noindent We have a simple test case that calls \Q!processDay! on a \Q!Family!, $1{,}095$ ($3\times365$) times.
%$3\times365$ times ($1{,}095$ days):
\begin{lstlisting}
// 2 parents (one 32, the other 34), and no children
var fam = new Family(List.of(new Person("Bob", 11720, 40),
    new Person("Alice", 12497, 87)), List.of());
    
for (Int day = 0; day < 365; day++) { // Run for 1 year
  fam.processDay(day);
}
for (Int day = 0; day < 365; day++) { // The next year
  fam.processDay(day);
  if (day == 45) {
    fam.addChild(new Person("Tim", 0, day)); }}

for (Int day = 0; r < 365; day++) { // The 3rd year
  fam.processDay(day);
  if (day == 340) {
    fam.addChild(new Person("Diana", 0, day)); }}
\end{lstlisting}
% The counts (including the invariant keyword, and read on the invariant method)
% Spec# 14 family, 2 main   = 16
% L42 	12 family, 1 person = 13
% Fake 42 = 14 (+2 for box ctor, -1 for family ctor)

The idea is that everything we do with the \Q!Family! is a mutation, in addition the \Q!fam.processDay! calls also mutate the contained \Q!Person!s.

This is a worst case scenario for our approach compared to visible state semantics since it reduces our advantages:
our approach avoids invariant checks when objects are not mutated
but in this example most operations are mutations; 
similarly, our approach prevents the exponential explosion of nested invariant checks\footnote{see section \ref{s:case-study}} when deep object graphs are involved, but in this example the object graph of \Q!fam! is very shallow.
\loseSpace

We ran this test case using several different languages: L42 (using our protocol) performs $4{,}000$ checks, D performs $7{,}995$, Eiffel performs $19{,}335$, and finally, Spec\# performs only $1{,}104$.

Our protocol performs a single invariant check at the end of each constructor,  \Q!processDay! and \Q!addChild! call (for both \Q!Person! and \Q!Family!). 

The visible state semantics of both D and Eiffel perform additional invariant checks at the beginning of each call to \Q!processDay! and \Q!addChild!. In addition, due to Eiffel's `uniform access principle', the field accesses of \Q!Person.daysLived! (in  \Q!Family!'s invariant) are not distinguished from ordinary method calls, thus each one performs two invariant checks.
% TODO: Actually implement it in eiffel (this will be a nightmare...)

The results for Spec\# are very interesting, since it performs less checks than L42.
This is the case since \Q!processDay! in \Q!Person! just does a simple field update, which in Spec\# do not invoke runtime invariant checks. Instead, Spec\# tries to statically verify that the update cannot break the invariant, if it is unable to do this it requires that the update be wrapped in an \Q!expose! block. In Spec\#, integer arithmetic is not allowed to overflow\footnote{A compilation option allows overflow to be check at runtime, by throwing  where unchecked exceptions (just as invariant failures) if it occurs}, as such it verifies that the field increment in \Q!processDay! cannot break the invariant.

%This is the case since \Q!processDay! in \Q!Person! just does a simple field increment, thus the Spec\# verifier is able to statically verify that this wont break the invariant, and so it does not require a corresponding \Q!expose! block, and hence does not perform a runtime invariant check.
%The Spec\# verifier is able to do this as it works on a language semantic where arithmetic overflow does not occur. Such semantic can be enforced by
%a compilation option (disable on default for performance reasons).
%%%%however one can turn on runtime checking for overflow.
%%%and check overflow errors at run time
%With this option turned on, eliding the invariant check is sound since overflow will have the same result as a runtime invariant check failure, namely it will throw an unchecked exception.

% Concluding Spec\# is able to replaces some runtime invariant checks with more efficient runtime overflow checks.

%This static reasoning is performed under the assumption that arithmetic overflow will not occur, thus Spec\# is considering a different semantic for \Q@Int@ then L42. Spec\# can inject run-time checks to enforce such arithmetic semantic.


The annotation difficulty with Spec\#\footnote{see the artifact for the full code} was similar to our previous examples, however since the fields of \Q!Person! all have immutable classes/types, we did not have to have any special annotations for that class. The \Q!Family! class was similar to our \Q!Cage! example (see section \ref{s:intro}), however in order to implement the \Q!addChild! method we were forced to do a shallow clone of the new child (this also caused a couple of extra runtime invariant checks).
