\section{Formal Language Model}
\label{s:formalism}

%----------------------------------
In order to model our system, we need to formalise an imperative object oriented language
with exceptions, object capabilities, and rich type system
support for TMs and strong exception safety.
Formal models of the runtime semantics of such languages are simple, but 
defining and proving, such a type system would require a paper
of its own, and indeed many such papers exist in literature%
~\cite{ServettoEtAl13a,ServettoZucca15,GordonEtAl12,clebsch2015deny,JOT:issue_2011_01/article1}.
Thus we are going to assume that we already have an expressive and sound type system enforcing the properties we need, and instead focus on invariant checking.
We clearly list in Appendix \ref{s:proof} the assumptions we make on such a type system, so that any language satisfying them, such as L42, can soundly support our invariant protocol.

To keep our small step semantics as conventional as possible, we follow Pierce~\cite{pierce2002types} and Featherweight Java~\cite{IgarashiEtAl01}, and assume:
\begin{itemize}
	\item An implicit program/class table.
	\item Memory, $\sigma : l\rightarrow C\{\Many{v}\}${, is} a finite map from locations, $l$, to annotated tuples, $C\{\Many{v}\}$, representing objects; where $C$ is the class name and $\Many{v}$ are the field values.
	We use the notation $\sigma[l.f=v]$ to update a field of an object, and $\sigma[l.f]$ to access one.
	\item A main expression that is reduced in the context of such a memory and program.
	\item A typing relation, $\Sigma;\Gamma\vdash\e:T$, where 
	the expression $\e$ can contain locations and free variables. The types of locations are encoded in 
a memory environment, 
$\Sigma : l\rightarrow C$,
	while the types of free variables are encoded in
a variable environment, $\Gamma : x\rightarrow T$.
	\item We use $\Sigma^\sigma$ to trivially extract the corresponding $\Sigma$ from a $\sigma$.
\end{itemize}
To encode object capabilities and I/O, we assume a special location  $c$ of class \Q@Cap@. This location would refer to an object whose fields model things like the content of files. In order to simplify our proof, we assume that:
\begin{itemize}
	\item instances of \Q@Cap@ cannot be created with a \Q@new@ expression,
	\item all methods in the \Q@Cap@ class must require a \Q@mut@ receiver, and will mutate its ROG,
	\item \Q@Cap@ can only have \Q@mut@ fields, and
	\item \Q@Cap@'s \Q@invariant@ method is defined to return \Q@true@.
\end{itemize}
For simplicity, we do not formalise actual exception objects, rather we have \emph{error}s, which correspond to expressions which are currently  `throwing' an exception; 
in this way there is no value associated with the \emph{error}.
Our L42 implementation instead models exceptions as throwing an \Q@imm@ value, formalising exceptions in this way would not cause any interesting variation of our proof.

\newcommand{\ctxG}{\myCalBig{G}}
\renewcommand{\vs}{\Many{v}}
\renewcommand{\Opt}[1]{#1?}
\begin{figure}
	\!\!\!\!
	\begin{grammatica}
		\produzione{\e}{\x\mid l\mid\Kw{true}\mid\Kw{false}\mid \e\singleDot\m\oR\es\cR\mid \e\singleDot\f 
			\mid\e\singleDot\f\equals\e 
			\mid\Kw{new}\ C\oR\es\cR
			\mid\Kw{try}\ \oC\e_1\cC\ \Kw{catch}\ \oC\e_2\cC
		}{expression}\\
		\seguitoProduzione{
			\mid \M{l}{\e_1}{\e_2}\mid\Kw{try}^{\sigma}\oC\e_1\cC\ \Kw{catch}\ \oC\e_2\cC
		}{runtime expr.}\\
		\produzione{v}{l}{value}\\
		\produzione{\ctx_v}{\square
			\mid \ctx_v\singleDot m\oR\es\cR
			\mid v\singleDot\m\oR\Many{v}_1,\ctx_v,\es_2\cR
			%\mid \ctx_v\singleDot\f 
			%\mid \ctx_v\singleDot\f\equals\e
			\mid v\singleDot\f\equals\ctx_v
		}{evaluation context}\\
		\seguitoProduzione{
			\mid \Kw{new}\ C\oR\Many{v}_1,\ctx_v,\es_2\cR
			\mid \M{l}{\ctx_v}{\e}
			\mid \M{l}{v}{\ctx_v}
			\mid \Kw{try}^\sigma\oC\ctx_v\cC\ \Kw{catch}\ \oC\e\cC}{}\\
		
		\produzione{\ctx}{\square\mid\ctx\singleDot m\oR\es\cR\mid\e\singleDot\m\oR\es_1,\ctx,\es_2\cR
			%\mid \ctx\singleDot\f 
			%\mid \ctx\singleDot\f\equals\e
			\mid \e\singleDot\f\equals\ctx
			\mid \Kw{new}\ C\oR\es_1,\ctx,\es_2\cR
		}{full context}\\
		\seguitoProduzione{
			\mid
			\M{l}{\ctx}{\e}\mid
			\M{l}{\e}{\ctx}\mid
			\Kw{try}^{\sigma?}\oC\ctx\cC\ \Kw{catch}\ \oC\e\cC\mid
			\Kw{try}^{\sigma?}\oC\e\cC\ \Kw{catch}\ \oC\ctx\cC
			
		}{}\\
		
		
		%\produzione{M_l}{\ctx[M\oR l,\e\cR]}{}\\
		%\produzione{\ctxG_l}{
		%  M_l\singleDot\m\oR\es_1,\ctx,\es_2\cR
		% |\e\singleDot\m\oR\es_1, M_l, \es_2, \ctx, \es_3\cR
		% |M_l\singleDot\f\equals\ctx
		% |\Kw{new}\ C\oR\es_1,M_l,\es_2,\ctx,\es_3\cR
		% |\Kw{try}\oC\ctx\cC\ \Kw{catch}\ \oC\e\cC
		% |\ctx[\ctxG_l]}{}\\
		\produzione{\mathit{CD}}{\Kw{class}\ C\ \Kw{implements}\ \Many{C}\oC\Many{F}\,\Many{M}\cC\mid 
			\Kw{interface}\ C\ \Kw{implements}\ \Many{C}\oC\Many{M}\cC
		}{class declaration}\\
		\produzione{F}{\T\ \f\semiColon}{field}\\
		\produzione{M}{\mdf\, \Kw{method}\, \T\ \m\oR\T_1\,\x_1,\ldots,\T_n\,\x_n\cR\ \Opt\e}{method}\\
		\produzione{\mdf}{\Kw{mut}\mid\Kw{imm}\mid\Kw{capsule}\mid\Kw{read}}{type modifier}\\
		\produzione{\T}{\mdf\,C}{type}\\
		\produzione{r_l}{
			v\singleDot\m\oR\Many{v}\cR
			\mid v\singleDot\f
			\mid v_1\singleDot\f\equals v_2
			\mid \Kw{new}\,C\oR\Many{v}\cR
			,\quad\text{where }l\in \{v,v_1,v_2,\Many{v}\}
		}{redex containing $l$}\\
		\produzione{\mathit{error}}{
			\ctx_v[\M{l}{v}{\Kw{false}}]
			,\quad\text{where }
			\ctx_v \text{ not of form}\ \ctx_v'[\Kw{try}^{\sigma?}\oC\ctx_v''\cC\ \Kw{catch}\ \oC\_\cC]
		}{validation error}
	\end{grammatica}
	\caption{Grammar}\label{f:grammar}
\end{figure}


\subheading{Grammar}
The detailed grammar is defined in Figure \ref{f:grammar}. 
Most of our expressions are standard.
\emph{Monitor expressions}
 are of the form \M{l}{\e_1}{\e_2}, they 
are run time expressions and thus are not present in method bodies, rather they are generated by our reduction rules inside the main expression. Here, $l$ refers to the object being monitored, $e_1$ is the expression which is being monitored, and $e_2$ denotes the evaluation of $l.\invariant$. If, at any point in execution, $\e_2$ is \Q!false!, then $l$'s invariant failed to hold; such a monitor expression corresponds to the throwing of an unchecked exception.

In addition, our reduction rules will annotate \Q@try@ expressions with
the original state of memory. This is used to model the guarantee of strong exception safety, that is, the annotated memory will not be mutated by executing the body of the \Q@try@.

\subheading{Well Formedness Criteria}
We additionally restrict the grammar with the following well formedness criteria:
\begin{itemize}
	\item \Q@invariant@ methods and capsule mutators satisfy the restrictions in Section \ref{s:protocol}.
	\item Field accesses and updates in methods are of the form $\Kw{this}.f$ or $\Kw{this}.f\equals\e$, respectively.
	\item Field accesses and updates in the main expression are of the form $l.f$ or $l.f\equals\e$, respectively.
	\item \REV{Locations that are preserved by \Q@try@ blocks are
	never monitored, that is, for $\Kw{try}^\sigma\oC\e\cC\ \_$, if $\e$ is of the form $\ctx[\M{l}{\_}{\_}]$, then $l\notin\sigma$.}{D}{... It must be a property *proven* true of program executions under the specific type system. This isn't something that would just follow from from of the SES work, either (at least not the papers cited specifically for SES), because it relates to the
	monitoring new to this work.}
\end{itemize}
\newcommand{\rowSpace}{\\\vspace{2.5ex}}
\begin{figure}
	\!\!
	$\!\!\!\!\!\begin{array}{l}
	\inferrule[(update)]{{}_{}}{
		\sigma|l.f\equals{}v\rightarrow \sigma[l.f=v]|
		\M{l}{l}{l\singleDot\invariant}
	}{}
	\quad
	\inferrule[(new)]{{}_{}}{
		\sigma|\Kw{new}\ C\oR\vs\cR\rightarrow \sigma,l\mapsto C\{\vs\}|
		\M{l}{l}{l\singleDot\invariant}
	}{}
	\\
	\rowSpace
	\inferrule[(mcall)]{{}_{}}{
		\sigma|l\singleDot\m\oR v_1,\ldots,v_n\cR\rightarrow \sigma|
		\e'[\Kw{this}=l,\x_1=v_1,\ldots,x_n=v_n]
	}{
		\begin{array}{l}
		\sigma(l)=C\{\_\}\\
		C.m=\mdf\,\Kw{method}\,\T\,\m\oR\T_1\,\x_1\ldots\T_n\x_n\cR\,\e\\
		
		\text{if }\ \exists \f\text{ such that } C.f=\Kw{capsule}\,\_,
		\mdf=\Kw{mut},
		\\*\quad\f\, \text{inside}\, C\singleDot\m
		\text{, and }
		\f\,\text{inside}\, C\singleDot\Kw{invariant}
		
		\\*
		\text{then }\e'=\M{l}{e}{l\singleDot\invariant}\\*
		\text{otherwise }\e'= \e
	\end{array}
}
\rowSpace
\inferrule[(monitor exit)]{{}_{}}{
	\sigma|\M{l}{v}{\Kw{true}}\rightarrow \sigma|v
}{}
\quad

\inferrule[(ctxv)]{\sigma_0|\e_0\rightarrow\sigma_1|\e_1}{
	\sigma_0|\ctx_v[\e_0]\rightarrow \sigma_1|\ctx_v[\e_1]
}{}

\quad
\inferrule[(try enter)]{{}_{}}{
	\sigma|\Kw{try}\ \oC \e_1\cC\ \Kw{catch}\ \oC\e_2\cC\rightarrow 
	\sigma|\Kw{try}^\sigma\oC\e_1\cC\ \Kw{catch}\ \oC\e_2\cC
}{}
\quad

\rowSpace

\inferrule[(try ok)]{{}_{}}{
	\sigma,\sigma'|\Kw{try}^{\sigma}\oC v\cC\ \Kw{catch}\ \oC\_\cC\rightarrow \sigma,\sigma'|v
}{}
\quad

\inferrule[(try error)]{{}_{}}{
	\sigma,\_|\Kw{try}^\sigma\oC \mathit{error}\cC\ \Kw{catch}\ \oC\e\cC\rightarrow \sigma|\e
}
\quad
\inferrule[(access)]{{}_{}}{
	\sigma|l.f\rightarrow \sigma|\sigma[l.f]
}{}
%\quad
\end{array}$
\caption{Reduction rules}\label{f:reductions}
\end{figure}

\subheading{Reduction rules}
Our reduction rules are defined in Figure \ref{f:reductions}.
They are pretty standard, except for our handling of monitor expressions.
We define the relation \emph{inside} as follows:\par
$%\begin{array}{l}
\f\, \textit{inside}\, C\singleDot\m\text{ iff }
C\singleDot\m=\_\,\Kw{method}\_\,\ctx[\Kw{this}\singleDot\f]
%\end{array}
$

%\noindent Inserting the monitor expressions during reduction is convenient for the proof,
%but it could instead be done ahead of time.

\noindent Monitor expressions are added after all field updates, \Q@new@ expressions, and calls to capsule mutators.
%Our formalism of monitor expressions are only a proof device, they need not be part of the language itself, for example L42 implements our invariant protocol by generating wrapper functions over primitive setters and factory methods.
%Monitor expressions are only a proof device, and an execution on a real hardware 
Monitor expressions are only a proof device, they need not be implemented directly as presented.
For example, in L42 we implement them by statically injecting calls to \Q!invariant! at the end of setters, factory methods and capsule mutators; this works as L42 does not have primitive expression forms for field updates and constructors, rather they are uniformly represented as method calls.
% do not need to represent them.  In L42 field updates are always performed throughout a setters, thus we can just inject calls to \Q@invariant@ on setters, at the end of constructor bodies and at the end of  capsule mutators.

Our \textsc{ctxv} rule evaluates monitor expressions, \M{l}{\e_1}{\e_2}, by first evaluating $\e_1$ and then $\e_2$. If $\e_2$ evaluates to \Q@true@, then the monitor succeeded, and will yield the result of $\e_1$. If however $\e_2$ evaluated to \Q!false!, then the monitor failure will be caught by our \textsc{try error} rule, as will any other uncaught monitor failure in $e_1$ or $e_2$.

\subheading{Statement of Soundness}
We define a deterministic reduction to mean that exactly one reduction is possible:\\*
\indent$\ \sigma_0|e_0\Rightarrow \sigma_1|e_1$ iff $\{\sigma_1|\e_1\}=\{\sigma|\e \text{, where } \sigma_0|e_0\rightarrow \sigma|e\}$

\noindent An object is \emph{valid} iff calling its \Q@invariant@ method would
deterministically produce \Q@true@ in a finite number of steps, i.e. it does not evaluate to \Q@false@, fail to terminate, or produce an \emph{error}.
We also require evaluating \Q@invariant@ to preserve existing memory ($\sigma$), however new objects ($\sigma'$) can be created and freely mutated.

\indent$\mathit{valid}(\sigma,l)$ iff $\sigma | l.\invariant {\Rightarrow^+} \sigma,\sigma' | \Kw{true}$.%\loseSpace

\noindent 
To allow the invariant method to be called on an invalid object, and access fields on such object, we define the set of trusted execution steps as the the call to \Q@invariant@ itself, and any field accesses inside its evaluation. Note that this only applies to single small step reductions, and not the entire evaluation of \Q!invariant!.

%\loseSpace
\noindent \REV{$\mathit{trusted}(\ctx_v,r_l)$}{D}{The definition ... is missing details on the inner evaluation context in the second case, which presumably needs to have a hole somewhere} iff\\*
\indent either
$r_l=l.\invariant$ and
$\ctx_v=\ctx_v'[\M{l}{v}{\square}]$,\\*
\indent or
$r_l=l$\Q@.f@ and
$\ctx_v=\ctx_v'[\M{l}{v}{\ctx_v''}]$.
%\loseSpace

\noindent Finally, we define what it means to soundly enforce our invariant protocol: every object referenced by any untrusted redex is valid.

\begin{theorem}[Soundness]\rm
if $c:\Kw{Cap};\emptyset\vdash \e: \T$ and
$c\mapsto\Kw{Cap}\{\_\}|\e\rightarrow^+ \sigma|\ctx_v[r_l]$, then
either $\mathit{valid}(\sigma,l)$ or $\mathit{trusted}(\ctx_v,r_l)$.
\end{theorem}


%We believe this property captures very precisely our statements in section~\ref{s:protocol}.