\section{Formal Language Model}
\label{s:formalism}
\saveSpace

%----------------------------------
In order to model our system, we need to formalise an imperative object oriented language
with exceptions and object capabilities,  and rich type system
support for \Q@mut@, \Q@imm@, \Q@read@, \Q@capsule@, and strong exception safety.
Formal modelling the semantics of such a language is simple, but 
defining such rich type system and proving correctness of it would require a paper
of its own, and indeed many such papers exist in literature%
~\cite{ServettoEtAl13a,ServettoZucca15,GordonEtAl12,clebsch2015deny,JOT:issue_2011_01/article1}.
Thus we are going to assume that there is an expressive and sound type system enforcing
those properties, and instead focus on invariant checking.
To provide good modularisation for reasoning, in the Appendix
we clearly list the properties our proof (also in Appendix) need to rely upon, so that \emph{every} type
system supporting those properties can support our invariant protocol.

We strive to keep our small step semantics as conventional as possible; following Pierce~\cite{pierce2002types} and Featherweight Java~\cite{IgarashiEtAl01} we assume:
\begin{itemize}
	\item An implicit program/class-table.
	\item Memory $\sigma\Coloneqq l\mapsto C\{\Many{v}\}$ is a finite map from locations $l$ to annotated tuples $C\{\Many{v}\}$: representing objects,
	where $C$ is the class name and $\Many{v}$ are the field values.
	We use the notation $\sigma[l.f=v]$ to update an object's field and $\sigma[l.f]$ to access it.
	\item A main expression that is reduced in the context of such memory and program.
	\item A type system $\Sigma;\Gamma\vdash\e:T$, where 
	the expression $\e$ can contain locations and free variables;
	the type of locations is encoded in $\Sigma\Coloneqq l\mapsto C$,
	while the types of free variables are encoded in $\Gamma\Coloneqq x\mapsto T$.
	\item We use $\Sigma^\sigma$ to trivially extract the corresponding $\Sigma$ from $\sigma$.
\end{itemize}
In addition, to encode object capabilities and I/O, we assume a special location  $c$ of class \Q@Cap@. This location would refer to an object whose fields model thins like the content of input and output files. In order to simplify our proof, we additionally assume that:
\begin{itemize}
	\item instances of \Q@Cap@ cannot be created with a \Q@new@ expression,
	\item all methods of \Q@Cap@ must be \Q@mut@, and mutate the ROG of their receiver,
	\item \Q@Cap@ can only have \Q@mut@ fields, and
	\item \Q@Cap@'s \Q@invariant@ method is defined to return \Q@true@.
\end{itemize}
\noindent
To keep our formalization focused on
the challenges of invariant checking, 
we impose limitations on \Q@this@, fields and constructors:
%there are some
%tweaks with respect to our informal description of our approach.
%From a formal perspective 
%these changes do not change expressivity:
%In the formalism we require 
\begin{itemize}
	\item The \Q@this@ receiver must always be specified explicitly.
	\item All fields are instance private. Getters and setters could simulate public fields.
\end{itemize}

Moreover, in the formalism for simplicity, we do not have actual exception objects, we just have a concept of \emph{errors} with no associated values.
In the L42 implementation we support \Q@imm@ objects as exception values. Adding them to our formalism would not cause any interesting variation of our proof.

\newcommand{\ctxG}{\myCalBig{G}}
\renewcommand{\vs}{\Many{v}}
\renewcommand{\Opt}[1]{#1?}
\begin{figure}
	\!\!\!\!
	\begin{grammatica}
		\produzione{\e}{\x\mid l\mid\Kw{true}\mid\Kw{false}\mid \e\singleDot\m\oR\es\cR\mid \e\singleDot\f 
			\mid\e\singleDot\f\equals\e 
			\mid\Kw{new}\ C\oR\es\cR
			\mid\Kw{try}\ \oC\e_1\cC\ \Kw{catch}\ \oC\e_2\cC
		}{expression}\\
		\seguitoProduzione{
			\mid \Kw{M}\oR l;\e_1;\e_2\cR\mid\Kw{try}^{\sigma}\oC\e_1\cC\ \Kw{catch}\ \oC\e_2\cC
		}{runtime expr.}\\
		\produzione{v}{l}{value}\\
		\produzione{\ctx_v}{\square
			\mid \ctx_v\singleDot m\oR\es\cR
			\mid v\singleDot\m\oR\Many{v}_1,\ctx_v,\es_2\cR
			%\mid \ctx_v\singleDot\f 
			%\mid \ctx_v\singleDot\f\equals\e
			\mid v\singleDot\f\equals\ctx_v
		}{evaluation context}\\
		\seguitoProduzione{
			\mid \Kw{new}\ C\oR\Many{v}_1,\ctx_v,\es_2\cR
			\mid \Kw{M}\oR l;\ctx_v;\e\cR
			\mid \Kw{M}\oR l;v;\ctx_v\cR
			\mid \Kw{try}^\sigma\oC\ctx_v\cC\ \Kw{catch}\ \oC\e\cC}{}\\
		
		\produzione{\ctx}{\square\mid\ctx\singleDot m\oR\es\cR\mid\e\singleDot\m\oR\es_1,\ctx,\es_2\cR
			%\mid \ctx\singleDot\f 
			%\mid \ctx\singleDot\f\equals\e
			\mid \e\singleDot\f\equals\ctx
			\mid \Kw{new}\ C\oR\es_1,\ctx,\es_2\cR
		}{full context}\\
		\seguitoProduzione{
			\mid
			\Kw{M}\oR l;\ctx;\e\cR\mid
			\Kw{M}\oR l;\e;\ctx\cR\mid
			\Kw{try}^{\sigma?}\oC\ctx\cC\ \Kw{catch}\ \oC\e\cC\mid
			\Kw{try}^{\sigma?}\oC\e\cC\ \Kw{catch}\ \oC\ctx\cC
			
		}{}\\
		
		
		%\produzione{M_l}{\ctx[M\oR l,\e\cR]}{}\\
		%\produzione{\ctxG_l}{
		%  M_l\singleDot\m\oR\es_1,\ctx,\es_2\cR
		% |\e\singleDot\m\oR\es_1, M_l, \es_2, \ctx, \es_3\cR
		% |M_l\singleDot\f\equals\ctx
		% |\Kw{new}\ C\oR\es_1,M_l,\es_2,\ctx,\es_3\cR
		% |\Kw{try}\oC\ctx\cC\ \Kw{catch}\ \oC\e\cC
		% |\ctx[\ctxG_l]}{}\\
		\produzione{CD}{\Kw{class}\ C\ \Kw{implements}\ \Many{C}\oC\Many{F}\,\Many{M}\cC\mid 
			\Kw{interface}\ C\ \Kw{implements}\ \Many{C}\oC\Many{M}\cC
		}{class declaration}\\
		\produzione{F}{\T\ \f;}{field}\\
		\produzione{M}{\mdf\, \Kw{method}\, \T\ \m\oR\T_1\,\x_1,\ldots,\T_n\,\x_n\cR\ \Opt\e}{method}\\
		\produzione{\mdf}{\Kw{mut}\mid\Kw{imm}\mid\Kw{capsule}\mid\Kw{read}}{type modifier}\\
		\produzione{\T}{\mdf\,C}{type}\\
		\produzione{r_l}{
			v\singleDot\m\oR\Many{v}\cR
			\mid v\singleDot\f
			\mid v_1\singleDot\f\equals v_2
			\mid \Kw{new}\,C\oR\Many{v}\cR
			,\quad\text{with }l\in \{v,v_1,v_2,\Many{v}\}
		}{redex containing $l$}\\
		\produzione{\mathit{error}}{
			\ctx_v[\Kw{M}\oR l; v;\Kw{false}\cR]
			,\quad\text{with }
			\ctx_v \text{not of form}\ \ctx_v'[\Kw{try}^{\sigma?}\oC\ctx_v''\cC\ \Kw{catch}\ \oC\_\cC]
		}{validation error}
	\end{grammatica}
	\caption{Grammar}
\end{figure}


\subheading{Grammar and Well Formedness Criteria}
The detailed grammar is defined in Figure 1.
The only non standard expression is the monitor. They are not present in the source code, but are inserted by our reduction rules. The object it monitors is the one referenced by $l$, $e_1$ is the expression which is being monitored, and $e_2$ denotes the evaluation of $l.invariant()$.
We annotate the monitor expression with $l$ to ensure
that if the invariant check fails, it is precisely $l$ that is invalid.
We use a failed monitor expression (i.e. when $\e_2$ is the value \Q@false@) to represent throwing unchecked exceptions.
In addition, our reduction rules annotate the body of \Q@try@ expressions with
the original state of memory. This is used to propagate the guarantees of strong exception safety,
that is, the annotated memory will not be mutated by executing the body of the \Q@try@.

Our well formedness criteria cooperate with the simplified language grammar to enforce the restrictions mentioned before:
\begin{itemize}
	\item \Q!invariant! methods and capsule mutators satisfy the restrictions in \ref{s:protocol}.
	\item Field accesses in method are of the form
	\Q@this.@$f$, and of form $l\singleDot\f$ in the main expression.
	
	%We could relax the restrictions for parameter and return types, since \Q@this@ is \Q@capsule@, it is a unique alias.
	\item 
	During reduction, locations that are preserved by a \Q@try@ block are
	never monitored; formally 
	for $\Kw{try}^\sigma\oC\e\cC\_$, $\e$ is not of the form $\ctx[$\Q@M(@$l;\_$\Q@)@$]$, for any $l\in\sigma$.restrictions
\end{itemize}

\newcommand{\rowSpace}{\\\vspace{2.5ex}}

\begin{figure}
	\!\!
	$\!\!\!\!\!\begin{array}{l}
	\inferrule[(update)]{{}_{}}{
		\sigma|l.f\equals{}v\rightarrow \sigma[l.f=v]|
		\Kw{M}\oR l;l;l\singleDot\Kw{invariant}\oR\cR\cR
	}{}
	\quad
	\inferrule[(new)]{{}_{}}{
		\sigma|\Kw{new}\ C\oR\vs\cR\rightarrow \sigma,l\mapsto C\{\vs\}|
		\Kw{M}\oR l;l;l\singleDot\Kw{invariant}\oR\cR\cR
	}{}
	\\
	\rowSpace
	\inferrule[(mcall)]{{}_{}}{
		\sigma|l\singleDot\m\oR v_1,\ldots,v_n\cR\rightarrow \sigma|
		\e'[\Kw{this}=l,\x_1=v_1,\ldots,x_n=v_n]
	}{
		\begin{array}{l}
		\sigma(l)=C\{\_\}\\
		C.m=\mdf\,\Kw{method}\,\T\,\m\oR\T_1\,\x_1\ldots\T_n\x_n\cR\,\e\\
		
		\text{if }\ \exists \f\text{ such that}\ \ C.f=\Kw{capsule}\,\_,
		\mdf=\Kw{mut},
		\\*\quad\f\, \text{inside}\, C\singleDot\m
		\text{ and }
		\f\,\text{inside}\, C\singleDot\Kw{invariant}
		
		\\*
		\text{then }\e'=\Kw{M}\oR l;\e;l\singleDot\Kw{invariant}\oR\cR\cR\\*
		\text{otherwise }\ \e'= \e
	\end{array}
}
\rowSpace
\inferrule[(monitor exit)]{{}_{}}{
	\sigma|\Kw{M}\oR l; v;\Kw{true}\cR\rightarrow \sigma|v
}{}
\quad

\inferrule[(ctxv)]{\sigma_0|\e_0\rightarrow\sigma_1|\e_1}{
	\sigma_0|\ctx_v[\e_0]\rightarrow \sigma_1|\ctx_v[\e_1]
}{}

\quad
\inferrule[(try enter)]{{}_{}}{
	\sigma|\Kw{try}\ \oC \e_1\cC\ \Kw{catch}\ \oC\e_2\cC\rightarrow 
	\sigma|\Kw{try}^\sigma\oC\e_1\cC\ \Kw{catch}\ \oC\e_2\cC
}{}
\quad

\rowSpace

\inferrule[(try ok)]{{}_{}}{
	\sigma,\sigma'|\Kw{try}^{\sigma}\oC v\cC\ \Kw{catch}\ \oC\_\cC\rightarrow \sigma,\sigma'|v
}{}
\quad

\inferrule[(try error)]{{}_{}}{
	\sigma,\_|\Kw{try}^\sigma\oC \mathit{error}\cC\ \Kw{catch}\ \oC\e\cC\rightarrow \sigma|\e
}
\quad
\inferrule[(access)]{{}_{}}{
	\sigma|l.f\rightarrow \sigma|\sigma[l.f]
}{}
%\quad
\end{array}$
\caption{Reduction rules}
\end{figure}

\loseSpace
\subheading{Reduction rules}
Reduction rules are defined in Figure 2.
These rules are pretty standard;
\textsc{mcall}
uses the auxiliary function \emph{inside},
formally defined as follows:

$%\begin{array}{l}
\f\, \textit{inside}\, C\singleDot\m\text{ iff }
C\singleDot\m=\_\,\Kw{method}\_\,\ctx[\Kw{this}\singleDot\f]
%\end{array}
$

%\noindent Inserting the monitor expressions during reduction is convenient for the proof,
%but it could instead be done ahead of time.

\noindent Monitors are added for all field updates and \Q@new@ expressions, and for all
method calls of capsule mutators.%
\footnote{%
There is no need to monitor \Q@capsule@ methods, since their receiver is a unique alias and hence can never be used again.
}
Monitor expressions are only a proof device, and an execution on a real hardware do not need to represent them. 
In L42 field updates are always performed throughout a setters,
thus we can just inject
calls to \Q@invariant@ on setters, at the end of constructor bodies and at the end of  capsule mutators.

The interaction with monitors, evaluation contexts and exceptions is interesting:
a monitor releases the value if the invariant check evaluates to \Q@true@, and produces an error if the 
check evaluates to \Q@false@.
If either monitor expressions $\e_1$ or $\e_2$ are not already values, the execution is propagated inside
by \textsc{ctxv}.
If either $\e_1$ or $\e_2$ evaluate to an error, such error is captured by 
\textsc{try error}.
Thanks to strong exception safety,
we do not need to worry
if the (partial) execution of $\e_1$ broke the object referenced by $l$.

\subheading{Statement of Soundness} We define
a deterministic reduction arrow, requiring exactly one reduction is possible:\\*
\indent$\ \sigma_0|e_0\Rightarrow \sigma_1|e_1$ iff $\{\sigma_1|\e_1\}=\{\sigma|\e \text{ where } \sigma_0|e_0\rightarrow \sigma|e\}$

\noindent An object is \emph{valid} iff calling its \Q@invariant@ method would
deterministically produce \Q@true@ in a finite number of steps, i.e. it does not evaluate to \Q@false@, fail to terminate, or produce an error.
We also require evaluating \Q@invariant@ to preserve existing memory ($\sigma$): but new objects ($\sigma'$) can be created and freely mutated.

\indent$valid(\sigma,l)$ iff $\sigma | l.invariant()\Rightarrow^+ \sigma,\sigma' | \text{\Q@true@}$.\loseSpace


\noindent 
To allow the invariant method to be called on an invalid object, and to allow its body to access the fields we define the set of trusted steps:
the call to \Q@invariant@ and the field accesses inside its evaluation.
Note that just the single small step reduction
of calling \Q@invariant@ is trusted, not the whole evaluation of the \Q@invariant@ expression.

\loseSpace
\noindent $\mathit{trusted}(\ctx_v,r_l)$ iff\\*
\indent either
$r_l=l.invariant()$ and
$\ctx_v=\ctx_v'[$\Q@M(@$l$\Q@;@$v$\Q@;@$\square$\Q@)@$]$,\\*
\indent or
$r_l=l$\Q@.f@ and
$\ctx_v=\ctx_v'[$\Q@M(@$l$\Q@;@$v$\Q@;@$\ctx_v''$\Q@)@$]$.
\loseSpace

\noindent Finally, we define what it means for a language to soundly enforce our invariant protocol: every object involved in any untrusted redex is valid.

\begin{theorem}[Soundness]
if $c:\Kw{Cap};\emptyset\vdash \e: \T$ and
$c\mapsto\Kw{Cap}\{\_\}|\e\rightarrow^+ \sigma|\ctx_v[r_l]$, then
either $valid(\sigma,l)$ or $\mathit{trusted}(\ctx_v,r_l)$.
\end{theorem}


%We believe this property captures very precisely our statements in section~\ref{s:protocol}.

