%-----------------------------------------------------------
%define simple objects
%show solution  for simple person: requires 3 properties
%show solution is sound --> proof in appendix
%naive is unsound - person 3 bugs
\saveSpace
\section{Our Invariant Protocol}
\label{s:protocol}
\saveSpace
\IODel{In this section we will formalize our approach over a core language, and we formally state our soundness property (proved in the Appendix).
In the next section, by examples, we will show that all our restrictions and
requirements are actually needed, and that just violating any one of them would cause our system to be unsound.}

Our invariant protocol guarantees that the whole ROG of any object involved in execution (formally, in a redex) is \emph{valid}:\IODel{if you can call methods on an object,} calling \Q@invariant@ on it is guaranteed to return \Q@true@ in a finite number of steps. However, the \Q!invariant! method itself needs to be able to operate on a potentially invalid \Q!this!, this will only happen when it is automatically called by the language itself, not by explicit calls present in the source code.

\IODel{Clearly the \Q@invariant@ method must be able to take an invalid \Q@this@, since the purpose of such method is to distinguish valid and invalid objects.
On a first look this may seem an open contradiction
 with the aim of this work, however only calls to \Q@invariant@ inserted by the language semantics can take an invalid \Q@this@. As for any other method, when the application code can call \Q@invariant@, \Q@this@ is guaranteed to be valid.
Also the bodies of constructors may interact with an invalid \Q@this@; we restrict their shape so that neither invariant methods nor constructors can observe the invalid object directly, but only its fields. }

%Logically, there are two reasons to access a field: we may wish to read the information stored in such object or we wish to mutate the object contained in the field.
%For the first case, we can type the field access as \Q@read@, but in the second case we
%need to type it as \Q@mut@. 
%We call `capsule mutators' a method accessing as \Q@mut@ a capsule field referenced in the invariant.
%We will show how capsule mutators are analogous of the pack/unpack/expose~\cite{???}.
%In order for a class to have an invariant under our protocol,
%\IODel{its }\Q@invariant@ method the form 
% Can  a program write say mut method invariant or is it syntactically [???]

We require that all classes contain a \Q@read method Bool invariant() {..}@, if no \Q!invariant! method is present, a trivial one returning \Q!true! will be assumed. As this method only takes a \Q!read! parameter (the receiver), we can be sure that it is pure \footnote{If the invariant were not pure, it would be nearly impossible to ensure that it would return \Q@true@ at any point.} (see Section \ref{s:purity}).

To ensure that invariants cannot be broken by unrelated code (see Section \ref{s:immutable}) we require that \Q@invariant@ methods only use \Q@this@ to read \Q@imm@ and \Q@capsule@ fields.
\IODel{Access \Q@mut@ fields is forbidden because their ROG can be changed by unrelated code. In order to prevent passing an invalid \Q@this@ to other methods.}

In order to ensure that a broken object is not visible whilst mutating one of their capsule fields (see Section \ref{s:encapsulated}), we place restrictions on any method (directly) reading a \Q!capsule! field of a \Q!mut! object, we call such methods \emph{capsule mutators}. Such methods must:
\begin{itemize}
\item access the \Q!capsule! field as \Q!this.f!,\footnote{Thus capsule fields are instance private.}
\item have no other occurrences of \Q!this!,
\item not take any \Q!mut! or \Q!read! parameters (excluding the receiver), and
\item not have a \Q!mut! return type.
\end{itemize}
\IOComm{mention these don't apply to \Q!capsule! recievers..}
\IODel{\noindent Also note that \Q@invariant@ is declared as not throwing any exceptions, thus only unchecked exceptions can be propagated out.}
%
Rather than requiring uninitialised objects to satisfy their invariants, we instead require that objects be fully initialised before use. We ensure this by preventing explicit constructor definitions, and instead assume they have the form \Q@$C$($T_1 x_1$,$\ldots$,$T_n x_n$) {this.$f_1$=$x_1$;$\ldots$;this.$f_n$=$x_n$;}@, where the fields of $C$ are $f_1,\ldots,f_n$ and have types $T_1,\ldots,T_n$.

\subheading{Monitoring}
The language runtime will enforce invariants by automatically calling \Q!invariant!, if it returns \Q!false!, an unchecked-exception will be thrown. Invariants are check on objects:
\begin{itemize}
	\item immediately after their constructor has returned,
	\item after one of their fields has been updated,
	\item at the end of a call to one of its capsule mutators (unless the call was terminated by an unchecked-exception, since strong exception safety (see Section \ref{s:exceptions}) guarantees the object will be unreachable anyway).
\end{itemize}

\subheading{Relaxations}
The above restrictions seem quite severe, however they are simple and make the proof simpler, without making it less interesting. We have implemented several relaxations in our L42 implementation:
\begin{itemize}
	\item Accesses to \Q!capsule! fields that are \emph{not} referenced in their receivers \Q!invariant! are not restricted (and hence methods containing such accesses are not considered to be \Q!capsule! mutators).
	
	\item \Q!invariant! methods can call instance methods that in turn only use \Q@this@ to read \Q!imm! or \Q!capsule!, or call other such instance methods. With this relaxation, the semantics of \Q@invariant@ needs to be understood with the body of those methods inlined; thus the semantic of the inlined code needs to be logically reinterpreted in the context of \Q@invariant@, where \Q@this@ may be invalid. In some sense, those inlined methods and field accesses can be thought of as macro expanded, and hence are not dynamically dispatched. 
	%This does prevent the calling of recursive methods,
	%allowing them would not cause problems with our protocol,
	%but it does not increase expressivity.

\end{itemize}

In addition helper methods can be made (or automatically generated) to simulate relaxations:
\begin{itemize}
	\item Unrestricted readonly access to \Q!capsule! fields can be allowed by automatically generate getters of the form \Q!read method read C f() { return this.f; }! (this is done in L42 implementation).
	\item Factories can be written to allow for more flexible construction, alternatively Java style constructors could be allowed, provided that \Q!this! is only used as the receiver of field initialisations.
\end{itemize}
%%
\IOComm{Put the following paragraph somewhere else?}
Both L42, and our formal language (see Section~\ref{s:formalism}) do not have traditional subclassing, rather all `classes' are either interfaces (which only have abstract methods), or are final (which cannot be subtyped). In a language with subclassing, invariant methods would implicitly start with a check that \Q@super.invariant()@ returns \Q@true@. Note that invariant checks would not be performed at the end of \Q@super(..)@ constructor calls, but only at the end of \Q@new@ expressions, as happens in~\cite{feldman2006jose}.
%%
\IODel{The L42 language support checked exceptions, but offer strong exception safety only for unchecked ones. In such context we need to add the constraint that capsule mutators are declared to not throw any checked exception.???}

%%%
\begin{comment}
Justifications:

This prevents objects from escaping their constructor partially initialised, and of course prevents explicitly calling \Q@invariant@ inside of \Q@invariants@ and constructors bodies, but most importantly, together with our other restrictions, it prevents \Q@this@, or an alias to \Q@this@, from being passed around to arbitrary code.
To provide more flexible initialisation one could always make a factory method.

While mutating the ROG of a \Q@capsule@ field mentioned in the invariant, the containing object may become invalid.
The restrictions over capsule mutators
enforce that such containing object is inaccessible.

\end{comment}

