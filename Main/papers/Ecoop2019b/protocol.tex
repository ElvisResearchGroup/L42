%-----------------------------------------------------------
%define simple objects
%show solution  for simple person: requires 3 properties
%show solution is sound --> proof in appendix
%naive is unsound - person 3 bugs
\section{Our Invariant Protocol}
\label{s:protocol}
Our invariant protocol guarantees that the whole ROG of any object involved in execution (formally, in a redex) is \emph{valid}: if you can call methods on an object, calling \Q@invariant@ on it is guaranteed to return \Q@true@ in a finite number of steps. However, calls to \Q!invariant! that are generated by our runtime monitoring (see below) can access the fields of a potentially invalid \Q!this!. This is necessary to allow for the \Q!invariant! method to do its job: namely distinguish between valid and invalid objects. However, as for calls to any other method, calls to \Q!invariant! written explicitly by users are guaranteed to have a valid receiver. 

% However, the \Q!invariant! method itself needs to be able to operate on a potentially invalid \Q!this!, this will only happen when it is automatically called by the language itself, not by explicit calls present in the source code.
% Clearly the \Q@invariant@ method must be able to take an invalid \Q@this@, since the purpose of such method is to distinguish valid and invalid objects. On a first look this may seem an open contradiction
% with the aim of this work, however only calls to \Q@invariant@ inserted by the language semantics can take an invalid \Q@this@. As for any other method, when the application code can call \Q@invariant@, \Q@this@ is guaranteed to be valid.
%

%Logically, there are two reasons to access a field: we may wish to read the information stored in such object or we wish to mutate the object contained in the field.
%For the first case, we can type the field access as \Q@read@, but in the second case we
%need to type it as \Q@mut@. 
%We call `capsule mutators' a method accessing as \Q@mut@ a capsule field referenced in the invariant.
%We will show how capsule mutators are analogous of the pack/unpack/expose~\cite{???}.
%In order for a class to have an invariant under our protocol,
%\Q@invariant@ method the form 
% Can  a program write say mut method invariant or is it syntactically [???]
For simplicity, in the following explanation and in our formalism
we require 
%the \Q@this@ receiver is 
receivers to always be specified explicitly, and require that the receivers of field accesses and updates are always \Q!this!; that is, all fields are instance private.
We also do not allow explicit constructor definitions, instead we assume constructors are of the standard form \Q@$C$($T_1 x_1$,$\ldots$,$T_n x_n$) {this.$f_1$=$x_1$;$\ldots$;this.$f_n$=$x_n$;}@, where the fields of $C$ are $T_1 f_1;\ldots; T_n f_n;$. This ensures that partially uninitialised (and likely invalid) objects are not passed around or used. 
These restrictions only apply to our formalism; our code examples and the L42 implementation soundly relax these, see below for a discussion.% of why this is sound.
%We will later explain how these and other restrictions can be partially relaxed, as in the code examples.

% In order to prevent passing an invalid \Q@this@ to other methods.
%and unrelated code cannot break the invariant
%s of arbitrary objects,
%since a \Q!read! or \Q!mut! field could be modified through arbitrary aliases 
%(see Section \ref{s:immutable}). 

%To ensure that invariants cannot be broken by unrelated code (see Section \ref{s:immutable})  %
\subheading{Capsule Fields}
In order to allow\IO{invariants over complex mutable objects} \IODel{complex mutations of objects with invariants}, we introduce a novel kind of \Q!capsule! field, which can be accessed within invariants: such a field can store an arbitrarily complex cyclic object graph. \IO{We enforce the following rules for \Q!capsule! fields, they ensure that an object has control over the mutation of it's capsule fields, and only when such mutation happens could the objects invariant be violated}:
\IODel{However, in order to know what mutations could violate such invariant, the following rules ensure that an object has control over the mutation of the ROGs of its capsule fields:}
\begin{itemize}
	\item A \Q!capsule! field can only be initialised/updated with a \Q!capsule! expression.
	\item Access to a \Q!capsule! field om a \Q@mut@ receiver will return a \Q!mut!. Since fields are instance private, this access will be on \Q!this! and within a \Q!mut! method, such methods are termed \emph{capsule mutators}, and must:
	\begin{itemize}
		\item use \Q!this! exactly once in their body, namely to access the capsule field,
		\item not have any \Q!mut! or \Q!read! parameters (excluding the \Q!mut! receiver),
		\item not have a \Q!mut! return type, and
		\item not have a non-empty \Q!throws! clause\footnote{To allow capsule mutators to leak checked exceptions, we would need to check the invariant when such exceptions are leaked. However, this would make the runtime semantics of checked exceptions inconsistent with unchecked ones.}.
	\end{itemize}	
	%The restrictions on \emph{capsule mutators} ensure that a \Q!mut!/\Q!capsule! reference to the ROG of the capsule field is not returned, stored in the ROG of a parameter, or in any other field of the method's receiver. We also ensure that no reference.
	\item Any other \Q!capsule! field access behaves like a \Q!mut! field access: if the receiver is \Q!imm!, the field access will return \Q!imm!, if the receiver is \Q!read!, it will return \Q!read!, if the receiver is \Q!capsule!, it will return \Q!mut! (which is then immediately promotable to \Q!capsule!). % On the other hand, a \Q!capsule! reference may be freely used to gain mutable alias to one of its capsule fields, since the receiver is \Q!capsule!, it cannot be referenced anywhere else.
	
\end{itemize}

\noindent These restrictions ensure that for all objects $o$, and capsule field's $f$ of that object:
\begin{itemize}
	\item $o.f$ does not alias $o$.
%		\item $o.f$ must have been initialised/updated with a \Q!capsule! expression, which couldn't alias $o$, since $o$ was used in the same expressions as the new value of $o.f$.
%		\item an alias to $o$ cannot be used inside capsule mutators (see below), such an alias could not be stored in the ROG of $o.f$.
	\item If we are not executing a capsule mutator on $o$ that reads $f$, \IODel{then $o$ is the only external mutable alias to the ROG of $o.f$.}
\IO{if a path of \Q!mut!/\Q!capsule! fields, starting from a \Q!mut!/\Q!capsule! reference, refers to the ROG of $o.f$, then it must pass through $o$. Since only a capsule mutator can see $o.f$ as \Q!mut!, this means that the only way to mutate the ROG of $o.f$ is through a capsule mutator on $o$.}
%	the ROG of $o.f$ is only mutable thanks to $o$, i.e. deleting $o$ will prevent the ROG of $o.f$ from ever being mutated again.
%		\item Capsule mutators preserve this property since they cannot return a \Q!mut!, they have no \Q!mut! parameters to which they could store such an alias in, and they cannot store such an alias somewhere else in the ROG of $o$, since $o$ is not usable within the capsule mutator (see below).
	\item If execution is in such a capsule mutator, then $o$ is used at most once, which will be to access $f$. 
% This holds since $o$ cannot alias $o.f$, \Q!this! is used only once (to access $f$), and none of the methods parameters can alias $this$ (since only \Q!imm!/\Q!capsule! parameters are allowed, and \Q!this! is \Q!mut!, our TM system guarantees the former does not alias the latter).
\end{itemize} 
Thus we can be sure that the ROG of $o.f$ will only mutate within a capsule mutator, and only after the single use of $o$ to access $o.f$; such mutation could invalidate the invariant of $o$, so we simply check it at the end of the method before $o$ can be used again. Provided that the invariant is re-established before returning, no invariant failure will be thrown, even if the invariant was broken \emph{during} the method call.

%As the expression is \Q!capsule!, we can be sure that the object being initialised/updated will have the only external alias to the ROG of the field's new value. In addition, since the reference was \Q!capsule!, the initialised/updated object could not already alias it, thus after the initialisation/update, the initilised/updated capsule field will not alias the object.
 
Rather than allowing the values of such fields to be shared between threads/actors, this new kind of \Q!capsule! field prevents representation exposure, as does the very similar concept of owner-as-modifier~\cite{?}, where we could consider an object to be the `owner' of all the mutable objects in the ROG of its capsule fields.

Note that these properties are \emph{weaker} than those of \Q!capsule! \emph{references}: we do not need to prevent arbitrary \Q!read! aliases to the ROG of a \Q!capsule! field, and we do allow \Q!mut! references to exist on the stack \IO{during the execution of a capsule mutator}. In particular, unrestricted readonly access to \Q!capsule! fields can be allowed by writing getters of the form \Q!read method read C f() { return this.f; }!. Such getters are already a fundamental part of the L42 language~\cite{?}. Since \Q!mut! is a subtype of \Q!read!, such a method can be called on a \Q!mut! \Q!this!, without making the method a capsule mutator.

\IOBlock{Move this paragraph somewhere!}{L42 also supports \Q!capsule method!s, which are not considered capsule mutators, since \Q!capsule! variables are unique references which can only be used once. Thus L42 guarantees that \Q!this! will not be reachable from anywhere else including the \Q!capsule! field itself, and so immediately after the single use of \Q!this! to read the \Q!capsule! field, \Q!this! will be garbage collectable.}

%\subheading{Capsule mutators}
%\IODel{In order to allow complex mutations of objects with invariants we, introduce the notion of \emph{capsule mutator}}. A \emph{capsule mutator} can perform an arbitrarily complex mutation of the ROG of a capsule field. We use TMs to ensure that the object containing the capsule field is not usable whilst the field's ROG is mutated, and its invariant is checked immediately afterwards. 
%Formally, \emph{capsule mutators} are \Q@mut@ methods whose body accesses a \Q@capsule@ field. 


%\end{itemize}
%Our type system will ensure that such methods are \Q!mut method!s, and the \Q!capsule! field will be seen as \Q!mut!.
%As \Q@capsule@ mutators use \Q!this! only once, and have no \Q!read! or \Q!mut! parameters, \Q!this! will not be accessible during execution, this is important as mutating the ROG of the \Q@capsule@ field may violate the invariant of \Q!this!.  Preventing \Q!mut! return types ensures that such methods cannot \REV{leak out a mutable alias to the \Q!capsule! field}{D}{why would it otherwise be possible ... Even doing this locally violates the soundness semantics for every reference immutability system I've see}, which could then be used to break the invariant.

%\footnote{This is sound provided \Q!this! can be used only once. This is already enforced by L42, since \Q!this! will be a \Q!capsule! variable, which L42 only allows to be used once.}. By the the properties of \Q!capsule!}

\subheading{Invariants}
We require that all classes contain a \Q@read method Bool invariant() {..}@, if no \Q!invariant! method is present, a trivial one returning \Q!true! will be assumed. As this method only takes a \Q!read! parameter (the receiver), we can be sure that it is pure \footnote{If the invariant were not pure, it would be nearly impossible to ensure that it would return \Q@true@ at any point.}, as discussed in Section \ref{s:purity}.
The bodies of \Q@invariant@ methods are limited in their usage of \Q@this@: \Q!this! can only occur as the receiver of a field access to an \Q!imm! or \Q!capsule! field. This restriction ensures that 
an invalid \Q@this@ cannot be passed around.
We prevent accessing \Q@mut@ fields since their ROG could be changed by unrelated code (see Section \ref{s:immutable}).
Note that we do not require such fields to be \Q@final@: when a field is updated, we simply check the invariant of the receiver of the update.

\subheading{Monitoring}
The language runtime will insert automatic calls to \Q!invariant!, if such a call returns \Q!false!, an unchecked exception will be thrown. Such calls are inserted in the following points:
\begin{itemize}
	\item After a constructor call, on the newly created object.
	\item After a field update, on the receiver.
	\item After a capsule mutator method returns, on the receiver of the method\footnote{The invariant is not checked if the call was terminated via an an unchecked exception, since strong exception safety guarantees the object will be unreachable anyway.}.
\end{itemize}

\noindent In Appendix \ref{s:proof}, we show that these checks, together with our aforementioned restrictions, are sufficient to ensure our guarantee that all objects involved in execution (except as part of an invariant check) are valid.

\subheading{Relaxations}
\IO{In L42, and our code examples, we allow a couple of sound relaxations:}
\begin{itemize}
	\item \Q!invariant! methods can \IODel{be allowed to} call instance methods that in turn only use \Q@this@ to read \Q!imm! or \Q!capsule! fields, or call other such instance methods.
	\IODel{With this relaxation, the semantics of \Q@invariant@ needs to be understood with the body of those methods inlined; thus the semantics of the inlined code needs to be logically}
	\IO{The semantics of such methods must then be} reinterpreted in the context of \Q@invariant@, where \Q@this@ may be invalid. \IODel{In some sense, those inlined methods and field accesses can be thought of as macro expanded, and hence are not dynamically dispatched.
	Such inlining has been implemented in L42.}
	
	\item \IODel{We could allow} All fields \IODel{to} \IO{can} be public, \IO{provided that} access to a \Q!capsule! field on a \Q!mut! receiver\IO{,} other than \Q!this!, \IO{is} typed as \Q!read!. \IO{However,} even without this relaxation\IODel{, however,} getters and setters could be used to simulate public fields.
	\item \IODel{\IOBlock{Moved!}{Unrestricted readonly access to \Q!capsule! fields \ldots}}
	\item \IODel{\IOBlock{Moved!}{Java style constructors\ldots}}
\end{itemize}

%\noindent\IO{L42 does not support traditional constructors or sub classing, however we could relax our restrictions to work with Pony and Gordon \etal's language which have these features:}
%\IO{Pony and Gordon \etal's language, unlike L42, supports traditional constructors and sub-classing. We were to be used in such languages, we could allow:}
If we were to extend L42 to support user written constructors or traditional sub-classing:
In our examples, we allow user written constructors, provided that \Q!this! is only used as the receiver of field initialisations. L42 itself does not support user-written constructors, instead one would just write a static factory method that behaves equivalently.

To apply our invariant protocol to a language with traditional sub-classing, such as Gordon\etal's, invariant methods of a sub-class would implicitly start with a check that \Q@super.invariant()@ returns \Q@true@. In addition, invariant methods of non-final classes should also be prevented from calling non-final methods on \Q!this!, so that a subclass can't override such a method to access non \Q!imm! or \Q!capsule! fields. Note that invariant checks would not be performed at the end of \Q@super(..)@ constructor calls, but only at the end of \Q@new@ expressions, as happens in~\cite{feldman2006jose}.

\IODel{Both L42, and our formal language (see Section~\ref{s:formalism}) do not have traditional subclassing, rather all `classes' are either interfaces (which only have abstract methods), or are final (which cannot be subtyped). In a language with traditional sub-classing, }

\IO{We do not allow the above relaxations in our formalism as they would make the proof more complicated, without making it more interesting.}