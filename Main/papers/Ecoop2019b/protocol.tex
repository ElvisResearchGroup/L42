%-----------------------------------------------------------
%define simple objects
%show solution  for simple person: requires 3 properties
%show solution is sound --> proof in appendix
%naive is unsound - person 3 bugs
\section{Our Invariant Protocol}
\label{s:protocol}
Our invariant protocol guarantees that the whole ROG of any object involved in execution (formally, in a redex) is \emph{valid}: if you can call methods on an object, calling \Q@invariant@ on it is guaranteed to return \Q@true@ in a finite number of steps. However, calls to \Q!invariant! that are generated by our runtime monitoring (see below) can access the fields of a potentially invalid \Q!this!. This is necessary to allow for the \Q!invariant! method to do its job: namely distinguish between valid and invalid objects. However, as for calls to any other method, calls to \Q!invariant! written explicitly by users are guaranteed to have a valid receiver. 

% However, the \Q!invariant! method itself needs to be able to operate on a potentially invalid \Q!this!, this will only happen when it is automatically called by the language itself, not by explicit calls present in the source code.
% Clearly the \Q@invariant@ method must be able to take an invalid \Q@this@, since the purpose of such method is to distinguish valid and invalid objects. On a first look this may seem an open contradiction
% with the aim of this work, however only calls to \Q@invariant@ inserted by the language semantics can take an invalid \Q@this@. As for any other method, when the application code can call \Q@invariant@, \Q@this@ is guaranteed to be valid.
%

%Logically, there are two reasons to access a field: we may wish to read the information stored in such object or we wish to mutate the object contained in the field.
%For the first case, we can type the field access as \Q@read@, but in the second case we
%need to type it as \Q@mut@. 
%We call `capsule mutators' a method accessing as \Q@mut@ a capsule field referenced in the invariant.
%We will show how capsule mutators are analogous of the pack/unpack/expose~\cite{???}.
%In order for a class to have an invariant under our protocol,
%\Q@invariant@ method the form 
% Can  a program write say mut method invariant or is it syntactically [???]
For simplicity, in the following explanation and in our formalism
we require 
%the \Q@this@ receiver is 
receivers to always be specified explicitly, and require that the receivers of field accesses and updates are always \Q!this!; that is, all fields are instance private.
We also do not allow explicit constructor definitions, instead we assume constructors are of the standard form \Q@$C$($T_1 x_1$,$\ldots$,$T_n x_n$) {this.$f_1$=$x_1$;$\ldots$;this.$f_n$=$x_n$;}@, where the fields of $C$ are $T_1 f_1;\ldots; T_n f_n;$. This ensures that partially uninitialised (and likely invalid) objects are not passed around or used. 
These restrictions only apply to our formalism; our code examples and the L42 implementation soundly relax these, see below for a discussion.% of why this is sound.
%We will later explain how these and other restrictions can be partially relaxed, as in the code examples.

\subheading{Invariants}
We require that all classes contain a \Q@read method Bool invariant() {..}@, if no \Q!invariant! method is present, a trivial one returning \Q!true! will be assumed. As this method only takes a \Q!read! parameter (the receiver), we can be sure that it is pure \footnote{If the invariant were not pure, it would be nearly impossible to ensure that it would return \Q@true@ at any point.}, as discussed in Section \ref{s:purity}.
The bodies of \Q@invariant@ methods are limited in their usage of \Q@this@: \Q!this! can only occur \IODel{in the body} as the receiver of a field access to an \Q!imm! or \Q!capsule! field. This restriction ensures that 
an invalid \Q@this@ cannot be passed around.
We prevent accessing \Q@mut@ fields since their ROG could be changed by unrelated code (see Section \ref{s:immutable}).
Note that we do not require such fields to be \Q@final@: when a field is updated, we simply check the invariant of the receiver of the update.
% In order to prevent passing an invalid \Q@this@ to other methods.
%and unrelated code cannot break the invariant
%s of arbitrary objects,
%since a \Q!read! or \Q!mut! field could be modified through arbitrary aliases 
%(see Section \ref{s:immutable}). 

%To ensure that invariants cannot be broken by unrelated code (see Section \ref{s:immutable})  %
\subheading{\IO{Capsule Fields}}
\IO{In order to allow complex mutations of objects with invariants we, introduce a novel kind of \Q!capsule! field:
\begin{itemize}
	\item A \Q!capsule! field can only be initialised/updated with a \Q!capsule! expression.
	\item An access of a \Q!capsule! field returns a reference with the same modifier as the receiver: i.e. 
\MS{accessing a capsule field on a \Q!mut! receiver produces a \Q!mut!,
accessing on a \Q!read! receiver produces a \Q!read!, and
accessing on a \Q!capsule! receiver produces a \Q!capsule!}
	\item \MS{\Q@mut@ methods accessing a \Q!capsule! field} must satisfy the restrictions on capsule mutators (see below).
\end{itemize}}
\IOComm{Requirng a \Q!capsule! expression is stronger than what we need, a transition (or \Q!trn!) in Pony would be sufficient. Mention this? In particular when storing an object in a capsule field there cannot be external read aliases to its ROG, but one can freely create such aliases afterwards!}

\IO{These restrictions, \MS{cooperate with TMs to}  ensure that for any object $o$ and capsule field $f$, no non-immutable object outside the ROG of $o.f$ can have a \Q!mut! or \Q!capsule! field that references the ROG of $o.f$. We also prevent $o$ from being in the ROG of $o.f$. Finally, only \Q!mut! methods of $o$, and method's called be one, can have a \Q!mut! reference to the ROG of $o.f$.}

\IO{Rather than allowing such fields to be shared between threads/actors\footnote{\IO{Provided that there are no read to a mutable object in the fields ROG, it would be safe to send the result of a destructive read to another thread.}}, these properties prevent representation exposure: i.e., the ROG of a capsule field can only be (indirectly) mutated by a \Q!mut! method of its containing object.}

\IO{Note that these properties are \emph{weaker} than those of \Q!capsule! \emph{references}: we do not need to prevent arbitrary \Q!read! aliases to the ROG of a \Q!capsule! field, and allow \Q!mut! references to exist on the stack. In particular,} unrestricted readonly access to \Q!capsule! fields can be allowed by \IO{writing} \IODel{automatically generated} getters of the form \Q!read method read C f() { return this.f; }!. Such getters are already a fundamental part of the L42 language. \IOComm{Cite the Programming paper?} \IO{Since \Q!mut! is a subtype of \Q!read!, such a method can be called on a \Q!mut! this, which would not make the method be classed as a capsule mutator. }

\subheading{Capsule mutators}
\IODel{In order to allow complex mutations of objects with invariants we, introduce the notion of \emph{capsule mutator}}. A \emph{capsule mutator} can perform an arbitrarily complex mutation of the ROG of a capsule field. We use TMs to ensure that the object containing the capsule field is not usable whilst the field's ROG is mutated, and its invariant is checked immediately afterwards. 

Formally, \emph{capsule mutators} are \Q@mut@ methods whose body accesses a \Q@capsule@ field. 
Capsule mutators must use \Q@this@ exactly once in their body, since fields are instance private, such use will be to access the \Q!capsule! field.
%By construction, such use is the access of the \Q@capsule@ field.
Excluding the \Q!mut! receiver, such methods cannot have any \Q!mut! or \Q!read! parameters, their return type must not be \Q!mut!, and their \Q!throws! clause must be empty.%
\footnote{\REVm{
To allow capsule mutators to leak checked exceptions,
we would need to check the invariant
when such exceptions are leaked. However, this would make the runtime semantics of checked exceptions inconsistent with unchecked ones.}}
\REVt{C}{to me, it would make sense that the runtime semantics (in particular: the invariant checking semantics) of checked exceptions would be inconsistent with that of unchecked semantics.}.


%\end{itemize}
%Our type system will ensure that such methods are \Q!mut method!s, and the \Q!capsule! field will be seen as \Q!mut!.
As \Q@capsule@ mutators use \Q!this! only once,
and have no \Q!read! or \Q!mut! parameters,
\Q!this! will not be accessible during execution, this is important as mutating the ROG of the \Q@capsule@ field may violate the invariant of \Q!this!. Provided that the invariant is re-established before returning, no invariant failure will be thrown. Preventing \Q!mut! return types ensures that such methods cannot \REV{leak out a mutable alias to the \Q!capsule! field}{D}{why would it otherwise be possible ... Even doing this locally violates the soundness semantics for every reference immutability system I've see}, which could then be used to break the invariant.
L42 supports \Q!capsule method!s, which are not considered capsule mutators, since \Q!capsule! variables are unique references which can only be used once. Thus L42 guarantees that \Q!this! will not be reachable from anywhere else including the \Q!capsule! field itself, and so immediately after the single use of \Q!this! to read the \Q!capsule! field, \Q!this! will be garbage collectable.
%\footnote{This is sound provided \Q!this! can be used only once. This is already enforced by L42, since \Q!this! will be a \Q!capsule! variable, which L42 only allows to be used once.}. By the the properties of \Q!capsule!}

\subheading{Monitoring}
The language runtime will insert automatic calls to \Q!invariant!, if such a call returns \Q!false!, an unchecked exception will be thrown. Such calls are inserted in the following points:
\begin{itemize}
	\item After a constructor call, on the newly created object.
	\item After a field update, on the receiver.
	\item After a capsule mutator method returns, on the receiver of the method\footnote{The invariant is not checked if the call was terminated via an an unchecked exception, since strong exception safety guarantees the object will be unreachable anyway.}.
\end{itemize}

\noindent In Appendix \ref{s:proof}, we show that these checks, together with our aforementioned restrictions, are sufficient to ensure our guarantee that all objects involved in execution (except as part of an invariant check) are valid.

\subheading{Relaxations}
\IO{In L42, and our code examples, we allow a couple of sound relaxations.}
\begin{itemize}
	\item \IOBlock{Compact this!}{\Q!invariant! methods can be allowed to call instance methods that in turn only use \Q@this@ to read \Q!imm! or \Q!capsule!, or call other such instance methods. With this relaxation, the semantics of \Q@invariant@ needs to be understood with the body of those methods inlined; thus the semantics of the inlined code needs to be logically reinterpreted in the context of \Q@invariant@, where \Q@this@ may be invalid. In some sense, those inlined methods and field accesses can be thought of as macro expanded, and hence are not dynamically dispatched. \IODel{Such inlining has been implemented in L42.}}
	\item We could allow all fields to be public, \IO{provided that} access to a \Q!capsule! field on a \Q!mut! receiver other than \Q!this!, \IO{is} typed as \Q!read!. \IO{However,} even without this relaxation\IODel{, however,} getters and setters could be used to simulate public fields.
	\item \IODel{\IOBlock{Moved!}{Unrestricted readonly access to \Q!capsule! fields \ldots}}
	\item \IODel{\IOBlock{Moved!}{Java style constructors\ldots}}
\end{itemize}

\IO{L42 does not support constructors or traditional sub classing, however we could relax our restrictions to work with languages Pony, and Gordon \etal's that have these features:}
\begin{itemize}
	\item User written constructors, provided that \Q!this! is only used as the receiver of field initialisations. In L42 however, one would just write a static factory method that behaves equivalently.
	\item \IODel{Java style} \IO{User written} constructors could be allowed, provided that \Q!this! is only used as the receiver of field initialisations. \IODel{42 does not provide such constructors, but one can always} \IO{In L42, one would just} write a static factory method that behaves equivalently.
	\item \IO{Class inheritance would could be allowed, provided that} invariant methods \IO{of a sub class} \IODel{would} implicitly start with a check that \Q@super.invariant()@ returns \Q@true@. Note that invariant checks would not be performed at the end of \Q@super(..)@ constructor calls, but only at the end of \Q@new@ expressions, as happens in~\cite{feldman2006jose}. \IO{In addition, } invariant method\IO{s of non-final classes} should also be prevented from calling non-final methods on \Q!this!, so that a subclass can't override such a method to access non \Q!imm! or \Q!capsule! fields. 
\end{itemize}
\IODel{Both L42, and our formal language (see Section~\ref{s:formalism}) do not have traditional subclassing, rather all `classes' are either interfaces (which only have abstract methods), or are final (which cannot be subtyped). In a language with traditional sub-classing, }

\IO{We do not allow the above relaxations in our formalism as they would make the proof more complicated, without making it more interesting.}
