%-----------------------------------------------------------
%define simple objects
%show solution  for simple person: requires 3 properties
%show solution is sound --> proof in appendix
%naive is unsound - person 3 bugs
\section{Our Invariant Protocol}
\label{s:protocol}
Our invariant protocol guarantees that the whole ROG of any object involved in execution (formally, in a redex) is \emph{valid}: if you can call methods on an object, calling \Q@invariant@ on it is guaranteed to return \Q@true@ in a finite number of steps. However, calls to \Q!invariant! that are generated by our runtime monitoring (see below) can access the fields of a potentially invalid \Q!this!. This is necessary to allow for the \Q!invariant! method to do its job: namely distinguish between valid and invalid objects. However, as for calls to any other method, calls to \Q!invariant! written explicitly by users are guaranteed to have a valid receiver. 

% However, the \Q!invariant! method itself needs to be able to operate on a potentially invalid \Q!this!, this will only happen when it is automatically called by the language itself, not by explicit calls present in the source code.
% Clearly the \Q@invariant@ method must be able to take an invalid \Q@this@, since the purpose of such method is to distinguish valid and invalid objects. On a first look this may seem an open contradiction
% with the aim of this work, however only calls to \Q@invariant@ inserted by the language semantics can take an invalid \Q@this@. As for any other method, when the application code can call \Q@invariant@, \Q@this@ is guaranteed to be valid.
%

%Logically, there are two reasons to access a field: we may wish to read the information stored in such object or we wish to mutate the object contained in the field.
%For the first case, we can type the field access as \Q@read@, but in the second case we
%need to type it as \Q@mut@. 
%We call `capsule mutators' a method accessing as \Q@mut@ a capsule field referenced in the invariant.
%We will show how capsule mutators are analogous of the pack/unpack/expose~\cite{???}.
%In order for a class to have an invariant under our protocol,
%\Q@invariant@ method the form 
% Can  a program write say mut method invariant or is it syntactically [???]
For simplicity, in the following explanation and in our formalism
we require 
%the \Q@this@ receiver is 
receivers to always be specified explicitly, and require that the receivers of field accesses and updates are always \Q!this!; that is, all fields are instance private.
We also do not allow explicit constructor definitions, instead we assume constructors are of the standard form \Q@$C$($T_1 x_1$,$\ldots$,$T_n x_n$) {this.$f_1$=$x_1$;$\ldots$;this.$f_n$=$x_n$;}@, where the fields of $C$ are $T_1 f_1;\ldots; T_n f_n;$. This ensures that partially uninitialised (and likely invalid) objects are not passed around or used. 
These restrictions only apply to our formalism; our code examples and the L42 implementation soundly relax these, see below for a discussion.% of why this is sound.
%We will later explain how these and other restrictions can be partially relaxed, as in the code examples.

% In order to prevent passing an invalid \Q@this@ to other methods.
%and unrelated code cannot break the invariant
%s of arbitrary objects,
%since a \Q!read! or \Q!mut! field could be modified through arbitrary aliases 
%(see Section \ref{s:immutable}). 

%To ensure that invariants cannot be broken by unrelated code (see Section \ref{s:immutable})  %
\subheading{Capsule Fields}
%L42 \Q@capsule@ fields are designed around syntactic restrictions over mutable fields~\cite{??}.
	%	THEY ARE NOT SYNTACTIC
%They can be initialized and updated only with 
%\Q@capsule@ references, but they can be accessed in
%controlled ways.
%L42 \Q@capsule@ access restriction are designed to be extensible; 
%here we add a new kind of \Q@capsule@ field
%access restriction designed to prevent representation exposure
%and to be allowed within invariants.
To allow invariants over complex (cyclic) mutable objects, we introduce a novel kind of \Q!capsule! field\footnote{
Our L42 implementation for our invariant protocol supports these fields by enforcing syntactic
restrictions over constructors, getters, setters, and capsule mutators.}, which can be accessed within invariants.
%To ensure that an object has control over the mutation of its capsule fields
To be able to easily detect when an objects invariant could be violated, we define the following rules on \Q!capsule! fields:
%Because the mutation of the ROG of objects capsule field could violate its invariant, we ensure that an object has control over such mutation of its capsule fields: this is preserved by the our rules on \Q!capsule! fields:
\SSI\begin{itemize}
	\item A \Q!capsule! field can only be initialised/updated with a \Q!capsule! expression.
	\item Access to a \Q!capsule! field on a \Q@mut@ receiver will return a \Q!mut!. Since fields are instance private, this access will be on \Q!this! and within a \Q!mut! method. We call such methods \emph{capsule mutators}, they must:
	\begin{itemize}
		\item use \Q!this! exactly once in their body, namely to access the capsule field,
		\item have no \Q!mut! or \Q!read! parameters (excluding the \Q!mut! receiver),
		\item not have a \Q!mut! return type, and
		\item be declared as not throwing any checked exception\footnote{To allow capsule mutators to leak checked exceptions, we would need to check the invariant when such exceptions are leaked. However, this would make the runtime semantics of checked exceptions inconsistent with unchecked ones.}.
	\end{itemize}	
	%The restrictions on \emph{capsule mutators} ensure that a \Q!mut!/\Q!capsule! reference to the ROG of the capsule field is not returned, stored in the ROG of a parameter, or in any other field of the method's receiver. We also ensure that no reference.
	\item Any other \Q!capsule! field access behaves like a \Q!mut! field access: if the receiver is \Q!imm!, the field access will return \Q!imm!, if the receiver is \Q!read!, it will return \Q!read!, if the receiver is \Q!capsule!, it will return \Q!mut!, which is then immediately promotable to \Q!capsule!. % On the other hand, a \Q!capsule! reference may be freely used to gain mutable alias to one of its capsule fields, since the receiver is \Q!capsule!, it cannot be referenced anywhere else.
	
\end{itemize}
%\IO{These restrictions ensure that an object has control over the mutation of its capsule fields.}

\noindent These restrictions ensure that for all objects $o$, and capsule field's $f$ of that object\footnote{See Appendix~\ref{s:proof} for a proof of these properties.}:
\SSI\begin{itemize}
	\item $o$ is not in the ROG of $o.f$.
%		\item $o.f$ must have been initialised/updated with a \Q!capsule! expression, which couldn't alias $o$, since $o$ was used in the same expressions as the new value of $o.f$.
%		\item an alias to $o$ cannot be used inside capsule mutators (see below), such an alias could not be stored in the ROG of $o.f$.
%\item Only a capsule mutator can see $o.f$ as \Q!mut!; this means that the only way to mutate the ROG of $o.f$ is through a capsule mutator on $o$.
\item 
When we are not executing a capsule mutator on $o$ that reads $f$, no object in the ROG of $o.f$ can be seen as \Q!mut! or \Q!capsule!, using any sequence of field accesses on a local variable.
%no object in the ROG of $o.f$ can be reached (using field access expression) from a local variable as \Q!mut! or \Q!capsule!.
%x.b = o.f;
%x is not a reference to the ROG of o.f.
%T is the only \Q@mut@ reference 
%every path of \Q!mut!/\Q!capsule! fields, starting from a \Q!mut!/\Q!capsule! reference, refers to the ROG of $o.f$, then it must pass through $o$. 
Since only a capsule mutator can see $o.f$ as \Q!mut!, this means that the only way to mutate the ROG of $o.f$ is through a capsule mutator on $o$.
%
%If we are not executing a capsule mutator on $o$ that reads $f$, 
%\IO{if a path of \Q!mut!/\Q!capsule! fields, starting from a \Q!mut!/\Q!capsule! reference, refers to the ROG of $o.f$, then it must pass through $o$. Since only a capsule mutator can see $o.f$ as \Q!mut!, this means that the only way to mutate the ROG of $o.f$ is through a capsule mutator on $o$.}
%	the ROG of $o.f$ is only mutable thanks to $o$, i.e. deleting $o$ will prevent the ROG of $o.f$ from ever being mutated again.
%		\item Capsule mutators preserve this property since they cannot return a \Q!mut!, they have no \Q!mut! parameters to which they could store such an alias in, and they cannot store such an alias somewhere else in the ROG of $o$, since $o$ is not usable within the capsule mutator (see below).
	\item If execution is (indirectly) in such a capsule mutator, then $o$ is only used as the receiver of the \Q!this.f! expression in the capsule mutator. %used at most once, which will be to access $f$. 

% This holds since $o$ cannot alias $o.f$, \Q!this! is used only once (to access $f$), and none of the methods parameters can alias $this$ (since only \Q!imm!/\Q!capsule! parameters are allowed, and \Q!this! is \Q!mut!, our TM system guarantees the former does not alias the latter).
\end{itemize} 
Thus we can be sure that the ROG of $o.f$ will only mutate within a capsule mutator, and only after the single use of $o$ to access $o.f$; such mutation could invalidate the invariant of $o$, so we simply check it at the end of the method before $o$ can be used again. Provided that the invariant is re-established before returning, no invariant failure will be thrown, even if the invariant was broken \emph{during} the method call.

%As the expression is \Q!capsule!, we can be sure that the object being initialised/updated will have the only external alias to the ROG of the field's new value. In addition, since the reference was \Q!capsule!, the initialised/updated object could not already alias it, thus after the initialisation/update, the initilised/updated capsule field will not alias the object.
 
Rather than allowing the values of such fields to be shared between threads/actors, this new kind of \Q!capsule! field prevents representation exposure, as does the very similar concept of owner-as-modifier~\cite{Dietl05universes:lightweight,10.1007/978-3-540-92188-2_4}, where we could consider an object to be the `owner' of all the mutable objects in the ROG of its capsule fields. \IO{In particular, our new kind of capsule field is designed specifically to be used in invariants; for other uses, one should consider using normal \Q!mut! fields or another kind of capsule field, such as those designed for safe parallelism~\cite{GordonEtAl12,clebsch2015deny,GIANNINI2019145}.}

Note that these properties are \emph{weaker} than those of \Q!capsule! \emph{references}: we do not need to prevent arbitrary \Q!read! aliases to the ROG of a \Q!capsule! field, and we do allow arbitrary \Q!mut! aliases  to exist during the execution of a capsule mutator. In particular, unrestricted readonly access to \Q!capsule! fields can be allowed by writing getters of the form \Q!read method read C f() { return this.f; }!. Such getters are already a fundamental part of the L42 language~\cite{DBLP:journals/programming/AroraSO19}. Since \Q!mut! is a subtype of \Q!read!, such a method can be called on a \Q!mut! \Q!this!, without making the method a capsule mutator.

L42 also supports \Q!capsule! methods\IODel{;}\IO{:} methods with a \Q@capsule@ \Q@this@. They are not considered capsule mutators since \Q!capsule! variables can only be used once. This means that L42 guarantees that \Q!this! will not be reachable from anywhere else including the \Q!capsule! field itself; thus immediately after the single use of \Q!this! to read the \Q!capsule! field, \Q!this! will be garbage collectable.

%\subheading{Capsule mutators}
%\IODel{In order to allow complex mutations of objects with invariants we, introduce the notion of \emph{capsule mutator}}. A \emph{capsule mutator} can perform an arbitrarily complex mutation of the ROG of a capsule field. We use TMs to ensure that the object containing the capsule field is not usable whilst the field's ROG is mutated, and its invariant is checked immediately afterwards. 
%Formally, \emph{capsule mutators} are \Q@mut@ methods whose body accesses a \Q@capsule@ field. 


%\end{itemize}
%Our type system will ensure that such methods are \Q!mut method!s, and the \Q!capsule! field will be seen as \Q!mut!.
%As \Q@capsule@ mutators use \Q!this! only once, and have no \Q!read! or \Q!mut! parameters, \Q!this! will not be accessible during execution, this is important as mutating the ROG of the \Q@capsule@ field may violate the invariant of \Q!this!.  Preventing \Q!mut! return types ensures that such methods cannot \REV{leak out a mutable alias to the \Q!capsule! field}{D}{why would it otherwise be possible ... Even doing this locally violates the soundness semantics for every reference immutability system I've see}, which could then be used to break the invariant.

%\footnote{This is sound provided \Q!this! can be used only once. This is already enforced by L42, since \Q!this! will be a \Q!capsule! variable, which L42 only allows to be used once.}. By the the properties of \Q!capsule!}

\subheading{Invariants}
We require that all classes contain a \Q@read method Bool invariant() {..}@, if no \Q!invariant! method is present, a trivial one returning \Q!true! will be assumed. Since \Q@invariant@ only takes a \Q!read! parameter (the receiver), it is pure \footnote{If \Q@invariant@ were not pure, it would be nearly impossible to ensure that it would \MS{keep returning} \Q@true@.}, as discussed in Section \ref{s:purity}.
The bodies of \Q@invariant@ methods are limited in their usage of \Q@this@: \Q!this! can only occur as the receiver of a field access to an \Q!imm! or \Q!capsule! field. This restriction ensures that 
an invalid \Q@this@ cannot be passed around.
We prevent accessing \Q@mut@ fields since their ROG could be changed by unrelated code (see Section \ref{s:immutable}).
Note that we do not require such fields to be \Q@final@: when a field is updated, we simply check the invariant of the receiver of the update.

\subheading{Monitoring}
The language runtime will insert automatic calls to \Q!invariant!, if such a call returns \Q!false!, an unchecked exception will be thrown. Such calls are inserted in the following points:
\SSI\begin{itemize}
	\item After a constructor call, on the newly created object.
	\item After a field update, on the receiver.
	\item After a capsule mutator method returns, on the receiver of the method\footnote{The invariant is not checked if the call was terminated via an an unchecked exception, since strong exception safety guarantees the object will be unreachable anyway.}.
\end{itemize}
\noindent In Appendix \ref{s:proof}, we show that these checks, together with our aforementioned restrictions, are sufficient to ensure our guarantee that all objects involved in execution (except as part of an invariant check) are valid.

\subheading{Relaxations}
In L42, and our code examples, we allow a couple of sound relaxations:
\SSI\begin{itemize}
	\item \Q!invariant! methods can call instance methods that in turn only use \Q@this@ to read \Q!imm! or \Q!capsule! fields, or call other such instance methods.
	The semantics of such methods must then be reinterpreted in the context of \Q@invariant@, where \Q@this@ may be invalid. 	
	\item All fields can be allowed to be public, provided that access to a \Q!capsule! field on a \Q!mut! receiver other than \Q!this! is typed as \Q!read!. However, even without this relaxation getters and setters could be used to simulate public fields.
\end{itemize}
%\noindent\IO{L42 does not support traditional constructors or sub classing, however we could relax our restrictions to work with Pony and Gordon \etal's language which have these features:}
%\IO{Pony and Gordon \etal's language, unlike L42, supports traditional constructors and sub-classing. We were to be used in such languages, we could allow:}
\noindent If we were to extend L42 to support user written constructors or traditional sub-classing:
In our examples, we allow user written constructors, provided that \Q!this! is only used as the receiver of field initialisations. L42 itself does not support user-written constructors, instead one would just write a static factory method that behaves equivalently.

To apply our invariant protocol to a language with traditional sub-classing, such as Gordon\etal's, invariant methods of a sub-class would implicitly start with a check that \Q@super.invariant()@ returns \Q@true@. In addition, invariant methods of non-final classes should also be prevented from calling non-final methods on \Q!this!, so that a subclass can't override such a method to access non \Q!imm! or \Q!capsule! fields. Note that invariant checks would not be performed at the end of \Q@super(..)@ constructor calls, but only at the end of \Q@new@ expressions, as happens in~\cite{feldman2006jose}.

We do not allow the above relaxations in our formalism as they would make the proof more complicated, without making it more interesting.