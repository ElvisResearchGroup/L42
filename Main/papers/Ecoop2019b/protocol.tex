%-----------------------------------------------------------
%define simple objects
%show solution  for simple person: requires 3 properties
%show solution is sound --> proof in appendix
%naive is unsound - person 3 bugs
\saveSpace
\section{Our Invariant Protocol}
\label{s:protocol}
\saveSpace
\IODel{In this section we will formalize our approach over a core language, and we formally state our soundness property (proved in the Appendix).
In the next section, by examples, we will show that all our restrictions and
requirements are actually needed, and that just violating any one of them would cause our system to be unsound.}

Our invariant protocol guarantees that the whole ROG of any object involved in execution (formally, in a redex) is \emph{valid}:\IODel{if you can call methods on an object,} calling \Q@invariant@ on it is guaranteed to return \Q@true@ in a finite number of steps. However, calls to \Q!invariant! that are generated by our runtime monitoring (see below) can access the fields of a potentially-invalid \Q!this!. This is necessary to allow for the \Q!invariant! method to do its job: namely distinguish between valid and invalid objects. However, as for any other method, calls to \Q!invariant! written explicitly by users are guaranteed to have a valid receiver. 

% However, the \Q!invariant! method itself needs to be able to operate on a potentially invalid \Q!this!, this will only happen when it is automatically called by the language itself, not by explicit calls present in the source code.
%\IODel{Clearly the \Q@invariant@ method must be able to take an invalid \Q@this@, since the purpose of such method is to distinguish valid and invalid objects. On a first look this may seem an open contradiction
% with the aim of this work, however only calls to \Q@invariant@ inserted by the language semantics can take an invalid \Q@this@. As for any other method, when the application code can call \Q@invariant@, \Q@this@ is guaranteed to be valid.
%\IODel{Also the bodies of constructors may interact with an invalid \Q@this@; we restrict their shape so that neither invariant methods nor constructors can observe the invalid object directly, but only its fields. }

%Logically, there are two reasons to access a field: we may wish to read the information stored in such object or we wish to mutate the object contained in the field.
%For the first case, we can type the field access as \Q@read@, but in the second case we
%need to type it as \Q@mut@. 
%We call `capsule mutators' a method accessing as \Q@mut@ a capsule field referenced in the invariant.
%We will show how capsule mutators are analogous of the pack/unpack/expose~\cite{???}.
%In order for a class to have an invariant under our protocol,
%\IODel{its }\Q@invariant@ method the form 
% Can  a program write say mut method invariant or is it syntactically [???]

We require that all classes contain a \Q@read method Bool invariant() {..}@, if no \Q!invariant! method is present, a trivial one returning \Q!true! will be assumed. As this method only takes a \Q!read! parameter (the receiver), we can be sure that it is pure \footnote{If the invariant were not pure, it would be nearly impossible to ensure that it would return \Q@true@ at any point.} (see Section \ref{s:purity}).\IOComm{Note about only leaking unchecked exceptions?}

We require that \Q@invariant@ methods only use \Q@this@ to read \Q@imm@ and \Q@capsule@ fields. This restriction ensures that unrelated code cannot break the invariants of arbitrary objects, since a \Q!read! or \Q!mut! field could be modified through arbitrary aliases (see Section \ref{s:immutable}). 
%To ensure that invariants cannot be broken by unrelated code (see Section \ref{s:immutable})  %\IODel{Access \Q@mut@ fields is forbidden because their ROG can be changed by unrelated code. In order to prevent passing an invalid \Q@this@ to other methods.}

In order to ensure that a broken object is not visible whilst mutating one of their capsule fields (see Section \ref{s:encapsulated}), 

A method that directly reads a \Q!capsule! field of a \Q!mut! receiver is said to be a \emph{capsule mutator}, unless the field is not read in the \Q!invariant! method of the enclosing class. We place the following static restrictions on capsule mutators:
\begin{itemize}
	\item the receiver of the \Q!capsule! field access must be \Q!this!,
	\item they must have no other (implicit) occurrences of \Q!this!,
	\item they cannot have any \Q!mut! or \Q!read! parameters (excluding the receiver), and
	\item they must not have a \Q!mut! return type.
	\item the method must not be declared to throw any checked exceptions\footnote{If we did allow this, we would have to inject invariant checks whenever checked-exceptions are thrown from such methods. However, this would make the runtime semantics of checked exceptions inconsistent with unchecked ones.},
\end{itemize}
Our type system will ensure that such methods are \Q!mut method!s, and the \Q!capsule! field will be seen as \Q!mut!. These restrictions allow \Q!capsule! fields to be freely mutated, potentially breaking the \Q!invariant! of the containing object, however as we cannot use \Q!this! and have no \Q!read! or \Q!mut! parameters, we can be sure that such broken object is not accessible during the execution. Preventing \Q!mut! return types ensures that the method cannot leak out a mutable alias to the \Q!capsule! field. Note that these restrictions do not apply when the receiver of the field access is \Q!capsule!, since we guarantee that the receiver is not in the ROG of such a field, and hence can never bee seen afterwards.
%\IOComm{mention these don't apply to \Q!capsule! recievers..}
%\IODel{\noindent Also note that \Q@invariant@ is declared as not throwing any exceptions, thus only unchecked exceptions can be propagated out.}

We do not allow explicit constructor definitions, rather we treat them as having the form \Q@$C$($T_1 x_1$,$\ldots$,$T_n x_n$) {this.$f_1$=$x_1$;$\ldots$;this.$f_n$=$x_n$;}@, where the fields of $C$ are $f_1,\ldots,f_n$ and have types $T_1,\ldots,T_n$. This ensures that partial-uninitialised (and likely invalid) objects are not passed around or used.

\subheading{Monitoring}
The language runtime will insert automatic calls to \Q!invariant!, if such a call returns \Q!false!, an unchecked-exception will be thrown. Such calls are inserted in the following points:
\begin{itemize}
	\item After a constructor call, on the newly created object.
	\item After a field update, on the receiver.
	\item After a capsule mutator method returns, on the receiver of the method\footnote{The invariant is not checked if the call was terminated via an an unchecked exception, since strong exception safety guarantees the object will be unreachable anyway.}.
\end{itemize}
In Appendix \ref{s:proof}, we show that these checks, together with our aforementioned restrictions, are sufficient to ensure our guarantee that all objects involved in execution (except as part of an invariant check) are valid.

\subheading{Relaxations}
The above restrictions can be partially relaxed without breaking soundness, however this would not make the proof more interesting. In particular:
\begin{itemize}
	\item \Q!invariant! methods can be allowed to call instance methods that in turn only use \Q@this@ to read \Q!imm! or \Q!capsule!, or call other such instance methods. With this relaxation, the semantics of \Q@invariant@ needs to be understood with the body of those methods inlined; thus the semantic of the inlined code needs to be logically reinterpreted in the context of \Q@invariant@, where \Q@this@ may be invalid. In some sense, those inlined methods and field accesses can be thought of as macro expanded, and hence are not dynamically dispatched. Such inlining has been implemented in L42.

	\item Unrestricted readonly access to \Q!capsule! fields can be allowed by automatically generate getters of the form \Q!read method read C f() { return this.f; }!. Such getters are already a fundamental part of the L42 language.
	
	\item Java style constructors could be allowed, provided that \Q!this! is only (implicitly) used as the receiver of field initialisations. L42 does not provide such constructors, but one can always write a static factory method that behaves equivalently.
\end{itemize}
\IOComm{Put the following paragraph somewhere else? Perhaps future work?}
Both L42, and our formal language (see Section~\ref{s:formalism}) do not have traditional subclassing, rather all `classes' are either interfaces (which only have abstract methods), or are final (which cannot be subtyped). In a language with subclassing, invariant methods would implicitly start with a check that \Q@super.invariant()@ returns \Q@true@. Note that invariant checks would not be performed at the end of \Q@super(..)@ constructor calls, but only at the end of \Q@new@ expressions, as happens in~\cite{feldman2006jose}.

