%-----------------------------------------------------------
%define simple objects
%show solution  for simple person: requires 3 properties
%show solution is sound --> proof in appendix
%naive is unsound - person 3 bugs
\saveSpace
\section{Our Invariant Protocol}
\label{s:protocol}
\saveSpace
\IODel{In this section we will formalize our approach over a core language, and we formally state our soundness property (proved in the Appendix).
In the next section, by examples, we will show that all our restrictions and
requirements are actually needed, and that just violating any one of them would cause our system to be unsound.}

Our invariant protocol guarantees that the whole ROG of any object involved in execution (formally, in a redex) is \emph{valid}: if you can call methods on an object, calling \Q@invariant@ on it is guaranteed to return \Q@true@ in a finite number of steps. However, the \Q!invariant! method itself needs to be able to operate on a potentially invalid \Q!this!, this will only happen when it is automatically called by the language itself, not by explicit calls present in the source code.

\IODel{Clearly the \Q@invariant@ method must be able to take an invalid \Q@this@, since the purpose of such method is to distinguish valid and invalid objects.
On a first look this may seem an open contradiction
 with the aim of this work, however only calls to \Q@invariant@ inserted by the language semantics can take an invalid \Q@this@. As for any other method, when the application code can call \Q@invariant@, \Q@this@ is guaranteed to be valid.
Also the bodies of constructors may interact with an invalid \Q@this@; we restrict their shape so that neither invariant methods nor constructors can observe the invalid object directly, but only its fields. }

%Logically, there are two reasons to access a field: we may wish to read the information stored in such object or we wish to mutate the object contained in the field.
%For the first case, we can type the field access as \Q@read@, but in the second case we
%need to type it as \Q@mut@. 
%We call `capsule mutators' a method accessing as \Q@mut@ a capsule field referenced in the invariant.
%We will show how capsule mutators are analogous of the pack/unpack/expose~\cite{???}.
%In order for a class to have an invariant under our protocol,
%\IODel{its }\Q@invariant@ method the form 
% Can  a program write say mut method invariant or is it syntactically [???]

We require that all classes contain a \Q@read method Bool invariant() {..}@, if no \Q!invariant! method is present, a trivial one returning \Q!true! will be assumed. As this method only takes a \Q!read! parameter (the receiver), we can be sure that it is pure \footnote{If the invariant were not pure, it would be nearly impossible to ensure that it would return \Q@true@ at any point.} (see Section \ref{s:purity}).

To ensure that invariants cannot be broken by unrelated code (see Section \ref{s:immutable}) we require that \Q@invariant@ methods only use \Q@this@ to read \Q@imm@ and \Q@capsule@ fields.
\IODel{Access \Q@mut@ fields is forbidden because their ROG can be changed by unrelated code. In order to prevent passing an invalid \Q@this@ to other methods.}

In order to ensure that a broken object is not visible whilst mutating one of their capsule fields (see Section \ref{s:encapsulated}), we place restrictions on any method (directly) reading a \Q!capsule! field of a \Q!mut! object, we call such methods \emph{capsule mutators}. Such methods must:
\begin{itemize}
\item access the \Q!capsule! field as \Q!this.f!,\footnote{Thus capsule fields are instance private}
\item have no other occurrences of \Q!this!,
\item not take any \Q!mut! or \Q!read! parameters (excluding the receiver), and
\item not have a \Q!mut! return type.
\end{itemize}
\IOComm{mention these don't apply to \Q!capsule! recievers..}
\IODel{\noindent Also note that \Q@invariant@ is declared as not throwing any exceptions, thus only unchecked exceptions can be propagated out.}
%
Rather than requiring uninitialised objects to satisfy their invariants, we instead require that objects be fully initialised before use. We ensure this by preventing explicit constructor definitions, and instead assume they have the form \Q@$C$($T_1 x_1$,$\ldots$,$T_n x_n$) {this.$f_1$=$x_1$;$\ldots$;this.$f_n$=$x_n$;}@, where $T_1, \ldots, T_n$ are the types (including modifiers) of $C$.

\subheading{Monitoring}
The language runtime will inject calls to \Q!invariant! 

\subheading{Relaxations}
The above restrictions seem quite severe, however they are simple and make the proof simpler, without making it less intresting. Several relaxations and extensions can be


