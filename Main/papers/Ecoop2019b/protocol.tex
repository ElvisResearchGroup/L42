%-----------------------------------------------------------
%define simple objects
%show solution  for simple person: requires 3 properties
%show solution is sound --> proof in appendix
%naive is unsound - person 3 bugs
\saveSpace
\section{Our Invariant Protocol}
\label{s:protocol}
\saveSpace
\IODel{In this section we will formalize our approach over a core language, and we formally state our soundness property (proved in the Appendix).
In the next section, by examples, we will show that all our restrictions and
requirements are actually needed, and that just violating any one of them would cause our system to be unsound.}

Our invariant protocol guarantees that the whole ROG of any object involved in execution (formally, in a redex) is \emph{valid}: if you can call methods on an object, calling \Q@invariant@ on it is guaranteed to return \Q@true@ in a finite number of steps. However, the \Q!invariant! method itself needs to be able to operate on a potentially invalid \Q!this! (or else our guarantee would be circular), this will only happen when it is automatically called be the language itself, not by explicit calls present in the source code.

\IODel{Clearly the \Q@invariant@ method must be able to take an invalid \Q@this@, since the purpose of such method is to distinguish valid and invalid objects.
On a first look this may seem an open contradiction
 with the aim of this work, however only calls to \Q@invariant@ inserted by the language semantics can take an invalid \Q@this@. As for any other method, when the application code can call \Q@invariant@,}


\Q@this@ is guaranteed to be valid.
Also the bodies of constructors may interact with an invalid \Q@this@; we restrict their shape so that neither invariant methods nor constructors can observe the invalid object directly, but only its fields.



%Logically, there are two reasons to access a field: we may wish to read the information stored in such object or we wish to mutate the object contained in the field.
%For the first case, we can type the field access as \Q@read@, but in the second case we
%need to type it as \Q@mut@. 
%We call `capsule mutators' a method accessing as \Q@mut@ a capsule field referenced in the invariant.
%We will show how capsule mutators are analogous of the pack/unpack/expose~\cite{???}.
%In order for a class to have an invariant under our protocol,
%\IODel{its }\Q@invariant@ method the form 
% Can  a program write say mut method invariant or is it syntactically [???]
Our protocol enforces that all classes have a method of the form \Q@read method Bool invariant() {..}@. If an \Q@invariant@ method is not defined by the programmer, one that always returns \Q@true@ will be generated for them.

\noindent Also note that \Q@invariant@ is declared as not throwing any exceptions,
	thus only unchecked exceptions can be propagated out.



%----------------------------------
In order to model our system, we need to formalise an imperative object oriented language
with exceptions and object capabilities,  and rich type system
support for \Q@mut@, \Q@imm@, \Q@read@, \Q@capsule@, and strong exception safety.
Formal modelling the semantics of such a language is simple, but 
defining such rich type system and proving correctness of it would require a paper
of its own, and indeed many such papers exist in literature%
~\cite{ServettoEtAl13a,ServettoZucca15,GordonEtAl12,clebsch2015deny,JOT:issue_2011_01/article1}.
Thus we are going to assume that there is an expressive and sound type system enforcing
those properties, and instead focus on invariant checking.
To provide good modularisation for reasoning, in the Appendix
we clearly list the properties our proof (also in Appendix) need to rely upon, so that \emph{every} type
system supporting those properties can support our invariant protocol.

We strive to keep our small step semantics as conventional as possible; following Pierce~\cite{pierce2002types} and Featherweight Java~\cite{IgarashiEtAl01} we assume:
\begin{itemize}
\item An implicit program/class-table.
\item Memory $\sigma\Coloneqq l\mapsto C\{\Many{v}\}$ is a finite map from locations $l$ to annotated tuples $C\{\Many{v}\}$: representing objects,
where $C$ is the class name and $\Many{v}$ are the field values.
We use the notation $\sigma[l.f=v]$ to update an object's field and $\sigma[l.f]$ to access it.
\item A main expression that is reduced in the context of such memory and program.
\item A type system $\Sigma;\Gamma\vdash\e:T$, where 
the expression $\e$ can contain locations and free variables;
the type of locations is encoded in $\Sigma\Coloneqq l\mapsto C$,
while the types of free variables are encoded in $\Gamma\Coloneqq x\mapsto T$.
\item We use $\Sigma^\sigma$ to trivially extract the corresponding $\Sigma$ from $\sigma$.
\end{itemize}
In addition, to encode object capabilities and I/O, we assume a special location  $c$ of class \Q@Cap@. This location would refer to an object whose fields model thins like the content of input and output files. In order to simplify our proof, we additionally assume that:
\begin{itemize}
	\item instances of \Q@Cap@ cannot be created with a \Q@new@ expression,
	\item all methods of \Q@Cap@ must be \Q@mut@, and mutate the ROG of their receiver,
	\item \Q@Cap@ can only have \Q@mut@ fields, and
	\item \Q@Cap@'s \Q@invariant@ method is defined to return \Q@true@.
\end{itemize}
\noindent
To keep our formalization focused on
the challenges of invariant checking, 
we impose limitations on \Q@this@, fields and constructors:
%there are some
%tweaks with respect to our informal description of our approach.
%From a formal perspective 
%these changes do not change expressivity:
%In the formalism we require 
\begin{itemize}
\item The \Q@this@ receiver must always be specified explicitly.
\item All fields are instance private. Getters and setters could simulate public fields.
\item There are no explicit constructor definitions, rather all constructors are of the canonical form
\Q@$C$($T_1 x_1$,$\ldots$,$T_n x_n$) {this.$f_1$=$x_1$;$\ldots$;this.$f_n$=$x_n$;}@,
 where $T_1, \ldots, T_n$ are the types (including modifiers) of $C$.
This prevents objects from escaping their constructor partially initialised, and of course prevents explicitly calling \Q@invariant@ inside of \Q@invariants@ and constructors bodies, but most importantly, together with our other restrictions, it prevents \Q@this@, or an alias to \Q@this@, from being passed around to arbitrary code.
To provide more flexible initialisation one could always make a factory method.
\item We require \Q@invariant@ methods to only use \Q@this@ to 
access \Q@imm@ and \Q@capsule@ fields.
Access \Q@mut@ fields is forbidden because their ROG can be changed by unrelated code.
\end{itemize}
The concrete implementation in L42, as well as the code on our examples
soundly relaxes those requirements:
only \Q@capsule@ fields used in \Q@invariant@ need to be instance private and
constructors can perform arbitrary computation but
may only use \Q@this@ to initialise fields.


Finally, we require that \Q@invariant@
only uses \Q@this@ to access fields,
in order to prevent passing an invalid \Q@this@ to other methods.
In L42 we relax this restriction allowing calling instance methods that in turn only use \Q@this@ to access fields, or call other such instance methods. With this relaxation, the semantics of \Q@invariant@ needs to be understood with the body of those methods inlined; thus the semantic of the inlined code need to be logically reinterpreted in the context of \Q@invariant@, where \Q@this@ may be invalid.
In some sense, those inlined methods and field accesses can be thought of as macro expanded, and hence are not dynamically dispatched. 
%This does prevent the calling of recursive methods,
%allowing them would not cause problems with our protocol,
%but it does not increase expressivity.



Moreover, in the formalism for simplicity, we do not have actual exception objects, we just have a concept of \emph{errors} with no associated values.
In the L42 implementation we support \Q@imm@ objects as exception values. Adding them to our formalism would not cause any interesting variation of our proof.


\newcommand{\ctxG}{\myCalBig{G}}
\renewcommand{\vs}{\Many{v}}
\renewcommand{\Opt}[1]{#1?}
\begin{figure}
\!\!\!\!
\begin{grammatica}
\produzione{\e}{\x\mid l\mid\Kw{true}\mid\Kw{false}\mid \e\singleDot\m\oR\es\cR\mid \e\singleDot\f 
\mid\e\singleDot\f\equals\e 
\mid\Kw{new}\ C\oR\es\cR
\mid\Kw{try}\ \oC\e_1\cC\ \Kw{catch}\ \oC\e_2\cC
}{expression}\\
\seguitoProduzione{
\mid \Kw{M}\oR l;\e_1;\e_2\cR\mid\Kw{try}^{\sigma}\oC\e_1\cC\ \Kw{catch}\ \oC\e_2\cC
}{runtime expr.}\\
\produzione{v}{l}{value}\\
\produzione{\ctx_v}{\square
\mid \ctx_v\singleDot m\oR\es\cR
\mid v\singleDot\m\oR\Many{v}_1,\ctx_v,\es_2\cR
%\mid \ctx_v\singleDot\f 
%\mid \ctx_v\singleDot\f\equals\e
\mid v\singleDot\f\equals\ctx_v
}{evaluation context}\\
\seguitoProduzione{
\mid \Kw{new}\ C\oR\Many{v}_1,\ctx_v,\es_2\cR
\mid \Kw{M}\oR l;\ctx_v;\e\cR
\mid \Kw{M}\oR l;v;\ctx_v\cR
\mid \Kw{try}^\sigma\oC\ctx_v\cC\ \Kw{catch}\ \oC\e\cC}{}\\

\produzione{\ctx}{\square\mid\ctx\singleDot m\oR\es\cR\mid\e\singleDot\m\oR\es_1,\ctx,\es_2\cR
%\mid \ctx\singleDot\f 
%\mid \ctx\singleDot\f\equals\e
\mid \e\singleDot\f\equals\ctx
\mid \Kw{new}\ C\oR\es_1,\ctx,\es_2\cR
}{full context}\\
\seguitoProduzione{
\mid
\Kw{M}\oR l;\ctx;\e\cR\mid
\Kw{M}\oR l;\e;\ctx\cR\mid
\Kw{try}^{\sigma?}\oC\ctx\cC\ \Kw{catch}\ \oC\e\cC\mid
\Kw{try}^{\sigma?}\oC\e\cC\ \Kw{catch}\ \oC\ctx\cC

}{}\\


%\produzione{M_l}{\ctx[M\oR l,\e\cR]}{}\\
%\produzione{\ctxG_l}{
%  M_l\singleDot\m\oR\es_1,\ctx,\es_2\cR
% |\e\singleDot\m\oR\es_1, M_l, \es_2, \ctx, \es_3\cR
% |M_l\singleDot\f\equals\ctx
% |\Kw{new}\ C\oR\es_1,M_l,\es_2,\ctx,\es_3\cR
% |\Kw{try}\oC\ctx\cC\ \Kw{catch}\ \oC\e\cC
% |\ctx[\ctxG_l]}{}\\
\produzione{CD}{\Kw{class}\ C\ \Kw{implements}\ \Many{C}\oC\Many{F}\,\Many{M}\cC\mid 
\Kw{interface}\ C\ \Kw{implements}\ \Many{C}\oC\Many{M}\cC
}{class declaration}\\
\produzione{F}{\T\ \f;}{field}\\
\produzione{M}{\mdf\, \Kw{method}\, \T\ \m\oR\T_1\,\x_1,\ldots,\T_n\,\x_n\cR\ \Opt\e}{method}\\
\produzione{\mdf}{\Kw{mut}\mid\Kw{imm}\mid\Kw{capsule}\mid\Kw{read}}{type modifier}\\
\produzione{\T}{\mdf\,C}{type}\\
\produzione{r_l}{
 v\singleDot\m\oR\Many{v}\cR
\mid v\singleDot\f
\mid v_1\singleDot\f\equals v_2
\mid \Kw{new}\,C\oR\Many{v}\cR
,\quad\text{with }l\in \{v,v_1,v_2,\Many{v}\}
}{redex containing $l$}\\
\produzione{\mathit{error}}{
\ctx_v[\Kw{M}\oR l; v;\Kw{false}\cR]
,\quad\text{with }
\ctx_v \text{not of form}\ \ctx_v'[\Kw{try}^{\sigma?}\oC\ctx_v''\cC\ \Kw{catch}\ \oC\_\cC]
}{validation error}
\end{grammatica}
\caption{Grammar}
\end{figure}


\subheading{Grammar and Well Formedness Criteria}
The detailed grammar is defined in Figure 1.
The only non standard expression is the monitor. They are not present in the source code, but are inserted by our reduction rules. The object it monitors is the one referenced by $l$, $e_1$ is the expression which is being monitored, and $e_2$ denotes the evaluation of $l.invariant()$.
We annotate the monitor expression with $l$ to ensure
that if the invariant check fails, it is precisely $l$ that is invalid.
We use a failed monitor expression (i.e. when $\e_2$ is the value \Q@false@) to represent throwing unchecked exceptions.
In addition, our reduction rules annotate the body of \Q@try@ expressions with
the original state of memory. This is used to propagate the guarantees of strong exception safety,
that is, the annotated memory will not be mutated by executing the body of the \Q@try@.

 Our well formedness criteria cooperate with the simplified language grammar to enforce the restrictions mentioned before:
\begin{itemize}
\item Field accesses in method are of the form
\Q@this.@$f$, and of form $l\singleDot\f$ in the main expression.

\item \Q@invariant@ methods are of the form \Q@read@ \Q@method@ \Q@Bool@ \Q@invariant()@ \emph{e}.
The only occurrences of \Q@this@ in $e$ are as the receiver for field accesses.
\item All fields referred to in \Q@invariant@ are either \Q@imm@ or \Q@capsule@.
\item \Q@mut@ methods whose body accesses a \Q@capsule@ field mentioned in the invariant
are called \emph{capsule mutators}.\footnote{% 
While mutating the ROG of a \Q@capsule@ field mentioned in the invariant, the containing object may become invalid.
The restrictions over capsule mutators
enforce that such containing object is inaccessible.
}%
\footnote{%
The L42 language support checked exceptions, but offer
strong exception safety only for unchecked ones. In such context
we need to add the constraint that capsule mutators are declared to not throw any checked exception.
}%
\footnote{%
Note that such constraints do not apply on \Q@capsule@, \Q@read@ or   \Q@imm@ methods accessing such fields.
}
They must have no \Q@mut@ or \Q@read@ parameters, no \Q@mut@ result, and 
must use \Q@this@ exactly once in their body; such use will be 
accessing the \Q@capsule@ field.
%We could relax the restrictions for parameter and return types, since \Q@this@ is \Q@capsule@, it is a unique alias.
\item 
During reduction, locations that are preserved by a \Q@try@ block are
never monitored; formally 
for $\Kw{try}^\sigma\oC\e\cC\_$, $\e$ is not of the form $\ctx[$\Q@M(@$l;\_$\Q@)@$]$, for any $l\in\sigma$.
\end{itemize}

\newcommand{\rowSpace}{\\\vspace{2.5ex}}

\begin{figure}
\!\!
$\!\!\!\!\!\begin{array}{l}
 \inferrule[(update)]{{}_{}}{
\sigma|l.f\equals{}v\rightarrow \sigma[l.f=v]|
\Kw{M}\oR l;l;l\singleDot\Kw{invariant}\oR\cR\cR
 }{}
\quad
 \inferrule[(new)]{{}_{}}{
\sigma|\Kw{new}\ C\oR\vs\cR\rightarrow \sigma,l\mapsto C\{\vs\}|
\Kw{M}\oR l;l;l\singleDot\Kw{invariant}\oR\cR\cR
 }{}
\\
\rowSpace
 \inferrule[(mcall)]{{}_{}}{
\sigma|l\singleDot\m\oR v_1,\ldots,v_n\cR\rightarrow \sigma|
\e'[\Kw{this}=l,\x_1=v_1,\ldots,x_n=v_n]
 }{
  \begin{array}{l}
  \sigma(l)=C\{\_\}\\
  C.m=\mdf\,\Kw{method}\,\T\,\m\oR\T_1\,\x_1\ldots\T_n\x_n\cR\,\e\\

\text{if }\ \exists \f\text{ such that}\ \ C.f=\Kw{capsule}\,\_,
\mdf=\Kw{mut},
\\*\quad\f\, \text{inside}\, C\singleDot\m
\text{ and }
\f\,\text{inside}\, C\singleDot\Kw{invariant}

\\*
\text{then }\e'=\Kw{M}\oR l;\e;l\singleDot\Kw{invariant}\oR\cR\cR\\*
\text{otherwise }\ \e'= \e
  \end{array}
}
\rowSpace
 \inferrule[(monitor exit)]{{}_{}}{
\sigma|\Kw{M}\oR l; v;\Kw{true}\cR\rightarrow \sigma|v
 }{}
\quad

 \inferrule[(ctxv)]{\sigma_0|\e_0\rightarrow\sigma_1|\e_1}{
\sigma_0|\ctx_v[\e_0]\rightarrow \sigma_1|\ctx_v[\e_1]
 }{}

\quad
 \inferrule[(try enter)]{{}_{}}{
\sigma|\Kw{try}\ \oC \e_1\cC\ \Kw{catch}\ \oC\e_2\cC\rightarrow 
\sigma|\Kw{try}^\sigma\oC\e_1\cC\ \Kw{catch}\ \oC\e_2\cC
 }{}
\quad

\rowSpace

 \inferrule[(try ok)]{{}_{}}{
\sigma,\sigma'|\Kw{try}^{\sigma}\oC v\cC\ \Kw{catch}\ \oC\_\cC\rightarrow \sigma,\sigma'|v
 }{}
\quad

 \inferrule[(try error)]{{}_{}}{
\sigma,\_|\Kw{try}^\sigma\oC \mathit{error}\cC\ \Kw{catch}\ \oC\e\cC\rightarrow \sigma|\e
 }
\quad
 \inferrule[(access)]{{}_{}}{
\sigma|l.f\rightarrow \sigma|\sigma[l.f]
 }{}
%\quad
\end{array}$
\caption{Reduction rules}
\end{figure}

\loseSpace
\subheading{Reduction rules}
Reduction rules are defined in Figure 2.
These rules are pretty standard;
\textsc{mcall}
uses the auxiliary function \emph{inside},
formally defined as follows:

$%\begin{array}{l}
\f\, \textit{inside}\, C\singleDot\m\text{ iff }
C\singleDot\m=\_\,\Kw{method}\_\,\ctx[\Kw{this}\singleDot\f]
%\end{array}
$

%\noindent Inserting the monitor expressions during reduction is convenient for the proof,
%but it could instead be done ahead of time.

\noindent Monitors are added for all field updates and \Q@new@ expressions, and for all
method calls of capsule mutators.%
\footnote{%
There is no need to monitor \Q@capsule@ methods, since their receiver is a unique alias and hence can never be used again.
}
Monitor expressions are only a proof device, and an execution on a real hardware do not need to represent them. 
In L42 field updates are always performed throughout a setters,
thus we can just inject
calls to \Q@invariant@ on setters, at the end of constructor bodies and at the end of  capsule mutators.

The interaction with monitors, evaluation contexts and exceptions is interesting:
a monitor releases the value if the invariant check evaluates to \Q@true@, and produces an error if the 
check evaluates to \Q@false@.
If either monitor expressions $\e_1$ or $\e_2$ are not already values, the execution is propagated inside
by \textsc{ctxv}.
If either $\e_1$ or $\e_2$ evaluate to an error, such error is captured by 
\textsc{try error}.
Thanks to strong exception safety,
we do not need to worry
if the (partial) execution of $\e_1$ broke the object referenced by $l$.




\noindent In our formal model we model subtyping with interfaces 
and do not consider subclassing.
In particular interfaces do not have an implemented \Q@invariant@ method, only classes do.

L42 does not have \Q@extends@ so we have not handled inheriting invariants.
In a language with subclassing, invariant methods would implicitly start with a check that \Q@super.invariant()@ returns \Q@true@.
Note that invariant checks would not be performed at the end of \Q@super(..)@ constructor calls, but only at the end of \Q@new@ expressions, as happens in~\cite{feldman2006jose}.


\subheading{Statement of Soundness} We define
a deterministic reduction arrow, requiring exactly one reduction is possible:\\*
\indent$\ \sigma_0|e_0\Rightarrow \sigma_1|e_1$ iff $\{\sigma_1|\e_1\}=\{\sigma|\e \text{ where } \sigma_0|e_0\rightarrow \sigma|e\}$

\noindent An object is \emph{valid} iff calling its \Q@invariant@ method would
deterministically produce \Q@true@ in a finite number of steps, i.e. it does not evaluate to \Q@false@, fail to terminate, or produce an error.
We also require evaluating \Q@invariant@ to preserve existing memory ($\sigma$): but new objects ($\sigma'$) can be created and freely mutated.

\indent$valid(\sigma,l)$ iff $\sigma | l.invariant()\Rightarrow^+ \sigma,\sigma' | \text{\Q@true@}$.\loseSpace


\noindent 
To allow the invariant method to be called on an invalid object, and to allow its body to access the fields we define the set of trusted steps:
the call to \Q@invariant@ and the field accesses inside its evaluation.
Note that just the single small step reduction
of calling \Q@invariant@ is trusted, not the whole evaluation of the \Q@invariant@ expression.

\loseSpace
\noindent $\mathit{trusted}(\ctx_v,r_l)$ iff\\*
\indent either
$r_l=l.invariant()$ and
 $\ctx_v=\ctx_v'[$\Q@M(@$l$\Q@;@$v$\Q@;@$\square$\Q@)@$]$,\\*
\indent or
$r_l=l$\Q@.f@ and
 $\ctx_v=\ctx_v'[$\Q@M(@$l$\Q@;@$v$\Q@;@$\ctx_v''$\Q@)@$]$.
\loseSpace

\noindent Finally, we define what it means for a language to soundly enforce our invariant protocol: every object involved in any untrusted redex is valid.

\begin{theorem}[Soundness]
if $c:\Kw{Cap};\emptyset\vdash \e: \T$ and
$c\mapsto\Kw{Cap}\{\_\}|\e\rightarrow^+ \sigma|\ctx_v[r_l]$, then
either $valid(\sigma,l)$ or $\mathit{trusted}(\ctx_v,r_l)$.
\end{theorem}


%We believe this property captures very precisely our statements in section~\ref{s:protocol}.

