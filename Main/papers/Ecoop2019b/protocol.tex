%-----------------------------------------------------------
%define simple objects
%show solution  for simple person: requires 3 properties
%show solution is sound --> proof in appendix
%naive is unsound - person 3 bugs
\section{Our Invariant Protocol}
\label{s:protocol}
Our invariant protocol guarantees that the whole ROG of any object involved in execution (formally, in a redex) is \emph{valid}: if you can call methods on an object, calling \Q@invariant@ on it is guaranteed to return \Q@true@ in a finite number of steps. However, calls to \Q!invariant! that are generated by our runtime monitoring (see below) can access the fields of a potentially invalid \Q!this!. This is necessary to allow for the \Q!invariant! method to do its job: namely distinguish between valid and invalid objects. However, as for any other method, calls to \Q!invariant! written explicitly by users are guaranteed to have a valid receiver. 

% However, the \Q!invariant! method itself needs to be able to operate on a potentially invalid \Q!this!, this will only happen when it is automatically called by the language itself, not by explicit calls present in the source code.
% Clearly the \Q@invariant@ method must be able to take an invalid \Q@this@, since the purpose of such method is to distinguish valid and invalid objects. On a first look this may seem an open contradiction
% with the aim of this work, however only calls to \Q@invariant@ inserted by the language semantics can take an invalid \Q@this@. As for any other method, when the application code can call \Q@invariant@, \Q@this@ is guaranteed to be valid.
%

%Logically, there are two reasons to access a field: we may wish to read the information stored in such object or we wish to mutate the object contained in the field.
%For the first case, we can type the field access as \Q@read@, but in the second case we
%need to type it as \Q@mut@. 
%We call `capsule mutators' a method accessing as \Q@mut@ a capsule field referenced in the invariant.
%We will show how capsule mutators are analogous of the pack/unpack/expose~\cite{???}.
%In order for a class to have an invariant under our protocol,
%\Q@invariant@ method the form 
% Can  a program write say mut method invariant or is it syntactically [???]
For simplicity, in the following explanation and in our formalism
we require 
%the \Q@this@ receiver is 
receivers to always be specified explicitly, and require that the receivers of field accesses and updates are always \Q!this!; that is, all fields are instance private.
We also do not allow explicit constructor definitions, instead we assume constructors are of the standard form \Q@$C$($T_1 x_1$,$\ldots$,$T_n x_n$) {this.$f_1$=$x_1$;$\ldots$;this.$f_n$=$x_n$;}@, where the fields of $C$ are $T_1 f_1;\ldots; T_n f_n;$. This ensures that partially uninitialised (and likely invalid) objects are not passed around or used. 
These restrictions only apply to our formalism; our code examples and the L42 implementation soundly relax these, see below for a discussion.% of why this is sound.
%We will later explain how these and other restrictions can be partially relaxed, as in the code examples.

\subheading{Invariants}
We require that all classes contain a \Q@read method Bool invariant() {..}@, if no \Q!invariant! method is present, a trivial one returning \Q!true! will be assumed. As this method only takes a \Q!read! parameter (the receiver), we can be sure that it is pure \REV{\footnote{If the invariant were not pure, it would be nearly impossible to ensure that it would return \Q@true@ at any point.}}{C}{to me, it would make sense that the runtime semantics (in particular: the invariant checking semantics) of checked exceptions would be inconsistent with that of unchecked semantics.}, as discussed in Section \ref{s:purity}.
The bodies of \Q@invariant@ methods are limited in their usage of \Q@this@: \Q!this! can only be used to access \Q@imm@ and \Q@capsule@ fields. This restriction ensures that 
an invalid \Q@this@ cannot be passed around.
We prevent accessing \Q@mut@ fields since their ROG could be changed by unrelated code (see Section \ref{s:immutable}).
Note that we do not require such fields to be \Q@final@: when a field is updated, we simply check the invariant of the receiver of the update.
% In order to prevent passing an invalid \Q@this@ to other methods.
%and unrelated code cannot break the invariant
%s of arbitrary objects,
%since a \Q!read! or \Q!mut! field could be modified through arbitrary aliases 
%(see Section \ref{s:immutable}). 

%To ensure that invariants cannot be broken by unrelated code (see Section \ref{s:immutable})  %
\subheading{Capsule mutators}
In order to allow complex mutations of objects with invariants we introduce the notion of \emph{capsule mutator}. A \emph{capsule mutator} can perform an arbitrarily complex mutation of the ROG of a capsule field. We use TMs to ensure that the object containing the capsule field is not usable whilst the fields ROG is mutated, and it's invariant is checked immediately afterwards. 

Formally, \emph{capsule mutators} are \Q@mut@ methods whose body accesses a \Q@capsule@ field mentioned in the invariant of the class containing the field. 
Capsule mutators must use \Q@this@ exactly once in their body, since fields are instance private, this will be to access the \Q!capsule! field.
%By construction, such use is the access of the \Q@capsule@ field.
Excluding the \Q!mut! receiver, such methods cannot have any \Q!mut! or \Q!read! parameters, their return type must not be \Q!mut!, and their \Q!throws! clause must be empty.%
\footnote{%
To allow capsule mutators to leak checked exceptions,
we would need check the invariant
when such exceptions are leaked. However, this would make the runtime semantics of checked exceptions inconsistent with unchecked ones.}.


%\end{itemize}
%Our type system will ensure that such methods are \Q!mut method!s, and the \Q!capsule! field will be seen as \Q!mut!.
As capsule mutators use \Q!this! only once, and have no \Q!read! or \Q!mut! parameters, \Q!this! will not be accessible during execution. This is important, as it allows the invariant to be violated \REV{part way through the capsule mutator, but re established by the end.}{D}{how does this allow an invariant to be violated for a non-trivial period of time before being checked again?}
Preventing \Q!mut! return types ensures that such methods cannot \REV{leak out a mutable alias to the \Q!capsule! field}{D}{why would it otherwise be possible ... Even doing this locally violates the soundness semantics for every reference immutability system I've seen}, which could then be used to break the invariant.
\REV{\REV{Note that these restrictions do not apply when the receiver of the field access is \Q!capsule!, since we guarantee that the receiver is not in the ROG of any of its \Q!capsule! fields, and hence it can never be seen afterwards.}{C}{I do not understand this sentence.}}{D}{I just don't understand what this sentence is suggesting.}

\subheading{Monitoring}
The language runtime will insert automatic calls to \Q!invariant!, if such a call returns \Q!false!, an unchecked exception will be thrown. Such calls are inserted in the following points:
\begin{itemize}
	\item After a constructor call, on the newly created object.
	\item After a field update, on the receiver.
	\item After a capsule mutator method returns, on the receiver of the method\footnote{The invariant is not checked if the call was terminated via an an unchecked exception, since strong exception safety guarantees the object will be unreachable anyway.}.
\end{itemize}

\noindent In Appendix \ref{s:proof}, we show that these checks, together with our aforementioned restrictions, are sufficient to ensure our guarantee that all objects involved in execution (except as part of an invariant check) are valid.

\subheading{Relaxations}
The above restrictions can be partially relaxed without breaking soundness, however this would not make the proof more interesting. In particular:
\begin{itemize}
	\item \Q!invariant! methods can be allowed to call instance methods that in turn only use \Q@this@ to read \Q!imm! or \Q!capsule!, or call other such instance methods. With this relaxation, the semantics of \Q@invariant@ needs to be understood with the body of those methods inlined; thus the semantics of the inlined code needs to be logically reinterpreted in the context of \Q@invariant@, where \Q@this@ may be invalid. In some sense, those inlined methods and field accesses can be thought of as macro expanded, and hence are not dynamically dispatched. Such inlining has been implemented in L42.
	\item We could allow all fields to be public, however \Q!capsule! fields, mentioned in the invariant of their containing class, should not be accessible over a \Q!mut! receiver other than \Q!this!. Even without this relaxation, however, getters and setters could be used to simulate public fields.
	\item \REV{Unrestricted readonly access to \Q!capsule! fields can be allowed by automatically generated getters of the form \Q!read method read C f() { return this.f; }!. Such getters are already a fundamental part of the L42 language.}{C}{this should be type-incorrect in all of
		the related systems cited, to the best of my knowledge. because as-is there's nothing stopping a caller ... from storing that \Q!read!
		result in the heap somewhere, leading to a violation of encapsulation. ... read-only access to capsule fields is permissible, which is not the case in the prior work I'm aware of, but perhaps L42 has made
different choices (which then should be explained here, given all the comparisons to Gordon et al.
and Pony).  This doesn't invalidate recovery to immutable, but means the system can no longer be
used for safe concurrency; fine if L42 has none, but again if this is deviating from prior work this must be discussed, and if it's relying on the details of a particular system, some detail of that specific system/paper should be given to contrast with the broad-stokes view of Gordon et al./Clebsch et al./Servetto et al.}
	
	\item Java style constructors could be allowed, provided that \Q!this! is only used as the receiver of field initialisations. L42 does not provide such constructors, but one can always write a static factory method that behaves equivalently.
\end{itemize}
Both L42, and our formal language (see Section~\ref{s:formalism}) do not have traditional subclassing, rather all `classes' are either interfaces (which only have abstract methods), or are final (which cannot be subtyped). In a language with traditional subclassing, invariant methods would implicitly start with a check that \Q@super.invariant()@ returns \Q@true@. Note that invariant checks would not be performed at the end of \Q@super(..)@ constructor calls, but only at the end of \Q@new@ expressions, as happens in~\cite{feldman2006jose}.

