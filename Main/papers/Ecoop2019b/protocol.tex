%-----------------------------------------------------------
%define simple objects
%show solution  for simple person: requires 3 properties
%show solution is sound --> proof in appendix
%naive is unsound - person 3 bugs
\saveSpace
\section{Our Invariant Protocol}
\label{s:protocol}
\saveSpace
\IODel{In this section we will formalize our approach over a core language, and we formally state our soundness property (proved in the Appendix).
In the next section, by examples, we will show that all our restrictions and
requirements are actually needed, and that just violating any one of them would cause our system to be unsound.}

Our invariant protocol guarantees that the whole ROG of any object involved in execution (formally, in a redex) is \emph{valid}: if you can call methods on an object, calling \Q@invariant@ on it is guaranteed to return \Q@true@ in a finite number of steps. However, the \Q!invariant! method itself needs to be able to operate on a potentially invalid \Q!this!, this will only happen when it is automatically called by the language itself, not by explicit calls present in the source code.

\IODel{Clearly the \Q@invariant@ method must be able to take an invalid \Q@this@, since the purpose of such method is to distinguish valid and invalid objects.
On a first look this may seem an open contradiction
 with the aim of this work, however only calls to \Q@invariant@ inserted by the language semantics can take an invalid \Q@this@. As for any other method, when the application code can call \Q@invariant@, \Q@this@ is guaranteed to be valid.
Also the bodies of constructors may interact with an invalid \Q@this@; we restrict their shape so that neither invariant methods nor constructors can observe the invalid object directly, but only its fields. }

%Logically, there are two reasons to access a field: we may wish to read the information stored in such object or we wish to mutate the object contained in the field.
%For the first case, we can type the field access as \Q@read@, but in the second case we
%need to type it as \Q@mut@. 
%We call `capsule mutators' a method accessing as \Q@mut@ a capsule field referenced in the invariant.
%We will show how capsule mutators are analogous of the pack/unpack/expose~\cite{???}.
%In order for a class to have an invariant under our protocol,
%\IODel{its }\Q@invariant@ method the form 
% Can  a program write say mut method invariant or is it syntactically [???]

We require that all classes contain a \Q@read method Bool invariant() {..}@, if no \Q!invariant! method is present, a trivial one returning \Q!true! will be assumed. As this method only takes a \Q!read! parameter (the receiver), we can be sure that it is pure \footnote{If the invariant were not pure, it would be nearly impossible to ensure that it would return \Q@true@ at any point.} (see Section \ref{s:purity}).

\IODel{\noindent Also note that \Q@invariant@ is declared as not throwing any exceptions, thus only unchecked exceptions can be propagated out.}