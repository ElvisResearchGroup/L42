
\begin{frame}[fragile]
\frametitle{Pow}

\begin{lstlisting}
@requires(exp > 0)
@ensures(result == x**exp)
Int pow(Int x, Int exp) {
	if (exp == 1) return x;
	if (exp %2 == 0) return pow(x*x, exp/2);//even
	return x*pow(x, exp-1); }  //odd
\end{lstlisting}
If the exponent is known at compile time,
unfolding the recursion produces even more efficient code:
\vspace{-1ex}
\begin{lstlisting}
@ensures(result == x**7) Int pow7(Int x) { 
  Int x2 = x*x; // x**2
  Int x4 = x2*x2; // x**4
  return x*x2*x4; } // Since 7 = 1 + 2 + 4
\end{lstlisting}

\end{frame}


\begin{frame}[fragile]
\frametitle{Pow}
\begin{itemize}
\item OO languages supporting static verification usually extends method
declaration with syntax supporting pre/post conditions. During
compilation, directly after typing, an automatic theorem prover
checks the constraints.
\item Very slow even on fast hardware!
\item \Q@pox(x,y)@ execution is slower than an hand written \Q@pow7(x)@
\item Manually declaring \Q@pow@$_n$ methods: repetitive, boring.
\item Running the static verifier on all \Q@pow@$_n$ versions: time consuming
\end{itemize}
\end{frame}


\begin{frame}[fragile]
\frametitle{Pow}

What if we could programmatically generate code at compile time?
For example, we could write \Q@generate(y)@ as a method
generating a class body with a method \Q@pow(x)@ computing
\Q@pow(x,y)@

\Q@class Pow7: generate(7)@

\Q@...@

\Q@Pow7.pow(4) == pow7(4)@

\end{frame}


\begin{frame}[fragile]
\frametitle{Iteratively building up \Q@pow@}
\vspace{-2ex}
\begin{itemize}
\item Verification supports code reuse / class inheritance.
\item What if metaprogramming was based on code reuse?
\item For example, here we use inheritance to encode statically verified
\Q@pow@s while reusing part of the already verified contract
\item \tiny{A code optimizer could inline nested calls, producing 
the same efficient code of the hand written versions of before}
\end{itemize}
\vspace{-1ex}
\begin{lstlisting}
class Pow1{
  @ensures(result=x**1)
  Int pow1(Int x){return x;}  }

class Pow2 extends Pow1{
  @ensures(result=x**2)
  Int pow2(Int x){return x*pow1(x);}  }

class Pow3 extends Pow2{
  @ensures(result=x**3)
  Int pow3(Int x){return x*pow2(x);}  }
\end{lstlisting}
\end{frame}


\begin{frame}[fragile]
\frametitle{Pow and Exp}


\end{frame}

\begin{frame}[fragile]
\frametitle{Thanks}
${}_{}$\\*
${}_{}$\\*
${}_{}$\\*
${}_{}$\\*
Questions?
\end{frame}

%\begin{frame}[fragile]
%\frametitle{This leaking in our approach}
%\end{frame}

%\begin{frame}[fragile]
%\frametitle{This leaking in our approach}
%\end{frame}
