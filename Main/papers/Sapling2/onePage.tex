\documentclass[a4paper,twoside,british,9pt]{extarticle}
\usepackage[a4paper,bindingoffset=0ex,%
            left=15ex,right=15ex,top=10ex,bottom=15ex,%
            footskip=5ex]{geometry}
\setlength{\parskip}{\medskipamount}
\setlength{\parindent}{0pt}
\input{../Def/Def}
\providecommand*{\code}[1]{\Q`#1`}
\pagenumbering{gobble}
\usepackage[square, numbers, comma, sort&compress]{natbib}
\setlength{\bibsep}{0.0pt}
\begin{document}
\title{Metaprogramming Statically verified code \vspace{-2ex}}
\author{
Hrshikesh Arora (arorahrsh@myvuw.ac.nz), Marco Servetto (marco.servetto@ecs.vuw.ac.nz)}
\date{}
\maketitle
\vspace{-5ex}
Quasi Quotation~\cite{moggi1999idealized,sheard2002template}
is a very expressive metaprogramming technique: it allows expressing arbitrary behaviour by
generating arbitrary abstract syntax trees.
However, it is hard to reason about Quasi Quotation statically because
the process is fundamentally low-level, imperative and bug prone.
In this paper, we present Iterative Composition~\cite{servetto2014meta} as
an \textbf{effective alternative} to Quasi Quotation.
Iterative Composition describes a code composition algebra over established code reuse techniques,
similar to trait composition~\cite{scharli2003traits} and generics.
Our main contribution is that by applying functional reasoning (such as induction and folds)
over those well-known operators we can generate arbitrary behaviour.
This allows us to reuse the extensive body of verification research in the 
context of object-oriented languages to verify the properties
of the code generated by Iterative Composition.
Finally, we present a prototype implementation of Iterative Composition in the context of the L42 language.

Quasi quotation (QQ) can be supported by two kinds of special parenthesis as a syntactic sugar to manipulate Abstract Syntax Trees (ASTs). Here we use
\Q@[|  |]@  and \Q@$\$$(  )@ as Template Haskell~\cite{sheard2002template}.
Usually programming with QQ requires thinking about the desired method body,
 and often allows generating a more efficient body by generating code specialized for some input value.
A typical example is about generating a \Q@pow@ function, where the exponent is well known.
An `efficient' version using QQ would be:
\vspace{-1ex}
\begin{lstlisting}[language=ML]
fun powerAux(n:Int):Expr<x:Int$\vdash$Int>=if(n=0) then [|1|] else [|x * $\$$(powerAux(n-1)) |];
fun powerGen(n:Int): Int->Int = compile([| $\lambda$ x. $\$$(powerAux(n)) |]);
power7=powerGen 7;
\end{lstlisting}
\vspace{-2ex}
\noindent As you can see, by generating the abstract syntax tree, we can obtain exactly:
\Q@power7_b=$\lambda$ x.x*x*x*x*x*x*x*1;@. On most machines, \Q@power7@ runs faster than a naive recursive version.
Metaprogramming applications include more than just speed boosts, but we start with this example because it is very popular and simple.
However, it is unclear how to statically verify
code generate with IC.
We now show how to rewrite our \Q@pow@ example
in our proposed approach, while annotating the code with pre and post conditions, as it happens in JML~\cite{jml}.
\newcommand\thisExp{\ensuremath{{}^{\textbf{this.exp()}}}}
\newcommand\thisSuperExp{\ensuremath{{}^{\textbf{this.superExp()}}}}
\newcommand\oneThisSuperExp{\ensuremath{{}^{\textbf{1+this.superExp()}}}}
\newcommand\powerY{\ensuremath{{}^{\textbf{y}}}}
\vspace{-1ex}
\begin{lstlisting}[language=FortyTwo]
Pow={
  static method Library base()={
    $\MComment{@ensures exp()=0}$ method Num exp()=0 
    $\MComment{@ensures pow(x)=x\thisExp}$ method Num pow(Num x)= 1 }
  static method Library inductive()={
    $\MComment{@ensures @result=1+this.superExp()}$ method Num exp()=1+this.superExp() 
    method Num superExp()
    $\MComment{@ensures @result=x\thisExp}$ method Num pow(Num x)= x*this.superPow(x)
    $\MComment{@ensures pow(x)=x\thisSuperExp}$ method Num superPow(Num x)}
  $\Comment{@requiresRV y>=0}$
  $\Comment{@ensuresRV @result.exp().ensures = (@result = y) and @result.pow(x).ensures = (@result = x\powerY)}$
  static method Library generate(Num y){
    var Library res=this.base()
    for(i in Range(y)){
      res=Override[exp()<-superExp(), pow()<-superPow()](res,this.inductive())}
    return res } }
\end{lstlisting}
\vspace{-2ex}
Our approach clearly is more verbose, but is exposing all the hidden complexity
of the QQ code.
In short, \Q@base()@ and \Q@inductive()@ 
are methods returning constant statically verified code. Static verification is a very computationally intensive step, and our approach verifies
\Q@base()@ and \Q@inductive()@ once and for all during compilation.
\Q@Override@ inside \Q@generate(y)@ behaves like mixin composition,
and the syntax \Q@[exp<-superExp()]@ encodes the
conventional super calls.
Thus, we iteratively create a chain of inheritance where
the \Q@base@ code is extended with \Q@inductive@ \Q@y@
times, generating the behaviour we need.
Crucially, the static verifier needs to only statically verify the
code of \Q@base()@ and \Q@inductive()@;
the \Q@generate(y)@ method will then just do
an efficient contract matching.
Thus, at every iteration of the for-loop, \Q@res@
will contain statically verified code; however, the contract of such code is not statically known.
Finally, as required by the \Q@ensuresRV@ clause, at the end of code generation, the system will
check that the contract of the generate code is the expected one.

Concluding, static verification of metaprogramming is a
near unexplored area and we are trying attack the problem by reusing conventional
object oriented static verification by
relying on
composition operators similar to \Q@extends@ and generics to
generate behaviour.
\vspace{-3ex}
\bibliographystyle{plain}
{\tiny \bibliography{main}}
\end{document}

