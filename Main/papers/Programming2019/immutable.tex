

\section{Background}
\label{s:background}
\noindent\textit{Type Modifiers:}
Type modifiers are a well known language mechanism~\cite{TschantzErnst05,BirkaErnst04,OstlundEtAl08,clebsch2015deny,GianniniEtAl16,GordonEtAl12} allowing static verification of mutability and aliasing properties of objects.
With sightly different names and semantics, the three most common modifiers for object references are:
\begin{itemize}
\item Mutable (\Q@mut@): the referenced object can be mutated, as in most languages without modifiers.
\item Readonly (\Q@read@): the referenced object cannot be mutated by such reference, but in the program there may be mutable references to this same object, so mutation can still be observed. 
\item Immutable (\Q@imm@): the referenced object can never mutate. Like \Q@read@ references, one cannot mutate through an \Q@imm@ reference, however \Q@imm@ references also guarantees that the referenced object will never be mutated, not even through another reference.
\end{itemize}
%In the context of object-oriented programming, type modifiers may also apply to the implicit \Q@this@ parameter in method declarations, restricting the type of references the method can be called on. In addition, due to the deep meanings we type field access on object references to be the most restrictive of the object references modifier and the field’s. As \Q@read@ references impose no assumptions about aliasing, any \Q@imm@ or \Q@mut@ expression can be safely implicitly promoted to \Q@read@, whereas other conversions are not generally safe.
%\loseSpace
TM are different to field or variable modifiers like Java’s \Q@final@: TM applies to references,  \Q@final@ specifies what can be done to the field itself. In comparison to \Q@imm@:

\begin{itemize}
\item A \Q@final@ variable/field cannot be reassigned, it always refers to the same object; however, the referenced object itself may be mutated.
\item A reference of an \Q@imm@ type however refers to an object that will never be mutated, and neither will its ROG. However, a field of type \Q@imm@ may be updated to another \Q@imm@ reference.
\footnote{In C, this is similar to the difference between \Q@const *A@ and \Q@*const A@, where a \Q@final imm@ variable would be like \Q@const *const A@.}
\end{itemize}



\noindent Consider the following  example usage of \Q@mut@, \Q@imm@ and \Q@read@:
\begin{lstlisting}
mut Point mp = new Point(1, 2);
mp.x = 3; // ok
imm Point ip = new Point(1, 2);
$\Comment{}$ip.x = 3; // type error
read Point rp = mp; // ok read is a common supertype of imm/mut
$\Comment{}$rp.x = 3; // type error
mp.x = 5; // ok, and now we can observe rp.x == 5
ip = new Point(3, 5); // ok, ip is not final
\end{lstlisting}
\noindent We cannot use a \Q@read@ reference to cause mutation, but we have no guarantee of the absence of mutation; in our example we can observe a change in \Q@rp@ caused by a mutation inside \Q@mp@.


There are several possible interpretations of the semantics of type modifiers.
Here we assume the full/deep meaning:
\begin{itemize}
  \item all the objects in the ROG of an immutable object are immutable;
  this corresponds to UML DataTypes,
  \item a mutable field accessed from a \Q@read@ reference produce a \Q@read@ reference,
  \item no \emph{down}-casting is allowed between different type modifiers.
\end{itemize}


\noindent There are many different existing techniques and type systems that handle the modifiers above~\cite{ZibinEtAl10,ClarkeWrigstad03,HallerOdersky10,GordonEtAl12,ServettoZucca15}.
The main progress in the last couple of years is with the flexibility of such type systems: where the programmer should use \Q@imm@ to represent objects that would obviously be modelled as UML DataTypes, and \Q@mut@ nearly everywhere else; the system will be able to transparently promote/recover~\cite{GordonEtAl12,clebsch2015deny,ServettoZucca15} the type modifiers, adapting them to their use context.
To see a glimpse of this flexibility, consider the following example:
\saveSpace
\begin{lstlisting}
mut Point mCenter = new Point(1, 2);
mut Circle mc = new Circle(mCenter, /*radius*/7);
mc.radius = 3; // ok
imm Circle ic = new Circle(new Point(0, 0), 7); // ok imm
imm Point ip = ic.center; // ok, ROG immutable
read Circle rc = mc
read Point rp = rc.center; // ok, fields of read Circle are read
$\Comment{}$mut Point mp = rc.center; // type error
\end{lstlisting}
\saveSpace

Here \Q@imm Circle ic@ and \Q@mut Circle mc@ are both initialized with \Q@new Circle(...)@.
This is not a special feature of \Q@new@ expressions: since \Q@new@ returns a \Q@mut@ and any expression typed as \Q@mut@ that only uses immutable variables can safely be promoted to \Q@imm@.
% (since the returned value could not possibly be aliased).
%FALSE: it can be internally aliased!
Such flexibility is also visible where \Q@rc.center@ returns a \Q@read@ but \Q@ic.center@ returns an \Q@imm@: any expression typed as read that only
uses immutable variables can safely be promoted to \Q@imm@.

 %(since \Q@ic@ is \Q@imm@, and \Q@imm@ is a deep modifier).
%true fact but not sufficient?

%With this kind of type system, we can ensure immutable classes by just declaring all their fields as final and immutable.%
%\footnote{
%In Java,  to ensure a class is immutable we need:
%the class must be final, all the fields must be final of immutable
%classes (thus no interface fields, final classes all the way down),
%and the SecurityManager need to properly tame reflection.}

% Not sure about this paragraph:



\loseSpace

TM are very useful in restricting the scope of mutation. 
Any expression that does not use any \Q@mut@ 
variable declared outside of such expression does not modify objects visible outside. This consideration is particularly useful to understand code in the presence of exceptions. Other authors have identified the concept of Strong Exception Safety~\cite{Abrahams2000} as a general issue when reasoning about objects state after catching an exception:
when a \Q@try-catch@ catches an exception, the visible objects must be the same as before the \Q@try@ block started its execution.
This can be obtained leveraging TM in the following way:
\begin{itemize}
\item all thrown exceptions are immutable objects,
\item code inside a \Q@try@ block is typed as if all \Q@mut@ variables declared outside of the block are \Q@read@.
\end{itemize}

\loseSpace
\noindent\textit{Object Capabilities:}
While type modifiers are statically verified properties of references, object capabilities are run time characteristics of specific objects.

Conceptually, an object capability is a communicable, unforgeable token of authority, a key to access special functionality: only certain objects with `special' powers can do `special' actions, and those objects are obtained in a controlled way. We call such objects `capability objects'.
Their main use case is to allow for fine-grained control over what sections of code are allowed to do. For example, in Java \Q@System.in@ is a capability object (it has the capability to read input); however it is globally accessible: thus any code could use it, preventing reasoning about determinism.
In a language enforcing object capabilities the \Q@main@ method could take a \Q@System@ object as a parameter, and using that object is the only way to perform I/O, as in \Q@mySystem.println("hello")@.
Moreover, the \Q@System@ class would have no visible constructor, and all its I/O methods would require a mutable (\Q@mut@) receiver.
Many other operations, like random numbers and file management 
%may just take a \Q@mut System@ object as a parameter.
could also work this way.
\noindent This design has been explored in literature by Joe-E~\cite{finifter2008verifiable}.

Here we use TM to guarantee that any method that is not (indirectly) passed a \Q@mut@ reference to a capability object will not use any capabilities:
\begin{itemize}
\item all capability-methods must require a \Q@mut@ receiver,
\item there are no global variables\footnote{Note: even just allowing \Q@imm@
global variables would prevent reasoning over determinism due to the possibility of global variable updates; however constant/final globals of an \Q@imm@ type would not cause such problems.},
\item user code cannot directly create a capability object: they can only indirectly do so through an existing \Q@mut@ capability object reference

% NOTE: SOMEWHERE MAKE IT CLEAR THAT NON-DETERMINISM CAN ONLY OCCUR THROUGH A CAPABILITY OBJECT
\end{itemize}

%-----------------------------------------------------------


%define simple objects
%show solution  for simple person: requires 3 properties

%show solution is sound --> proof in appendix
%naive is unsound - person 3 bugs


\section{The \Q@.validate()@ Method}
\label{s:validate}
Thanks to TM and OC, we can now express the signature for \Q@.validate()@ method as follows:
\saveSpace
\begin{lstlisting}
read method imm Bool validate();
\end{lstlisting}
\saveSpace
%The method is \Q@read@: thus the method body will see the \Q@this@ object as a \Q@read@ reference; and has no other parameters. 
%By starting from a \Q@read@ reference and nothing else, we are guaranteed that the method is pure:
If the class containing the validate method has a super-class, we would automatically check \Q@super.validate()@ at the beginning of the sub-class’s \Q@.validate()@ method, this is required as otherwise `invalid' objects could easily be created by simply using subtyping to redefine \Q@.validate()@.
As this method is declared as \Q@read@, and only takes the implicit parameter \Q@this@ (as \Q@read@), we can guarantee the method is pure:
\begin{itemize}
\item the ROG from \Q@this@ is only accessed as \Q@read@ (or \Q@imm@), thus it cannot be mutated\footnote{
This can even be safe in a multi-thread environment: TM are often used to ensure correct parallelism; for example threads may be required to not share \Q@mut@ data, thus a \Q@read@ reference could only be mutated by a \Q@mut@ reference under the control of the same thread.
},
\item if a capability object (such as \Q@System@) is in the ROG of \Q@this@, then it can only be accessed as \Q@read@, preventing use of its capability (such as I/O),
\item nothing else is accessible (we do not have global variables).
\end{itemize}

\noindent Also note \Q@.validate()@ is not declared as throwing any exceptions, thus it can only leak unchecked exceptions.


Clearly the \Q@.validate()@ method must be able to take an invalid \Q@this@, since the purpose of such method is to distinguish valid and invalid objects.\footnote{
At a first look this may seam an open contradiction
with the aim of this work, however only calls to validate inserted by the language semantic can take an invalid \Q@this@. As for any other method, when the application code calls \Q@.validate()@,
\Q@this@ is guaranteed to be valid.
} However, if we allow the method to use \Q@this@ directly (e.g. storing it in a local variable or passing it to a method), we would break the guarantees of validation (namely: `invalid objects are not reachable by application code'); as such we enforce the simple restriction that \Q@.validate()@ may only use \Q@this@ to access fields.
As a relaxation, we could allow calling instance methods that in turn only use \Q@this@ to access fields, or call other such instance methods. With this relaxation, the semantics of \Q@.validate()@ need to be understood with the body of those methods inlined; thus the semantic of the inlined code need to be logically reinterpreted in the context of \Q@.validate()@, where \Q@this@ may be invalid.
In some sense, those inlined methods and field accesses can be thought as macro-expanded.


Finally,
the code of \Q@.validate()@ can not access  \Q@mut@ and \Q@read@ fields, because their content can be changed by unrelated code.
Thus, with the modifiers presented so far, we can only access \Q@imm@ fields.
We will later introduce a \Q@capsule@ modifier to allow more flexible validation.


% JUSTIFY that the fields are valid...

%validable objects are not circular (do not belong in their ROG of any of its fields)
%validate as a predicate on object fields never really see this.
%
%clarifications:
%a validate check is never needed/generated/injected when working on a read x
%multi threading is not relevant/supported
%validable objects are not circular (do not belong in their ROG of any of its fields)

\section{Validating immutable state}
\label{s:immState}
In this section we consider validation over fields of \Q@imm@ types.\footnote{
In a real language, for conciseness one could make the \Q@imm@ modifier the default, allowing it to be omitted and our \Q@Person@ example class would only use 3 type modifiers; however we explicitly use it here for clarity.
}
In the next section we expand our technique.

In the following code \Q@Person@ has a single immutable (non final) field \Q@name@:
\begin{lstlisting}
class Person {
  read method imm Bool validate() {return !name.isEmpty();}
  private imm String name;
  read method imm String name() {return this.name;}
  mut method imm Strinig name(imm String name) {this.name = name;}
  Person(imm String name) {this.name = name;} }
\end{lstlisting}
\Q@Person@, only has immutable fields and the constructor only uses \Q@this@ to access/update fields.%; we say such a class is \emph{simple}.
%\Q@Person@, only has immutable fields and the constructor 
%uses the parameters to directly initialize (all) the fields.
% We say such a class is \emph{simple}.%
%\footnote{
%We consider only standard contractors for simplicity of exposition.
%More complex constructors could be supported, provided that \Q@this@ is only used to access fields, we do discuss them for simplicity.}
The difference with respect to UML DataTypes 
%immutable types (like UML DataTypes)
%UML datatypes are aclass property. immutable types are often an instance one (so no final fields) 
 is that fields are not required to be final, thus the object can change state during its lifetime. This means that the ROGs of all the \emph{fields} are immutable, but the object itself may be mutable.
%Of course UML DataTypes
%immutable types
%No, a type is not a class
% are just a special case of simple classes.
Validation for such a class can easily be enforced by generating checks on the result of \Q@.validate()@, immediately after each field update, and at the end of the constructor\footnote{since the constructor only initialises fields, as with the \Q@.validate()@ method itself, we don't check for validity during the constructor as \Q@this@ is not directly reached, doing so would require the initial/default value of \Q@this@ to be valid.}:
% If a simple class provides a \Q@.validate()@ method, then validation will be enforced.
% For \Q@Person@, intuitively, the code would behave as follow:

%\Comment{if we made this public, all users who update the field need to call validate}%
%There are many interpretations for your comment
%why you deleted my code comments?
\begin{lstlisting}
class Person {
  read method imm Bool validate() {return !name.isEmpty();}
  private imm String name;
  read method imm String name() {return this.name;}
  mut method imm String name(imm String name) {
    this.name = name; // check after field update
    if (!this.validate()) {throw new Error(...);} 
  }
  Person(imm String name) {
    this.name = name; // check at end of constructor
    if (!this.validate()) {throw new Error(...);}
}}// Generated code, not directly written by the programmer
\end{lstlisting}
%... $\MComment{validation error}$ 

% Many programmers attempted to write similar code in mainstream languages like Java to ensure  that some property always holds. Indeed, at first look, this code seems to correctly enforce validation. Sadly, without relying on TM and OC, the former code would be broken: just making the fields private and checking the \Q@.validate()@ method at the \textbf{end of the constructor} and at the \textbf{end of mutator methods} is not enough to enforce validation.
% The trick is that our intuition relies not on statically verified properties, or on the semantics of the language, but on the expectations about `correct' behaviour of \Q@String@. We need to enforce Validation without assuming the behaviour of other objects.

If we were to relax (as in Rust) or even eliminate (as in Java) the support for TM or OC, the validation of this simple \Q@Person@ class would become harder, or even impossible. We now proceed to show examples where
relaxation of TM or OC breaks our validation. 

\loseSpace
\noindent\textit{Unrestricted use of object-capabilities:}
Allowing \Q@.validate()@ to (indirectly) use an object capability could allow for it to be non deterministic, by either:
\begin{itemize}
\item allowing \Q@.validate()@ to (indirectly) access a \Q@mut@ reference to a capability-object,
\item relaxing the rule that capability-methods must have a \Q@mut@ receiver, or
\item allowing capability objects to be created out of thin air.
\end{itemize}

For example consider this simple and contrived (mis)use of person:
\begin{lstlisting}
class EvilString extends String {
  @Override read method Bool isEmpty() {
    // Creates a new capability object out of thin air
    return new Random().bool();
} }
...
imm method mut Person createPersons(imm String name){
  // we can not be sure wether name is an `EvilString'
  mut Person schrodinger1 = new Person(name); // exception here?
  mut Person schrodinger2 = new Person(name); // what about here?
  ...}
\end{lstlisting}
Despite the code for \Q@Persion.validate()@ intuitively looking correct and deterministic, the above calls to it are not. Obviously this breaks any reasoning and makes our validation unsound. 
In particular, note how in the presence of dynamic class loading, 
we can not make any assumption on the dynamic type of \Q@name@.
%???
%Even if we disallow subtyping the same problem could still occur if we had a strange implementing of \Q@String@, or \Q@Persion.validate()@ itself.

\loseSpace
\noindent\textit{Allowing internal mutations/back-doors:}
% TODO: Come up with better title
Suppose we relax our mutation rules, by allowing interior mutability
as in Rust and Javari: thus allowing mutation of the ROG of an immutable object through back-doors:
\begin{lstlisting}
class AtomicBool {
  imm method imm Void store(imm Bool val){
    ... // Mutate through an imm reciever
  }
}

class NastyString extends String {
  imm AtomicBool evil = new AtomicBool(false);
  imm method imm Void nasty() {
    this.evil.store(true); // this imm method can do mutation
  }

  @Override read method Bool isEmpty() {
    return this.evil.load() ? false : super.isEmpty();
  }
  ...
}
...
imm NastyString name = new NastyString("bob");
imm Person person = new Person(name); // person is valid
name.nasty(); // mutate the ROG of person, without it noticing
// person is now invalid!
\end{lstlisting}

In this example we use \Q@AtomicBool@ as a back-door to remotely break the invariant of \Q@person@ without any interaction with the \Q@person@ object itself.
%mine: yes, too strong: For validation we need the language to guarantee true deep immutability.
%your: just points outside: It would require some powerful static or dynamic analysis to keep track of every case the ROG of \Q@Person@ could be indirectly mutated, and insert validity checks appropriately, however ensuring deep mutability trivialises this for simple classes.


Allowing such back-doors could also be used to break the determinism of the \Q@.validate()@ method, by allowing it to store and read information about previous calls.

%In our simple example, \Q@Person@ objects can be mutated using the setter, and exposed using the getter.
%We may consider the getter to be safe since in modern languages we expect strings to be immutable objects.
%\footnote{While we can update the field \Q@name@ to point to another string, we cannot mutate the string object itself.
%To obtain  \Q@"Hello"@ from \Q@"hello"@ we need to create a whole new string object that looks like the old one except for the first character. This would be different in older languages like C, where strings are just mutable arrays of characters.}
%
%Again, the assumption that they are immutable depends on the correctness of the code inside \Q@String@: if there was a bug in the \Q@String@ class, or any \Q@String@ subclass, then executing 
%\Q@println(bob.name())@ may change \Q@bob@ by quietly changing a part of its ROG.
%Again, checking
%what methods mutate states cannot be responsibility of the \Q@Person@ programmer.
%For Validation we need a language supporting aliasing and mutability control.
%\begin{comment}
%\item Sample Bug 1:
%Suppose there was a bug in \Q@String.isEmpty()@, causing the method to non-deterministically return \Q@true@ or \Q@false@.
%What would it mean for Validation?
%Would a \Q@Person@ be at the same time 
%valid and invalid?
%
%Only deterministic methods can be used for validation.
%Ensuring this cannot be responsibility of the \Q@Person@ programmer, since it may depend on third party code, as shown in this example.
%However, statically checking if a method is deterministic is hard/impossible in most imperative object-oriented languages.
%
%While we may not expect the presence of bugs in the standard library class \Q@String@, the same behaviour can be achieved with subtyping:
%\saveSpace
%\begin{lstlisting}
%class EvilStr extends String{
%  method Bool isEmpty(){
%    return new Random().bool();
%  }}
%...
%String name=...$\Comment{can this be an EvilStr?}$
%Person bob=new Person(name);
%\end{lstlisting}
%\saveSpace
%As you can see, it is hard to make sound claims about Validation.
%
%\item Sample Bug 2:
%In our simple example, \Q@Person@ objects can be mutated using the setter, and exposed using the getter.
%We may consider the getter to be safe since in modern languages we expect strings to be immutable objects.
%\footnote{While we can update the field \Q@name@ to point to another string, we cannot mutate the string object itself.
%To obtain  \Q@"Hello"@ from \Q@"hello"@ we need to create a whole new string object that looks like the old one except for the first character. This would be different in older languages like C, where strings are just mutable arrays of characters.}
%
%Again, the assumption that they are immutable depends on the correctness of the code inside \Q@String@: if there was a bug in the \Q@String@ class, or any \Q@String@ subclass, then executing 
%\Q@println(bob.name())@ may change \Q@bob@ by quietly changing a part of its ROG.
%
%Again, checking
%what methods mutate states cannot be responsibility of the \Q@Person@ programmer.
%For Validation we need a language supporting aliasing and mutability control.
%\end{comment}

\loseSpace
\noindent\textit{Strong Exception Safety:}
The ability to catch and recover from validation failures is extremely useful as it allows the program to take corrective action.
This may be implemented with a conventional \Q@try-catch@, since violations are represented by throwing unchecked exceptions. Due to the guarantees of strong exception safety, the only trace that the invalid object existed is the exception thrown; any object that has been mutated/created during the \Q@try@ block is now unreachable (as happens in alias burying~\cite{boyland2001alias}).

However, if instead we chose not to enforce strong exception safety, an invalid object could be easily made reachable:
\saveSpace
\begin{lstlisting}[morekeywords={assert}, escapechar=\%]
mut Person bob = new Person("bob");
// Catch and ignore validation failure:
try {bob.name("");} catch (imm Error t){}
assert bob.name().isEmpty(); // now we have a rechable invalid object!
\end{lstlisting}
\saveSpace
As you can see, recovering from a validation failure in this way is unsound and breaks the guarantees of validation.
Strong exception safety is a useful property to enforce, but for the specific purpose of validation this could be relaxed by restricting only \Q@try-catch@ blocks that could capture unchecked exceptions.
Since calls to \Q@.validate()@ may only throw unchecked-exceptions, violating strong exception safety within a \Q@try-catch@ that cannot catch unchecked-exceptions would not break validation.

%LATER: This means that we could relax our Strong Exception Safety to hold only on unchecked exceptions (by restricting only \Q@try-catch@ blocks that capture unchecked exceptions.



% One of the advantages of checking Validation at run time, is that
% we can allow the program can take corrective actions if a property is violated.
% This may be implemented with a conventional \Q@try-catch@ if violations are represented by throwing errors.
% However, there is an issue with exceptions modelling invalid objects: they can be captured when the invalid object is still in scope. For example:


%As you can see, if we can capture validation failures as normal exceptions %(very desirable feature) then we may end up using invalid objects.
%Moreover,
% as shown before with the example of transferring cargo between two boats,
%after an invariant has been violated, even objects with valid invariant may be in an unexpected state.

% This situation is a general issue about reasoning on the state after recovering from exceptions.
% In particular, as shown in the example this prevent sound validation.

% Note how this produces a different semantics with respect to static verification, where violations
% never happened. However this will not necessarily lead to a broken semantics:
%Thanks to Strong exception safety we have a system where either the application terminate
%when an invalid object is detected, or where any witness of the execution causing the invalid object is erased from history
%those objects and all the witnesses will be garbage collected
% (as happens in alias burying~\cite{boyland2001alias}).
%In our example, this means that to continue execution after a detected bug, 
%we would require to garbage collect the overloaded boat, their cargo and probably most of the commercial port too.








%\subsubsection*{Solving Issue 3: Constructors}
%\saveSpace
%Exposing \Q@this@ during construction is a generally recognized problem~\cite{gil2009we}.
%A simple solution is to require all constructors to 
%simply take a parameter for each field and to just initialize the fields.
%An advantage of such approach is syntactic brevity: constructors are implicitly defined
%by the set of fields and thus there is no need to define them manually.
%\textbf{Expressive initialization operations can still be performed, by following the factory pattern.}
%\saveSpace


%\subsubsection*{Recap}
%By utilising type modifiers (\Q@imm@, \Q@mut@ and \Q@read@), object capabilities and immutable exceptions we obtain sound runtime verification for immutable classes/UML data types.