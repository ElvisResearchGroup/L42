

\section{Type modifiers  in literature}

Type modifiers are a well known language mechanism~\cite{TschantzErnst05,BirkaErnst04,OstlundEtAl08,clebsch2015deny,GianniniEtAl16,GordonEtAl12} allowing static verification of mutability and aliasing properties of objects.
With sightly different names and semantics, the three most common modifiers for object references are:
\begin{itemize}
\item Mutable \Q@mut@: the referenced object can be mutated, as in a language without modifiers,
\item Immutable \Q@imm@: the referenced object can never mutate, no matter what happens,
\item and Readonly \Q@read@: the referenced object cannot be mutated by such reference, but in the program there may be mutable references to this same object, so mutation can still be observed. 
\end{itemize}
\noindent
Type modifiers are different to field or variable modifiers like Java \Q@final@: TM applies to references,  \Q@final@ specifies what can be done to the field itself.
Example, compare Java's \Q@final@ modifier to our \Q@imm@ modifier:

\begin{itemize}
\item A \Q@final@ variable/field cannot be reassigned, it always refers to the same object. However, the referenced object itself may be mutated.
\item A reference of an \Q@imm@ type however refers to an object that will never be mutated, neither will its ROG. However, a field of type \Q@imm@ may be updated to another \Q@imm@ reference.
\footnote{In C, this is similar to the difference between \Q@const *A@ and \Q@* const A@, where a \Q@final imm@ variable would be like \Q@const *const A@.}
\end{itemize}



\noindent Consider the following  example of usage of \Q@mut@, \Q@imm@ and \Q@read@:
\begin{lstlisting}
mut Point mp = new Point(1,2)
mp.setX(3) $\Comment{ok}$
imm Point ip = new Point(1,2)
$\Comment{}$ip.setX(3) $\Comment{type error}$
read Point rp = mp $\Comment{ok read common supertype of imm/mut}$
$\Comment{}$rp.setX(3) $\Comment{type error}$
mp.setX(5) $\Comment{ok, and now we can observe rp.x()==5}$
ip = new Point(3,5) $\Comment{ok, ip not final}$
\end{lstlisting}
\noindent We cannot use a \Q@read@ reference to cause mutation, but we have no guarantee of the absence of mutation; in our example we can observe a change in \Q@rp@ caused by a mutation inside \Q@mp@.
 
There are several possible interpretations of the semantics of type modifiers.
Here we assume the full/deep meaning:
\begin{itemize}
\item all the objects in the ROG of an immutable object are immutable;
 this corresponds to UML DataTypes,
\item a mutable field accessed from a \Q@read@ reference is also a \Q@read@ reference,
\item no casting is allowed between different type modifiers.
\end{itemize}
%With this kind of type system, we can ensure immutable classes by just declaring all their fields as final and immutable.%
%\footnote{
%In Java,  to ensure a class is immutable we need:
%the class must be final, all the fields must be final of immutable
%classes (thus no interface fields, final classes all the way down),
%and the SecurityManager need to properly tame reflection.}

% Not sure about this paragraph:
\noindent There are many different existing techniques and type systems that handle the modifiers above~\cite{ZibinEtAl10,ClarkeWrigstad03,HallerOdersky10,GordonEtAl12,ServettoZucca15}.
The main progress in the last couple of years is with the flexibility of such type systems: where the programmer should use \Q@imm@ to represent objects that obviously are UML DataTypes, and \Q@mut@ nearly everywhere else; the system will be able to transparently promote/recover~\cite{GordonEtAl12,clebsch2015deny,ServettoZucca15} the type modifiers adapting them to their use context.
To see a glimpse of this flexibility, consider the following example:
\saveSpace

\begin{lstlisting}
mut Point mCenter = new Point(1,2)
mut Circle mc = new Circle(mCenter, $\MComment{radius}$7)
mc.setRadius(3) $\Comment{ok}$
imm Circle ic = new Circle(new Point(0,0),7) $\Comment{ok imm}$
imm Point ip = ic.center() $\Comment{ok, ROG immutable}$
read Circle rc = mc
read Point rp = rc.center() $\Comment{ok, fields of read Circle are read}$
$\Comment{}$mut Point mp = rc.center() $\Comment{type error}$ 
\end{lstlisting}
\saveSpace

Here \Q@imm Circle ic@ and
\Q@mut Circle mc@ are both initialized with a \Q@new Circle(...)@.
This is not a special feature of the \Q@new@ construct: since \Q@new@ returns a \Q@mut@ and any expression typed as a \Q@mut Circle@ can be promoted/recovered into \Q@imm Circle@ if it uses only immutable references.
Such flexibility is also visible where \Q@rc.center()@ returns a \Q@read@ but \Q@ic.center()@ returns an \Q@imm@.

\loseSpace

TM are very useful to restrict the scope of mutation. 
Any expression that does not use any \Q@mut@ 
reference declared outside of such expression does not modify the state visible outside. This consideration is particularly useful to understand code in the presence of exceptions. Other authors have identified the concept of Strong Exception Safety~\cite{Abrahams2000} as a general issue when reasoning about the state after catching an exception:
when a \Q@try-catch@ catches an exception, the visible state must be the same as before the \Q@try@ block started its execution.
This can be obtained leveraging TM in the following way:
\begin{itemize}
\item all thrown exceptions are immutable objects,
\item code inside \Q@try@ blocks capturing an exception is typed considering all 
\Q@mut@ variable declared outside of the block as \Q@read@.
\end{itemize}




\section{Object capabilities in literature}

While type modifiers are a statically verified property of references, object capabilities are run time characteristics of specific objects.

Conceptually, an object capability is a communicable, unforgeable token of authority, a key to access special functionalities: only certain objects with ``special'' powers can do ``special'' actions, and those objects are obtained in a controlled way. We call such objects ``capability objects''. 
For example, in Java \Q@System.in@ is a capability object (it has the capability to read input), however it is globally accessible, thus any code could use it, preventing reasoning about determinism.
In a language enforcing object capabilities the \Q@main@ method will take a \Q@System@ object as a parameter, and that object has to be used to perform I/O, as in \Q@mySystem.println("hello")@.
Moreover, there is no visible constructor for the \Q@System@ object and all the I/O methods require a mutable (\Q@mut@) receiver.
Many other operations, like random numbers and file management may just take a \Q@mut System@ object as a parameter.
\noindent This design space has been explored in literature by Joe-E~\cite{finifter2008verifiable}.


We use TM to guarantee that any method that is not (indirectly) passed a \Q@mut@ reference to a capability object will not use that capability:
\begin{itemize}
\item all capability-methods to take a \Q@mut@ receiver,
\item and all global-variables are \Q@imm@ references.
\end{itemize}

%-----------------------------------------------------------


%define simple objects
%show solution  for simple person: requires 3 properties

%show solution is sound --> proof in appendix
%naive is unsound - person 3 bugs


\section{Validating Simple Objects}

Thanks to TM and OC, we can now express the \Q@.validate()@ method as follows:
\saveSpace
\begin{lstlisting}
read method imm Bool validate(){...}
\end{lstlisting}
\saveSpace
The method is \Q@read@: thus the method body will see the \Q@this@ object as a \Q@read@ reference, and has no other parameters.
By starting from a \Q@read@ reference and nothing else, we are guaranteed that the method is pure:
\begin{itemize}
\item the ROG from \Q@this@ is only accessed in \Q@read@, thus it cannot be mutated,
\item nothing else is accessible (we do not have global variables),
\item if a \Q@System@ object is in the ROG of \Q@this@, then we will only access it as \Q@read@, preventing I/O.
\end{itemize}

Also note \Q@.validate()@ do not declare any \Q@throws@ exception, so it can only leak unchecked exceptions.
This means that we could relax our Strong Exception Safety to hold only on unchecked exceptions (by restricting only \Q@try-catch@ blocks that capture unchecked exceptions.

Clearly, \Q@.validate()@ may take an invalid \Q@this@. At first look this may seams in open contradiction
with the aim of this work, that objects are always valid, and indeed this is the case and all this work suck and my life is wasted

1 no this except for this.field

2 this 

3 all methods under a validate call can take invalid objects //free use of this in validate

class ValidA {
		bool validate() { return True; }
		private T f;
		public T get_f() { return f; }
}

class A {
		bool validate() {
			return v.get_f() > 3
		}
		private ValidA v;
		public T get_f() { this.v.get_f(); }
}

class A wraps B {
	'' supper' 
}




\saveSpace







\saveSpace
\section{Naive Validation is unsound}
\saveSpace\saveSpace
Many programmers may believe that making the fields private and checking the \Q@.validate()@ method
at the \textbf{end of the constructor} and at the \textbf{end of mutator methods} is enough to enforce
Validation.
As we will see in this article, in most mainstream object-oriented languages, this is \textbf{very far} from enough.
Let's focus first on a simpler example, when a \Q@Person@ just has its name:
\begin{lstlisting}
class Person{
  public Bool validate(){  return !name.isEmpty(); }
  private String name;
  public String name(){ return this.name; }
  public String name(String name){
    this.name=name;
    if(!this.validate()){throw $\MComment{error}$}
    }
  public Person(String name){
    this.name=name;
    if(!this.validate()){throw $\MComment{error}$}
    }
  }
\end{lstlisting}
\noindent At first look, this code seems to correctly enforce Validation.
However our intuition relies not on statically verified properties, or on the semantics of the language,
but on the expectations about ``correct'' behaviour of \Q@String@.
We want to enforce Validation without assuming the behaviour of the other object.
\begin{itemize}
\item Sample Bug 1:
Suppose there was a bug in \Q@String.isEmpty()@, causing the method to non-deterministically return \Q@true@ or \Q@false@.
What would it mean for Validation?
Would a \Q@Person@ be at the same time 
valid and invalid?

Only deterministic methods can be used for validation.
Ensuring this cannot be responsibility of the \Q@Person@ programmer, since it may depend on third party code, as shown in this example.
However, statically checking if a method is deterministic is hard/impossible in most imperative object-oriented languages.

While we may not expect the presence of bugs in the standard library class \Q@String@, the same behaviour can be achieved with subtyping:
\saveSpace
\begin{lstlisting}
class EvilStr extends String{
  method Bool isEmpty(){
    return new Random().bool();
  }}
...
String name=...$\Comment{can this be an EvilStr?}$
Person bob=new Person(name);
\end{lstlisting}
\saveSpace
As you can see, it is hard to make sound claims about Validation.


\item Sample Bug 2:
In our simple example, \Q@Person@ objects can be mutated using the setter, and exposed using the getter.
We may consider the getter to be safe since in modern languages we expect strings to be immutable objects.
\footnote{While we can update the field \Q@name@ to point to another string, we cannot mutate the string object itself.
To obtain  \Q@"Hello"@ from \Q@"hello"@ we need to create a whole new string object that looks like the old one except for the first character. This would be different in older languages like C, where strings are just mutable arrays of characters.}

Again, the assumption that they are immutable depends on the correctness of the code inside \Q@String@: if there was a bug in the \Q@String@ class, or any \Q@String@ subclass, then executing 
\Q@println(bob.name())@ may change \Q@bob@ by quietly changing a part of its ROG.

Again, checking
what methods mutate states cannot be responsibility of the \Q@Person@ programmer.
For Validation we need a language supporting aliasing and mutability control.


\item Sample Bug 3:
One of the advantages of checking Validation at run time, is that
we can allow the program can take corrective actions if a property is violated.
This may be implemented with a conventional \Q@try-catch@ if violations are represented by throwing errors.
However, there is an issue with exceptions modelling invalid objects: they can be captured when the invalid object is still in scope. For example:
\saveSpace
\begin{lstlisting}
 Person bob=new Person("bob");
 try{bob.name("");}catch(Throwable t){}$\Comment{ Catch and ignore invariant failure:}$
 assert bob.name().isEmpty();$\Comment{now we have a broken object around!}$
\end{lstlisting}
\saveSpace
As you can see, if we can capture Validation failures as normal exceptions (very desirable feature) then we may end up using invalid objects.
%Moreover,
% as shown before with the example of transferring cargo between two boats,
%after an invariant has been violated, even objects with valid invariant may be in an unexpected state.

This is not a special problem relevant to just Validation, but a more general issue of reasoning about the state after recovering from exceptions.
Other authors have identified the concept of Strong Exception Safety~\cite{Abrahams2000}:
when a \Q@try-catch@ captures an exception, the visible state at the start of the catch must be the same as before the \Q@try@ block started its execution.
For Validation, we only need String Exception Safety against unchecked exceptions. We will show how to obtain it using TM.
%Note how this produces a different semantics with respect to static verification, where violations
%never happened. However this will not necessarily lead to a broken semantics:
% we aim to create a system where either the application terminate
%when such a bug is identified, or where those objects and all the witnesses will be garbage collected
% (as happens in alias burying~\cite{boyland2001alias}).
%In our example, this means that to continue execution after a detected bug, 
%we would require to garbage collect the overloaded boat, their cargo and probably most of the commercial port too.
\end{itemize}








\subsection{Immutable Objects}
\label{s:immutable}
\saveSpace
Immutable objects (such as UML data types or deeply immutable objects~\cite{Potanin2013}) are the simplest category to handle, since all the ROG is immutable.
Even in this simple case Validation is challenging:
\begin{enumerate}
  \item buggy immutable objects may actually be mutable;
  \item buggy \Q@.valid()@ methods may not be pure;
  \item the \Q@this@ pointer, pointing to an invalid object, may be leaked during object
 construction levering on a mutable parameter
\item or can be leaked during Validation checking via an exception object.
\end{enumerate}

\subsubsection*{Solving Issue 1: Type Modifiers}

Type modifiers are a well known language mechanism~\cite{TschantzErnst05,BirkaErnst04,OstlundEtAl08,clebsch2015deny,GianniniEtAl16,GordonEtAl12} allowing static verification of mutability and aliasing properties of objects.
The three most common modifiers for object references are:
\begin{itemize}
\item Mutable \Q@mut@: the referred object can be mutated, as in a language without modifiers,
\item Immutable \Q@imm@: the referred object can never mutate, no matter what happens,
\item and Readable/Readonly \Q@read@: the referred object cannot be mutated by such reference, but in the program there may be mutable references to this same object, so mutation can still be observed. 
\end{itemize}
\noindent
The difference between (using Java terminology) final and non final as well as immutable and mutable can be confusing; what each of the four combinations means?
\begin{itemize}
\item A final variable or field cannot be reassigned.
It is always going to point to the same object.
However, fields of the referred object may be updated.
Final is a modifier over the variable or field, not over the reference.
\item An immutable reference refers to an object that will never mutate.
That is, its fields are never going to be updated, nor the fields of any object in its ROG.
\textbf{However, a non final variable with an immutable reference may be updated to point to another object.}%
\footnote{In C, this is similar to the difference between ``\Q@const *A@'', ``\Q@* const A@'' and ``\Q@const *const A@''.}
\end{itemize}
\noindent Consider the following  example of usage of \Q@mut@, \Q@imm@ and \Q@read@:
\begin{lstlisting}
mut Point mp=new Point(1,2)
mp.setX(3)$\Comment{ok}$
imm Point ip=new Point(1,2)
$\Comment{}$ip.setX(3)$\Comment{type error}$
read Point rp=mp$\Comment{ok read common supertype of imm/mut}$
$\Comment{}$rp.setX(3)$\Comment{type error}$
mp.setX(5)$\Comment{ok, and now we can observe rp.x()==5}$
ip=new Point(3,5)$\Comment{ok, ip not final}$
\end{lstlisting}
\noindent We cannot use a \Q@read@ reference to cause mutation, but we have no guarantee of the absence of mutation; in our example we observe a change in \Q@rp@ caused by a mutation inside \Q@mp@.
 
There are several possible interpretations of the semantics of type modifiers.
Here we assume the full/deep meaning:
\begin{itemize}
\item all the ROG from an immutable object is immutable,
\item a mutable field accessed from a read reference is seen as read,
\item no casting is allowed between different type modifiers.
\end{itemize}
\saveSpace
\begin{lstlisting}
mut Point mCenter=new Point(1,2)
mut Circle mc=new Circle(mCenter,$\MComment{radius}$7)
mc.setRadius(3)$\Comment{ok}$
imm Circle ic=new Circle(new Point(0,0),7)
imm Point ip=ic.center()$\Comment{ok, ROG immutable}$
read Circle rc=mc
read Point rp=rc.center()$\Comment{ok, read Circle show read Point}$
$\Comment{}$mut Point mp=rc.center()$\Comment{type error}$ 
\end{lstlisting}
\saveSpace
%With this kind of type system, we can ensure immutable classes by just declaring all their fields as final and immutable.%
%\footnote{
%In Java,  to ensure a class is immutable we need:
%the class must be final, all the fields must be final of immutable
%classes (thus no interface fields, final classes all the way down),
%and the SecurityManager need to properly tame reflection.}

% Not sure about this paragraph:
There are many different existing techniques and type systems that handle the modifiers above~\cite{ZibinEtAl10,ClarkeWrigstad03,HallerOdersky10,GordonEtAl12,ServettoZucca15}.
The main progress in the last couple of years is about the flexibility of those type systems: the programmer may use \Q@imm@ when dealing with objects that obviously behave like
 UML data types, and \Q@mut@ nearly everywhere else,
 and the system will be able to transparently promote/recover~\cite{GordonEtAl12,clebsch2015deny,ServettoZucca15}
 the type modifiers adapting them to the context.
To see a glimpse of this flexibility, note how in the example above \Q@imm Circle ic@ and
\Q@mut Circle mc@ are both initialized with a \Q@new Circle(...)@.
This is not a special feature of the \Q@new@ construct: any expression typed as a \Q@mut Circle@ can be promoted/recovered into \Q@imm Circle@ if it uses only immutable references.

\saveSpace
\subsubsection*{Solving Issue 2: Object Capabilities}

While type modifiers are a statically verified property of references, object capabilities are run time characteristics of specific objects.
Conceptually, an object capability is a communicable, unforgeable token of authority, a key to access special functionalities: only certain objects with ``special'' powers can do ``special'' actions, and those objects are obtained in a controlled way.
We call those objects ``capability objects''.
In a language with capabilities, we would not have \Q@System.out.println(..)@ but the \Q@main@ method will take a \Q@System@ object as a parameter, and that object has to be used to perform I/O, as in \Q@mySystem.println("hello")@.

Moreover, there is no visible constructor for the \Q@System@ object and all the I/O methods require a mutable (\Q@mut@) object.

Many other operations, like random numbers and file management may just take a \Q@mut System@ object as a parameter.

In this setting, the \Q@.valid()@ method may be defined as follows:
\saveSpace
\begin{lstlisting}
read method imm Bool valid(){...}
\end{lstlisting}
\saveSpace
The method is \Q@read@: thus the method body will see the \Q@this@ object as a \Q@read@ reference, and has no other parameters.
By starting from a \Q@read@ reference and nothing else, we are guaranteed that the method is pure:
\begin{itemize}
\item the ROG from \Q@this@ is only accessed in \Q@read@, thus it cannot be mutated,
\item nothing else is accessible (we do not have global variables),
\item if a \Q@System@ object is in the ROG of \Q@this@, then we will only access it as \Q@read@, preventing I/O.
\end{itemize}
\noindent This design space has been explored in literature by Joe-E~\cite{finifter2008verifiable}.
\saveSpace

\subsubsection*{Solving Issue 3: Constructors}
\saveSpace
Exposing \Q@this@ during construction is a generally recognized problem~\cite{gil2009we}.
A simple solution is to require all constructors to 
simply take a parameter for each field and to just initialize the fields.
An advantage of such approach is syntactic brevity: constructors are implicitly defined
by the set of fields and thus there is no need to define them manually.
\textbf{Expressive initialization operations can still be performed, by following the factory pattern.}
\saveSpace
\subsubsection*{Solving Issue 4: Exceptions}
\saveSpace
The \Q@.valid()@ method can still throw exceptions.
We think this is a good thing: we may want to generate a user friendly error message explaining the reason why the invariant is broken.
However, if such exception was to refer to \Q@this@ in its ROG, then we will allow such broken object to escape.
A simple solution solving just this issue is to require all thrown exceptions to be immutable:
\Q@this@ is \Q@read@, thus it can not be inserted in the ROG of an immutable object.
Exceptions are going to trouble our life again later in this paper:
to handle the next case a more complex solution is required.




%\subsubsection*{Recap}
%By utilising type modifiers (\Q@imm@, \Q@mut@ and \Q@read@), object capabilities and immutable exceptions we obtain sound runtime verification for immutable classes/UML data types.