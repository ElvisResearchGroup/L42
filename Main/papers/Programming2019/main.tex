\documentclass[english,submission,code=tt]{programming}
\makeatletter
\DeclareOldFontCommand{\rm}{\normalfont\rmfamily}{\mathrm}
\DeclareOldFontCommand{\sf}{\normalfont\sffamily}{\mathsf}
\DeclareOldFontCommand{\tt}{\normalfont\ttfamily}{\mathtt}
\DeclareOldFontCommand{\bf}{\normalfont\bfseries}{\mathbf}
\DeclareOldFontCommand{\it}{\normalfont\itshape}{\mathit}
\DeclareOldFontCommand{\sl}{\normalfont\slshape}{\@nomath\sl}
\DeclareOldFontCommand{\sc}{\normalfont\scshape}{\@nomath\sc}
\makeatother
\usepackage[backend=biber]{biblatex} % Use Biblatex
\addbibresource{main.bib}
\addbibresource{main.bib}
\usepackage{mathpartir}
\usepackage{amsmath}
\usepackage{amsthm}
\theoremstyle{plain}
\newcounter{theoremQ}
\newtheorem{Theorem}[theoremQ]{Theorem}
\newcounter{definition}
\newtheorem{Definition}[definition]{Definition}
\newcounter{assumption}
\newtheorem{Assumption}[assumption]{Assumption}
\newcounter{lemma}
\newtheorem{Lemma}[lemma]{Lemma}
\input{../Def/Def}
%\lstset{language=FortyTwo, morekeywords={imm,new,class,this,assert}}
\newcommand\saveSpace{\vspace{-3px}}
\newcommand\loseSpace{\vspace{1ex}}
\begin{document}
\paperdetails{
perspective=theoretical,
area={Program verification}
}
\title{Validation}
%\author{Authors omitted for double-blind review.}
\author{Isaac Oscar Gariano}
\author{Marco Servetto}
%\affiliation{Victoria University of Wellington}
%\email{marco.servetto@ecs.vuw.ac.nz}
\author{Alex Potanin}
\affiliation{Victoria University of Wellington}
%\email{alex@ecs.vuw.ac.nz}

\keywords{type modifiers, object capabilities, runtime verification, class invariants}

\begin{CCSXML}
<ccs2012>
	<concept>
		<concept_id>10003752.10010124.10010138.10010139</concept_id>
		<concept_desc>Theory of computation~Invariants</concept_desc>
		<concept_significance>500</concept_significance>
	</concept>
	<concept>
		<concept_id>10003752.10010124.10010138.10010142</concept_id>
		<concept_desc>Theory of computation~Program verification</concept_desc>
		<concept_significance>500</concept_significance>
	</concept>
	<concept>
		<concept_id>10011007.10011006.10011008.10011009.10011011</concept_id>
		<concept_desc>Software and its engineering~Object oriented languages</concept_desc>
		<concept_significance>500</concept_significance>
	</concept>
	<concept>
		<concept_id>10011007.10010940.10010992.10010998.10011001</concept_id>
		<concept_desc>Software and its engineering~Dynamic analysis</concept_desc>
		<concept_significance>300</concept_significance>
	</concept>
	<concept>
		<concept_id>10011007.10011006.10011008.10011024.10011032</concept_id>
		<concept_desc>Software and its engineering~Constraints</concept_desc>
		<concept_significance>300</concept_significance>
	</concept>
</ccs2012>
\end{CCSXML}

\ccsdesc[500]{Theory of computation~Invariants}
\ccsdesc[500]{Theory of computation~Program verification}
\ccsdesc[500]{Software and its engineering~Object oriented languages}
\ccsdesc[300]{Software and its engineering~Dynamic analysis}
\ccsdesc[300]{Software and its engineering~Constraints}

\maketitle

\begin{abstract}
\emph{Context:} % What is the broad context of the work? What is the importance of the general research area?
Object-oriented programming languages, through sub typing and dynamic dispatch provide great flexibility by allow writing of code that can be adapted/specialized to behave differently in different contexts.
However this flexibility hampers code reasoning, which is even more complicated by dynamic class loading (supported by most mainstream OO languages).
Thus object-behaviour is nearly completely unrestricted. This is further complicated with the support OO languages typically have for exceptions, imperative code, and I/O.
In the absence of on the fly static verification of dynamically loaded code, it is difficult for programmers to ensure or even write correct code.


\loseSpace
\emph{Inquiry:} %What problem or question does the paper address? How has this problem or question been addressed by others (if at all)?
We wish to guarantee that a user defined property (\emph{validity}) holds for all instances of a class: we call such guarantee \emph{validation}.

This concept is closely related to the concept of `class invariants', however, unlike validation, this allows for objects to temporarily be in a ‘broken’ state. However our work allows class invariants to be easily encoded in terms of validity. Prior work on class-invariants is typically unsound due to assumptions about library code (e.g. that they obey the Liskov Substitution Principle), or due to the trust that programmers use the provided tools correctly.
Even if sound, such prior work, particularly static analysis, typically heavily restricts such features as dynamic-class loading or the use of I/O, and are very performance costly.


\loseSpace
\emph{Approach:} %What was done that unveiled new knowledge?
We combine previous work on type-modifiers and object capabilities to ensure properties of objects and methods. 
Type-modifiers and object capabilities are useful in their own right, but we use these facilities here to ensure validation by conservatively injecting runtime-validation code.


\loseSpace
\emph{Knowledge:} %What new facts were uncovered? If the research was not results oriented, what new capabilities are enabled by the work?
By means of examples, we show how hard it is to reason on code behaviour in
the context of dynamic class loading and I/O.
Building over type modifiers and object capabilities, we lay down the foundation needed to
reason about OO code in this context.
We discuss how relaxations in type modifiers and object capabilities would break validation.


\loseSpace
\emph{Grounding:} %What argument, feasibility proof, artifacts, or results and evaluation support this work?
We provide an informal argument justifying that our language’s rules enforce validation, in particular we show that without such rules (which most languages lack) validation becomes nearly impossible. We also 
formally model a language soundly supporting validation; which is formally verified by a proof, parametric on the presence of a type system with certain properties.
Type-system’s with such properties have already been explored, formalized, and proved in prior work.


\loseSpace
\emph{Importance:} %Why does this work matter?
Validation allows the programmers to soundly reason on properties of their code.
This is of great practical importance since it is independent of the presence of buggy code, or even dynamically loaded malicious code.

Our work represents a philosophical shift similar to the jump from unchecked casts in C to checked casts in Java: it is the programmer's responsibility to create valid objects and to preserve validation
while mutating objects, however a validation failure is soundly detected by a run-time exception,
and even after capturing such an exception, validation still holds for all objects involved in the execution.

	
%TODO
%Class invariants provide guarantees about the state of objects throughout the execution.
%Runtime verification of class invariants is
%a hard problem due to issues with aliasing, exceptions,
%non-deterministic invariants, I/O, subtyping and untrusted code.
%We challenge this problem in the context of
%a Java-like language where the invariants are expressed in the language itself.
%We formally define \textbf{Sound Invariant Checking}
%and formally prove that a combination of carefully selected type modifiers, object capabilities,
% and strong exception safety is sufficient
%to handle Sound Invariant Checking for the most common categories of objects.

\end{abstract}

%\input{intro}
%\input{immutable}
%\input{encapsulated}
%\input{meaning}
%\input{related}
\input{futurework}
%\input{conclusion}

\printbibliography
%\input{appendix}
\end{document}