\documentclass[english,submission,code=tt]{programming}
\makeatletter
\DeclareOldFontCommand{\rm}{\normalfont\rmfamily}{\mathrm}
\DeclareOldFontCommand{\sf}{\normalfont\sffamily}{\mathsf}
\DeclareOldFontCommand{\tt}{\normalfont\ttfamily}{\mathtt}
\DeclareOldFontCommand{\bf}{\normalfont\bfseries}{\mathbf}
\DeclareOldFontCommand{\it}{\normalfont\itshape}{\mathit}
\DeclareOldFontCommand{\sl}{\normalfont\slshape}{\@nomath\sl}
\DeclareOldFontCommand{\sc}{\normalfont\scshape}{\@nomath\sc}
\makeatother
\usepackage[backend=biber]{biblatex} % Use Biblatex
\addbibresource{main.bib}
\addbibresource{main.bib}
\usepackage{mathpartir}
\usepackage{amsmath}
\usepackage{amsthm}
\theoremstyle{plain}
\newcounter{theoremQ}
\newtheorem{Theorem}[theoremQ]{Theorem}
\newcounter{definition}
\newtheorem{Definition}[definition]{Definition}
\newcounter{assumption}
\newtheorem{Assumption}[assumption]{Assumption}
\newcounter{lemma}
\newtheorem{Lemma}[lemma]{Lemma}
\input{../Def/Def}
%\lstset{language=FortyTwo, morekeywords={imm,new,class,this,assert}}
\newcommand\saveSpace{\vspace{-3px}}
\newcommand\loseSpace{\vspace{1ex}}
\begin{document}
\paperdetails{
perspective=theoretical,
area={Program verification}
}
\title{Validation}
%\author{Authors omitted for double-blind review.}
\author{Isaac Oscar Gariano}
\author{Marco Servetto}
%\affiliation{Victoria University of Wellington}
%\email{marco.servetto@ecs.vuw.ac.nz}
\author{Alex Potanin}
\affiliation{Victoria University of Wellington}
%\email{alex@ecs.vuw.ac.nz}

\keywords{type modifiers, object capabilities, runtime verification, class invariants}

\begin{CCSXML}
<ccs2012>
	<concept>
		<concept_id>10003752.10010124.10010138.10010139</concept_id>
		<concept_desc>Theory of computation~Invariants</concept_desc>
		<concept_significance>500</concept_significance>
	</concept>
	<concept>
		<concept_id>10003752.10010124.10010138.10010142</concept_id>
		<concept_desc>Theory of computation~Program verification</concept_desc>
		<concept_significance>500</concept_significance>
	</concept>
	<concept>
		<concept_id>10011007.10011006.10011008.10011009.10011011</concept_id>
		<concept_desc>Software and its engineering~Object oriented languages</concept_desc>
		<concept_significance>500</concept_significance>
	</concept>
	<concept>
		<concept_id>10011007.10010940.10010992.10010998.10011001</concept_id>
		<concept_desc>Software and its engineering~Dynamic analysis</concept_desc>
		<concept_significance>300</concept_significance>
	</concept>
	<concept>
		<concept_id>10011007.10011006.10011008.10011024.10011032</concept_id>
		<concept_desc>Software and its engineering~Constraints</concept_desc>
		<concept_significance>300</concept_significance>
	</concept>
</ccs2012>
\end{CCSXML}

\ccsdesc[500]{Theory of computation~Invariants}
\ccsdesc[500]{Theory of computation~Program verification}
\ccsdesc[500]{Software and its engineering~Object oriented languages}
\ccsdesc[300]{Software and its engineering~Dynamic analysis}
\ccsdesc[300]{Software and its engineering~Constraints}

\maketitle

\begin{abstract}
\emph{Context:} % What is the broad context of the work? What is the importance of the general research area?
Object-oriented programming languages, through sub typing and dynamic dispatch provide great flexibility to write code that can be adapted/specialized to behave differently in different contexts.
However this flexibility hamper code reasoning; this is further complicated by dynamic class loading.
This makes object-behaviour nearly completely unrestricted.
In the absence of `on the fly static verification of dynamically loaded code',
how can programmers write correct code?
Ideally we would like to be able to enforce that all objects of a certain type respect a certain property , specified by their type.

\emph{Inquiry:} %What problem or question does the paper address? How has this problem or question been addressed by others (if at all)?
We wish to guarantee \emph{validity}:  a user-defined property  ....***...on instances of classes always hold: we call such property ‘validation’.
We work in the context of an imperative OO language with dynamic dispatch, dynamic class loading, exceptions and I/O.

This concept is closely related to the concept of `class invariant', but 
Our work is related to the well known but weaker concept of `class invariants':
class invariants can be broken, and observed broken. They are only required to hold before and
after all public methods, while validity holds for all objects involved in execution.


%global verification - continuosly anilize and reanileze all method bodies to prove stuff
%do not require pre-post on everything 
%(no dynamic loading)

%modular verification - assume pre-post on all the other methods and on any recursive call on
%the current method and prove pre-post on the current method
%(no dynamic loading)

%limited verification aka type system work truly modular: no assumption the rest of the code is correct, just type-safe

related work on CI either is unsound (by assuming properties on library code or by trusting the programmer to
use the tools correctly)
or do not soundly support some of the following fundamental features: unrestricted dynamic class loading,
non deterministic I/O, exceptions.


%either work on trust:
%they trust that the programmer can correctly validate the object’s themselves,
%and that libraries respect their properties.
%and/or they use, or rely on static-verification 
%or extremely costly runtime-verification. 


\emph{Approach:} %What was done that unveiled new knowledge?
We combine previous work on type-modifiers and object capabilities to ensure properties of objects and methods. 
Type-modifiers and object capabilities are useful in their own right;
We ensure validation by using these facilities together and conservatively injecting runtime-validation code.



\emph{Knowledge:} %What new facts were uncovered? If the research was not results oriented, what new capabilities are enabled by the work?
By mean of examples, we show how hard is to reason on code behaviour in
the context of dynamic class loading and I/O.
Building over type modifiers and object capability, we lay down the foundation needed to
reason on OO code in this context.
We discuss how relaxations in type modifiers and object capabilities would break validation.
The technique we use for Validation is a fundamental building block that can be used 
for class invariants and pre-post conditions.

\emph{Grounding:} %What argument, feasibility proof, artifacts, or results and evaluation support this work?
We provide an informal argument justifying that our language’s rules enforce validation, in particular we show that without such rules (which most languages lack) validation becomes nearly impossible. We also 
formally model a language soundly supporting validation. This is formally verified by a proof, parametric on in the presence of a type system with certain properties.
Type-system’s with such properties have already been explored, formalized, and proved in prior work.


\emph{Importance:} %Why does this work matter?
Validation allows the programmers to soundly reason on properties of their code.
This is of great practical importance since is independent of the presences of buggy code, or even dynamically loaded malicious code.

Our work represents a philosophical shift similar to the jump from unchecked casts in C to checked casts in Java: it is the programmer's responsibility to create valid objects and to preserve validation
while mutating objects, however a validation failure is soundly detected by a run-time exception,
and even after capturing such an exception, validation still holds for all objects involved in the execution.

	
%TODO
%Class invariants provide guarantees about the state of objects throughout the execution.
%Runtime verification of class invariants is
%a hard problem due to issues with aliasing, exceptions,
%non-deterministic invariants, I/O, subtyping and untrusted code.
%We challenge this problem in the context of
%a Java-like language where the invariants are expressed in the language itself.
%We formally define \textbf{Sound Invariant Checking}
%and formally prove that a combination of carefully selected type modifiers, object capabilities,
% and strong exception safety is sufficient
%to handle Sound Invariant Checking for the most common categories of objects.

\end{abstract}

\input{intro}
\input{immutable}
\input{encapsulated}
\input{meaning}
\input{related}
\input{futurework}
\input{conclusion}

%\bibliography{main,bib}
\printbibliography
\input{appendix}
\end{document}