
\saveSpace
\section{Related work}
\label{s:related}
\saveSpace

\textit{Type Modifiers:}
We rely on a combination of modifiers that are supported by at least 3 languages/lines of research:
L42~\cite{ServettoZucca15,ServettoEtAl13a,JOT:issue_2011_01/article1,GianniniEtAl16},
Pony~\cite{clebsch2015deny,clebsch2017orca}, and Gordon's~\cite{GordonEtAl12}; 
each of these works is accompanied by proofs about the properties of those modifiers.
Since such proofs have already been done, in this work we just assume the required properties.
Those approaches all support deep/strong interpretation, without back-doors.

TM approaches like Javari~\cite{TschantzErnst05,Boyland06} and Rust~\cite{matsakis2014rust} are unsuitable since they introduce back-doors which are not easily verifiable as being used properly.
Many approaches just try to preserve purity (as for example~\cite{pearce2011jpure}), but here we also need aliasing control.
Ownership~\cite{ClarkeEtAl13,ZibinEtAl10,DietlEtAl07} is another popular form of aliasing control that can be used as a building block for static verification~\cite{%
muller2002modular,%
barnett2011specification%
}.%On ownership verification
%Peter Mueller and Arnd Peotzsch Heffter,  eg Müller, P.: Modular Specification and Verification of Object-Oriented Programs, 2002.
%M. Barnett and M. Fähndrich and K. R. M. Leino and P. Müller and W. Schulte and H. Venter: Specification and Verification: The Spec# Experience. Communications of the ACM, 2011.
\MSComm{add discussion on the work reviewrs pointed out}

%\noindent\textit{Strong Exception Safety:}
%Exception safety seems at first glance a smaller issue with respect 
%to the other two, but is the final piece that lets the whole system work in a real world setting.
%Note that state of the art type systems to enforce exception safety
% do not restrict code that do not capture errors, and
%only the point of error capturing is constrained.

\textit{Object Capabilities:}
Object capabilities~\cite{RobustComposition}, in conjunction with type modifiers, are able to
 enforce purity of code in a modular way, without requiring following a monadic style.
The Joe-E language~\cite{finifter2008verifiable} explores how to use object capabilities to ensure pure behaviour for methods.
However, in order to express Joe-E as a subset of Java, they leverage on a simplified model of immutability:
immutable classes must be final with only final fields that refer to immutable classes.
%Instances of immutable classes are immutable objects.
In Joe-E every method that only takes instances of immutable classes is pure.
%\IOComm{Worth mentioning Wyvern? Since alex mentioned that it enforces purirty? Perhaps he can write that section?}
Their model however would not allow the verification of purity for invariant methods of mutable objects.
In contrast our model has a more fine grained representation of immutable/readonly: it is \emph{reference based} instead of \emph{class based}. \IOComm {Redundent?} This means that in our model, every method taking only \Q@read@ or \Q@imm@ references as input is pure,
both in the sense that no object visible outside of the method is mutated, but also that no I/O is performed.

\textit{Class invariants protocols:}
Class invariants are a fundamental part of the design by contract methodology. 
Invariant protocols differ wildeley and can be unsound or complicated, particular due to re-entrancy and aliasing
\cite{leino2004object,drossopoulou2008unified}\IOComm{Cite bertrand meyer? He refers to these as 'referemce leaking' and 'furtive accesses'}.

%literature on class invariant accepts that sometime the object invariant may not hold,
%and that is exacerbated because of 
%Leino, K. R. M. and Müller, P.: Object Invariants in Dynamic Contexts (ECOOP), 2004.
%S. Drossopoulou and A. Francalanza and  P. Müller and A. J. Summers: A Unified Framework for Verification Techniques for Object Invariants ECOOP 2008. 
There are different options as to what object-invariants are known to hold:
\begin{itemize}
\item  when the object is in a \textit{steady} state:
 the execution is not inside any of its (non `helper'~\cite{JML}) methods~\cite{Gopinathan:2008:RMO:1483018.1483028};
 constantly maintained between calls to public methods~\cite{WikiInvariant},
\item at the start and at the end of every public method (which may or may not include recursive method calls)~\cite{Burdy2005};\MSComm{add more citations},
\item at the start and end of every \emph{qualified} call~\cite{?},
\item only when explicitly required (such as in a method contract or implied by another object's invariant) and after an explicit check (`pack') operation~\cite{?},
%\url{https://en.wikipedia.org/wiki/Class_invariant}};
%\item
%constantly maintained when the object is \textit{closed};
%invariant can be manually opened and closed by using special operations; % Add cite here!
\item or, as in this work, when an object could be \emph{involved} in execution.
\end{itemize}
Those different protocols are deceivingly similar, and 
some approaches like JML suggest verifying a simpler approach (that method calls preserve the invariant of the \emph{receiver}) but assume a more powerful one (the invariant of \emph{every} object except the receiver holds).

% use the unsound option of assuming one protocol, but actually checking another.

%DONE IN INTRO breaking class invariants = bug in class code
%braking validation= DEPEND.

%To encode this range of invariant semantics
%in our approach we can add a boolean \Q@isOpen@ field and add \Q@this.isOpen || ..@
%in front of the validity condition.
%Validation can be used to manually encode complex scenarios,
%for example if a method called on an object needs to break the invariant of another object,
%it can do so by manually setting the \Q@isOpen@ flag on the other object.


%On ownership verification
%Peter Mueller and Arnd Peotzsch Heffter,  eg Müller, P.: Modular Specification and Verification of Object-Oriented Programs, 2002.
%M. Barnett and M. Fähndrich and K. R. M. Leino and P. Müller and W. Schulte and H. Venter: Specification and Verification: The Spec# Experience. Communications of the ACM, 2011.

\newcommand\sepItems{\saveSpace\saveSpace\saveSpace\\*${}_{}$\\*${}_{}\,\bullet\,$}

\LINE

\textit{Runtime verification tools:}
Many languages and tools support some form of runtime invariant checking (e.g. Eiffel~\cite{Meyer:1992:EL:129093}, D~\cite{Alexandrescu:2010:DPL:1875434}
and JML~\cite{Burdy2005}).
By looking to a survey by Voigt et al.~\cite{Voigt2013} and the extensive MOP project~\cite{meredith2012overview},
it seems that most runtime verification tools (RV) empower users
to implement what kind of monitoring they see fit for their specific problem at hand. This means that users are responsible for deciding, designing, and encoding both the logical properties and the instrumentation criteria\cite{meredith2012overview}.
In the context of object-invariants, this means the user defines the invariant protocol, and the soundness of such protocol is not checked by the tool.

In practice, this means that the logic, instrumentation, and implementation end up connected:
a specific instrumentation strategy is only good to test certain logic properties in certain applications.
No guarantee is given that the implemented instrumentation strategy is able to support the required logic in the monitored application.
Some of those tools are designed to support class invariants: for example InvTS~\cite{gorbovitski08efficient} lets you write Python conditions that are verified on a set of Python objects, but the programmer needs to be able
to predict which objects are in need of being checked and to use a simpler domain specific language to target them. Hence if a programmer makes a mistake while using this domain specific language, invariant checking
will not be triggered.
Some tools are intentionally unsound and just perform invariant checks following some heuristic that is expected to catch most of failures: jmlrac~\cite{Burdy2005} and Microsoft Code Contracts~\cite{fahndrich2010embedded}.

\IOComm{Put this in Gui section a footnote: whose heuristic also run the invariant checking $77$ times on our GUI case study}

%In particular, the heuristic of 
%We encoded our GUI example also on Microsoft Code Contract; their system also ran the invariant checking $77$ times. Their system is easy to use, but it is unsound since it is built over an unsound/incomplete static verifier~\cite{?}.






%
%In this work we define a language where a minimal, standardized,
%efficient and completely general purpose instrumentation strategy can soundly verify conditions
%expressible as a\\* \Q@read method imm Bool invariant()@, for any well-typed program; with open world assumption
%and possible Byzantine behaviour of any object in the system.
%
%By seeing class invariant as a part of the type of the object,
%the `RV tool' philosophy is akin to letting the programmer customize the behaviour of the
%type system: the programmer implementation may be unsound; while our philosophy is
%to give the user a way to represent complex and expressive types (in the form of arbitrary code in 
%the \Q@invariant()@ method), but 
%the type system implementation is fixed in stone by the language designer.

Many works attempt to move out of the `RV tool' philosophy to ensure RV monitors work as expected, as for example%
%\sepItems
%In avionics, where memory allocation is disallowed, making reasoning about aliasing much simpler~\cite{laurent2015assuring}:
%``\emph{Runtime Verification (RV) can act as the last line of defense to
%protect the public safety, but only if the RV system itself is trusted.}''.
%\sepItems
%In domain specific languages~\cite{ferrari2002guardians}:
%``\emph{Proof techniques for establishing security properties}''.
%\sepItems
%On assertions over restrictive domain specific languages, to tame some of the C/C++
%undefined behaviour~\cite{agten2015sound}:
%``\emph{no verified assertion in the verified
%module will ever fail at runtime, even if the module runs as part of
%a vulnerable application thSound and Unsound monitorsat is subject to code injection attacks}''.
the study of contracts as refinements of types~\cite{findler2001contract}, focusing only on pre and post conditions in OO languages.

Gopinathan \&al.'s.~\cite{Gopinathan:2008:RMO:1483018.1483028} approach keeps invariants under tight control:
relying on powerful aspect-oriented support, they detect any field update in the whole ROG of any object, and check all the invariants that such update may have violated.
They argue against any variation of visible state semantic, where  methods still have to assume that any object may be broken; in such case calling any public method would trigger an error, but while the object is just passed around (and for example stored in collections), the broken state will not be detected.
``\emph{there are many instances where $o$'s invariant is violated by the programmer inadvertently changing the state of $p$ when $o$ is in a steady state. Typically, $o$ and $p$ are objects exposed by the API, and the programmer (who is the user of the API), unaware of the dependency between $o$ and $p$, calls a method of $p$ in such a way that $o$'s invariant is violated. The fact that the violation occurred is detected much later, when a method of $o$ is called again, and it is difficult to determine exactly where such violations occur.}''

However, their approach addresses neither exceptions nor non-determinism caused by I/O, so their work is unsound when those aspects are took in consideration.

Their approach is very computationally intensive, but we think it is powerful enough that it could even be used to roll-back the very field update that caused the invariant to fail, making the object valid again.
We considered a roll-back approach, however rolling back a single-field update is likley to be completley unexpected, rather we should roll back more meaningful operations, similarly to what happens
with transational memory. As with transactional-memory, this is likely to be very hard to support efficiently.
%However we think roll-back this would be a 
%\REVComm{\REVComm{terrible}{2}{It seems in poor taste to complain of ``terrible'' ideas, especially without attempting to demonstrate the improvements of the proposed approach.}}{3}{Nontechnical term. It is not a great idea to label previous work as ``terrible''}
% ideally not only the field-update breaking the invariant should be reverted, %the roll-back should 
Using TMs to enforce strong exception safety is a much simpler alternative, providing the same level of safety, albeit being more restrictive (namely that if the operation did succeed it is still effectively rolled-back).

%: for example
%assume that we are moving object between two boats:
%the overflowing object may be removed from the \Q@cargo@ of the second boat, but it would not
%be placed back in the first boat. It would look like the object has disappeared.
%The important pTheir approach is very computationally intensive, but we think it is powerful enough that it could even be used to roll-back the very field update that caused oint here is that the program would be in an unexpected state
%even if no object invariants are violated, and this would happen \textbf{because} of the 
%invariant checking/fixing behaviour, not because of code written by the programmer.
%We believe that the only viable option is to detect violations after the fact.
\LINE
\IOComm{ADD THOSE TO PERFORMANCE EIFFEL,D\cite{feldman2006jose,fahndrich2010embedded,abercrombie2002jcontractor,tran2003design}}

%\noindent\textit{Performance}
%Our case study shows that our sound approach can monitor programs
%for a fraction of the cost of many other approaches.
%Many other works%
%~\cite{feldman2006jose,fahndrich2010embedded,abercrombie2002jcontractor,tran2003design}
% check/run
%the invariant code at the start and end of every public
%method; this even include trivial getters.
%In  our approach, we call the \validate{} method
%one time at the end of each setter, capsule mutator method and constructor.
%We do not inject it at the end of other methods, which are usually more numerous and invoked much more often.
%Of course, \validate{} can still be called indirectly, for example by calling a setter.
%We expect our approach to result in a dramatic reduction over the number of required checks,
%except for cases when public methods just update many fields directly (without using setters).


\LINE


\noindent\textit{Security and DMZ:}
Static verification lets us reason about a complete program
and verify its correctness.
Traditional static verification is like a mathematical proof: a program is valid if it is all correct,
but a single error invalidates all the claims.
Thus, it is hard to perform verification on large programs, or when independently
maintained third party libraries are involved.
%\REVComm{
%To solve this issue, static verification systems are %starting to
%}{2}{[is this correct?] verification of reference %monitors, gradual typing, and contracts have been %explored for longer}
To soundly verify code embedded in an untrusted 
environment, it is possible to 
consider a verified core
and a run-time verified boundary.
You can see our approach as an extremely modularized version of such system:
every class is its own demilitarized zone, and the rest of the code 
could have Byzantine behaviour.
Our formal proofs 
shown that every class that compiles/type checks is soundly validated
independently of the code that uses this class or any other surrounding code.
Our approach works both with an open world assumption and in a library setting.
Consider for example the work of Parkinson~\cite{parkinson2007class}:
in his short paper he verified an \Q@Observer@ class invariant over
a \Q@Subject/Observer@ pattern.
However, the proof relies on the method \Q@Subject.register(Observer)@ respecting its contract.
Such assumption is unrealistic in a real system with dynamic class loading,
and this invariant could trivially be broken by a user defined \Q@EvilSubject@.


\noindent\textit{Dedicated specification language or underling language:}
Using a specification languages near to the logic and disjointed from a specific language's
semantics may seem attractive, however
a study~\cite{chalin2007logical} discovered that developers expect
the specification language to use the semantics of the underling language, including
short circuit semantics and arithmetic exceptions; thus for example
\Q@1/0 || 2>1@
should not hold, while 
\Q@2>1 || 1/0@ should hold thanks to short circuit semantics.
This study was influential enough to convince JML to change its interpretation of logical expressions
accordingly~\cite{chalin2008jml}.
We believe this is evidence that using a method in the underlying language to encode the validation is
a developers-friendly solution.



${}_{}$\sepItems
Works over C\# recognize the need
for purity/determinism when method calls are allowed in contracts~\cite{barnett200499}
``\emph{There are three main current approaches: a) forbid the use of functions in specifications, b) allow only provably pure functions, or c) allow programmers free use
	of functions. The first approach is not scalable, the second overly restrictive and
	the third unsound.}''\\*
They recognize that many tools unsoundly use option (c), such as AsmL~\cite{barnett2003runtime}.
They propose a concept of observational purity, that if completely fleshed out
could possibly be a great addition to our proposed type system.
We speculate that some 
primitive language support may be needed, for example implementing the Flyweight pattern 
as part of the language semantics.


%1 aliasing control
%  example hamster can be broken with those 2 lines
%2 I/O /determinism
%  hamster EvilPoint with random equal is accepted
%3 exceptions
%  spec sharp is happy to be unsound with capturing %unchecked exceptions
%---
%*TMs, OCs
%
%*expand on invariant protocol
%
%*RV tool
%------------
%*spec# unsond, parkinson critique, and static %verification is like math proof
%
%*Soundness or not
%
%*C#purity, dedicate spec language



%\noindent\textit{Theorem provers and SAT solvers}
%Rather than providing a simple set of rules as to what a \Q@validate@ method can contain,
%and where to insert calls to it, we could instead rely on implementation-specific static analysis:
% in which a \Q@validate@ method is valid iff the compiler can prove that it is deterministic
% and that it’s generated \Q@validate()@ calls are sufficient to enforce validation.
%Though approaches like this are frequently used such as with unifying Java’s generic-wildcards [], Rust’s ‘borrow checker’, …; we believe that would not produce a good result for our purposes: 
%\begin{itemize}
%	\item it would mean that a programmer would have no way of telling whether their code would compile, in particular code compiling would depend on the specific compiler (version) used.
%	\item the runtime cost of validation would be completely unpridictibable; since it is deterministic there is nothing stopping the compiler from calling \Q@validate@ any number of times, and at any point in time.
%	\item When a validation error could be throw would likewise be unpredictable, though it should happen after an object is made invalid\footnote{technically our definition of validation technically allows the error to happen sooner, as long as it’s not too late; however pre-emptive errors like this would be extremely hard to debug}, it could happen any time before it’s use. Making matters worse, if multiple object’s would be invalidated before either is used, which one’s error would be thrown is unconstrained
%	\item This approach will not work well in the pressence of dynamic code loading, in particular it woud likley significantly slow down such loading or spurioslly fail depending on what other code has been loaded
%\end{itemize}



%Conclusions? future work?
%@StrongExceptionSafety is 
%a very strong property,
%and some languages may be unwilling to commit to always preserve it.
%In particular, depending on the details of a specific language
% releasing resources as in \Q@finally@ blocks may require
%some relaxation of @StrongExceptionSafety. Sound releasing of resources could be interesting
%future work.
