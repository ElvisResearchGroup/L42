\saveSpace
\subsection{Simple Objects}
\label{s:simple}
\saveSpace
A simple object is an object whose fields are all of type \Q@imm T@.
The difference with respect to the UML data type is that such fields are not required to be final, and thus the object can change state during its life time.
This means that all the ROG (except the object itself) is
immutable.
The simplified \Q@Boat@ example at the start, is a Simple object.
Of course now we introduced type modifiers, so we should write the \Q@Boat@ class as:

\begin{lstlisting}
class Boat{
  read method imm Bool invariant(){return !this.name.isEmpty();}  
  imm String name;
  read method imm String name(){return this.name;}
  mut method Void name(imm String that){this.name=that;}  }
\end{lstlisting}

We can generate code and inject \Q@invariant()@ checking
following the same procedure for simple objects and
for immutable objects:
\begin{itemize}
\item Fields are made be private.
%All the 
%The programmer cannot access a field directly.
%Not even using the \Q@this@ reference.
Fields are also not accessible by reflection or other mechanisms.
\item A constructor taking the fields and initialising them is generated.
Such constructor checks the invariant.
There are no other constructors.%
%\footnote{This does not restrict the expressive power, if the programmer wants a more expressive
%way to build objects, static factory methods can be used.}
%\item For each non final field, a setter is generated;
\item For every occurrence of a field update
in the code of the class, the invariant is checked after the setting.
\end{itemize}
Thus the complete code (generated by the language compiler) would be the following:

\begin{lstlisting}
class Boat{
  read method imm Bool invariant(){return !this.name.isEmpty();}
  private imm String name;
  read method imm String name(){return this.name;}
  mut method Void name(imm String name){
    this.name=name;
    if(!this.invariant()){throw $\MComment{error}$}
    }
  public Boat(imm String name){
    this.name=name;
    if(!this.invariant()){throw $\MComment{error}$}
  }}$\Comment{Generated code, not directly written by the programmer}$
\end{lstlisting}


\noindent
\textit{Exception Safety:}
Without special care about exceptions, 
this code could be be broken;
consider the following example (already shown in the introduction)
may expose a corrupt object 
if we capture either the invariant failure or any other exception
that could be leaked by the invariant method.
\saveSpace\begin{lstlisting}
 mut Boat b=new Boat("Mary");
 try{b.name("");}catch(Throwable t){}$\Comment{catch and ignore exceptions}$
 assert b.name()==""$\Comment{now we have a corrupt object around!}$
\end{lstlisting}
\saveSpace
%A solution, proposed on []%lombock mailing list % MARCO FIND CITE
As explained before, we refrain from fixing objects, since that may cause unintended behaviour.
%Moreover, fixing a broken object in a standard way looks like sweeping the issue under the rug.

To solve this problem at the root, we propose to enforce the concept of strong exception safety:
if an operation throws an exception, then no mutation performed in the \Q@try@ is visible outside of the \Q@try@.
Following the general idea of Lagorio et al~\cite{JOT:issue_2011_01/article1}, from a type perspective, we can leverage on modifiers and type the body of a \Q@try@ where all free variables of type \Q@mut@ will be seen as \Q@read@.
This means that we need to capture exceptions either very close to a non-mutating operation that can throw them, or very far in the stack, where all the potentially corrupt objects are guaranteed to be garbage collected if the \Q@try@ fails.
Thus, our example would look as follows:
\saveSpace
\begin{lstlisting}
 mut Boat b=new Boat("Mary");
 try{b.name("");}$\Comment{type error}$
$\Comment{try block mutates an object visible outside of it}$
\end{lstlisting}
\saveSpace
And a possible fix could be to declare \Q@b@ inside of the try:
\saveSpace\begin{lstlisting}
 try{
   mut Boat b=new Boat("Mary");
   b.name("");
 }catch(Throwable t){}$\Comment{catch and ignore exceptions}$
 $\Comment{b is now garbage!}$
\end{lstlisting}
\saveSpace
Note how the problem originates from a field update.
In the former case of immutable objects this
issue do not arise.
The invariant is checked in the constructor only, and exiting from such scope will ensure that the newly created object is now ready for garbage collections.


%Note how this technique is sound only because we can rely on immutability
%of \Q@Int@, \Q@Str@ and on puritiy of all their methods.