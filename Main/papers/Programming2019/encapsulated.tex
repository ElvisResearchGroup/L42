\saveSpace
\section{Validating encapsulated state}
\label{s:encapsulated}
\saveSpace
%Suppose we wanted to have a type and mutate it's state, but have such mutation's validated:


%It is very common for an object to be logically defined by the composition of sub-objects.
%The head object would then driving mutation of the sub-objects, and public methods
%of the sub-objects may be used in the validation. 
% However, the sub objects may come from a third party library, that is not annotated with contracts, and the %authors may change their behaviour in the future. Worst, they actual dynamic type may be dynamically loaded
%so that there is no way to predict their behaviour.
%That is, we are unable or unwilling to constrain sub-objects to
% cooperate into verification. We aim for verification to be correct independently of
% possibly buggy, possibly even malicious sub-objects.


Consider code managing shipping of items:
\saveSpace
%shipping list /UPS cost too much over 300
\begin{lstlisting}
class ShippingList {
  imm Int capacity; // how much weight the ship can withstand
  mut Items items;
  ShippingList(mut Items items) {this.items = items;}
  read method imm Bool validate() {	// too heavy and the ship may sink
    return this.items.weight() <= this.capacity;
  }
  mut method imm Void addItem(imm Item item) {this.items.add(item);}
}
\end{lstlisting}
\saveSpace
At first glance this class looks easy to validate, just insert calls to validate at the end of the constructor and the \Q@addItem@ method.
However, the \Q@mut Items cargo@ field makes this code broken in two distinct ways.
Firstly, the cargo we receive in the constructor may be already compromised:
\saveSpace
\begin{lstlisting}
mut ShippingList l = new ShippingList(evilAlias);
// l is ok now, but we can break it
evilAlias.addItem(new HeavyItem()); // l is now invalid as the item's are too heavy
// how can we discover it and give error?
\end{lstlisting}
\saveSpace 
Secondly, even if the \Q@ShippingList@ has full control at initialization time, such control may be lost later:
\saveSpace
\begin{lstlisting}
mut ShippingList l = new ShippingList(new Items());
// l is ok now
mut Items evilAlias = l.items // here l loses control
// l is still ok
evilAlias.addItem(new HeavyItem()); // we invalidated l now
\end{lstlisting}
\saveSpace
% However, as the constructor takes a \Q@mut Items@ 
As you can see it is possible for external code with no knowledge of the \Q@ShippingList@ to mutate its items.

Conventional ownership solves these problems by requiring a deep clone of all the data the constructor takes as input, as well as all exposed data (such as via getters).
Such solution need to be employed in mainstream languages like Java/C\#:
in order to write correct library code
defensive cloning~\cite{Bloch08} is needed.
For performance reasons, this is hardly done in practice and is a continuous source of bugs and unexpected behaviour.

To avoid this performance bottleneck, we can leverage on the well known \Q@capsule@ type modifier[], where:
\begin{itemize}
\item Everything in the ROG (including itself) of a capsule reference is mutable only through that reference; however immutable references can be freely shared across capsule boundaries.
As a relaxation over previous work where capsules are `balloons'~\cite{Almeida97,ServettoEtAl13a} in the object graph, the ROG of a \Q@capsule@ can also be referenced as \Q@read@ from outside:
 for the purposes of validation we only need to restrict mutation.
\item A capsule local variable can only be used once as \Q@capsule@ or \Q@mut@.
%An expression that uses a capsule variable may only use it as a \Q@capsule@ or \@mut@ once,
%\item An expression of a \@capsule@ type can be implicitly promoted to \@mut@,
\item A field of a \Q@capsule@ type must be instance-private; that is only accessible as \Q@this.fieldName@ within an instance method.
\item An expression of a \Q@mut@ type that uses no \Q@mut@ variables declared outside can be implicitly promoted to \Q@capsule@.
\item Only a capsule expression can be used to initialize or update a \Q@capsule@ field.
\item A capsule field access inherits the type modifier of the receiver.
\end{itemize}

%This is to ensure the capsule doesn't `leak', potentially violating it's exclusivity,
\noindent Capsule references are usually expressed using linear/affine types~\cite{Boyland01} when they are passed around and manipulated. Existing work either does not include handling of capsule fields~\cite{ServettoEtAl13a,ServettoZucca15} or leverages on destructive reads.\cite{GordonEtAl12,clebsch2015deny}.
Destructive reads would be a bad idea for validation as they would likely invalidate objects.

In addition to the above we put restrictions on any \Q@mut@ and \Q@capsule@ methods using a \Q@capsule@ field (we call such methods `capsule mutators'):
\begin{itemize}
\item only a single use of \Q@this@ is allowed (and is the one that uses the field),
\item no \Q@mut@ or \Q@read@ parameters are allowed (apart from the implicit \Q@this@ parameter)
\item and the return type cannot be \Q@mut@.
\end{itemize}
\noindent  Moreover, if the used capsule field is referenced in \Q@.validate()@, a \Q@this.validate()@ call is injected at the end of the method.
Using the capsule field, our \Q@ShippingList@ class would, after automatic insertion of validation checks, could be modified to:
\saveSpace
\begin{lstlisting}
class ShippingList{
  imm Int capacity; // how much weight the ship can withstand
  private capsule Items items;
  ShippingList(capsule Items items) {
    this.items = items; // mutation of capsule field
    if (!this.validate) {throw Error(...);} // check at end of constructor
  }
  read method imm Bool validate() {	// too heavy and the ship may sink
    return this.items.weight() <= this.capacity;
  }
  mut method imm Void addItem(imm Item item) {
    this.items.add(item); // mutation of a capsule field
    // check at end of capsule mutator
    if (!this.validate) {throw Error(...);}
}}
\end{lstlisting}
\saveSpace

\noindent The previous restrictions ensure that capsules are essentially an exclusive mutable reference.
Removing those restrictions would make validation unsound; for example, if we allow for a \Q@mut@ return type, this example would be accepted:

\saveSpace
\begin{lstlisting}
mut method mut Items exposeItems(imm C c) {
  return c.foo(this.items);
}
\end{lstlisting}
\saveSpace
\noindent However, depending on dynamic dispatch on \Q@c@, \Q@c.foo()@ may just be the identity function.
Static analysis is usually unable/unwilling to track precise behaviour of dynamic dispatch.

\noindent Allowing \Q@this@ to be used more then once can also cause problems:
\saveSpace
\begin{lstlisting}
mut method imm Void multiThis(imm C c) {
  read Foo f = c.foo(this);
  this.items.add(new HeavyItem());
  f.hi(); // can it observe a broken this?
}
\end{lstlisting}
\saveSpace
\noindent If the former code was accepted, depending on dynamic dispatch on \Q@c@,
the reference to \Q@this@ may be reachable from \Q@f@, thus \Q@f.hi()@ may observe a broken object.
In order to ensure that a second reference to \Q@this@ is not reachable through the parameters we only accept \Q@imm@ and \Q@capsule@ parameters.
If we were however to accept a \Q@read@ parameter, as in the example below,
we would be in the same situation as the former example, where \Q@f@ may contain
a reference to \Q@this@.
\saveSpace
\begin{lstlisting}
mut method imm Void addHeavy(read Foo f) {
  this.items.add(new HeavyItem())
  f.hi() // Can `this' be observed here?
}
...
mut ShippingList l = new ShippingList();
read Foo f = new Foo(l);
l.addHeavy(f); // We pass another reference to `l' through f
\end{lstlisting}
\saveSpace

%, we would have the same problem with a \Q@read@ paramater. ... justify why we ned capsule
% The boat will sink if the weight of the cargo goes over 300. However, 
% \Q@Item@ and \Q@Items@ come from a third party library,  are not annotated with contracts and the authors may change their behaviour in the future. 
% All the code using \Q@Boat@  (client code) would like to  assume the boat has not sunk yet.
% In turn, that depends on the behaviour of \Q@Items.weight()@, thus the meaning of the \Q@Boat@ invariant is parametric on the everchanging meaning of  \Q@Items.weight()@.
% Can the code in the \Q@Boat@ class somehow enforce that for every possible well typed \Q@Item@ and \Q@Items@, client code will interact only with valid (non sunk)  boats?
% That is, we are unable or unwilling to constrain \Q@Item@ and \Q@Items@ to
% cooperate into making \Q@Boat@s unsinkable; 
% we aim to make so that \Q@Boat@s can be correct independently of
% possibly buggy, possibly even malicious \Q@Item@ and \Q@Items@ implementations.
% Indeed, thanks to the encapsulation, any kind of check in the language,
% as in `\Q@if(cargo.weight()>=300){..}@', would delegate the 
% behaviour to untrusted code in \Q@Items@.

% \textbf{without any knowledge about the behaviour of \Q@add()@ and \Q@weight()@}
% \footnote{A statically verified system with contracts on all methods may have this kind of knowledge.}
% there is no way we can discover the invariant violation without actually adding the objects and checking the 
% weight after the fact; thus in the general case violations can only be detected 
% when a broken object is already present in the system.
% Remember that to keep our approach lightweight,
% we do not rely on pre-post conditions; thus
% the behaviour of \Q@Items.weight()@ and \Q@Items.add(item)@ is uncertain.
% The names may suggest a specific behaviour, but there is no contract annotated on such methods.

% Note also that in the general case there is no way to fix a broken object,
%or to perform a deep clone and to test the operation on the clone first.


%REWRITE THIS BIT
%Here capsule fields 
%as input to our code-generation / \Q@validate()@-injection; that is, \Q@capsule T f@ is expanded by the language into:
%\begin{itemize}
%\item Induce a \Q@capsule@ parameter for the generated %constructor.
%\item Require to be updated with a \Q@capsule@ expression.
%\item Are accessed as a \Q@mut@ field.
%Access is \textbf{not} a destructive read.
% However methods accessing them are kept under
%strict control; either
%\begin{itemize}
%\item they have \Q@read this@: they act like a normal %getter, and can not propagate
%writing permission over the ROG of that field.
%Indeed, with \Q@read this@, any field access \Q@this.f@ will be typed \Q@read@ or \Q@imm@.
%\item they have \Q@mut this@, no parameter is \Q@mut@ or \Q@read@,
%the return type is not \Q@mut@ and \Q@this@ appear exactly one time in
%the method body: we call those methods \textbf{exposers}, and the invariant is going to be checked at the end of
%the exposers.
%\end{itemize}


%\end{itemize}
%Exposers are the key part of our solution.


% Those restrictions also enforce that while executing a capsule-mutator no object outside the ROG of \Q@this@ can be mutated, and thus capability objects cannot be usedI/O can not be performed: the capability objects are externally visible mutable objects and thus the type system will never place them into a \Q@capsule@.
%\subsection{The true expressibility of capsule modifiers}
%A capsule mutator method is a wrapper of a logical operation on a field, which is guaranteed to not see the \Q@this@ object.
%Thus, if \Q@this@ where to become broken during 
%the method's execution, we could not observe it until after. At first glance, it may seams that capsule %mutators allows for limited kinds of mutations.
%This is however not the case, consider the following
%general capsule mutator method that allows to apply any possible transformation over the content of a capsule %field:
%At first glance it mayseem from

\loseSpace
\noindent\textit{The transform pattern:}
A simple pattern to allow flexible use of capsule fields is to define a \Q@.transform()@ function and a \Q@ItemTransformer@ interface\footnote{A real language could
provide a generic \Q@Transformer@ interface and allow to auto-generate the \Q@.transform()@ function, similarly to auto-generating getter/setters.} like so:


%interface Foo{ma mb}
%
%class Raw implements Foo{
%  no validate 
%}
%class ValidFoo1 implemens Foo{
%  private capsule Foo inner;
%  ma(){
%    this.inner.ma();
%  }
%  validate
%}
%
%
%class Raw {
%  mut method mut A stuff(read A a) {
%      if a.bar() {
%         x = ...
%      }
%      return new A(x)
%  }
%
%  read method imm Object stuffPre(read A a) {
%     return a.bar()
%  }
%  read method mut A stuffPost(imm Object o) {
%     return new A(x)
%  }
%  mut method imm Object stuffInner(imm Object) {
%      x = ...
%  }
%}
%class ValidFoo1 {
%	cpasule Raw r;
%  mut method mut A stuff(read A a) {
%     imm Object p = this.r.stuffPre(a);
%     imm Object res = this.transformR(r -> r.stuffInner(p));
%      return this.r.stuffPost(res)
%  }
%}
%
%
%
%class ValidFoo2 implemens Foo{
%  private capsule Foo inner;
%  validate
%}

\saveSpace
\begin{lstlisting}
interface ItemTransformer { 
  imm method imm Void transform(mut  items);
}
class ShippingList {
  ...
  mut method imm Void transformItems(imm ItemTransformer t) {
   t.transform(this.items);
   if (!this.validate) {throw Error(...);}
}}
\end{lstlisting}
This \Q@.transformItems()@ method 
has a similar expressive power to provide a
\Q@mut@ getter, but ensures that 
the field content cannot leak out.
For example:
\begin{lstlisting}[escapechar=\%]
imm Void method imm Void doStuff(read C c) {
  imm Item i = c.getItem()
  // Lambda Expression that creates a new ItemTransformer
  this.transformItems(items -> {
    items.add(i); // Ok, can capture `i' because it is `imm'
    %\Comment{}%this.items.add(i);
    // Cant instead capture `this': it can't be typed as `imm'
    // since `ItemTransformer.transform()' is an `imm' method
  })
}
\end{lstlisting}
%  // instead of:
  %\Comment{}%this.exposeItems().add(i)

Note that since \Q@.doStuff()@ does not access a capsule field but merely calls a method that does;
\Q@.doStuff()@ is not a capsule mutator method, so it is not constrained by the restrictions on capsule mutators. Code like the above would also allow one to mutate multiple capsule fields in one method, however each mutation must be completed in a separate way.%
%,  i.e. they can't see or update the other capsule fields.


\loseSpace
\noindent\textit{The box pattern:}
At first glance it would seam that by only being able to validate immutable and encapsulated state one could not create validated classes with complicated, mutable interconnected object graphs, such as with a doubly linked list type:
\begin{lstlisting}[escapechar=\%]
class List {
  mut List prev;
  mut List next;
  imm Object elem;
  
  read method imm Bool innerValidate() {
     ... // Check on this, this.prev and this.next
  }
}
\end{lstlisting}
Clearly the \Q@mut@ fields of \Q@List@ cannot be marked as \Q@capsule@ since we would would want \Q@this.next.prev == this@.
However, we would like \Q@.innerValidate()@ to be the \Q@validate@ method for \Q@list@, but we can’t do so since we would wan’t it to check (among other things) that \Q@this.next.prev == this@, the solution is to use a `box' over our \Q@List@ which we construct so that it can be validated:

\begin{lstlisting}[escapechar=\%]
class ListBox { 
  capsule List inner;
  read method imm Bool validate() { return this.inner.innerValidate(); }
}
\end{lstlisting}
We would also want to create forwarding methods in \Q@ListBox@ for all public methods defined in \Q@List@. This approach allows the validation of many interesting and practically useful data-structures.
However the limitations of capsule mutator methods means that 
Any \Q@mut@ methods in \Q@ListBox@ taking \Q@read@ or \Q@mut@ parameters or returning \Q@mut@, cannot be trivially forwarded.

% since they necessitate mutating a \Q@capsule@, instead complicated and involved forwarding would be needed, if it is even possible.
Our example is about a list of immutable objects.
To validate a list of mutable objects we would need to use our box pattern not just around the list,
but around a section of data encapsulating both the list and all the contained elements.
This is because our simple \Q@capsule@ modifier requires the whole ROG to be encapsulated.
Conceptually, it would be better for the list (of mutable objects) to be validated by its
head, since the behaviour of the contained objects is transparent to the validation criteria. 
This corresponds to full encapsulation and contrasts with flexible encapsulation as in 
ownership~\cite{ClarkeEtAl98}. However, neither traditional flexible encapsulation/Ownership nor our language are capable of verifying that \Q@List.elem@ is not (indirectly) referenced within \Q@ListBox.validate()@.

