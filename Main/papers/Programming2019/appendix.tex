\appendix
\section{Proof} 
\label{s:proof}

\begin{theorem}[Sound Validation]
	if $c:\Kw{Cap};\emptyset\vdash \e: \T$ and
	$c\mapsto\Kw{Cap}\{\_\}|\e\rightarrow^+ \sigma|\ctx_v[r_l]$, then
	either $valid(\sigma,l)$ or $\mathit{trusted}(\ctx_v,r_l)$.
\end{theorem}

We believe this property captures very precisely our statement in Section~\ref{s:validation}.

It is hard to prove Sound Validation directly,
so we first define a stronger property,
called \emph{Stronger Sound Validation} and
show that it is preserved during reduction by means of conventional 
Progress and Subject Reduction (Progress is one of our assumption,
while Subject Reduction relies heavily on SubjectReductionBase).
That is,
Progress+Subject Reduction $\Rightarrow$ Stronger Sound Validation,
\\*and Stronger Sound Validation $\Rightarrow$ Sound Validation.

\subsection{Stronger Sound Validation $\Rightarrow$ Sound Validation}

Stronger Sound Validation depends on 
$\mathit{wellEncapsulated}$, $\mathit{monitored}$
and $OK$:

\noindent\textbf{Define} $\mathit{wellEncapsulated}(\sigma,\e,l_0)$:\\*
\indent$\forall l \in \mathit{erog}(\sigma,l_0), \text{not}\ \mathit{mutatable}(l,\sigma,\e)$

\noindent The main idea is that an object is well encapsulated if its encapsulated state is safe from
modification. 

\noindent\textbf{Define} $\mathit{monitored}(\e,l)$:\\*
\indent$\e=\ctx_v[M(l,\e_1;\e_2)]$ and either $\e_1=l$ or $l$ is not inside $\e_1$.

\noindent An object is monitored if the execution
is currently inside of a monitor for that object, and
the monitored expression $\e_1$ does not
contains $l$ as a \emph{proper} subexpression.

A monitored object is associated with an expression that can not observe it, but may 
reference its internal representation directly.
In this way, we can safely modify its representation before checking for the invariant.

The idea is that at the start the object will be valid and $\e_1$ will contain $l$;
but during reduction, the $l$ reference will be used in order to
give access to the internal state of $l$; only after that moment, the object may become invalid.


\noindent\textbf{Define} $OK(\sigma,e)$:\\
\indent $\forall l\in\dom(\sigma)$
  either\\
\indent\indent 1. $\mathit{garbage}(l,\sigma,\e)$\\
\indent\indent 2. $\mathit{valid}(\sigma,l)$ and $\mathit{wellEncapsulated}(\sigma,\e,l)$\\
\indent\indent 3. $\mathit{monitored}(\e,l)$

Finally, the system is in a valid state with respect to validation
if for all the objects in the memory, one of these 3 cases apply:
%the class of the object has no invariant method;
the object is not (transitively) reachable from the expression (thus can be garbage collected);
the object is valid, and the object is encapsulated;
or the object is currently monitored.

\begin{theorem}[Stronger Sound Validation]
if $c:\Kw{Cap};\emptyset\vdash \e_0: \T_0$ and
$c\mapsto\Kw{Cap}\{\_\}|\e_0\rightarrow^+ \sigma|\e$, then
$OK(\sigma,\e)$
\end{theorem}
\noindent Starting from only the capability object,
any well typed expression $\e_0$ can be reduced for an arbitrary amount of steps,
and $IOK$ will always hold.
\\
\begin{theorem} Stronger Sound Validation $\Rightarrow$ Sound Validation
\end{theorem}
\begin{proof}
\noindent By Stronger Sound Validation, each $l$ in the current redex must be $OK$:
\begin{enumerate}
	\item If $l$ is garbage, it cannot be in the current redex, a contradiction.
	\item If $\mathit{valid}(\sigma,l)$, then $l$ is valid, so thanks to Determinism
	no invalid object could be observed.
	\item Otherwise, if $\mathit{monitored}(\e,l)$ then either:
	\begin{itemize}
	 \item we are executing inside of $\e_1$ thus the current redex is inside of a sub-expression of the monitor that does not contain $l$, a contradiction.
	 \item or we are executing inside $\e_2$:
	 by our reduction rules, all monitor expressions start with 
	 $\e_2=l$\Q@.validate()@, thus the first execution step
	 of $\e_2$ is trusted. Following execution steps are also trusted, since by well formedness the body of invariant methods only use \Q@this@ (now translated to $l$) to access fields.
	\end{itemize}
\end{enumerate}
In any of the possible cases above, Sound Validation holds for $l$, and so it holds for all redexes.
\end{proof}

\subsection{Subject Reduction}

\noindent\textbf{Define} $\text{fieldGuarded}(\sigma,\e)$:\\*
\indent$\forall \ctx$ such that $\e=\ctx[l\singleDot\f] $
and $\Sigma^\sigma(l).f=\Kw{capsule}\,\_$, and $\f\mathrel{\mathit{inside}} \Sigma^\sigma(l).\mathit{validate}$\\*
\indent\indent either 
$\forall T, \forall C, \Sigma^\sigma;\x:\Kw{mut}\,C\,\not\vdash\ctx[\x]:T$, or\\*
\indent\indent $\ctx=\ctx'[$\Q@M(@$l$\Q@;@$\ctx''$\Q@;@$\e$\Q@)@$]$ and $l$ is contained exactly once in $\ctx''$

That is, all \emph{mutating} capsule field accesses are individually guarded by monitors.
Note how we use $C$ in $\x:\Kw{mut}\,C$ to guess the type of the accessed field,
and that we use the full context $\ctx$ instead of the evaluation context $\ctx_v$
to refer to field accesses everywhere in the expression $\e$.


\begin{theorem}[Subject Reduction]
if $\Sigma^{\sigma_0};\emptyset\vdash e_0: T_0$,
$\sigma_0|e_0\rightarrow \sigma_1|e_1$,
$OK(\sigma_0,\e_0)$
and
$\mathit{fieldGuarded}(\sigma_0,\e_0)$
then
$\Sigma^{\sigma_1};\emptyset\vdash e_1: T_1$,
$OK(\sigma_1,e_1)$ and
$\mathit{fieldGuarded}(\sigma_1,\e_1)$
\end{theorem}

\begin{theorem}
	Progress + Subject Reduction $\Rightarrow$ Stronger Sound Validation
\end{theorem}
\begin{proof}
This proof proceeds by induction in the usual manner.

\emph{Base Case}: At the start of the execution, the memory is going to only contain $c$: since $c$ is defined to be initially $\mathit{valid}$, and has only \Q@mut@ fields, and so it is trivially $\mathit{wellEncapsulated}$, thus $OK(c\mapsto\Kw{Cap},e)$.

\emph{Induction}: By Progress we always have another evaluation step to take, by Subject Reduction such a step will preserve $\mathit{OK}$, and so by induction $\mathit{OK}$ holds after any number of steps.

Note how for the proof garbage collection is important: 
when the \Q@validate()@ method evaluates to \Q@false@, 
execution can continue only if the offending object is classified as garbage.
\end{proof}

\subsection{Proof of Subject Reduction}
We first introduce a lemma derived from well formedness and the type system:
\begin{Lemma}[ExposerInstrumentation]
If $\sigma_0 | \e_0\rightarrow \sigma_1 |\e_1$ and
$\text{fieldGuarded}(\sigma_0,\e_0)$
\\*
then $\text{fieldGuarded}(\sigma_1,\e_1)$
\end{Lemma}
\begin{proof}
The only rule that can 
introduce a new field access is \textsc{mcall}.
In that case, ExposerInstrumentation holds
by well formedness (all field accesses in methods are of the form \Q@this.f@) 
and since \textsc{m call} inserts a monitor while invoking capsule mutator methods, and not field accesses themselves. If however the method is not a \Q@mut@ method but still accesses a capsule field, by MutField such a field access expression cannot be typed as \Q@mut@ and so no monitor is needed.

Note that \textsc{monitor exit} is fine because monitors are removed only when
 $e_1$ is a value.
\end{proof}

\begin{theorem}
	Subject Reduction Base $\Rightarrow$ Subject Reduction
\end{theorem}
\begin{proof}
Any reduction step can be obtained
by exactly one application of rule \textsc{ctx} and then one other rule.



Thus the proof can simply proceed by cases on such other applied rule.

By SubjectReductionBase and ExposerInstrumentation, 
$\Sigma^{\sigma_1};\emptyset\vdash e_1: T_1$ and  $\mathit{fieldGuarded}(\sigma_1,\e_1)$. So we just need to proceed by cases on the reduction rule applied to verify that $OK(\sigma_1,\e_1)$:


\begin{enumerate}
\item \textsc{update:} $\sigma|l\singleDot f\equals v\rightarrow \sigma'|\e'$:
\begin{itemize}
  \item by \textsc{update} $\e'=\Kw{M}\oR l;l;l\singleDot\text{validate}\oR\cR\cR;$, thus $\mathit{monitored}(\e,l)$.
  \item Every $l_1$ such that $l\in \text{rog}(\sigma,l_1)$ will verify the same case
  as the former step:
  \begin{itemize}
  	\item If it was $\mathit{garbage}$, clearly it still is.
  	\item If it was $\mathit{monitored}$, it also still is.
  	\item If can't have been $\mathit{wellEncapsulated}$ since $mutatable(l, \sigma, e)$, (by MutField)
  \end{itemize}
  \item Every other $l_0$ is not reached by $l$ thus it being $\mathit{OK}$ could not have been effected by this reduction step.
\end{itemize}

\noindent\textbf{case field access} $l.f\rightarrow v$:

    If for $l$ $IOK$ holds by (2),  
    it is possible that the next step is not encapsulated.
    This would mean that the field $f$ is a capsule and that we are required
to type it as \Q@mut@ to type the expression for the next step.
By $\mathit{fieldGuarded}(\sigma_0,\e_0)$
    the former step was inside of a monitor \Q@M(@$l$\Q@;@$\ctx_v[l$\Q@.f@$]$\Q@;@$\e$\Q@)@
    and the $l$ under reduction was the only occurrence of $l$.
    since $f$ is a capsule, we know that $l\notin \text{erog}(\sigma,l)$
    by HeadNonCircular.
    Thus in the new step not $l\, \text{inside}\ \ctx_v[v]$.
    Thus for l (3)[monitored] holds.
    
We still need to show that properties $\mathit{monitored}$ and $\mathit{wellEncapsulated}$
 for other objects are
not disturbed. This is the point where our aliasing and mutability control are most crucial:
We know that mutable $v$ is (directly) reachable from
$l$ that have invariant.
Thanks to CapsuleTree we know that for all $l_0$ reaching $l$,
$v$ can be reached by $l_0$ only passing trough $l$.
Thus, we can conclude  $l_0$ is not encapsulated in the former step (containing mutable $l$).
Thus, $l_0$ is either without invariant, garbage or monitored.
None of those 3 cases can be disturbed by a field access.


\noindent\textbf{case meth call}:\\*
  This reduction step does not influence any object in the memory and does not
disturb the properties $\mathit{monitored}$ and $\mathit{wellEncapsulated}$.

\noindent\textbf{case new}:\\*
  If $C$ has invariant, then by @ConstructionInstrumentation the new object is monitored.
As for the method call, other objects and properties are not disturbed.


\noindent\textbf{case monitor exit} \Q@M(@$l;v;$\Q@true)@$\rightarrow v$ :
  \begin{itemize}
\item
    If it was a setter $v=l$, and 
    thanks to Determinism the execution of invariant is deterministic;
    thus for $l$ in the former step both case (2) and (3) holds.
    In the next step (2) will hold for $l$.
\item
    If it was a capsule mutator method, thanks to Determinism the execution
 of \Q@.validate()@ is deterministic;
    thus for $l$ in the former step both $H$ and case (3) holds.
    Thanks to ExposerInstrumentation $v$ is offered without mutation permissions, so
    In the next step $l$ is encapsulated and (2) will hold.
\item
    If it is was a constructor, 
    then $v$ is encapsulated and thanks to Determinism
    the execution of invariant is deterministic, thus in the next step (2) will hold.
\end{itemize}

\noindent\textbf{case try enter and try ok}
This case do not influence any object in the memory and does not
disturb the properties $\mathit{monitored}$ and $\mathit{wellEncapsulated}$.

\noindent\textbf{case try catch} $\sigma,\sigma_0|\Kw{try}^\sigma \oC\mathit{error}\cC\Kw{catch}\, \e\rightarrow \sigma|\e$:\\*
From the premise we know 
$IOK(\sigma,\sigma_0;\ctx_v[\Kw{try}^\sigma \oC\mathit{error}\cC\Kw{catch}\, \e])$;
thus we need to show
$IOK(\sigma;\ctx_v[\e])$.
By StrongExceptionSafety we know that $\sigma_0$ is garbage with respect to $\ctx_v[\e]$.

There could be many $l$ inside $\sigma,\sigma_0$ that are $\mathit{monitored}$
in the former step thanks to monitor expressions inside $\mathit{error}$.
However, all such $l$ are defined inside $\sigma_0$,
for the last well formedness condition.
\end{enumerate}
\end{proof}