
\section{Introduction}
\saveSpace\saveSpace

Reasoning about imperative object oriented (OO) programs is a non trivial task,
made particularly difficult by mutation, aliasing, dynamic dispatch, dynamic class loading,
unrestricted I/O and exceptions.

Static verification of method contracts can prove the correctness of OO programs, but this is costly and requires defining the desired semantics of the program in a verification language.
This however requires limiting dynamic class loading, ensuring that only statically verified code can be loaded.
Without this restriction, even predicting the behaviour of an innocent looking call like 
\Q@myPoint.getX()@ is impossible: the dynamic type of \Q@myPoint@ can refer to a dynamically loaded class
whose method \Q@.getX()@ uses I/O to behave non deterministically, or even to format the user’s hard drive.

Recent research on \emph{type modifiers} (TM) and \emph{object capabilities} (OC) offer us a simpler way to perform high-level reasoning on OO programs, without restricting dynamic class loading or employing a verification language.
Type modifiers have been used to enforce ownership and  correct behaviour of parallel code~\cite{GordonEtAl12,clebsch2015deny,clebsch2017orca}. Object capabilities have been used to enforce certain methods to be deterministic and not perform I/O~\cite{finifter2008verifiable}.
Given these benefits, many emerging languages (such as Rust~\cite{matsakis2014rust} and newspeak~\cite{bracha2010modules})
support some form of type modifiers and/or object capabilities.

\loseSpace
\noindent\textit{Validation:}
\label{s:validation}
In this paper, we rely on TM and OC to define a language where a user defined property is ensured to hold for all instances of a class:
all classes provide a \Q@Bool validate()@ method, encoding the expectations all instances should satisfy.
As a short cut, if a class does not explicitly define a
\Q@.validate()@ method, it is assumed to have an implicit default implementation of \Q@{return true;}@, i.e. every instance is valid.
%A class may provide a \Q@Bool validate()@ method, encoding the expectations all instances should satisfy.
%TO DISCUSS: what about validate can only refer to imm and capsule fields?; those that do not, have an implicit default implementation of \Q@{return true;}@, i.e. every instance is valid.
An object \Q@o@ is valid when \Q@o.validate()@ would return \Q@true@, and is invalid otherwise (e.g. if it returns \Q@false@, throws an exception or does not terminate).
We say that a language enforces validation if:
\begin{itemize}
\item \Q@.validate()@ methods are guaranteed to be deterministic and to not mutate any state; they represent logic predicates on the receiver’s reachable object graph (ROG).
\item Invalid objects are not reachable by application code; thus programmers can always assume the properties checked by \Q@.validate()@ hold.
For example, at the point of a method call, all the parameters (including \Q@this@) and all the objects in their ROGs will be valid.
\end{itemize}

\noindent Though this is very similar to enforcing class-invariants, their are a few key differences:
\begin{itemize}
\item Class invariants can be \emph{temporarily} broken during class-methods, whereas validation doesn’t allow this.
\item \REV{It is the responsibility of the class \emph{author} to ensure the invariant is preserved across all public methods, whereas with validation it is the responsibility of the class \emph{user} to not (indirectly) mutate the object in any way that will break it}.
\end{itemize}
\noindent Our system is more primitive and general then class invariants, and can be used as a building block to encode 
them.
% and allows 
%global (global is not the right word)
% reasoning through the program.
Indeed, class-invariants can be represented in our system by defining validity as 
%your ``and'' was wrong, is ``or''
the class-invariant holding or a mutator-method is currently running (this is easily implemented with a boolean flag).

\loseSpace
\noindent\textit{Our approach:}
Our language\footnote{
In literature, both static and run-time verification discuss
the correctness of common programming patterns in conventional languages.
Their struggle is proof of how hard it is to deal with the expressive power of unrestricted imperative object oriented programming.
 Here instead we define a new language, where TM and OC tame the use of imperative features. In this way
we have a fresh start where
% Here instead we define a new language, where
many \REV{conventional programming patterns are disallowed},
and need to be replaced with other patterns allowing simpler reasoning.
} supports validation by invoking the \Q@.validate()@ method, before a possibly invalid object becomes reachable. Such invocations are not present in the code written by the programmer. 
Like assertions, an (unchecked) exception is thrown if such a call returns \Q@false@ (indicating that the object is invalid).

Note how validation does not ensure the absence of invalid objects, instead we use exceptions to steer execution to a point where the type-system ensures the object is not reachable.
If you were to step with a debugger, you may see invalid objects, and validation checks failing.

\noindent Our approach follows the principles of \emph{Defensive/Offensive programming}\REV{~\cite{WikiDefensive}}:
\begin{itemize}
\item The failure (an unchecked exception)
is raised as close as possible to the defect (the operation creating an invalid object), i.e. we ``fail-fast''.
\item No attempt to fix or recover the invalid object is performed.
%, and all objects observing modified by the execution
%creating such objects are made be unreachable if the corresponding unchecked exception was to be captured.
\end{itemize}

%This approach contrasts with an alternative approach, %that of static verification, in which case a program that %could produce invalid objects would fail to compile. Our %approach is 
%more flexible 
%as it allows for a program that may produce invalid objects to still be useful, with the programmer only needing to handle them when they occur.

% \subsection{Random stuff }
% We show that a na\"{i}ve approach that just checks \Q@.validate()@ at the end of constructors and setters would be insufficient. We take advantage of TM+OC to conservatively identify classes where validation is possible.
%
\noindent\textit{Similarity with checked casts:}
%\subsection{Extended type system and similarity with checked casts}
Even if not as good as full static verification, from a formal perspective
% our system clearly aid reasoning.
our system provides sound guarantees that aid reasoning.

Programmers are still responsible for creating and mutating objects in order to preserve their validity;
but once an object has been successfully created/mutated, it is guaranteed to be valid.
Attempting to create a new invalid object, or to mutate an object into an invalid one, causes
a run time error.

This is similar to casts in Java with respect to casts in C:
In both languages the programmer is responsible for casting values correctly;
however, in Java casts are soundly checked: if in a Java program the control flow \REV{goes over a cast},
we know that in that specific
execution such assumption was correct.
On the other hand incorrect C casts just default to undefined behaviour:
if a C execution continue after a cast, we know absolutely nothing. The same execution
may fail when run on a different machine, 
or even on the same one in another moment.
In the same sense as checked-casts, object construction and ROG mutation are soundly checked by our system,
and success in a mutation means that in that specific execution, validity was preserved.




%load Item i
%  playCargo(this.cargo(),i)
%
%static playCargo(mut Cargo c, Item i)
%  c.add(i)
%  c.remove(i)
%  
% 
%valid/validation/validity
%
%name of the method: valid/validate
%-----------------------------------
%
%
%%awesome capability objects
%
%%awesome type modifiers
%
%awesome exception safety %%no, we try to sell Exception safety as an application of TM
%
%%with those 3 together we get validation
%
%%is like a extended type system %? yes by comparision with casts?
%
%contrast with class invariants
%
%
%valid only access fields
%
%valid
%
%
%patterns wrapper/state variable allows for flexible invariants
%
%verify the programmer intentions are self-consistent
%
%encoding post conditions and pre conditions as specialized types
%
%code example
%

%%%
%%%May coonect with "OffensiveProgramming/DefensiveProgramming".
%%%


\noindent\textit{Structure of our paper:} We now present how a real language could support
validation. 
We would like to underline that the
features we need have all been presented in the past, but their application to sound validation has never been explored.

%To ease our explanation, we present various categories
%of objects where we can support validation, starting from the simpler one to handle.
In Section \ref{s:background} we will introduce one by one the various
language features cooperating
to support validation. %, and we work under the assumption that there are no static variables.
We will provide a brief introduction to type modifiers, object capabilities, and exception safety.

In Sections \ref{s:validate}, \ref{s:immState}, and \ref{s:encapsulated}, we will show how TM and OC enable validation.
To clearly communicate what kind of checks the language semantics should perform,
 we will write them down as if they were `generated source code'.
However, our proposed approach is independent of the actual technique to insert these checks, and they may instead be inserted directly into bytecode, or they can be part of the underlying semantics of a virtual machine.

In Section \ref{s:meaning} we will provide formal definitions, and in Appendix \ref{s:proof} we provide  a proof that our language soundly enforces validation.




