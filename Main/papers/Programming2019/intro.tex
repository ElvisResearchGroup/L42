\section{Introduction}
%\newpage
%\LINE
Intuitively all valid objects should satisfy the invariant of their class.
Class-invariants can be presented as documentation, checked as part of static-verification of class-definitions, or, as we do in this paper, monitored for violations using runtime-verification.
Here a class specifies its invariant by defining a boolean method called \Q@invariant@. We say that an object is \emph{valid} if calling \Q@invariant@ would return \Q@true@.

An \emph{invariant protocol} specifies when class invariants need to be checked, and when they can be assumed; if such checks guarantee said assumptions, the protocol is sound.
%Two popular invariant protocols presented in the literature are \emph{visible state semantics}~\cite{???} and pack/unpack~\cite{?}. Visible state semantics treat a class-invariant as an implicit pre-condition on the receiver of every public method, and as a post-condition on every public method and constructor. Thus runtime-verification will check the invariant before and after every public method call, and after \Q@new@ expressions.

Two main sound invariant protocols present in literature are visible state semantic \cite{??} and Pack/Unpack~\cite{?}. Visible state semantics expect the receiver's invariant to hold before and after every public method call, and after its constructor. The invariant is simply checked in all such points, and so this approach is obviously sound, but can be incredibly inefficient even in simple cases.
In contrast, pack/unpack marks all objects as either packed or unpacked, where a packed object is one whose invariant is expected to hold.
In this approach, an object's invariant is checked only by the pack-operation.
In order for this to be sound, some form of aliasing and mutation control is necessary. For example, Spec\# uses a theorem prover together with source-code annotations.

Here we propose an invariant protocol with the 
efficiency of pack/unpack, but with a much lower annotation burden.
We have performed a case study to quantify the benefit of our approach:
on a simple use case with 5 objects with class invariants, the visible state semantics 
require checking the invariant 53 millions times more,
while Spec\# and our approach check it only 77 times.
We found the Spec\# annotation burden to be about 3 times more 
than our approach.

In this paper we argue that our protocol is not only more succinct than pack/unpack but is also easier and safer to use.
Moreover, our approach is sound in a broader scope with respect to Spec\#, since we allow sound catching of invariant failures and other unchecked exceptions, and carefully handle
the impact of I/O and other non deterministic operations.

Instead of using static analysis,
we obtain our results thanks to coarse grained type system support and a careful design of the standard library. Three languages already support the type system and the standard library design that we need:
L42, Pony and M\#. To perform our case studies we fully implemented our protocol on L42.
We believe it would be easy to implement our protocol also on those other two languages.

In order to obtain safety, simplicity and efficiency we traded some expressive power:
we can not verify some forms of data-structures, such as collections of mutable elements.\footnote{Our approach does not prevent correctly implement such data-structures, rather we do not support encoding the correctness of such objects as a class-invariant.}
In our case study we show that
we can still encode most of the examples explored in ~\cite{???} (including for example mutable collections of immutable objects) whilst having a significantly lower annotation-burden.
In section \ref{TODO} we...
In section \ref{TODO} we...
In section \ref{TODO} we...

