
\section{Introduction}
\saveSpace\saveSpace

Reasoning about imperative object oriented (OO) programs is a non trivial task,
made particularly difficult by mutations, aliasing, dynamic dispatch, dynamic class loading,
unrestricted I/O and exceptions.

Static verification of method contracts can prove correctness of OO programs, but this is costly and requires to define the desired semantic of the program in a verification language then prove consistency.
This however requires limiting dynamic class loading, ensuring that only statically verified code can be loaded.
Without this restriction, even predicting the behaviour of an innocent looking call like 
\Q@myPoint.getX()@ is impossible: the dynamic type of \Q@myPoint@ can refer to a dynamically loaded class
whose method \Q@.getX()@ uses I/O to behave non deterministically, or even to format the hard drive.

Recent research on \emph{type modifiers} (TM) and \emph{object capabilities} (OC) offer us a simpler way to perform high-level reasoning on OO programs, without restricting dynamic class loading or employing a verification language.
Type modifiers have been used to enforce ownership and  correct behaviour of parallel code~\cite{GordonEtAl12,clebsch2015deny,clebsch2017orca}. Object capabilities have been used to enforce certain methods to be deterministic and to not perform I/O~\cite{finifter2008verifiable}.
Given these benefits, many emerging languages (such as Rust~\cite{matsakis2014rust} and newspeak~\cite{bracha2010modules})
support some form of type modifiers and/or object capabilities.

\loseSpace
\noindent\textit{Validation:}
\label{s:validation}
In this paper, we rely on TM and OC to define a language where a user defined property is ensured to holds for all instances of a class:
all classes provide a \Q@Bool validate()@ method, encoding the expectations all instances should satisfy.
As a short cut, if a class does not explicitly define a
\Q@.validate()@ method, it is assumed to have an implicit default implementation of \Q@{return true;}@, i.e. every instance is valid.
%A class may provide a \Q@Bool validate()@ method, encoding the expectations all instances should satisfy.
%TO DISCUSS: what about validate can only refer to imm and capsule fields?; those that do not, have an implicit default implementation of \Q@{return true;}@, i.e. every instance is valid.
An object \Q@o@ is valid when \Q@o.validate()@ would return \Q@true@, and is invalid otherwise (e.g. if it returns \Q@false@, throws an exception or does not terminate).
We say that a language enforces object validity if:
\begin{itemize}
\item \Q@.validate()@ methods are guaranteed to be deterministic and to not mutate any state; they represent logic predicates on the reachable object graph (ROG).
\item Invalid objects are not reachable by application code; thus programmers can always assume such properties hold.
For example, at the point of a method call, all the parameters (including \Q@this@) and all the objects in their ROGs will be valid.
\end{itemize}

\noindent Though this is very similar to enforcing class-invariants, their are a few key differences:
\begin{itemize}
\item Class invariants can be \emph{temporarily} broken during class-methods, whereas validation dosenâ€™t allow this
\item It is the responsibility of the class \emph{author} to ensure the invariant is preserved across all public methods, whereas with validation it is the responsibility of the class \emph{user} to not (indirectly) mutate the class in any way that will break it.
\end{itemize}
\noindent Our system is more primitive then class invariants, and can be used as a buding block to encode 
them.
% and allows 
%global (global is not the right word)
% reasoning through the program.
Indeed, class-invariants can be represented in our system by defining validity as 
%your ``and'' was wrong, is ``or''
the class-invariant holding, or a mutator-method is currently running (this is easily implemented with a boolean flag).

\loseSpace
\noindent\textit{Our approach:}
Our language\footnote{
In literature, both static and run-time verification discuss
the correctness of common programming patterns in conventional languages. Here instead we define a new language, where
many conventional programming patterns are disallowed,
and need to be replaced with other patterns allowing simpler reasoning.
} supports validation by invoking the \Q@.validate()@ method, before a possibly invalid object becomes reachable. Such invocations are not present in the code written by the programmer. 
Like assertions, an (unchecked) exception is thrown if such a call returns \Q@false@ (indicating that the object is invalid).

Note how validation does not ensure the absence of invalid objects, instead we use exceptions to steer execution to a point where the type-system ensures the object is not reachable.
If you were to step with the debugger, you may see invalid objects, and validation checks failing.

\noindent Our approach follows the principles of \textbf{Offensive programming}:
\begin{itemize}
\item The failure (an unchecked exception)
is raised as close as possible to the defect (the operation creating an invalid object), i.e. we ``fail-fast''.
\item No attempt to fix or recover the invalid object is performed.
%, and all objects observing modified by the execution
%creating such objects are made be unreachable if the corresponding unchecked exception was to be captured.
\end{itemize}

%This approach contrasts with an alternative approach, %that of static verification, in which case a program that %could produce invalid objects would fail to compile. Our %approach is 
%more flexible 
%as it allows for a program that may produce invalid objects to still be useful, with the programmer only needing to handle them when they occur.

% \subsection{Random stuff }
% We show that a na\"{i}ve approach that just checks \Q@.validate()@ at the end of constructors and setters would be insufficient. We take advantage of TM+OC to conservatively identify classes where validation is possible.
%
\noindent\textit{Similarity with checked casts:}%
%\subsection{Extended type system and similarity with checked casts}
 Even if not as good as full static verification, from a formal perspective
 our system clearly aid reasoning.
Programmers are still responsible to create and mutate objects in order to preserve their validity;
but once an object has been successfully created/mutated, is guaranteed to be valid.
Attempting to create a new invalid object, or to mutate an object into an invalid one causes
a run time error.

This is similar to casts in Java with respect to casts in C:
In both languages the programmer is responsible to cast values correctly.
However, in Java casts are soundly checked: if in a Java program the control flow go over a cast,
we know that in that specific
execution such assumption was correct.
On the other side incorrect C casts just default to undefined behaviour:
if a C execution continue after a cast, we know absolutely nothing. The same execution
may fail when run on a different machine, 
or even on the same one in another moment.
In the same sense, object construction and ROG mutation are soundly checked by our system,
and success in a mutation means that in that specific execution, the validity was preserved.




%load Item i
%  playCargo(this.cargo(),i)
%
%static playCargo(mut Cargo c, Item i)
%  c.add(i)
%  c.remove(i)
%  
% 
%valid/validation/validity
%
%name of the method: valid/validate
%-----------------------------------
%
%
%%awesome capability objects
%
%%awesome type modifiers
%
%awesome exception safety %%no, we try to sell Exception safety as an application of TM
%
%%with those 3 together we get validation
%
%%is like a extended type system %? yes by comparision with casts?
%
%contrast with class invariants
%
%
%valid only access fields
%
%valid
%
%
%patterns wrapper/state variable allows for flexible invariants
%
%verify the programmer intentions are self-consistent
%
%encoding post conditions and pre conditions as specialized types
%
%code example
%

%%%
%%%May coonect with "OffensiveProgramming/DefensiveProgramming".
%%%


\saveSpace
\section{A language supporting sound Validation}
\label{s:language}
\saveSpace
We now present how a real language could support
Validation. To ease our explanation, we present various categories
of objects where we can support Validation, starting from the simpler one to handle.
We will introduce one by one the various
language features cooperating
to support Validation.%, and we work under the assumption that there are no static variables.
We will provide a brief introduction to type modifiers, object capabilities, and exception safety and we will show how they enable sound invariant checking.

To clearly communicate what kinds of checks the language semantic should insert,
 we will write them down as if they were `generated source code'. 
However our proposed approach is independent of the actual technique to insert these checks, and they may be inserted directly into the bytecode, or they can be part of the underlying semantics of the virtual machine.
In this section we rely on code example and informal explanations. In the next section we will provide formal definitions.
We would like to underline that the
features we need have all been presented in the past, but their application to sound Validation has never been explored.



