
\section{Introduction}
\saveSpace\saveSpace
Reasoning about imperative object oriented (OO) programs is a non trivial task,
made particularly difficult by mutations, aliasing, dynamic dispatch, dynamic class loading,
unrestricted I/O(input/output) and exceptions.

Static verification with method contracts can prove correctness of OO programs, but is costly and requires to define the desired semantic of the program in a verification language then prove consistency.
This however require to limit dynamic class loading, ensuring that only statically verified code can be loaded.
Without this restriction, even predicting the behaviour of an innocent looking call, like 
\Q@myPoint.getX()@ is impossible: the dynamic type of \Q@myPoint@ can refer to a dynamically loaded class
whose method \Q@.getX()@ uses I/O to behave non deterministically, or even to format the user hard drive.

Recent research on type modifiers (TM) and object capabilities (OC) offer us a simpler way to perform high-level reasoning on OO programs without restricting dynamic class loading or employing a verification language.
For example, type modifiers has been used to enforce ownership and to guarantee correct behaviour of
parallel code[]. Object capabilities have been used to enforce certain methods to be deterministic and to not perform I/O[joe].
Given these benefits, many emerging languages (as Rust[] and newspeak[])
support some forms of type modifiers and/or object capabilities.

\vspace{1ex}

\subsection{Validation}
In this paper, we rely on TM and OC to define a language ensuring \textbf{validation}: that is, its ensure a user defined property (it being 'valid') holds for all instances of a class.

%##what is validation
Some classes can provide a \Q@Bool validate()@ method, encoding the expectations
all instances should satisfy.
An object \Q@o@ is valid when \Q@o.validate()@ would return \Q@true@, and is invalid in all the other cases (return \Q@false@, exception or non termination).
We say that a language enforces object validity if:
\begin{itemize}
\item \Q@.validate()@ methods are guaranteed to be deterministic and to not mutate any state; they represent logic predicates on the reachable object graph (ROG).
\item Invalid object are not reachable by application code. Thus programmers can always assume such properties to hold.
For example, at the point of a method call,
all the parameters (including \Q@this@) and all the objects in their ROG will be valid.
\end{itemize}

\noindent 

\subsection{How we implement}
Our language supports validation by invoking the \Q@.validate()@ method before a possibly invalid object becomes reachable. Such invocations are not present in the code written by the programmer. 
Like assertions, an (unchecked) exception is thrown if such a call returns false (indicating that the object is invalid).

Note how validation does not ensure the absence of invalid objects, instead we use exceptions to steer execution to a point where the type-system ensures the object is not reachable.
If you were to step with the debugger, you may see invalid objects, and validation checks failing.

Our approach follows the principles of \textbf{Offensive programming}:
\begin{itemize}
\item The failure (unchecked exception)
is raised as near as possible to the defect: the operation creating an invalid object (``fail-fast'').
\item No attempt to fix or recover the invalid object is performed.
%, and all objects observing modified by the execution
%creating such objects are made be unreachable if the corresponding unchecked exception was to be captured.
\end{itemize}

\subsection{Random stuff }
We show that a naive approach that just checks \Q@.validate()@ at the end of constructors and setters would be insufficient. We take advantage of TM+OC to conservatively identify classes where validation is possible.
%
%\noindent\textit{Similarity with checked casts:}%
%\subsection{Extended type system and similarity with checked casts}
Even if not as good as full static verification, from a formal perspective
 our system clearly \textbf{aid reasoning}.
However, programmers are still responsible to create and mutate objects in order to preserve their validity;
but once an object has been successfully created/mutated, is guaranteed to be valid.
Attempting to create a new invalid object, or to mutate an object into an invalid one causes
a run time error.

This is similar to casts in Java with respect to casts in C:
In both languages the programmer is responsible to cast values correctly.
However, in Java casts are soundly checked: if in a Java program the control flow go over a cast,
 we know that in that specific
execution such assumption was correct.
On the other side incorrect C casts just default to undefined behaviour:
if a C execution continue after a cast, we know absolutely nothing. The same execution
 may fail when run on a different machine, 
or even on the same one in another moment.

In the same sense, object construction and ROG mutation are soundly checked by our system,
and success in a mutation means that in that specific execution, the validity was preserved.




%load Item i
%  playCargo(this.cargo(),i)
%
%static playCargo(mut Cargo c, Item i)
%  c.add(i)
%  c.remove(i)
%  
% 
%valid/validation/validity
%
%name of the method: valid/validate
%-----------------------------------
%
%
%%awesome capability objects
%
%%awesome type modifiers
%
%awesome exception safety %%no, we try to sell Exception safety as an application of TM
%
%%with those 3 together we get validation
%
%%is like a extended type system %? yes by comparision with casts?
%
%contrast with class invariants
%
%
%valid only access fields
%
%valid
%
%
%patterns wrapper/state variable allows for flexible invariants
%
%verify the programmer intentions are self-consistent
%
%encoding post conditions and pre conditions as specialized types
%
%code example
%

%%%
%%%May coonect with "OffensiveProgramming/DefensiveProgramming".
%%%

\saveSpace
\section{Naive Validation is unsound}
\saveSpace\saveSpace
Many programmers may believe that making the fields private and checking the \Q@.validate()@ method
at the \textbf{end of the constructor} and at the \textbf{end of mutator methods} is enough to enforce
Validation.
As we will see in this article, in most mainstream object-oriented languages, this is \textbf{very far} from enough.
Let's focus first on a simpler example, when a \Q@Person@ just has its name:
\begin{lstlisting}
class Person{
  public Bool validate(){  return !name.isEmpty(); }
  private String name;
  public String name(){ return this.name; }
  public String name(String name){
    this.name=name;
    if(!this.validate()){throw $\MComment{error}$}
    }
  public Person(String name){
    this.name=name;
    if(!this.validate()){throw $\MComment{error}$}
    }
  }
\end{lstlisting}
\noindent At first look, this code seems to correctly enforce Validation.
However our intuition relies not on statically verified properties, or on the semantics of the language,
but on the expectations about ``correct'' behaviour of \Q@String@.
We want to enforce Validation without assuming the behaviour of the other object.
\begin{itemize}
\item Sample Bug 1:
Suppose there was a bug in \Q@String.isEmpty()@, causing the method to non-deterministically return \Q@true@ or \Q@false@.
What would it mean for Validation?
Would a \Q@Person@ be at the same time 
valid and invalid?

Only deterministic methods can be used for validation.
Ensuring this cannot be responsibility of the \Q@Person@ programmer, since it may depend on third party code, as shown in this example.
However, statically checking if a method is deterministic is hard/impossible in most imperative object-oriented languages.

While we may not expect the presence of bugs in the standard library class \Q@String@, the same behaviour can be achieved with subtyping:
\saveSpace
\begin{lstlisting}
class EvilStr extends String{
  method Bool isEmpty(){
    return new Random().bool();
  }}
...
String name=...$\Comment{can this be an EvilStr?}$
Person bob=new Person(name);
\end{lstlisting}
\saveSpace
As you can see, it is hard to make sound claims about Validation.


\item Sample Bug 2:
In our simple example, \Q@Person@ objects can be mutated using the setter, and exposed using the getter.
We may consider the getter to be safe since in modern languages we expect strings to be immutable objects.
\footnote{While we can update the field \Q@name@ to point to another string, we cannot mutate the string object itself.
To obtain  \Q@"Hello"@ from \Q@"hello"@ we need to create a whole new string object that looks like the old one except for the first character. This would be different in older languages like C, where strings are just mutable arrays of characters.}

Again, the assumption that they are immutable depends on the correctness of the code inside \Q@String@: if there was a bug in the \Q@String@ class, or any \Q@String@ subclass, then executing 
\Q@println(bob.name())@ may change \Q@bob@ by quietly changing a part of its ROG.

Again, checking
what methods mutate states cannot be responsibility of the \Q@Person@ programmer.
For Validation we need a language supporting aliasing and mutability control.


\item Sample Bug 3:
One of the advantages of checking Validation at run time, is that
we can allow the program can take corrective actions if a property is violated.
This may be implemented with a conventional \Q@try-catch@ if violations are represented by throwing errors.
However, there is an issue with exceptions modelling invalid objects: they can be captured when the invalid object is still in scope. For example:
\saveSpace
\begin{lstlisting}
 Person bob=new Person("bob");
 try{bob.name("");}catch(Throwable t){}$\Comment{ Catch and ignore invariant failure:}$
 assert bob.name().isEmpty();$\Comment{now we have a broken object around!}$
\end{lstlisting}
\saveSpace
As you can see, if we can capture Validation failures as normal exceptions (very desirable feature) then we may end up using invalid objects.
%Moreover,
% as shown before with the example of transferring cargo between two boats,
%after an invariant has been violated, even objects with valid invariant may be in an unexpected state.

This is not a special problem relevant to just Validation, but a more general issue of reasoning about the state after recovering from exceptions.
Other authors have identified the concept of Strong Exception Safety~\cite{Abrahams2000}:
when a \Q@try-catch@ captures an exception, the visible state at the start of the catch must be the same as before the \Q@try@ block started its execution.
For Validation, we only need String Exception Safety against unchecked exceptions. We will show how to obtain it using TM.
%Note how this produces a different semantics with respect to static verification, where violations
%never happened. However this will not necessarily lead to a broken semantics:
% we aim to create a system where either the application terminate
%when such a bug is identified, or where those objects and all the witnesses will be garbage collected
% (as happens in alias burying~\cite{boyland2001alias}).
%In our example, this means that to continue execution after a detected bug, 
%we would require to garbage collect the overloaded boat, their cargo and probably most of the commercial port too.
\end{itemize}






