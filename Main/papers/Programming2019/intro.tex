
\section{Introduction}
\saveSpace\saveSpace

Reasoning about imperative object oriented (OO) programs is a non trivial task,
made particularly difficult by mutation, aliasing, dynamic dispatch, dynamic class loading,
unrestricted I/O and exceptions.

% Static verification of method contracts can prove the correctness of OO programs, but this is costly and requires defining the desired semantics of the program in a verification language.
% This however requires limiting dynamic class loading, ensuring that only statically verified code can be loaded.
% Without this restriction, even predicting the behaviour of an innocent looking call like 
% \Q@myPoint.getX()@ is impossible: the dynamic type of \Q@myPoint@ can refer to a dynamically loaded class
% whose method \Q@.getX()@ uses I/O to behave non deterministically, or even to format the user’s hard drive.

% Recently, a new design for \emph{type modifiers}(TMs) has emerged, that radically improves their usability.
% Three different research languages are being independently developed relying on this new design: \IO{Gordon}, Pony and 42.
% Those modifiers include \Q@mut@, \Q@imm@ and \Q@capsule@, to represent mutable, immutable and encapsulated data.
% Gordon and Pony need those type informsations to better exploit multi core machine.
% These modifiers provide opt-in restrictions/guarantees: code where everything has a \Q@mut@-type is as flexible as Java.
% However, when \Q@imm@/\Q@capsule@ are used some code may perform better on a multi core machine, either automatically (gordon) or if the program uses actors (pony).
% 42 developers also recognize that those modifiers may provide benefit for parallelism, but they focus on the implications on third party library usage safety.

% Point: new TM is usable, and there are 3 languages using it for parallelism

Recently, a new design for \emph{type modifiers} (TMs) has emerged that radically improves their usability.
Three different research languages are being independently developed relying on this new design: \IO{Gordon}~cite{TODO}, Pony~cite{TODO} and 42~cite{TODO}. Those modifiers offer us a simpler way to perform high-level reasoning on OO programs, without restricting dynamic class loading or employing a verification language.
Gordon and Pony use TMs to provide automatic/correct parallelism~cite{GordonEtAl12,clebsch2015deny,clebsch2017orca}.
\IO{Add explanation of Gordon+Pony lots of code}

\emph{Object capabilities} (OCs) are a complementary technique 
	% todo let marco right this:
		% breif summary of what they are for
		% citations....
	 	% breif mention of how much their used

% Point:OC and SES are also needed for parallelism and are present in 42, likely present in Gordon and irrelevant in pony

% Gordon briefly discuss that they relies on \emph{Object capabilities} (OCs) to make their approach sound in respect to interaction with I/O. To the best of our knowledge Gordon do not disclose interaction with exceptions, while Pony do not have exceptions in the first place.


% Point: thus, those 3 system are good canditate for our validation

% Their work do not 
% In order to be sound they need OC and exception safety
%  Object capabilities can been used to enforce determinism and the absence of I/O~\cite{finifter2008verifiable}.

%Recent research on \emph{type modifiers} (TMs) and \emph{object capabilities} (OCs) offer us a simpler way to perform high-level reasoning on OO programs, without restricting dynamic class loading or employing a verification language.
%Type modifiers have been used to enforce ownership and automatic/correct parallelism~cite{GordonEtAl12,clebsch2015deny,clebsch2017orca}. Object capabilities can been used to enforce determinism and the absence of I/O~\cite{finifter2008verifiable}.



%Given these benefits, many emerging languages (such as Rust~\cite{matsakis2014rust} and newspeak~\cite{bracha2010modules}) support some form of type modifiers and/or object capabilities.

\loseSpace
\noindent\textit{Validation:}
\label{s:validation}
In this paper, we rely on TMs and OCs to define a language where a user defined property is ensured to hold for all instances of a class:
all classes provide a \Q@Bool validate()@\ method, encoding the expectations all instances should satisfy.
As a short cut, if a class does not explicitly define a
\validate{} method, it is assumed to have an implicit default implementation of \Q@{return true;}@, i.e. every instance is valid.
%A class may provide a \Q@Bool validate()@ method, encoding the expectations all instances should satisfy.
%TO DISCUSS: what about validate can only refer to imm and capsule fields?; those that do not, have an implicit default implementation of \Q@{return true;}@, i.e. every instance is valid.
An object \Q@o@ is valid when \Q@o.validate()@ would return \Q@true@, and is invalid otherwise (e.g. if it returns \Q@false@, throws an exception or does not terminate).
We say that a language enforces validation iff:
\begin{itemize}
\item \validate{} methods are guaranteed to be pure; i.e. that they are deterministic and do not mutate any state.%; hence they represent logic predicates on the receiver’s reachable object graph (ROG).
\item Invalid objects are not reachable by application code; thus programmers can always assume the properties checked by \validate{} hold.
For example, at the point of a method call, all the parameters (including \Q@this@) and all the objects in their ROGs will be valid.
\end{itemize}
%-------------------------------------
Different verification approaches have different invariant protocols~\cite{FlexibleInvariants}, specifying when the invariant is expected to hold, and when it is allowed to be violated.
The common invariant protocol~\cite{JML, OOSC..., D, Eiffel} only enforce the invariant on the receiver before and after every public method call. Sadly, this allows such receivers to be invalidated and passed around to other code.

% TODO: Call the invariant protocl 'validation'
Our invariant protocol follows the mindset of Spec\#~\cite{TODO}: we allow temporally violating objects invariants when their ROG is being updated; however, we guarantee that such objects are not involved in execution during this process. \footnote{Spec\# 
is more general, and, as extra feature, allows specially declared methods to use invalid objects, while we require such objects to be never used.}
%Our approach ensures that invalid objects are never accessed by code.
Our system also allows catching invariant failures as exceptions; this is sound since TMs can guarantee that the invalid object is no longer accessible.

Our approach has 2 main benefits over the traditional one: it greatly simplifies reasoning since programmers can assume that objects accessible to them are valid. %programmers can always assume that all the accessed objects are valid. 
It requires that the invariant be checked significantly less often; we have conducted a case-study which shows that the traditional approach staggeringly performs 10,000 times more runtime-checks than ours.
% systems performs 10,000 less  is up to 10,000 times slower.
% \item Debugging is easier since the invariant failure always happens when the method invalidating the object is still active on the stack trace.
%\end{itemize}

Spec\# uses uses heavy anotations to guid static-analysis to reason about ownership.

In contrast to Spec\#, which we use a much simpler and user-friendly TMs

We also improve over the Spec\# approach, which uses static-analysis to reason about ownership. We enforce our guarantees relying on the much simpler and user-friendly TMs. In our case study we can see how our approach requires much less annotations.

%------------------------------
Note that we do not require that invariants are never violated, rather we just ensure that invalid objects are never accessed by code. Our system allows catching the invariant failure as an exception; TMs can guarantee that the invalid object is no longer accessible.

Invariant protocols have many options~\cite{FlexibleInvariants}. Here we allow temporally violating
objects invariants when their ROG is being updated; however, as in Spec\#~\cite{TODO}\footnote{Spec\# 
however also allows specially declared methods to use invalid objects.}, we guarantee that such objects are not involved in execution during this process. As opposed to Spec\# which uses static-analysis to reason about ownership, we achieve this relying on the much simpler and user-friendly TMs.

In contrast, the common invariant protocol~\cite{JML, OOSC..., D, Eiffel} is that all public-method calls requires and ensures validity of their receiver, both before and after the call. This allows the object to be visible as invalid during the execution of such methods, including allowing private method calls on invalid objects or even passing an invalid objects to other functons. However due to aliasing this approach makes reasoning much more difficuilt, an object can not be assumed to be valid since at any time their might be an executing method call over it. In addition, performig runtime-verification of this approach is much more costly than ours, we have conducted a case-study which showed that it is several orders of magnitude slower.



This greatly simplify reasoning since programmers can always assume that all the accessed objects are valid.
In the traditional system (D,EffielPro
%objectOriented software constuction
,EffeilAgainst), thanks to unrestricted aliasing, any method may receive an invalid object as a parameter.

This also improves the efficiency of our approach:
by controlling the scope of invariant violation, we can insert invariant run-time checking
only in a handful of places, while the traditional system requires invariant checking before and after every public method call (Jose, Effiel, D,(Open)JML,..).

We performed case studies showing the impact of this optimization, and we discovered to be many order of magnitude (...)




%---
% \item \REVComm{It is the responsibility of the class \emph{author} to ensure the invariant is preserved across all public methods, whereas with validation it is the responsibility of the class \emph{user} to not (indirectly) mutate the object in any way that will break it}{2}{What does this mean?}.

\end{itemize}
% \noindent Our system is more primitive and general than class invariants, and can be used as a building block to encode 
% them.
% and allows 
%global (global is not the right word)
% reasoning through the program.
% \REVComm{Indeed, class invariants can be represented in our system by defining validity as 
%your ``and'' was wrong, is ``or''
% the class invariant holding or a mutator method currently running (this is easily implemented with a boolean % flag).}{3}{Hard to understand setence}

\loseSpace
\noindent\textit{Our approach:}
Our language\footnote{
In literature, both static and run-time verification discuss
the correctness of common programming patterns in conventional languages.
Their struggle is proof of how hard it is to deal with the expressive power of unrestricted imperative object oriented programming.
 Here instead we define a new language, where TM and OC tame the use of imperative features. In this way
we have a fresh start where
% Here instead we define a new language, where
many \REVComm{conventional programming patterns are disallowed}{2}{[What] patterns are disallowed?},
and need to be replaced with other patterns allowing simpler reasoning.
} supports validation by invoking the \validate{} method, before a possibly invalid object becomes reachable. Such invocations are not present in the code written by the programmer. 
Like assertions, an (unchecked) exception is thrown if such a call returns \Q@false@ (indicating that the object is invalid).

Note how validation does not ensure the absence of invalid objects, instead we use exceptions to steer execution to a point where the type system ensures the object is not reachable.
If you were to step with a debugger, you may see invalid objects, and validation checks failing.

\noindent Our approach follows the principles of \REVComm{\emph{Defensive/Offensive programming}~\cite{WikiDefensive}}{2}{Is [this citation] a (or the most) reliable source of defensive programming principles?}:
\begin{itemize}
\item The failure (an unchecked exception)
is raised \REVComm{as close as possible to the defect}{3}{[meaning] is not clear} (the operation creating an invalid object), i.e. we ``fail-fast''.
\item No attempt to fix or recover the invalid object is performed.
%, and all objects observing modified by the execution
%creating such objects are made be unreachable if the corresponding unchecked exception was to be captured.
\end{itemize}

%This approach contrasts with an alternative approach, %that of static verification, in which case a program that %could produce invalid objects would fail to compile. Our %approach is 
%more flexible 
%as it allows for a program that may produce invalid objects to still be useful, with the programmer only needing to handle them when they occur.

% \subsection{Random stuff }
% We show that a na\"{i}ve approach that just checks \validate{} at the end of constructors and setters would be insufficient. We take advantage of TM+OC to conservatively identify classes where validation is possible.
%
\noindent\textit{Similarity with checked casts:}
%\subsection{Extended type system and similarity with checked casts}
Even if not as good as full static verification, from a formal perspective
% our system clearly aid reasoning.
our system provides sound guarantees that aid reasoning.

Programmers are still responsible for creating and mutating objects in order to preserve their validity;
but once an object has been successfully created/mutated, it is guaranteed to be valid.
Attempting to create a new invalid object, or to mutate an object into an invalid one, causes
a run time error.

This is similar to casts in Java with respect to casts in C:
In both languages the programmer is responsible for casting values correctly;
however, in Java casts are soundly checked: if in a Java program the control flow \REVComm{goes over a cast}{2}{unclear about whether it describes a cast that succeeds or fails/},
we know that in that specific
execution such assumption was correct.
On the other hand incorrect C casts just default to undefined behaviour:
if a C execution continue after a cast, we know absolutely nothing. The same execution
may fail when run on a different machine, 
or even on the same one in another moment.
In the same sense as checked-casts, object construction and ROG mutation are soundly checked by our system,
and success in a mutation means that in that specific execution, validity was preserved.




%load Item i
%  playCargo(this.cargo(),i)
%
%static playCargo(mut Cargo c, Item i)
%  c.add(i)
%  c.remove(i)
%  
% 
%valid/validation/validity
%
%name of the method: valid/validate
%-----------------------------------
%
%
%%awesome capability objects
%
%%awesome type modifiers
%
%awesome exception safety %%no, we try to sell Exception safety as an application of TM
%
%%with those 3 together we get validation
%
%%is like a extended type system %? yes by comparision with casts?
%
%contrast with class invariants
%
%
%valid only access fields
%
%valid
%
%
%patterns wrapper/state variable allows for flexible invariants
%
%verify the programmer intentions are self-consistent
%
%encoding post conditions and pre conditions as specialized types
%
%code example
%

%%%
%%%May coonect with "OffensiveProgramming/DefensiveProgramming".
%%%


\noindent\textit{Structure of our paper:} We now present how a real language could support
validation. 
We would like to underline that the
features we need have all been presented in the past, but their application to sound validation has never been explored.

%To ease our explanation, we present various categories
%of objects where we can support validation, starting from the simpler one to handle.
In Section \ref{s:background} we will introduce one by one the various
language features cooperating
to support validation. %, and we work under the assumption that there are no static variables.
We will provide a brief introduction to type modifiers, object capabilities, and exception safety.

In Sections \ref{s:validate}, \ref{s:immState}, and \ref{s:encapsulated}, we will show how TM and OC enable validation.
To clearly communicate what kind of checks the language semantics should perform,
 we will write them down as if they were `generated source code'.
However, our proposed approach is independent of the actual technique to insert these checks, and they may instead be inserted directly into bytecode, or they can be part of the underlying semantics of a virtual machine.

In Section \ref{s:meaning} we will provide formal definitions, and in Appendix \ref{s:proof} we provide  a proof that our language soundly enforces validation.




