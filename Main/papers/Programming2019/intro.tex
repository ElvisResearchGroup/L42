
\section{Introduction}
\saveSpace\saveSpace
Reasoning about imperative object oriented (OO) programs is a non trivial task,
made particularly difficult by mutations, aliasing, dynamic dispatch, dynamic class loading,
unrestricted I/O(input/output) and exceptions.

Static verification with method contracts can prove correctness of OO programs, but is costly and requires to define the desired semantic of the program in a verification language then prove consistency.
This however require to limit dynamic class loading, ensuring that only statically verified code can be loaded.
Without this restriction, even predicting the behaviour of an innocent looking call, like 
\Q@myPoint.getX()@ is impossible: the dynamic type of \Q@myPoint@ can refer to a dynamically loaded class
whose method \Q@.getX()@ uses I/O to behave non deterministically, or even to format the user hard drive.

Recent research on type modifiers (TM) and object capabilities (OC) offer us a simpler way to perform high-level reasoning on OO programs without restricting dynamic class loading or employing a verification language.
For example, type modifiers has been used to enforce ownership and to guarantee correct behaviour of
parallel code[]. Object capabilities have been used to enforce certain methods to be deterministic and to not perform I/O[joe].
Given these benefits, many emerging languages (as Rust[] and newspeak[])
support some forms of type modifiers and/or object capabilities.

\loseSpace

\subsection{Validation}
In this paper, we rely on TM and OC to define a language ensuring \textbf{validation}: that is, its ensure a user defined property (it being 'valid') holds for all instances of a class.

%##what is validation
Some classes can provide a \Q@Bool validate()@ method, encoding the expectations
all instances should satisfy.
An object \Q@o@ is valid when \Q@o.validate()@ would return \Q@true@, and is invalid in all the other cases (return \Q@false@, exception or non termination).
We say that a language enforces object validity if:
\begin{itemize}
\item \Q@.validate()@ methods are guaranteed to be deterministic and to not mutate any state; they represent logic predicates on the reachable object graph (ROG).
\item Invalid object are not reachable by application code. Thus programmers can always assume such properties to hold.
For example, at the point of a method call,
all the parameters (including \Q@this@) and all the objects in their ROG will be valid.
\end{itemize}

\noindent 

\subsection{How we implement}
Our language supports validation by invoking the \Q@.validate()@ method before a possibly invalid object becomes reachable. Such invocations are not present in the code written by the programmer. 
Like assertions, an (unchecked) exception is thrown if such a call returns false (indicating that the object is invalid).

Note how validation does not ensure the absence of invalid objects, instead we use exceptions to steer execution to a point where the type-system ensures the object is not reachable.
If you were to step with the debugger, you may see invalid objects, and validation checks failing.

Our approach follows the principles of \textbf{Offensive programming}:
\begin{itemize}
\item The failure (unchecked exception)
is raised as near as possible to the defect: the operation creating an invalid object (``fail-fast'').
\item No attempt to fix or recover the invalid object is performed.
%, and all objects observing modified by the execution
%creating such objects are made be unreachable if the corresponding unchecked exception was to be captured.
\end{itemize}

\subsection{Random stuff }
We show that a naive approach that just checks \Q@.validate()@ at the end of constructors and setters would be insufficient. We take advantage of TM+OC to conservatively identify classes where validation is possible.
%
%\noindent\textit{Similarity with checked casts:}%
%\subsection{Extended type system and similarity with checked casts}
Even if not as good as full static verification, from a formal perspective
 our system clearly \textbf{aid reasoning}.
However, programmers are still responsible to create and mutate objects in order to preserve their validity;
but once an object has been successfully created/mutated, is guaranteed to be valid.
Attempting to create a new invalid object, or to mutate an object into an invalid one causes
a run time error.

This is similar to casts in Java with respect to casts in C:
In both languages the programmer is responsible to cast values correctly.
However, in Java casts are soundly checked: if in a Java program the control flow go over a cast,
 we know that in that specific
execution such assumption was correct.
On the other side incorrect C casts just default to undefined behaviour:
if a C execution continue after a cast, we know absolutely nothing. The same execution
 may fail when run on a different machine, 
or even on the same one in another moment.

In the same sense, object construction and ROG mutation are soundly checked by our system,
and success in a mutation means that in that specific execution, the validity was preserved.




%load Item i
%  playCargo(this.cargo(),i)
%
%static playCargo(mut Cargo c, Item i)
%  c.add(i)
%  c.remove(i)
%  
% 
%valid/validation/validity
%
%name of the method: valid/validate
%-----------------------------------
%
%
%%awesome capability objects
%
%%awesome type modifiers
%
%awesome exception safety %%no, we try to sell Exception safety as an application of TM
%
%%with those 3 together we get validation
%
%%is like a extended type system %? yes by comparision with casts?
%
%contrast with class invariants
%
%
%valid only access fields
%
%valid
%
%
%patterns wrapper/state variable allows for flexible invariants
%
%verify the programmer intentions are self-consistent
%
%encoding post conditions and pre conditions as specialized types
%
%code example
%

%%%
%%%May coonect with "OffensiveProgramming/DefensiveProgramming".
%%%


\saveSpace
\section{A language supporting sound Validation}
\label{s:language}
\saveSpace
We now present how a real language could support
Validation. To ease our explanation, we present various categories
of objects where we can support Validation, starting from the simpler one to handle.
We will introduce one by one the various
\textbf{language features} cooperating
to support Validation.%, and we work under the assumption that there are no static variables.
We will provide a brief introduction to type modifiers, object capabilities, and exception safety and we will show how they enable sound invariant checking.

To clearly communicate what kinds of checks the language semantic should insert,
 we will write them down as if they were ``generated source code''. 
However our proposed approach is independent of the actual technique to insert these checks, and they may be inserted directly into the bytecode, or they can be part of the underlying semantics of the virtual machine.
In this section we rely on code example and informal explanations. In the next section we will provide formal definitions.
We would like to underline that the
features we need have all been presented in the past, but their application to sound Validation has never been explored.



