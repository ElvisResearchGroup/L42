\section{Introduction}
%\newpage
%\LINE

Class invariants are an important concept when reasoning about software correctness.
Class-invariants can be presented as documentation, checked as part of static-verification of class-definitions, or, as we do in this paper, monitored for violations using runtime-verification.
In our system a class specifies its invariant by defining a boolean method called \Q@invariant@. We say that an object is \emph{valid} if calling \Q@invariant@ would return \Q@true@.

An \emph{invariant protocol}~\cite{?} specifies when class invariants need to be checked, and when they can be assumed; if such checks guarantee said assumptions, the protocol is sound.
The two main sound invariant protocols present in literature are visible state semantic \cite{??} and Pack/Unpack~\cite{?}. Visible state semantics expects the receiver's invariant to hold before and after every public method call, and after its constructor. The invariant is simply checked in all such points, and so this approach is obviously sound, but can be incredibly inefficient even in simple cases.
In contrast, pack/unpack marks all objects as either packed or unpacked, where a packed object is one whose invariant is expected to hold.
In this approach, an object's invariant is checked only by the pack-operation.
In order for this to be sound, some form of aliasing and mutation control is necessary. For example, Spec\# uses a theorem prover together with source-code annotations.
While Spec\# can be used for full static verification, it conveniently allows invariant checks to be performed
at run time, while statically verifying aliasing, purity and other similar standard properties.
This allows us to closely compare our approach with Spec\#.
Lets consider an example: we have a \Q@Hamster@ in a \Q@Cage@.
The hamster will move across a list of \Q@Point@s.
The invariant is that the hamster position need to be in such list.
The code for \Q@Point@ and \Q@Hamster@ is unremarkable.
We use twice the annotation \Q@read@ on \Q@equals@ so that it does not modify neither the
receiver nor the parameter.
\begin{lstlisting}
class Point {
  Double x; Double y;
  Point(Double x, Double y) { this.x = x; this.y = y; }
  @Override read method equals(read Object that) {
	if(that==null || !(that instanceof Point)){return false;}
 	return ((Point)that).x==this.x && ((Point)that).y==this.y; 
  } }
class Hamster {
  Point pos; Hamster(Point pos) { this.pos = pos; } }
\end{lstlisting}
Then, in the \Q@Cage@
we use \Q@capsule@ to ensure
the \Q@Hamster@ ROG is fully under the control
of the cage object.
We annotated with \Q@mut@ the methods \Q@move()@
and \Q@moveTo()@ since they modify
the receiver ROG by modifying the hamster.
\begin{lstlisting}
class Cage {
  capsule Hamster h; List<Point> path;
  Cage(capsule Hamster h, List<Point> path) {
    this.h = h; this.path = path; }
  read method Bool invariant() {
    return this.path.contains(this.h.pos); }
  mut method Void move() {
    int index = 1 + this.path.indexOf(this.h.pos);
    if (index >= this.path.Count) index = 0;
    this.moveTo(this.path.get(index));
  }
  mut method Void moveTo(Point p) { this.h.pos = p; } }
..
mut Cage c = new Cage(new Hamster(new Point(0,0), 
	Arrays.asList(new Point(0,0),new Point(1,1))))
\end{lstlisting}
Note how we just use \Q@List.contains()@ and \Q@List.indexOf()@
to check if the hamster position is inside the list.
In our system, the default annotation is \Q@immutable@.

The best Spec\# solution we found that could verify this example is not as natural:
we needed to define our own equalty for \Q@Point@ instead of relying on \Q@Object.Equals@,
thus we could not use \Q@List.Contains@ and \Q@List.IndexOf@.
Here is our solution:
\begin{lstlisting}[language={[Sharp]C}, morekeywords={invariant,ensures,requires,expose,exists}]
class Point {
  double x; double y;
  Point(double x, double y) { this.x = x; this.y = y; }
  [Pure] virtual bool Equal(double x, double y)
  ensures true; { return x == this.x && y == this.y; } }
class Hamster {
  [Peer] Point pos;
  Hamster([Captured] Point pos) { this.pos = pos; } }
class PureObject { [Pure] PureObject() { } }
class Cage: PureObject {
  [Rep] Hamster h;
  [Rep, ElementsRep] List<Point> path;
  Cage([Captured] Hamster h, [Captured] List<Point> path)
    requires Owner.Same(Owner.ElementProxy(path), path);
  { this.h = h; this.path = path; }
  invariant exists {int i in (0 : this.path.Count);
    this.path[i].Equal(this.h.pos.x, this.h.pos.y)};
  void Move() { expose (this) {
    int index = 0;
    while (index < this.path.Count && 
      !this.path[index++].Equal(this.h.pos.x, this.h.pos.y));
    if (index >= this.path.Count) index = 0;
    this.h.pos = this.path[index];
  } } }
..
List<Point> pl = new List<Point>{new Point(0, 0), new Point(0, 1)};
Owner.AssignSame(pl, Owner.ElementProxy(pl));
Cage c = new Cage(new Hamster(new Point(0, 0)), pl);

\end{lstlisting}
%3 read 2 capsule 3 mut extra method moveTo
%----
Summarizing, in Spec\# we had to add ....
%3 pure,
%1 peer
%3 captured
%2 rep
%1 ElementsRep
%1 ensures true
%1 requires Owner.Same(Owner.ElementProxy(path), path);
%1 invariant
%1 exists
%expose(this)
%re implementation of indexOf
%dumb equals(double,double)
%dumb class PureObject { [Pure] PureObject() { } }
%Owner.AssignSame(pl, Owner.ElementProxy(pl));
Also note how we have to manually handle ownership details while instantiating a \Q@new Cage(..)@.
\begin{comment}

\newpage
\begin{lstlisting}
class SafeMovable implements Widget{
  @Override read method Widgets children(){return this.box.cs;}
  @Override read method Int left(){return this.box.l;}
  @Override read method Int top(){return this.box.t;}
  @Override read method Int width(){return this.w;}
  @Override read method Int height(){return this.h;}
  capsule Box box;
  Int w; Int h;
  read method Bool invariant(){//iterate on box.cs, check:
    //not overlap with each other, are inside the widget bounds
  }
  SafeMovable(Int w,Int h,capsule List<Widget> cs) {
    this.w=w; this.h=h; this.box=boxWithButton(cs);}
  static method capsule Box boxWithButton(capsule Widgets cs){
    mut Box b=new Box(5,5,cs);
    b.cs.add(new Button(0,0,10,10,new MoveAction(b));
    return b;//b is declare mut, but it is soundly returned capsule
  }}
\end{lstlisting}

\begin{lstlisting}
class Box{
  Int l; Int t; mut List<Widget> cs;
  Box(Int l, Int t, mut List<Widget> cs){...} }

class MoveAction implements Action{
  mut Box outer; MoveAction(mut Box outer){this.outer=outer;}
  mut method Void process(Event event) {this.outer.l+=1;} }
\end{lstlisting}

\begin{lstlisting}
class Point {int x; int y;
  /*... constructor, equals and other obvious utility methods*/}
class Hamster { Point pos; Hamster(Point pos){this.pos=pos;} }
class Cage {
  Hamster h;  List<Point> path;
  Cage(Hamster h, List<Point> path){ this.h=h; this.path=path; }
  bool invariant(){
    return this.path.contains(this.h.pos);
  }
  void move() {
    int index=1+this.path.indexOf(this.h.pos);
    if (index>=this.path.size()) {index=0;}
    this.h.pos=this.path.get(index);
  }
  String toString(){return "hPos:"+this.h.pos+", path:"+this.path;}
}
\end{lstlisting}
\end{comment}
Ideally, we would like the invariant to be dynamically checked 
at the end of the constructor and at the end of the \Q@move@ method.
However, this would be unsound without some form of aliasing control over \Q@Hamster@,
the \Q@List@ and all the \Q@Point@s, as shown in the following example\footnote{
The visible state semantic prevent \Q@toString()@ from producing a non nonsensical result
by checking the invariant and throwing an invariant error.
}
\begin{lstlisting}
List<Point>ps=Arrays.asList(new Point(2,3),new Point(4,5));
Cage c=new Cage(new Hamster(new Point(2,3),ps);
//invariant holds here
ps.get(0).x=8;//invariant is broken here, since ps
//was accessible from outside the cage
c.toString()//the hamster is in a position that is not on the list
c.invariant();//return false!!
\end{lstlisting}

Moreover, this is unsound also if we can not ensure determinism of the invariant method;
for example we could have an \Q@EvilList@

\begin{lstlisting}
class EvilList<T> extends ArrayList<T>{..
  @Override boolean contains(T elem){return new Random().bool();}
}
..
List<Point>ps=Arrays.asList(new Point(2,3),new Point(4,5));
Cage c=new Cage(new Hamster(new Point(2,3),ps);
//invariant happens to holds at the end of the constructor by chance,
c.invariant();//here instead it return false!!
\end{lstlisting}

Despite the code for \Q@Cage.invariant()@ intuitively looking correct and deterministic, the above calls to it are not. Obviously this breaks any reasoning and should be considered unsound. 
In particular, note how in the presence of dynamic class loading, 
we can not make any assumption on the dynamic type of \Q@path@.
%A:TrustInvariant<><{ int num}
%B:Invariant<><{A a}

Spec\# allows us verify purity and aliasing over this example, so that
it will statically verify that runtime checks are needed only
after the constructor and after the \Q@move@ method.
You can find the
full Spec\# solution in Appendix ??. Such solution required us to add
the following annotations:
\begin{itemize}
\item \Q@[Pure, Reads(ReadsAttribute.Reads.Nothing)]@ to \Q@Point.equals@
\item \Q@[Peer]@ to \Q@Hamster.pos@.
\item \Q@[Rep]@ to \Q@Cage.h@ and \Q@[Rep, ElementsRep]@ to \Q@Cage.path@
\item the following constructor arguments need to be \Q@[Captured]@:
\Q@Point@ in \Q@Hamster@, \Q@Hamster@ in \Q@Cage@.
\item shallow defensive cloning of \Q@path@ is needed in the \Q@Cage@ constructor.
\item\Q@expose(this){..}@ block is needed inside of \Q@move@.
\end{itemize}

Instead of using static analysis, 
is becoming more popular to verify aliasing and immutability using a type system.
For example, there are 3 languages L42, Pony and the language of Gordon at Al~\cite{}
using Type Modifiers (TMs) and Object Capabilities (OCs) to ensure safe and deterministic parallelism.%
\footnote{TMs is called \emph{reference capabilities} in other works. We use the term TM here
to not confuse them with OCs, another technique we also use in this paper.}
While studying those languages, we discovered an elegant way to enforce class invariant.
For example, we can reword the example of before using TMs as in L42 in the following way:
\begin{lstlisting}
class Point {Int x; Int y;
  /*... constructor, equals and other obvious utility methods*/}
class Hamster { Point pos; Hamster(Point pos){this.pos=pos;} }
class Cage {
  capsule Hamster h;  List<Point> path;
  Cage(capsule Hamster h, List<Point> path){ this.h=h; this.path=path; }
  read method Bool invariant(){
    return this.path.contains(this.h.pos);
  }
  mut method Void move() {
    Int index=1+this.path.indexOf(this.h.pos);
    if (index>=this.path.size()) {index=0;}
    this.moveTo(this.path.get(index));
  }
  mut method Void moveTo(Point p){  this.h.pos=p }//new method
  @Override method String toString(){
    return "hPos:"+this.h.pos+", path:"+this.path;
  }
}
\end{lstlisting}

%\begin{lstlisting}
%Point:Data<><{var Num x, var Num y}
%Points:Collections.vector(ofMut:Point)
%Hamster:Data<><{var Point pos}
%Cage:Data<><{
%  capsule Hamster h
%  Points path
%  read method Bool #invariant()
%    this.path().contains(this.h().pos())
%  mut method Void move() (
%    var Size index=1Size+this.path().indexOfLeft(val:this.h().pos())
%    if index>=this.path().size() (index:=0Size)
%    this.move(newPos:this.path().val(index))
%    )
%  mut method Void move(Point newPos)
%    this.#h().pos(newPos)
%  }
%\end{lstlisting}
%In L42 we only need to add 
%1 \Q@read@, 2 \Q@mut@ and 1 \Q@capsule@ annotations.
%We also need to add a new method \Q@moveTo@. This is equivalent to the explicit \Q@expose(this){..}@
%block required in Spec\#.

%To keep the syntax familiar, we present our code example in a tweaked Java syntax using type modifiers.
%If a method override an interface method, we inherit the modifiers from the interface.
%Any non annotated type is implicitly immutable.
%Note how we just added 1 \Q@read@, 2 \Q@mut@ and 2 \Q@capsule@ annotations; in L42 constructors can be automatically generated, this would remove the need for 1 of the\Q@capsule@ annotations.
%We also need to add a new method \Q@moveTo@. This is equivalent to the explicit \Q@expose(this){..}@
%block required in Spec\#.

Also, many verification approaches takes advantage of the separation between primitive types and objects.
L42 is a pure OO language without primitive types, so we can not, and we do not need to, rely
on differences between primitive types and objects.
We write all the types upper-case, to underline this fact.

%In L42 any non annotated type is implicitly immutable.
%We also need to add a new method \Q@moveTo@. This is equivalent to the explicit \Q@expose(this){..}@
%block required in Spec\#.
%In this paper we will show how those minor code modifications are sufficient
%to statically verify that runtime verification is needed only
%after the constructor and after the \Q@moveTo@ method.
%We will also show how designing the standard library in OCs style
%ensures that any \Q@read@ method with no parameters (as \Q@invariant()@) is
%deterministic.
%We obtain our results thanks to coarse grained type system support and a careful design of the standard library, where all the possible sources of non determinism follow the OCs style.

We evaluate our contribution by means of case studies;
to perform our case studies we fully implemented our protocol on L42.
We believe it would be easy to implement our protocol also on those other two languages.
A experimental version of L42 including our invariant is available here [..].
In addition of being so much more compact, our approach can also handle capturing unchecked exceptions
and Isaac may justify IO.


\LINE


%---------------------


Here we propose an invariant protocol with the 
efficiency of pack/unpack, but with a much lower annotation burden.
We have performed a case study to quantify the benefit of our approach:
on a simple use case with 5 objects with class invariants, the visible state semantics 
require checking the invariant 53 millions times more,
%5 objects with invariant, all instances of the same class
while Spec\# and our approach check it only 77 times.
We found the Spec\# annotation burden to be about 3 times more 
than our approach.

In this paper we argue that our protocol is not only more succinct than pack/unpack but is also easier and safer to use.
Moreover, our approach is sound in a broader scope with respect to Spec\#, since we allow sound catching of invariant failures and other unchecked exceptions, and carefully handle
the impact of I/O and other non deterministic operations.

Instead of using static analysis,
we obtain our results thanks to coarse grained type system support and a careful design of the standard library. Three languages already support the type system and the standard library design that we need:
L42, Pony and M\#. To perform our case studies we fully implemented our protocol on L42.
We believe it would be easy to implement our protocol also on those other two languages.

In order to obtain safety, simplicity and efficiency we traded some expressive power:
we can not verify some forms of data-structures, such as collections of mutable elements.\footnote{Our approach does not prevent correctly implement such data-structures, rather we do not support encoding the correctness of such objects as a class-invariant.}
In our case study we show that
we can still encode most of the examples explored in ~\cite{???} (including for example mutable collections of immutable objects) whilst having a significantly lower annotation-burden.
In section \ref{TODO} we...
In section \ref{TODO} we...
In section \ref{TODO} we...

%http://www.cs.cmu.edu/~NatProg/papers/p496-coblenz-Glacier-ICSE-2017.pdf