\saveSpace\saveSpace
\section{Introduction}
\saveSpace
Consider code simulating a port, where a ship is being loaded with cargo:
\saveSpace
\begin{lstlisting}
class Boat{$\Comment{too much cargo and the ship may sink}$
  Bool invariant(){  return cargo.weight()<=300;}
  Items cargo;
  Void load(Item item){  this.cargo.add(item);}
  Item unload(String itemName){  return this.cargo.extract(itemName);}
  }
\end{lstlisting}
\saveSpace

The boat will sink if the weight of the cargo goes over 300.
However, 
\Q@Item@ and \Q@Items@ come from a third party library,  are not annotated with contracts and the authors may change their behaviour in the future.
All the code using \Q@Boat@  (client code) would like to 
assume the boat has not sunk.
In turn, that depends on the behaviour of \Q@Items.weight()@, thus the meaning of the \Q@Boat@ invariant is parametric on the everchanging meaning of  \Q@Items.weight()@.
Can the code in the \Q@Boat@ class somehow enforce that for every possible well typed \Q@Item@ and \Q@Items@, client code will interact only with valid (non sunk)  boats?
That is, we are unable or unwilling to constrain \Q@Item@ and \Q@Items@ to
cooperate into making \Q@Boat@s unsinkable; we aim
to make so that \Q@Boat@s can be correct independently of
possibly buggy, possibly even malicious \Q@Item@ and \Q@Items@ implementations.

This is an arduous task, that cannot be achieved while relying only on conventional Java-like semantics and type system.
Indeed, thanks to the encapsulation, any kind of check in the language,
as in `\Q@if(cargo.weight()>=300){..}@', would delegate the 
behaviour to untrusted code in \Q@Items@.
Even if at a certain moment, a boat respects its
invariant, there is no guarantee that
it will hold at another moment,
even if methods \Q@load/unload@ are not called.
Aliasing would be the most obvious cause, but also I/O can be to blame.
Worse, the \Q@cargo@ may internally record how many times
it has been used, providing low weight whenever we try to test its behaviour, and a high one otherwise.
It appears that there is no way to write a \Q@Boat@
that is correct independently from the rest of the program.

However, there is still hope: the restrictions of the type system will apply,
and the result of \Q@weight()@ is going to be an \Q@Int@.
Holding on tightly to a new hope, how can one design a Java-like language with
a type system just powerful enough, and semantics just constrained enough, so that we can assume the \Q@Boat@ invariant while working with \Q@Boat@ instances, and being promptly notified of sinking \Q@Boat@s?

In this paper we will formally define  Sound Invariant Checking (SIC), an \textbf{ultra-lightweight runtime verification technique} 
 keeping invariants under control, and 
 a Java-like imperative language
 with conventional field update and exceptions handling
 but where the type system and the input/output functionalities
 have been tweaked just enough to support SIC.
 
 We will leverage on recent developments in the area of object capabilities, aliasing and immutability control, and strong exception safety.
The structure of this paper is as follows:

First we show an informal definition of \emph{sound invariant checking}, and we compare it with 
the meaning of invariants in other approaches.
Then in Section~\ref{s:example} by way of a general example we show how arduous our goal is.
Unsurprisingly aliasing is an issue, but so are subtyping, encapsulation, exceptions, and undesired side effects like mutation and I/O.
As we will explain in Section~\ref{s:related}, state of the art runtime verification systems
ignore at least some of the challenges highlighted by our example,
making them unsound from the perspective of our definition of SIC.

% TODO (alex): The above needs cites and unsound needs explanation!


In Section~\ref{s:language} we discuss our approach in the context of
a nominally and statically typed object-oriented language with
imperative features such as field update, input/output and exceptions.
It can perform I/O using  \textbf{object capabilities}.
It supports a rich type system offering \textbf{aliasing and immutability control} and \textbf{strong exception safety}.
We show how to ensure our property for various categories of objects, and 
how those features are important building blocks to support our approach.

Finally in Section~\ref{s:meaning} we formally define \emph{sound invariant checking} and
a language supporting it by a rich type system.
 Section~\ref{s:related} discusses the related work and Section~\ref{s:conclusion} concludes.



\saveSpace\saveSpace
\section{Defining Sound Invariant Checking (SIC)}
\label{s:def}
\saveSpace
In SIC the user specifies their desired invariant by adding an \Q@invariant()@ method:
Each class that has an \Q@invariant()@ method is a
\emph{class with invariant}.
Such invariant methods must return a boolean and take no parameter.
The invariant should reason only over the reachable object graph (ROG) of \Q@this@, and
it must be \textbf{deterministic}:
it should not mutate any pre-existing objects and it should not interact with the outside world.%
\footnote{The invariant methods could throw exceptions, as discussed later.}

Thus, it cannot access any external input or mutable global state.
These requirements allow such method to be seen as a logic predicate over the object.

An object is \textit{coherent} if its \Q@invariant()@ method
would deterministically reduce to \Q@true@ in a finite numbers of steps.
An object is \textit{broken} in case of \Q@invariant@ returning \Q@false@, non termination and any kind of exception/dynamic error.

There are only two cases where reduction steps may involve broken objects:
(1) when an \Q@invariant()@ method is called the receiver may be broken, and (2) inside of the \Q@invariant()@ method, a possibly
broken \Q@this@ may be used to read the value of the fields.
We call these reduction steps \emph{trusted}.
Note that we are referring to the individual reduction steps when calling \Q@invariant()@,
and accessing fields. We do not need to relax the whole computation of the \Q@invariant()@ method.

% TODO (alex) Huh? Relax the whole computation of the method? What does this even mean?

\begin{quote}[SIC]
A language supports SIC
if in the execution of every well typed program in that language,
every reduction step is either trusted or involves only coherent objects.
\end{quote}

\noindent For example, at the point of a method call,
all the parameters will soundly respect their invariant.\footnote{
Our presented solution in Section~\ref{s:meaning} does not requires to run the invariant method for all the objects
in every reduction step, and should induce an acceptable overhead. We will consider efficiency later in the paper.}

\noindent At first glance, it may seem that SIC ensures the absence of broken objects.
Note our careful wording earlier: we are not stating that all invariants hold all the time for all the objects.
A SIC system can just use exceptions to
steer the execution before the broken objects have an opportunity to be observed.
If you were to step with the debugger, you may see broken objects, and
invariant checks failing.

Our very strong SIC property allows to reason about any program in a reliable way.
On the other side, it limits the freedom of programmers,
unable to break SIC even if they needs to and they believe it would be `safe'.
We think this can be compared with type systems, where sometime we
need to introduce extra indirections to satisfy the type system.

 


%Some have attempted using AOP 
% change the semantic of the language injecting checks and collecting data across the whole system.
 
%In this paper we go in the opposite direction and we consider what expressive type

\section{Breaking Things}
\label{s:example}
\saveSpace

\subsection{Breaking objects}
\saveSpace
Static verification ensures all objects are always coherent.
In order to keep such semantics in a runtime verified system,
we should detect violations just before operations that would create a broken object,
thus still keeping all objects always coherent.

Sadly, this seems impossible in the general case with limited knowledge.
%, and even if we could detect them it
%would have nasty consequences.
Going back to our \Q@Boat@ example,
\textbf{without any knowledge about the behaviour of \Q@add()@ and \Q@weight()@}%
%\footnote{A statically verified system with contracts on all methods may have this kind of knowledge.}
there is no way we can discover the invariant violation without actually adding the objects and checking the 
weight after the fact; thus in the general case violations can only be detected 
when a broken object is already present in the system.
Remember that to keep our approach lightweight,
we do not rely on pre-post conditions; thus
the behaviour of \Q@Items.weight()@ and \Q@Items.add(item)@ is uncertain.
The names may suggest a specific behaviour, but there is no contract annotated on such methods.

Note also that in the general case there is no way to fix a broken object,
or to perform a deep clone and to test the operation on the clone first.
In environments offering a powerful enough aspect-oriented support,
it could be possible to detect any field update in the whole ROG of
any object, following the strategy of 
Gopinathan et al.~\cite{Gopinathan:2008:RMO:1483018.1483028}.
Using such power would even be possible to roll-back the very field update that caused 
the invariant to fail, making the object coherent again.
However, we think this would be a \textbf{terrible idea causing unexpected strange behaviour}: for example
assume that we are moving object between two boats:
the overflowing object may be removed from the \Q@cargo@ of the second boat, but it would not
be placed back in the first boat. It would look like the object has disappeared.
The important point here is that the program would be in an unexpected state
even if no object invariants are violated, and this would happen \textbf{because} of the 
invariant checking/fixing behaviour, not because of code written by the programmer.


We believe that the only viable option is to detect violations 
\textbf{after the fact}, that is,
after a broken object has been materialised.
Note how this produces a different semantics with respect to static verification, but as discussed earlier, this will not necessarily lead to a broken semantics: we aim to create a system where those objects and all the witnesses will be garbage collected without influencing the observable behaviour (as happens in alias burying~\cite{boyland2001alias}).

We detect existing broken objects by encoding the invariant as a normal instance method.
Using the underlying programming language instead of a dedicated specification language allows one to transparently refer to the behaviour/interface of any of these reachable objects without exposing their internal representation.
Indeed, in the general case, without relying on primitive types and with no assumptions on the meaning of methods,
\textbf{using the underlying language is the only way to express invariants.}


\subsection{Breaking preconceptions}
Once the need for breaking objects is accepted, 
many programmers may believe that making the fields private and checking the invariant method
at the \textbf{end of the constructor} and at the \textbf{end of mutator methods} is enough to enforce the 
class invariant.
As we will see in this article, in most mainstream object-oriented languages, this is \textbf{very far} from enough.
Let's focus first on a simpler example, when the boat only has its name:
\begin{lstlisting}
class Boat{
  public Bool invariant(){  return !name.isEmpty(); }
  private String name;
  public String name(){ return this.name; }
  public String name(String name){
    this.name=name;
    if(!this.invariant()){throw $\MComment{error}$}
    }
  public Boat(String name){
    this.name=name;
    if(!this.invariant()){throw $\MComment{error}$}
    }
  }
\end{lstlisting}
\noindent At first look, this code seems to correctly enforce SIC.
However our intuition relies not on statically verified properties, or on the semantics of the language,
but on the expectations about ``correct'' behaviour of \Q@String@, and again
we want to enforce the class invariant without assuming the behaviour of the other objects.
\begin{itemize}
\item Sample Bug 1:
Suppose there was a bug in \Q@String.isEmpty()@, causing the method to non-deterministically return \Q@true@ or \Q@false@.
What would it mean for the \Q@Boat@ invariant?
Would a \Q@Boat@ be at the same time 
coherent and broken?

Only deterministic and pure methods can be interpreted as valid invariants.
Ensuring this cannot be responsibility of the \Q@Boat@ programmer, since it may depend on third party code, as shown in this example.
However, statically checking if a method is deterministic and pure is hard/impossible in most imperative object-oriented languages.

While we may not expect the presence of bugs in the standard library class \Q@String@, the same behaviour can be achieved with subtyping:
\saveSpace
\begin{lstlisting}
class EvilStr extends String{
  method Bool isEmpty(){
    return new Random().bool();
  }}
...
String name=...$\Comment{can this be an EvilStr?}$
Boat b=new Boat(name);
\end{lstlisting}
\saveSpace
As you can see, when subtyping is present,
without statically ensuring the purity of the invariants and accounting
for every possible alias in the system one cannot use modular 
reasoning to make any sound claims about object's class invariant.


\item Sample Bug 2:
In our simple example, \Q@Boat@ objects can be mutated using the setter.
However, in modern languages we expect strings to be immutable objects. While we can update the field \Q@name@ to point to another string, we cannot mutate the string object itself.
To obtain  \Q@"Hello"@ from \Q@"hello"@ we need to create a whole new string object that looks like the old one except for the first character.%
\footnote{This is possible in older languages like C, where strings are just mutable arrays of characters.}

Again, the assumption that they are immutable depends on the correctness of the code inside \Q@String@: if there was a bug in the \Q@String@ class, or any \Q@String@ subclass, then executing 
\Q@println(myBoat.name())@ may change \Q@myBoat@ by quietly changing a part of its ROG.

Again, checking
what methods mutate states cannot be responsibility of the \Q@Boat@ programmer.
We need a language supporting aliasing and mutability control.


\item Sample Bug 3:
Under runtime verification, the program can take corrective actions if a property is violated.
This may be implemented with a conventional \Q@try-catch@ if violations are represented by throwing errors.
However, there is an issue with exceptions modelling broken invariants: they can be captured when the broken object is still in scope. For example:

\begin{lstlisting}
 Boat b=new Boat("Mary");
 try{p.name("");}catch(Throwable t){}$\Comment{ Catch and ignore invariant failure:}$
 assert p.name().isEmpty();$\Comment{now we have a broken object around!}$
\end{lstlisting}

As you can see, if we can capture invariant failures as normal exceptions (very desirable feature) then we may end up with objects that have broken class invariants.
Moreover,
 as shown before with the example of transferring cargo between two boats,
after an invariant has been violated, even objects with valid invariant may be in an unexpected state.

This is not a special problem relevant to just invariant, but a more general issue with
recovering from exceptions.
Other authors have identified the concept of Strong Exception Safety~\cite{Abrahams2000}:
when a \Q@try-catch@ captures an exception, the visible state at the start of the catch must be the same as before the \Q@try@ block started its execution.
\end{itemize}

