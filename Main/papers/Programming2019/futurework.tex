\section{Future Work}
Though we prove\footnote{see appendix} that given a type system properly enforcing our TM and OC approach our language would properly enforce validation, we have only informally described our type-system. It is known […] to be quite difficuilt to properly formalize and prove usefull properties of any but the simplest type-systems; as the properties we want from a type system are not specific to validation such work would be out of scope for our paper. Without a proper formal type system however our language is incomplete.


The language, and type-modifier system we have presented here is quite restrictive, even when choosing to not validate classes; of course such restriction is the main ‘feature’ of the system it does however have some that doo seem excesive, in particular the restrictions on \@capsule@ expressions and capsule-mutator methods can require programmers to write lots of extra boilerplate and functions, and prevent entire classes of object’s from being properlly validated (such as a LinkedList of mutable elements).


Though it is possible to relax these restrictions whilst still ensuring our desired semantics, doing so is unlikely to be simple; un particular we believe simplicity of a type-system is valuable, not only does it make it easier to implement and reason about, it can also make it easier to \emph{use}: if a programmer understands the language they are using they are more able to write code in a way that works as expected.


Rather than providing a simple set of rules as to what a \Q@validate@ method can contain, and where to insert calls to it, we could instead rely on implementation-specific static analysis: in which a \Q@validate@ method is valid iff the compiler can prove that it is deterministic and that it’s generated \Q@validate()@ calls are sufficient to enforce validation. Though approaches like this are frequently used such as with unifying Java’s generic-wildcards [], Rust’s ‘borrow checker’, …; we believe that would not produce a good result for our purposes: 
\begin{itemize}
	\item it would mean that a programmer would have no way of telling whether their code would compile, in particular code compiling would depend on the specific compiler (version) used.
	\item the runtime cost of validation would be completely unpridictibable; since it is deterministic there is nothing stopping the compiler from calling \Q@validate@ any number of times, and at any point in time.
	\item When a validation error could be throw would likewise be unpredictable, though it should happen after an object is made invalid\footnote{technically our definition of validation technically allows the error to happen sooner, as long as it’s not too late; however pre-emptive errors like this would be extremely hard to debug}, it could happen any time before it’s use. Making matters worse, if multiple object’s would be invalidated before either is used, which one’s error would be thrown is unconstrained
	\item This approach will not work well in the pressence of dynamic code loading, in particular it woud likley significantly slow down such loading or spurioslly fail depending on what other code has been loaded
\end{itemize}


An alternative, less powerful but ultimately more usable approach would be to extend our type system and programs with additional (programmer provided, or generated) annotations, such as additional ownership-based type-modifiers, in order to keep track of the properties of objects.