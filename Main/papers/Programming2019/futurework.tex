\section{Conclusions and Future Work}

\LINE

Our approach follows the principles of \emph{Offensive programming}
~\cite{stephens2015beginning}, where 
no attempt to fix or recover the invalid object is performed and
%	\begin{itemize}
%\item
 the failure (an unchecked exception)
		is raised close to the defect:
    the method directly calling the operation breaking the invariant is still on the stack trace.
%}{3}{[meaning] is not clear} (the operation creating an invalid object), i.e. we ``fail-fast''.    
%		\item
%	\end{itemize}


The aim of our work is only to enforce validation, so we do not present complexities unnecessary for this purpose. We do not formalize any specific type system, to stay parametric over 
the various existing type systems which provably enforce the properties we require for our proof (and much more).
In essence we present what we \emph{believe} to be the simplest sound system.
It could be worthwhile formalising the minimal type system required by validation.



%However the restrictions we make to ensures that \Q@validate@ is deterministic, namely those the type-system enforces due to its signature, seem quite flexible and reasonable;

%%%%%examples of things that future work may investigate allowing are deterministic I/O and multi-threading. 


The language we have presented here restricts the form of \validate
and capsule mutator methods; in particular
our strong restrictions of capsule mutator methods
allows injection of \validate{} calls merely at the end of such methods.
While these restrictions do not interfere with simple
forms of validation, to verify complex mutable data-structures we necessitate verbose patterns (such as our `box').

We believe it is possible to relax our restrictions whilst
still ensuring our desired semantics, however such a language is unlikely to be easily understood by programmers;
being able to predict whether code would be well typed allows programmers
to better take advantage of the language.
Directions that could be investigated to improve our work include the addition of syntax-sugar to ease the burden of our suggested patterns; type modifier inference, and support for flexible ownership types.

%Our work, in comparison to previous RV techniques,
%aims to be efficient by limiting the number of validation calls, however we have \REVComm{no empirical evaluation of our approach's performance}{3}{\label{CONTRA1}contradictory to [see footnote \ref{CONTRA2}]}.
%To improve efficiency it could be worth investigating elision of unnecessary validation calls
%or even only validating parts of objects (by running the part of \Q@validate@ that could fail).