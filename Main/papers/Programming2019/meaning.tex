\saveSpace
\section{Formal properties of Validation}
\label{s:meaning}
\saveSpace
In order to model our system, we need to formalise an imperative object-oriented language
with exceptions and object capabilities,  and with a rich type system
supporting \Q@mut, imm, read, capsule@ and strong exception safety.
Formally modelling the semantics of such language is easy, but 
modelling and proving correctness of such rich type system would deserve a paper
of its own, and indeed many such papers exist in literature%
~\cite{ServettoEtAl13a,ServettoZucca15,GordonEtAl12,clebsch2015deny,JOT:issue_2011_01/article1}.
Thus, we are going to assume that there is an expressive and sound type system enforcing
those properties, and we are going to focus on validation.
To provide a good modularisation for our reasoning, 
we will clearly list the properties we need to rely upon, so that \emph{every type
system supporting those properties} is a good match for validation.

To encode object capabilities and I/O, we assume a special object
$c$ (a special kind of object location $l$) of type \Q@Cap@.
This object will have fields modelling, for example, the content of input and output files.
All its methods are going to require a \Q@mut this@, and the main expression will start with
such  $c$ object in scope.
The typing will start assuming $c:$\Q@mut Cap@.

\noindent We strived to keep our small step semantic as conventional as possible; following Pierce~\cite{pierce2002types} we assume:
\begin{itemize}
\item An implicit program/class-table $p$.
\item memory $\sigma:\!:\!= l\mapsto C\{\Many{l}\}$ as a finite map from locations $l$ to annotated tuples $C\{\Many{l}\}$ representing objects,
where $C$ is the class name and $\Many{l}$ contains the values for the fields.
\item a main expression $e$ that is reduced in the context of such memory and program.
\item a reduction arrow $\sigma|\e\rightarrow \sigma'|e'$.
\item a type system $\Sigma;\Gamma\vdash\e:T$ where 
the expression $\e$ can contain locations $l$ and free variables $x$;
the type of locations is encoded in the memory environment $\Sigma:\!:\!= l\mapsto C$
and the type of the free variables is encoded in the variable environment $\Gamma:\!:\!= x\mapsto T$.
\item We use $\Sigma^\sigma$ to trivially extract $\Sigma$ from a memory $\sigma$.
\item The special capability object $c$,is of the reserved type
\Q@mut Cap@.
\item We have a special \emph{monitor} expression \Q@M(@$l$\Q@;@$\e_1$\Q@;@$\e_2$\Q@)@,
the user will never write those expressions, they are inserted by the reduction as
a form of instrumentation engine: they are used to validate.
They will all start with $\e_2=$\Q@l.validate()@;
the idea is that $\e_1$ is reduced until it becomes a value, then
$\e_2$ is used to test if $l$ is broken.
\item We do not need an explicit \Q@error@  expression.
The failure of a monitor, that is 
\Q@M(@$l$\Q@;@$v$\Q@;false)@ represents a run time error. It could also be wrapped inside
of other expressions, excluding \Q@try-catch@es, as defined in the metavariable $\mathit{error}$.
\item Before reducing the body of a \Q@try@, we annotate it with a snapshot of 
the state of the memory. The idea is that such state will not be mutated by executing
the body of the \Q@try@.

\end{itemize}

To keep our formalization focused on
the challenges of validation, 
there are some
tweaks with respect to our informal description of our approach.
From a formal perspective 
those changes do not change the expressiveness:
\begin{itemize}
\item All fields are instance-private (was: capsule fields are instance-private):
for non capsule fields, we could always provide getters and setters.
\item Constructors are standard (was: can only access/initialize fields): to provide flexible initialization, we could always use a factory
\item \Q@.validate()@ can only use \Q@this@ to access fields (was: can call methods that do not use \Q@this@ directly):
we model the semantic after a simple inlining pre-processing.
\item For simplicity, in our formal model we do not have actual exception objects;
we believe adding them would not cause any interesting
variation to our proof.
\end{itemize}


\subsection{Grammar and Well-formedness criteria}

\newcommand{\ctxG}{\myCalBig{G}}
\renewcommand{\vs}{\Many{v}}
\renewcommand{\Opt}[1]{#1?}
\begin{figure}
\!\!\!\!\begin{grammatica}
\produzione{\e}{\x\mid l\mid\Kw{true}\mid\Kw{false}\mid \e\singleDot\m\oR\es\cR\mid \e\singleDot\f 
\mid\e\singleDot\f\equals\e 
\mid\Kw{new}\ C\oR\es\cR
\mid\Kw{try}\oC\e_1\cC \Kw{catch}\oC\e_2\cC
}{expression}\\
\seguitoProduzione{
\mid M\oR l;\e_1;\e_2\cR\mid\Kw{try}^{\sigma?}\oC\e_1\cC \Kw{catch}\oC\e_2\cC
}{run-time expr.}\\
\produzione{v}{l}{value}\\
\produzione{\ctx_v}{\square
\mid \ctx_v\singleDot m\oR\es\cR
\mid v\singleDot\m\oR\Many{v}_1,\ctx_v,\es_2\cR
\mid \ctx_v\singleDot\f 
\mid \ctx_v\singleDot\f\equals\e
\mid v\singleDot\f\equals\ctx_v
}{evaluation ctx}\\
\seguitoProduzione{
\mid \Kw{new}\ C\oR\Many{v}_1,\ctx_v,\es_2\cR
\mid M\oR l;\ctx_v;\e\cR
\mid M\oR l;v;\ctx_v\cR
\mid \Kw{try}^\sigma\oC\ctx_v\cC\Kw{catch}\oC\e\cC}{}\\

\produzione{\ctx}{\square\mid\ctx.m\oR\es\cR\mid\e\singleDot\m\oR\es_1,\ctx,\es_2\cR\mid \ctx\singleDot\f 
\mid \ctx\singleDot\f\equals\e
\mid \e\singleDot\f\equals\ctx
\mid \Kw{new}\ C\oR\es_1,\ctx,\es_2\cR
}{full ctx}\\
\seguitoProduzione{
\mid
M\oR l;\ctx;\e\cR\mid
M\oR l;\e;\ctx\cR\mid
\Kw{try}^{\sigma?}\oC\ctx\cC\Kw{catch}\oC\e\cC\mid
\Kw{try}^{\sigma?}\oC\e\cC\Kw{catch}\oC\ctx\cC

}{}\\


%\produzione{M_l}{\ctx[M\oR l,\e\cR]}{}\\
%\produzione{\ctxG_l}{
%  M_l\singleDot\m\oR\es_1,\ctx,\es_2\cR
% |\e\singleDot\m\oR\es_1, M_l, \es_2, \ctx, \es_3\cR
% |M_l\singleDot\f\equals\ctx
% |\Kw{new}\ C\oR\es_1,M_l,\es_2,\ctx,\es_3\cR
% |\Kw{try}\oC\ctx\cC\Kw{catch}\oC\e\cC
% |\ctx[\ctxG_l]}{}\\
\produzione{CD}{\Kw{class}\ C\ \Kw{implements}\ \Many{C}\oC\Many{F}\,\Many{M}\cC\mid 
\Kw{interface}\ C\ \Kw{implements}\ \Many{C}\oC\Many{M}\cC
}{class decl}\\
\produzione{F}{\T\ \f;}{field}\\
\produzione{M}{\mdf\, \Kw{method}\, \T\ \m\oR\T_1\,\x_1\ldots\T_n\,\x_n\cR\Opt\e}{method}\\
\produzione{\mdf}{\Kw{mut}\mid\Kw{imm}\mid\Kw{capsule}\mid\Kw{read}}{modifier}\\
\produzione{\T}{\mdf\,C}{type}\\
\produzione{r_l}{
 v\singleDot\m\oR\Many{v}\cR
\mid v\singleDot\f
\mid v_1\singleDot\f\equals v_2
\mid \Kw{new}\,C\oR\Many{v}\cR
\quad\text{with }l\in \{v,v_1,v_2,\Many{v}\}
}{$l$ inside a redex}\\
\produzione{\mathit{error}}{
\ctx_v[\Kw{M}\oR l; v;\Kw{false}\cR]
\quad\text{with }
\ctx_v \text{not of form}\ \ctx_v'[\Kw{try}^{\sigma?}\oC\ctx_v''\cC\Kw{catch}\oC\_\cC]
}{error}
\end{grammatica}

\caption{Grammar}
\end{figure}

The detailed grammar is exposed in Figure 1.
As explained before, the only non-standard expression is the monitor.
We denote with $r_l$ a redex that contains the location $l$.

For simplicity, we require all field access in method bodies are on form
\Q@this.@$f$. Thus we require all fields to be instance-private.
All field accesses in the main expression are of form $l\singleDot\f$.

\noindent Well formedness criteria:
\begin{itemize}
\item \Q@.validate()@ takes a \Q@read this@, and uses \Q@this@ only to access fields. Even calling methods on \Q@this@
is disallowed.
\item All the fields referred in \Q@.validate()@ are either \Q@imm@ or \Q@capsule@.
\item All the methods that access capsule fields 
either have a \Q@read this@ (this allows to write a getter),
or have \Q@mut/capsule this@, no \Q@mut@ or \Q@read@ parameters, no \Q@mut@ result and 
use \Q@this@ exactly once in their body.
\item 
During reduction, locations $l$ that are preserved by a \Q@try@ block, are
never monitored; formally 
in $\Kw{try}^\sigma\oC\e\cC\_$, $\e$ not of form $\ctx[$\Q@M(@$l;\_$\Q@)@$]$ with $l\in\sigma$.
\end{itemize}

We model subtyping with interfaces 
and we do not consider \Q@extends@ and subclassing.
Indeed interfaces do not have implemented \Q@.validate()@ method, objects implementing those interfaces do.
To enrich our formalism with subclassing, we would need to add the well 
formed criteria that \Q@validate()@ methods starts by calling the \Q@super@.\Q@validate()@.
\saveSpace
\subsection{Reduction rules}
\saveSpace
\begin{figure}
$\begin{array}{l}
 \inferrule[(update)]{{}_{}}{
\sigma|l.f\Kw{=}v\rightarrow \sigma[l.f=v]|
\text{M}\oR l;l;l\singleDot\text{validate}\oR\cR\cR
 }{}
\quad
 \inferrule[(new)]{{}_{}}{
\sigma|\Kw{new} C\oR\vs\cR\rightarrow \sigma,l:C(\vs)|
\text{M}\oR l;l;l\singleDot\text{validate}\oR\cR\cR
 }{}
\\[5ex]
 \inferrule[(mcall)]{{}_{}}{
\sigma|l\singleDot\m\oR v_1,\ldots,v_n\cR\rightarrow \sigma|
\e'[\Kw{this}=l,\x_1=v_1,\ldots,x_n=v_n]
 }{
  \begin{array}{l}
  \sigma(l)=C(\_)\\
  C.m=\mdf\,\Kw{method}\,\T\,\m\oR\T_1\,\x_1\ldots\T_n\x_n\cR\e\\

\text{if }\ \exists \f\text{ such that}\ \ C.f=\Kw{capsule}\,\_,
\mdf=\Kw{mut},
\\*\quad\f\, \text{inside}\, C\singleDot\m
\text{ and }
\f\,\text{inside}\, C\singleDot\mathtt{validate}

\\*
\text{then }\e'=\text{M}\oR l;\e;l\singleDot\mathtt{validate}\oR\cR\cR\\*
\text{otherwise }\ \e'= \e
  \end{array}
}
\\[5ex]
 \inferrule[(monitor exit)]{{}_{}}{
\sigma|\Kw{M}\oR l; v;\Kw{true}\cR\rightarrow \sigma|v
 }{}
\quad

 \inferrule[(ctxv)]{\sigma_0|\e_0\rightarrow\sigma_1|\e_1}{
\sigma_0|\ctx_v[\e_0]\rightarrow \sigma_1|\ctx_v[\e_1]
 }{}

\quad
 \inferrule[(try enter)]{{}_{}}{
\sigma|\Kw{try}\oC \e_1\cC\Kw{catch}\oC\e_2\cC\rightarrow 
\sigma|\Kw{try}^\sigma\oC\e_1\cC\Kw{catch}\oC\e_2\cC
 }{}
\quad


\\[5ex]


 \inferrule[(try ok)]{{}_{}}{
\sigma,\sigma'|\Kw{try}^{\sigma}\oC v\cC\Kw{catch}\oC\_\cC\rightarrow \sigma,\sigma'|v
 }{}
\quad

 \inferrule[(try error)]{{}_{}}{
\sigma,\_|\Kw{try}^\sigma\oC \mathit{error}\cC\Kw{catch}\oC\e\cC\rightarrow \sigma|\e
 }
\quad
 \inferrule[(access)]{{}_{}}{
\sigma|l.f\rightarrow \sigma|\sigma[l.f]
 }{}
%\quad
\end{array}$
\caption{Reduction rules}
\end{figure}

Reduction rules are defined in Figure 2.
Those rules are pretty standard;
rule \textsc{mcall}
uses the intuitive auxiliary function $\text{inside}$
formally defined as follow:

\noindent $\begin{array}{l}
\f\, \text{inside}\, C\singleDot\m\text{ holds iff }
C\singleDot\m=\_\,\Kw{method}\_\,\ctx[\Kw{this}\singleDot\f]
\end{array}$

\noindent Inserting the monitor expressions during reduction is convenient for the proof,
but a concrete implementation would
instead instrument the byte code as shown in the informal examples before.

That is, the monitor is added for all field update and new objects, but;
for method calls the monitor is added if the method has \Q@mut@ modifier and its body accesses \Q@capsule@ field.

The interaction with monitors and exceptions are interesting:
a monitor release the value if the check is \Q@true@, and raises an error if the 
check is \Q@false@.
In case either $\e_1$ or $\e_2$ are not values, the execution is propagated inside
by \textsc{ctxv}.
If either $\e_1$ or $\e_2$ throw an error, such error is captured by 
\textsc{try error}.
Thanks to strong exception safety
in this case we do not need to worry
if the (partial) execution of $\e_1$ broke the $l$ object.
If the language was to support checked and unchecked exceptions, and offered 
strong exception safety only for the unchecked ones, then 
the type system should require both $\e_1$ and $\e_2$ to not leak 
checked exceptions.





%WHERE TO PUT THIS?
%Note that for \Q@capsule@ fields, the constructor and the field update
%will require \Q@capsule@ for the correspoi, while the field access will produce a \Q@mut@.



\subsection{Axiomatic type properties}

As discussed, instead of providing a concrete set of type rules, we provide a set of properties
that such type system needs to respect.
To express those properties, we first need some auxiliary definitions:

%\noindent\textbf{Define}
%$\mathit{encapsulatedObj}(C)$:\\*
%${}_{}$\quad\quad \Q@class @$C$\,\Q@implements @$\Many{C}$\Q@{@$\,\Many{F}\,\Many{M}$\Q@}@
% and $\forall \mdf\,C\,\f \in \Many{F},\ \mdf \in \{\Kw{imm},\Kw{capsule}\}$\\*
%\noindent As we discussed, only encapsulated objects can support invariants;
%their class declarations only have immutable or capsule fields. Note how here we see immutable
%and simple objects as special cases of encapsulated ones.

\noindent\textbf{Define} $\mathit{erog}(\sigma,l_0)$\\*
${}_{}\quad\quad
l \in \mathit{erog}(\sigma,l_0)
\text{ if } \Sigma^\sigma(l_0).f \in \{\Kw{imm}\,\_,\Kw{capsule}\,\_\}
\text{ and } l \in \mathit{rog}(\sigma,\sigma(l_0).f)
$\\*
\noindent
The encapsulated ROG of $l_0$ is composed by all the objects
in the ROG of its immutable and capsule fields.


\noindent\textbf{Define} $\mathit{mutated}(l,\sigma,\e)$\\*
${}_{}$\quad\quad with $T=\Kw{imm}\,\Sigma^\sigma(l)$ and $\e=\ctx[l]$,\\*
${}_{}$\quad\quad $\Sigma^\sigma,\x:T\vdash\ctx[\x]:T'$ does not hold for any $T'$.\\*
\noindent That is, an object can be mutated by a $\sigma,\e$ if there is an occurrence of 
$l$ in $e$ that when seen as immutable makes the expression ill-typed.



\noindent\textbf{Define}$\ \sigma_0|e_0\Rightarrow \sigma_1|e_1$:\\*
${}_{}$\quad\quad
iff $\{\sigma_1|\e_1\}=\{\sigma|\e \text{ where } \sigma_0|e_0\rightarrow \sigma|e\}$

%if $\ \sigma_0|e_0\rightarrow \sigma|e$ then $\sigma_1|\e_1=\sigma|\e$
% $\exists! \sigma_1|\e_1$ such that $\sigma_0|\e_0\rightarrow \sigma_1|\e_1$\\*
\noindent We define
a deterministic reduction arrow;
as discussed earlier, validation expressions inside monitors need to behave deterministically.
Here we require that there is exactly one reduction possible.


%We can now assume the following properties over the type system:

\begin{Assumption}[Progress]
if $\Sigma^{\sigma_0}\vdash e_0: T_0$,
and $e_0$ not a value or $\mathit{error}$, then
$\sigma_0|e_0\rightarrow \sigma_1|e_1$
\end{Assumption}


\begin{Assumption}[SubjectReductionBase]
if $\Sigma^{\sigma_0}\vdash e_0: T_0$,
$\sigma_0|e_0\rightarrow \sigma_1|e_1$,
then
$\Sigma^{\sigma_1}\vdash e_1: T_1$
\end{Assumption}


\begin{Assumption}[MutField]
(1)\ if $\Sigma;\Gamma\vdash\e\singleDot\f:\Kw{mut}\,\_$
then $\Sigma;\Gamma\vdash\e:\Kw{mut}\,\_$
\ \ and \\*(2)
if $\Sigma;\Gamma\vdash\e\singleDot\f\Kw{=}\_:\_$
then $\Sigma;\Gamma\vdash\e:\Kw{mut}\,\_$
\end{Assumption}
\noindent If the result of a field access is mutable,
the receiver is mutable too, and the receiver of a field update is always mutable.

\begin{Assumption}[HeadNotCircular]
if
$\Sigma^\sigma;\Gamma\vdash l:\_\,C$
then $l\notin\text{erog}(\sigma,l)$
\end{Assumption}
\noindent
\noindent An immutable or capsule field do not contain
An object is not part of the ROG of its immutable or capsule fields.


\begin{Assumption}[CapsuleTree]
If   $\Sigma^\sigma;\Gamma\vdash \e:\T$,
$l_2\in\text{erog}(\sigma,l_1)$,
$l_1\in\text{erog}(\sigma,l_0)$,\\*
and
$\mathit{mutated}(l_2,\sigma,\e)$
then 
$l_2\notin\text{erog}(\sigma\setminus l_1,l_0)$
\end{Assumption}
\noindent In a well typed $\sigma,e$, if mutable $l_2$ is reachable from
$l_1$, and $l_1$ is reachable from $l_0$,
then all the paths connecting $l_0$ and $l_2$ pass trough $l_1$; thus
if we was to remove the node $l_1$ from the object graph, $l_0$ would not reach $l_2$ any more.


CapsuleTree and HeadNotCircular together 
shows that capsule fields section the object graph into a tree,
where nodes are mutable encapsulated objects and
edges are given by reachability between those objects in the original memory:

$l_2$ is in the encapsulated ROG of $l_1$;
$l_2$ is mutated \textbf{and} is reached trough $l_1$, thus
it must be reachable by an $l_1$ \Q@capsule@ field.
Thanks to HeadNotCircular and $l_1\in\text{erog}(\sigma,l_0)$ we can derive 
$l_0\notin\text{erog}(\sigma,l_1)$.



\begin{Assumption}[Determinism]
if $\emptyset;\Gamma\vdash \e:\T$, $\e'=\e[x_1=l_1,\ldots,x_n=l_n]$,
$\Sigma^\sigma;\emptyset\vdash \e':\T$,
$\forall x \Gamma(x)\neq\Kw{mut}\,\_$ and
$\sigma | \e'\rightarrow^+ \sigma' | \e''$
then 
$\sigma | \e'\Rightarrow^+ \sigma,\_ | \e''$
\end{Assumption}
\noindent The execution of an expression
with no \Q@mut@ free variables is deterministic and do not
  mutate pre existing memory (and thus does not not perform I/O by mutating pre existing $c$).


\begin{Assumption}[StrongExceptionSafety]
if $\Sigma^{\sigma,\sigma'};\emptyset\vdash \ctx[\Kw{try}^\sigma\oC\e_0\cC\Kw{catch}\oC\e_1\cC]:\T$
and\\*
$
\sigma,\sigma'|\ctx[\Kw{try}^\sigma\oC\e_0\cC\Kw{catch}\oC\e_1\cC]\rightarrow 
\sigma''|\ctx[\Kw{try}^\sigma\oC\e'\cC\Kw{catch}\oC\e_1\cC]
$
then 
$\sigma''=\sigma,\_$
and
$\Sigma^\sigma;\emptyset\vdash \ctx[\e_1]:\T$
\end{Assumption}
\noindent
For each \Q@try-catch@, the execution preserve the memory needed to continue the execution in case of error
(the memory visible outside of the \Q@try@)%

%Thanks to how our reduction rules are designed, especially \textsc{try error},
%@Progress will need to rely on @StrongExceptionSafety internally.

Note that our last well formedness rule requires 
rules \textsc{update} and \textsc{mcall} to introduce
monitor expressions only over locations
that are not preserved by a \Q@try@ block.
This can be achieved since monitors are introduced
around $\mathit{mutating}$ operations
(and \textsc{new}),
and StrongExceptionSafety ensures no mutation happens on the preserved memory.

To the best of our knowledge, only the type system of 42~\cite{ServettoEtAl13a,ServettoZucca15}
 supports all those assumptions out of the box,
while both~\cite{GordonEtAl12} and Pony~\cite{clebsch2015deny,clebsch2017orca} supports all except StrongExceptionSafety,
however it should be trivial to modify them to support it:
the \Q@try-catch@ rule need to be modified so that
$\Gamma\vdash\Kw{try}\oC\e_0\cC\Kw{catch}\oC\e_1\cC:\T$
if $\Gamma'\vdash\e_0:\T$ and $\Gamma\vdash\e_1:\T$,
where $\Gamma'$ is a weaker version of gamma where all the mutable
references are seen as read; formally $\Gamma'=\Gamma,\{x:\Kw{read}\,C | x:\Kw{mut}\,C\,\in\Gamma\}$.

\subsection{Statement of Validation}

\noindent We can now define what it means for validation to hold:
The call to \Q@.validate()@ needs to deterministically reduce to \Q@true@ in a finite number
of steps. 
That is, an object is \emph{invalid} if calling its \Q@.validate()@
method would not produce \Q@true@, and this includes \Q@false@, non termination and raising an exception.
We also require the reduction to preserve the memory \Q@sigma@.
Note how thanks to `$\sigma,\_ $' new objects can be created and freely mutated, while 
pre existing objects will stay unmodified.
Then, we can define the set of trusted steps, 
as the call to \Q@.validate()@ and the field access inside a monitor.

\noindent\textbf{Define} $H(\sigma,l)$:\\*
${}_{}$\quad\quad$\sigma | l.validate()\Rightarrow^+ \sigma,\_ | \text{\Q@true@}$\\*
\noindent\textbf{Define} $\mathit{trusted}(\ctx_v,r_l)$:\\*
${}_{}$\quad\quad either
$r_l=l$\Q@.validate()@ and
 $\ctx_v=\ctx_v'[$\Q@M(@$l$\Q@;@$v$\Q@;@$\square$\Q@)@$]$\\*
${}_{}$\quad\quad or
$r_l=l$\Q@.f@ and
 $\ctx_v=\ctx_v'[$\Q@M(@$l$\Q@;@$v$\Q@;@$\ctx_v''$\Q@)@$]$

${}_{}$

\noindent Finally, we can define our main property: every object involved in any untrusted redex
is coherent.

\begin{Theorem}[Sound Validation]
if $c:\text{Cap}\vdash \e: \T$ and
$c:\text{Cap}\{\_;\_\}|\e\rightarrow^+ \sigma|\ctx_v[r_l]$, then
either $H(\sigma,l)$ or $\mathit{trusted}(\ctx_v,r_l)$.
\end{Theorem}

We believe this property captures very precisely our statement in Section~\ref{s:def}.
The proof is in the appendix. 
%The structure of the proof is interesting:
%It is hard to prove Sound Validation directly,
%so we first define a stronger property,
%called Stronger Sound Validation and
%we show that it is preserved during reduction by mean of conventional Progress and Subject Reduction.
%That is,
%Progress+Subject Reduction $\Rightarrow$ Stronger Sound Validation
%and Stronger Sound Validation $\Rightarrow$ Sound Validation.