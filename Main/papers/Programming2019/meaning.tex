\saveSpace
\section{Formalisation of Validation}
\label{s:meaning}
\saveSpace
In order to model our system, we need to formalise an imperative object-oriented language
with exceptions and object capabilities,  and with a rich type system
supporting \Q@mut, imm, read, capsule@ and strong exception safety.
Formally modelling the semantics of such a language is easy, but 
modelling and proving correctness of such a rich type system would deserve a paper
of its own, and indeed many such papers exist in literature%
~\cite{ServettoEtAl13a,ServettoZucca15,GordonEtAl12,clebsch2015deny,JOT:issue_2011_01/article1}.
Thus, we are going to assume that there is an expressive and sound type system enforcing
those properties, and instead focus on validation.
To provide a good modularisation for our reasoning, 
we will clearly list the properties we need to rely upon, so that \emph{every type
system supporting those properties} supports validation.

To encode object capabilities and I/O, we assume a special location
$c$ of type \Q@Cap@.
This location would refer to an object whose fields model, for example, the content of input and output files.
All its methods must require a \Q@mut this@, and shall mutate the ROG of $c$, and the main expression will start with
such $c$ location in scope. In order to simplify our proof, we assume that $c$ only has \Q@mut@ fields, hence it is always valid (i.e. $c.validate()$ is defined to evaluate to \Q@true@).
We strive to keep our small step semantics as conventional as possible; following \REVRComm{Pierce~\cite{pierce2002types}}{2}{A citation to Featherweight Java (TOPLAS 2001) would be specific than [this]} we assume:
\begin{itemize}
\item An implicit program/class-table.
\item Memory $\sigma:\!:\!= l\mapsto C\{\Many{v}\}$ as a finite map from locations $l$ to annotated tuples $C\{\Many{v}\}$ representing objects,
where $C$ is the class name and $\Many{v}$ contains the values of the fields.
We use the notation $\sigma[l.f=v]$ to update an object field and $\sigma[l.f]$ to access the field.
\item A main expression that is reduced in the context of such a memory and program.
\item A reduction relation $\sigma|\e\rightarrow \sigma'|e'$.
\item A type system $\Sigma;\Gamma\vdash\e:T$, where 
the expression $\e$ can contain locations $l$ and free variables $x$;
the type of locations is encoded in the memory environment $\Sigma:\!:\!= l\mapsto C$
and the type of the free variables is encoded in the variable environment $\Gamma:\!:\!= x\mapsto T$.
\item We use $\Sigma^\sigma$ to trivially extract $\Sigma$ from a memory $\sigma$.
\item The special capability object location $c$ of the \Q@Cap@ class; instances of \Q@Cap@ cannot be created with a \Q@new@ expression.
\item We have a special \emph{monitor} expression \Q@M(@$l$\Q@;@$\e_1$\Q@;@$\e_2$\Q@)@.
Those expressions are not present in the source code but are inserted by the reduction.
\REVRComm{Initially we will have $\e_2= l$\Q@.validate()@;
$\e_1$ will be reduced until it becomes a value, then
$\e_2$ will be reduced to test if $l$ is invalid.}{3}{Hard to understand sentence} We annotate the monitor-expression with $l$ to track
that if the validation check fails, it is precisely $l$ that is invalid.
We use a failed monitor expression (i.e. when $\e_2$ is \Q@false@) to represent an \Q@error@ expression.
\item Before reducing the body of a \Q@try@, we annotate it with a snapshot of 
the state of the memory. This is used to annotate that such state will not be mutated by executing the body of the \Q@try@.
\end{itemize}

To keep our formalization focused on
the challenges of validation, 
there are some
tweaks with respect to our informal description of our approach.
From a formal perspective 
these changes do not change expressiveness:
\begin{itemize}
\item We require that all fields are instance-private, as opposed to only capsule fields. One could always provide getters and setters to simulate public fields.
\item We do not have explicit constructor definitions, rather we assume that all constructors are of the canonical form
\Q@$C$($T_1 x_1$,$\ldots$,$T_n x_n$) {this.$f_1$=$x_1$;$\ldots$;this.$f_n$=$x_n$;}@,
 where $T_1,\ldots\T_n$ are the types (including modifiers) of the fields of $C$.
To provide more flexible initialization one could always make a factory method.
\item We require that \Q@.validate()@ can only use \Q@this@ to access fields,
this can be achieved by inlining method calls.
%or if they are recursive, replacing them with calls to methods that take the fields of \Q@this@ instead of \Q@this@ itself.
\item For simplicity, we do not have actual exception objects,
rather we just have a concept of an \emph{error} with no associated value.
We believe adding traditional exceptions would not cause any interesting variation of our proof.
\end{itemize}


\newcommand{\ctxG}{\myCalBig{G}}
\renewcommand{\vs}{\Many{v}}
\renewcommand{\Opt}[1]{#1?}
\begin{figure}
\!\!\!\!
\begin{grammatica}
\produzione{\e}{\x\mid l\mid\Kw{true}\mid\Kw{false}\mid \e\singleDot\m\oR\es\cR\mid \e\singleDot\f 
\mid\e\singleDot\f\equals\e 
\mid\Kw{new}\ C\oR\es\cR
\mid\Kw{try}\ \oC\e_1\cC\ \Kw{catch}\ \oC\e_2\cC
}{expression}\\
\seguitoProduzione{
\mid \Kw{M}\oR l;\e_1;\e_2\cR\mid\Kw{try}^{\sigma}\oC\e_1\cC\ \Kw{catch}\ \oC\e_2\cC
}{run-time expr.}\\
\produzione{v}{l}{value}\\
\produzione{\ctx_v}{\square
\mid \ctx_v\singleDot m\oR\es\cR
\mid v\singleDot\m\oR\Many{v}_1,\ctx_v,\es_2\cR
%\mid \ctx_v\singleDot\f 
%\mid \ctx_v\singleDot\f\equals\e
\mid v\singleDot\f\equals\ctx_v
}{evaluation ctx}\\
\seguitoProduzione{
\mid \Kw{new}\ C\oR\Many{v}_1,\ctx_v,\es_2\cR
\mid \Kw{M}\oR l;\ctx_v;\e\cR
\mid \Kw{M}\oR l;v;\ctx_v\cR
\mid \Kw{try}^\sigma\oC\ctx_v\cC\ \Kw{catch}\ \oC\e\cC}{}\\

\produzione{\ctx}{\square\mid\ctx\singleDot m\oR\es\cR\mid\e\singleDot\m\oR\es_1,\ctx,\es_2\cR
%\mid \ctx\singleDot\f 
%\mid \ctx\singleDot\f\equals\e
\mid \e\singleDot\f\equals\ctx
\mid \Kw{new}\ C\oR\es_1,\ctx,\es_2\cR
}{full ctx}\\
\seguitoProduzione{
\mid
\Kw{M}\oR l;\ctx;\e\cR\mid
\Kw{M}\oR l;\e;\ctx\cR\mid
\Kw{try}^{\sigma?}\oC\ctx\cC\ \Kw{catch}\ \oC\e\cC\mid
\Kw{try}^{\sigma?}\oC\e\cC\ \Kw{catch}\ \oC\ctx\cC

}{}\\


%\produzione{M_l}{\ctx[M\oR l,\e\cR]}{}\\
%\produzione{\ctxG_l}{
%  M_l\singleDot\m\oR\es_1,\ctx,\es_2\cR
% |\e\singleDot\m\oR\es_1, M_l, \es_2, \ctx, \es_3\cR
% |M_l\singleDot\f\equals\ctx
% |\Kw{new}\ C\oR\es_1,M_l,\es_2,\ctx,\es_3\cR
% |\Kw{try}\oC\ctx\cC\ \Kw{catch}\ \oC\e\cC
% |\ctx[\ctxG_l]}{}\\
\produzione{CD}{\Kw{class}\ C\ \Kw{implements}\ \Many{C}\oC\Many{F}\,\Many{M}\cC\mid 
\Kw{interface}\ C\ \Kw{implements}\ \Many{C}\oC\Many{M}\cC
}{class decl}\\
\produzione{F}{\T\ \f;}{field}\\
\produzione{M}{\mdf\, \Kw{method}\, \T\ \m\oR\T_1\,\x_1,\ldots,\T_n\,\x_n\cR\ \Opt\e}{method}\\
\produzione{\mdf}{\Kw{mut}\mid\Kw{imm}\mid\Kw{capsule}\mid\Kw{read}}{type modifier}\\
\produzione{\T}{\mdf\,C}{type}\\
\produzione{r_l}{
 v\singleDot\m\oR\Many{v}\cR
\mid v\singleDot\f
\mid v_1\singleDot\f\equals v_2
\mid \Kw{new}\,C\oR\Many{v}\cR
\quad\text{with }l\in \{v,v_1,v_2,\Many{v}\}
}{$l$ inside a redex}\\
\produzione{\mathit{error}}{
\ctx_v[\Kw{M}\oR l; v;\Kw{false}\cR]
\quad\text{with }
\ctx_v \text{not of form}\ \ctx_v'[\Kw{try}^{\sigma?}\oC\ctx_v''\cC\ \Kw{catch}\ \oC\_\cC]
}{validation error}
\end{grammatica}
\caption{Grammar}
\end{figure}


\loseSpace
\noindent\textit{Grammar and Well-Formedness Criteria:}
The detailed grammar is exposed in Figure 1.
As explained before, the only non-standard expression is the monitor.
We denote with $r_l$ a redex that contains the location $l$.

\noindent Our well formedness criteria are:
\begin{itemize}
\item All field accesses in method bodies are of the form
\Q@this.@$f$. Thus we require all fields to be instance-private.

\item Field accesses in the main expression, 
must be of the form $l\singleDot\f$.

\item \Q@.validate()@ takes a \Q@read this@, and uses \Q@this@ only to access fields. Even calling methods on \Q@this@
is disallowed.
\item All the fields referred in \Q@.validate()@ are either \Q@imm@ or \Q@capsule@.
\item All the methods that access capsule fields 
either have a \Q@read this@,
or have a \Q@mut/capsule this@, no \Q@mut@ or \Q@read@ parameters, no \Q@mut@ result and 
must use \Q@this@ exactly once in their body.
\item 
During reduction, locations $l$ that are preserved by a \Q@try@ block are
never monitored; formally 
in $\Kw{try}^\sigma\oC\e\cC\_$, $\e$ is not of the form $\ctx[$\Q@M(@$l;\_$\Q@)@$]$ with $l\in\sigma$.
\end{itemize}

We model subtyping with interfaces 
and we do not consider subclassing.
Indeed interfaces do not have an implemented \Q@.validate()@ method, objects implementing those interfaces do.
To enrich our formalism with subclassing, we would need to add the 
well-formed criteria that \Q@validate()@ 
methods start by checking the result of \Q@super@.\Q@validate()@.

\begin{figure}
\!\!
$\!\!\!\!\!\begin{array}{l}
 \inferrule[(update)]{{}_{}}{
\sigma|l.f\equals{}v\rightarrow \sigma[l.f=v]|
\Kw{M}\oR l;l;l\singleDot\Kw{validate}\oR\cR\cR
 }{}
\quad
 \inferrule[(new)]{{}_{}}{
\sigma|\Kw{new}\ C\oR\vs\cR\rightarrow \sigma,l\mapsto C\{\vs\}|
\Kw{M}\oR l;l;l\singleDot\Kw{validate}\oR\cR\cR
 }{}
\\[5ex]
 \inferrule[(mcall)]{{}_{}}{
\sigma|l\singleDot\m\oR v_1,\ldots,v_n\cR\rightarrow \sigma|
\e'[\Kw{this}=l,\x_1=v_1,\ldots,x_n=v_n]
 }{
  \begin{array}{l}
  \sigma(l)=C\{\_\}\\
  C.m=\mdf\,\Kw{method}\,\T\,\m\oR\T_1\,\x_1\ldots\T_n\x_n\cR\e\\

\text{if }\ \exists \f\text{ such that}\ \ C.f=\Kw{capsule}\,\_,
\mdf=\Kw{mut},
\\*\quad\f\, \text{inside}\, C\singleDot\m
\text{ and }
\f\,\text{inside}\, C\singleDot\Kw{validate}

\\*
\text{then }\e'=\Kw{M}\oR l;\e;l\singleDot\Kw{validate}\oR\cR\cR\\*
\text{otherwise }\ \e'= \e
  \end{array}
}
\\[5ex]
 \inferrule[(monitor exit)]{{}_{}}{
\sigma|\Kw{M}\oR l; v;\Kw{true}\cR\rightarrow \sigma|v
 }{}
\quad

 \inferrule[(ctxv)]{\sigma_0|\e_0\rightarrow\sigma_1|\e_1}{
\sigma_0|\ctx_v[\e_0]\rightarrow \sigma_1|\ctx_v[\e_1]
 }{}

\quad
 \inferrule[(try enter)]{{}_{}}{
\sigma|\Kw{try}\ \oC \e_1\cC\ \Kw{catch}\ \oC\e_2\cC\rightarrow 
\sigma|\Kw{try}^\sigma\oC\e_1\cC\ \Kw{catch}\ \oC\e_2\cC
 }{}
\quad


\\[5ex]


 \inferrule[(try ok)]{{}_{}}{
\sigma,\sigma'|\Kw{try}^{\sigma}\oC v\cC\ \Kw{catch}\ \oC\_\cC\rightarrow \sigma,\sigma'|v
 }{}
\quad

 \inferrule[(try error)]{{}_{}}{
\sigma,\_|\Kw{try}^\sigma\oC \mathit{error}\cC\ \Kw{catch}\ \oC\e\cC\rightarrow \sigma|\e
 }
\quad
 \inferrule[(access)]{{}_{}}{
\sigma|l.f\rightarrow \sigma|\sigma[l.f]
 }{}
%\quad
\end{array}$
\caption{Reduction rules}
\end{figure}

\loseSpace
\noindent\REVRComm{\textit{Reduction rules:}}{2}{This discussion is surprisingly short}
Reduction rules are defined in Figure 2.
These rules are pretty standard;
\textsc{mcall}
uses the intuitive auxiliary function \emph{inside}
formally defined as follow:

$%\begin{array}{l}
\f\, \text{inside}\, C\singleDot\m\text{ holds iff }
C\singleDot\m=\_\,\Kw{method}\_\,\ctx[\Kw{this}\singleDot\f]
%\end{array}
$

%\noindent Inserting the monitor expressions during reduction is convenient for the proof,
%but it could instead be done ahead of time.

That is, the monitor is added for all field update and new objects, but;
for method calls the monitor is added only if the method has a \Q@mut@ modifier and its body accesses \Q@capsule@ field.

The interaction with monitors and exceptions is interesting:
a monitor releases the value if the check is \Q@true@, and produces an error if the 
check is \Q@false@.
If either $\e_1$ or $\e_2$ are not values, the execution is propagated inside
by \textsc{ctxv}.
If either $\e_1$ or $\e_2$ evaluate to an error, such error is captured by 
\textsc{try error}.
Thanks to strong exception safety
we do not need to worry
if the (partial) execution of $\e_1$ broke the $l$ object.
If the language were to support checked and unchecked exceptions, but offered 
strong exception safety only for the unchecked ones, then 
the type system should require neither $\e_1$ nor $\e_2$ leak 
checked exceptions.





%WHERE TO PUT THIS?
%Note that for \Q@capsule@ fields, the constructor and the field update
%will require \Q@capsule@ for the correspoi, while the field access will produce a \Q@mut@.



\loseSpace
\noindent\textit{Axiomatic type properties:}
As discussed, instead of providing a concrete set of type rules, we provide a set of properties
that such a type system needs to respect.
To express these properties, we first need some auxiliary definitions:

%\noindent\textbf{Define}
%$\mathit{encapsulatedObj}(C)$:\\*
%${}_{}$\quad\quad \Q@class @$C$\,\Q@implements @$\Many{C}$\Q@{@$\,\Many{F}\,\Many{M}$\Q@}@
% and $\forall \mdf\,C\,\f \in \Many{F},\ \mdf \in \{\Kw{imm},\Kw{capsule}\}$\\*
%\noindent As we discussed, only encapsulated objects can support invariants;
%their class declarations only have immutable or capsule fields. Note how here we see immutable
%and simple objects as special cases of encapsulated ones.

\noindent\textbf{Define} $\mathit{erog}(\sigma,l_0)$:\\*
\indent $l \in \mathit{erog}(\sigma,l_0)
\text{ if } \Sigma^\sigma(l_0).f \in \{\Kw{imm}\,\_,\Kw{capsule}\,\_\}
\text{ and } l \in \mathit{rog}(\sigma,\sigma(l_0).f)
$\\*
\noindent
The encapsulated ROG of $l_0$ is composed by all the objects
in the ROG of its immutable and capsule fields.


\noindent\textbf{Define} $\mathit{mutatable}(l,\sigma,\e)$:\\*
\indent with $T=\Kw{imm}\,\Sigma^\sigma(l)$ and $\e=\ctx[l]$,\\*
\indent $\Sigma^\sigma;\x:T\vdash\ctx[\x]:T'$ does not hold for any $T'$.\\*
\noindent That is, an object is mutatable by a $\sigma,\e$ if there is an occurrence of 
$l$ in $e$ that when seen as immutable makes the expression ill-typed.



\noindent\textbf{Define}$\ \sigma_0|e_0\Rightarrow \sigma_1|e_1$:\\*
\indent iff $\{\sigma_1|\e_1\}=\{\sigma|\e \text{ where } \sigma_0|e_0\rightarrow \sigma|e\}$

%if $\ \sigma_0|e_0\rightarrow \sigma|e$ then $\sigma_1|\e_1=\sigma|\e$
% $\exists! \sigma_1|\e_1$ such that $\sigma_0|\e_0\rightarrow \sigma_1|\e_1$\\*
\noindent We define
a deterministic reduction arrow.
Here we require that there is exactly one reduction possible.


%We can now assume the following properties over the type system:

\begin{Assumption}[Progress]
if $\Sigma^{\sigma_0};\emptyset\vdash e_0: T_0$,
and $e_0$ not a value or $\mathit{error}$, then
$\sigma_0|e_0\rightarrow \sigma_1|e_1$
\end{Assumption}


\begin{Assumption}[SubjectReductionBase]
if $\Sigma^{\sigma_0};\emptyset\vdash e_0: T_0$,
$\sigma_0|e_0\rightarrow \sigma_1|e_1$,
then
$\Sigma^{\sigma_1};\emptyset\vdash e_1: T_1$
\end{Assumption}


\begin{Assumption}[MutField]
\ \\
\indent(1)\ if $\Sigma;\Gamma\vdash\e\singleDot\f:\Kw{mut}\,\_$
then $\Sigma;\Gamma\vdash\e:\Kw{mut}\,\_$
,\ and 
\\*\indent(2)
if $\Sigma;\Gamma\vdash\e_0\singleDot\f\equals\e_1:T$
then $\Sigma;\Gamma\vdash\e_0:\Kw{mut}\,\_$
\end{Assumption}
\noindent If the result of a field access is mutable,
the receiver is mutable too, and the receiver of a field update is always mutable.

\begin{Assumption}[HeadNotCircular]
if
$\Sigma^\sigma;\Gamma\vdash l:T$
then $l\notin\text{erog}(\sigma,l)$
\end{Assumption}
\noindent
\noindent An object is not part of the ROG of its immutable or capsule fields.


\begin{Assumption}[CapsuleTree]
If   $\Sigma^\sigma;\Gamma\vdash \e:\T$,
$l_2\in\text{erog}(\sigma,l_1)$,
$l_1\in\text{erog}(\sigma,l_0)$,\\*
and
$\mathit{mutatable}(l_2,\sigma,\e)$
then 
$l_2\notin\text{erog}(\sigma\setminus l_1,l_0)$
\end{Assumption}
\noindent In a well typed $\sigma,e$, if mutatable $l_2$ is reachable from
$l_1$, and $l_1$ is reachable from $l_0$,
then all the paths connecting $l_0$ and $l_2$ pass trough $l_1$; thus
if we was to remove the node $l_1$ from the object graph, $l_0$ would not reach $l_2$ any more.


CapsuleTree and HeadNotCircular together 
shows that capsule fields section the object graph into a tree of nested `balloons',
where nodes are mutable encapsulated objects and
edges are given by reachability between those objects in the original memory:

$l_2$ is in the encapsulated ROG of $l_1$;
$l_2$ is mutatable and is reached trough $l_1$, thus
it must be reachable by a \Q@capsule@ field.
Thanks to HeadNotCircular and $l_1\in\text{erog}(\sigma,l_0)$ we can derive 
$l_0\notin\text{erog}(\sigma,l_1)$.



\begin{Assumption}[Determinism]
if $\emptyset;\Gamma\vdash \e:\T$, 
$\forall x \Gamma(x)\neq\Kw{mut}\,\_$, and
$\sigma | \e'\rightarrow^+ \sigma' | \e''$
then 
$\sigma | \e'\Rightarrow^+ \sigma,\_ | \e''$,
where $\e'=\e[x_1=l_1,\ldots,x_n=l_n]$ and $\Sigma^\sigma;\emptyset\vdash \e':\T$
\end{Assumption}
\noindent The execution of an expression
with no \Q@mut@ free variables is deterministic and does not
  mutate pre existing memory (and thus does not not perform I/O by mutating pre existing $c$).


\begin{Assumption}[StrongExceptionSafety]
if $\Sigma^{\sigma,\sigma'};\emptyset\vdash \ctx[\Kw{try}^\sigma\oC\e_0\cC\ \Kw{catch}\ \oC\e_1\cC]:\T$
and\\*
$
\sigma,\sigma'|\ctx[\Kw{try}^\sigma\oC\e_0\cC\ \Kw{catch}\ \oC\e_1\cC]\rightarrow 
\sigma''|\ctx[\Kw{try}^\sigma\oC\e'\cC\ \Kw{catch}\ \oC\e_1\cC]
$
then 
$\sigma''=\sigma,\_$
and
$\Sigma^\sigma;\emptyset\vdash \ctx[\e_1]:\T$
\end{Assumption}
\noindent
For each \Q@try-catch@, the execution preserves the memory needed to continue the execution in case of error
(the memory visible outside of the \Q@try@).%

%Thanks to how our reduction rules are designed, especially \textsc{try error},
%@Progress will need to rely on @StrongExceptionSafety internally.

Note that our last well formedness rule requires 
\textsc{update} and \textsc{mcall} to introduce
monitor expressions only over locations
that are not preserved by a \Q@try@ block.
This can be achieved since monitors are introduced
around $\mathit{mutating}$ operations
(and \textsc{new}),
and StrongExceptionSafety ensures no mutation happens on the preserved memory.

To the best of our knowledge, only the type system of 42~\cite{ServettoEtAl13a,ServettoZucca15}
 supports all these assumptions out of the box,
while both Gordon~\cite{GordonEtAl12} and Pony~\cite{clebsch2015deny,clebsch2017orca} supports all except StrongExceptionSafety,
however it should be trivial to modify them to support it:
the \Q@try-catch@ rule could be modified to
$\emptyset;\Gamma\vdash\Kw{try}\ \oC\e_0\cC\ \Kw{catch}\ \oC\e_1\cC:\T$
if\\* $\emptyset;
\Gamma,\{x:\Kw{read}\,C | x:\Kw{mut}\,C\,\in\Gamma\}
\vdash\e_0:\T$ and $\emptyset;\Gamma\vdash\e_1:\T$,
i.e. $e_0$ can be typed when seeing all externally defined mutable references as \Q@read@.

\loseSpace
\noindent\textit{Statement of Validation:}
%We first need to define what it means for an object to be valid:
An object is \emph{valid} iff calling its \Q@.validate()@ method would
deterministically produce \Q@true@ in a finite number of steps, i.e. it does not evaluate to \Q@false@, fail to terminate, or produce an error.
We also require that evaluating \Q@.validate()@ preserve existing memory ($\sigma$), but new objects ($\sigma'$) can be created and freely mutated.

\noindent\textbf{Define} $valid(\sigma,l)$:\\*
\indent $\sigma | l.validate()\Rightarrow^+ \sigma,\sigmaâ€™ | \text{\Q@true@}$

\noindent In order for validation to be meaningful it needs to be possible for \Q@.validate()@ to potentially observe an invalid object. However, invalid objects should not be observed outside of \Q@.validate()@.
For this purpose we define the set of trusted steps, 
as the call to \Q@.validate()@ and the field accesses inside a monitor.
Note that just the single small-step reduction
of calling \Q@.validate()@ is trusted, not the whole evaluation of the \Q@.validate()@ expression.


\noindent\textbf{Define} $\mathit{trusted}(\ctx_v,r_l)$:\\*
\indent either
$r_l=l$\Q@.validate()@ and
 $\ctx_v=\ctx_v'[$\Q@M(@$l$\Q@;@$v$\Q@;@$\square$\Q@)@$]$\\*
\indent or
$r_l=l$\Q@.f@ and
 $\ctx_v=\ctx_v'[$\Q@M(@$l$\Q@;@$v$\Q@;@$\ctx_v''$\Q@)@$]$

\noindent Finally, we can now define what it means for a language to soundly enforce validation: every object involved in any untrusted redex is valid.

\begin{theorem}[Sound Validation]
if $c:\Kw{Cap};\emptyset\vdash \e: \T$ and
$c\mapsto\Kw{Cap}\{\_\}|\e\rightarrow^+ \sigma|\ctx_v[r_l]$, then
either $valid(\sigma,l)$ or $\mathit{trusted}(\ctx_v,r_l)$.
\end{theorem}

We believe this property captures very precisely our statement in Section~\ref{s:validation}.
The proof is in Appendix~\ref{s:proof}. 
%The structure of the proof is interesting:
%It is hard to prove Sound Validation directly,
%so we first define a stronger property,
%called Stronger Sound Validation and
%we show that it is preserved during reduction by mean of conventional Progress and Subject Reduction.
%That is,
%Progress+Subject Reduction $\Rightarrow$ Stronger Sound Validation
%and Stronger Sound Validation $\Rightarrow$ Sound Validation.