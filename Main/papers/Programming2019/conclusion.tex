
Concluding, 
the philosophy of our approach is to be like an extended type system: 
\begin{itemize}
\item The programmer decides to annotate a field with a certain type, or the class with a certain invariant.
\item If that is a valid type, or a valid invariant, the user is not questioned in its intent.
\item The system enforce that field will only contain values or that type, or that instance of that class
will respect that invariant.
\end{itemize}
This is in sharp contrast with most work in RV, that is often conceived more as a tool to ease debugging:
both deciding the invariant and enforcing it is controlled by the programmers.

Static verification requires great effort, but can ensures all invariants \textbf{always} holds, thus all objects are always coherent.

However, Static verification is very heavy weight, and often impractical.
In the context of a conventional OO language with imperative features,
we propose an \textbf{ultra-lightweight} verification approach,
where the programmer specifies \textbf{only} the desired class invariants as an 
\Q@invariant()@ method written in the language itself.
This is much more convenient with respect to requiring the specification of methods pre and post conditions,
since the number of classes is usually order of magnitude smaller then the number of methods,
and a fully annotated program requires to write down 
pre-post conditions for each methods, encoding a generalization of its behaviour
in the dedicated specification language.
This means that, even in the best case scenario, 
using pre-post conditions
the user is required to specify the program semantic twice:
first in the specification language and then in the underlying programming language.


With just invariants, our system will then 
\textbf{soundly ensure invariants of all objects involved in the execution}.
Our approach do not rely on assumption over the behaviour of methods/classes;
except for the language semantics and the type system guarantees.
Methods are just treated as black-boxes, producing a result or throwing an error.

Of course, there is a catch: this result is obtained by modifying/instrumenting the
semantic of the language, so that (as for type casts) \textbf{violations are detected at run-time}, and exceptions
are throw in order to stop the execution before involving any broken object.
