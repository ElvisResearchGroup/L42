
\loseSpace
The philosophy of our approach is to be like an extended type system: 
It is the programmer's decision
to annotate a field with a certain type,
or the class with a certain \validate.
If the program is well-typed, they are not questioned in their intent.
During execution the system is solely responsible for soundly enforcing object validity.
This is in sharp contrast with most work in RV, that is often conceived more as a tool to ease debugging:
both deciding properties and enforcing them is controlled by the programmers.
This is also different from static verification,
%where the properties are ensured instead of enforced.
where the properties are ensured ahead of time instead of being enforced during execution.
%Static verification is very heavy weight, and often impractical/restrictive.

Both static and runtime verification
aim to monitor a wide range of properties; to this aim they accept a 
great deal of complexity, and require the programmer to develop a deep understanding
over the behaviour and the structure of code.
For example, the specification of methodâ€™s pre and post-conditions
encode a generalization of the program behaviour in the dedicated specification language.
This means that, even in the best case scenario, 
using pre/post-conditions the user is required to specify the program semantics twice:
first in the specification language and then in the underlying programming language.
In comparison, our approach aims to only verify conditions on immutable or well encapsulated state.
This makes our approach \emph{ultra-lightweight}:
the programmer specifies only the desired \validate{} method.
Moreover, our approach does not aim to replace static or run-time verification,
but is a building block they can rely upon.

The popularity of TM and OC is growing, and we expect future languages to support some variation of these.
Crucially, any language already designed with TM and OC
can also support sound validation with minimal added complexity.


\noindent\textit{Our approach:}
In literature, both static and run-time verification discuss
the correctness of common programming patterns in conventional languages.
Their struggle is proof of how hard it is to deal with the expressive power of unrestricted imperative object oriented programming.
 Here instead we build on languages using TMs and OCs to tame the use of imperative features. In this way
we have a fresh start where static variables are disallowed, unchecked exceptions require care to be captured, and I/O is allowed only when an opportune capability object is reachable.
Following those restrictions allow simpler reasoning.