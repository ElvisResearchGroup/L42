
\loseSpace
\noindent Concluding, 
the philosophy of our approach is to be like an extended type system: 
It is the programmer decision
to annotate a field with a certain type,
or the class with a certain \Q@.validate()@.
If the program is well-typed, they are not questioned in their intent.
During execution the system is the sole responsible to soundly enforce objects validity.
This is in sharp contrast with most work in RV, that is often conceived more as a tool to ease debugging:
both deciding properties and enforcing them it is controlled by the programmers.
This is also different from Static verification,
where the properties are ensured instead of enforced.
Static verification is very heavy weight, and often impractical/restrictive.

Both static and runtime verification
aim to monitor a wide range of properties; to this aim they accept a 
great deal of complexity, and require the programmer to develop a deep understanding
over the behaviour and the structure of the code.
For example, the specification of methods pre and post conditions
encodes a generalization of the program behaviour in the dedicated specification language.
This means that, even in the best case scenario, 
using pre-post conditions the user is required to specify the program semantic twice:
first in the specification language and then in the underlying programming language.
On the opposite, our approach aims to only verify conditions on immutable or well encapsulated state.
This makes our approach \emph{ultra-lightweight}:
the programmer specifies only the desired \Q@.validate()@ method.

The popularity of TM and OC is growing, and we expect future languages to support some variation of those.
Crucially, any language already designed with TM and OC
can also support sound validation with minimal added complexity.