Definitions:
    mdf is mutatable iff mdf is in {lent, mut, capsule}
    mdf' in FM(L, f, mdf) and P in FP(L, f, mdf) iff:
			if mdf is mutatable then mdf" is mutatable,
      class method mdf" _(_ mdf' P f _) in L
        or mdf" method _ #?f(mdf' P that) in L

    mdf' in FA(l, f, mdf) iff:
			if mdf is mutatable then mdf" is mutatable,
      mdf' method mdf" P #?f() is in L
      mdf' != capsule

Coherent:
Under a program p, a library literall L' is coherent iff, for some L:

    L is the same as L' except the following are deleted: (note: this rule is just for simplicity)
        nested classes,
        non-abstract methods,
        refine keywords, and
        exception clauses
    Either L contains not class-methods or:
			Let f1,...,fn be variable-names
		  Every method in L is either of the form:
					class method mdf P m(mdf1 P1 f1', ..., mdfn Pn fn'), where:
			      p|-This<=P
			      mdf not in {class, fwd mut, fwd imm}
			      each mdfi is not lent
			      if mdf in {imm, capsule} then each mdfi not in {mut, fwd mut}
			      if read in {mdf1..mdfn) then mdf in {read, lent}
						{f1', ..., fn'} = {f1, ..., fn}
					mdf method _, where:
						mdf is mutatable
						there is no class method mdf' _ in L where mdf' is mutatable
		      mdf method T #?fi(mdf' P' that), where:
						mdf != class
						p |- imm Void <= T
						mdf' in {imm, mut, capsule, class}//that is not in {read, lent, fwd mut, fwd imm}
						if mdf = lent, then mdf' != mut
		        mdf is mutatable
		      mdf method mdf' P' #?fi(), where:
						mdf != class
   					mdf' = class iff FM(L, fi, mdf) = {class}
		        forall P in FP(L, fi, mdf), p |- P <= P'
	          if mdf' = imm and mdf != imm, then:
	              FM(L,fi, mdf) subseteq {imm, fwd imm,capsule}, and
	              {fwd mut, mut, lent} not in FA(L,fi, mdf)
	          if mdf' = capsule then:
	              mdf = capsule, and
	              FM(L, fi, mdf) subseteq {mut, fwd mut, capsule}, and
	              imm not in FA(L, fi, mdf)
	          if mdf' = lent then:
	              FM(L, fi, mdf) subseteq {mut, fwd mut, capsule}, and
	              mdf is mutatable
	          if mdf' = mut then:
	              FM(L, fi, mdf) subseteq {mut, fwd mut, capsule}, and
	              mdf in {mut, capsule}

Now for InvariantClose, we just make2 definitions:
    A field f is validatable iff FM(L, f, read) subseteq {imm, fwd imm, capsule, class}
    '_ method mdf P #?f();' is an exposer iff:
        f is a validatable field
        mdf is mut or lent (note: if it were capsule, a call to the
method would destroy this)

And say that:
    this can only (indirectly) be used to access validatable fields in
#invariant
    After every update to a validatable field an invariant-check is inserted
    An exposer can only be called on this //check for nested classes too A{ #f() B:{ ...A().#f()..}}
    A method that calls an exposer is a capsule-mutator (and hence has
all the restrictions), if the exposer is mut, need to not return mut/lent, if the exposer is lent, can not return lent