{
Bool:{ implements Outer1.S.ToS
method 
Void #checkTrue() exception Void using Outer1.Alu check ifInt32EqualDo(n1:this.binaryRepr2(), n2:Outer1.N.#numberParser(that:{//@stringU
//0
}).binaryRepr()) exception void
class method 
This true() This.#apply2(binaryRepr2:Outer1.N.#numberParser(that:{//@stringU
//1
}).binaryRepr())
class method 
This false() This.#apply2(binaryRepr2:Outer1.N.#numberParser(that:{//@stringU
//0
}).binaryRepr())
method 
This #and(This that) (
  Void unused=(
    Void unused0=(
      Void unused2=this.#checkTrue()
      catch exception unused3 (
        on Void void
        )
      return that
      )
    Void unused1=return this
    void
    )
  catch return result (
    on This result
    )
  error {//@stringU
  //CurlyBlock-Should be unreachable code
  }
  )
method 
This #or(This that) (
  Void unused=(
    Void unused0=(
      Void unused2=this.#checkTrue()
      catch exception unused3 (
        on Void void
        )
      return this
      )
    Void unused1=return that
    void
    )
  catch return result (
    on This result
    )
  error {//@stringU
  //CurlyBlock-Should be unreachable code
  }
  )
method 
This #bang() (
  Void unused=(
    Void unused0=(
      Void unused2=this.#checkTrue()
      catch exception unused3 (
        on Void void
        )
      return This.false()
      )
    Void unused1=return This.true()
    void
    )
  catch return result (
    on This result
    )
  error {//@stringU
  //CurlyBlock-Should be unreachable code
  }
  )
method toS() (
  Void unused=(
    Void unused0=(
      Void unused2=this.#checkTrue()
      catch exception unused3 (
        on Void void
        )
      return Outer1.S.#stringParser(that:{//@stringU
      //true
      })
      )
    Void unused1=return Outer1.S.#stringParser(that:{//@stringU
    //false
    })
    void
    )
  catch return result (
    on This.toS() result
    )
  error {//@stringU
  //CurlyBlock-Should be unreachable code
  }
  )
class method //@private
This #apply2(Library^binaryRepr2//@private @consistent
) 
mut method //@private @consistent
Library #binaryRepr2() 
read method //@private @consistent
Library binaryRepr2() }
ExitCode:{
class method 
Library normal() {//@exitStatus
//0
}
class method 
Library failure() {//@exitStatus
//42000
}}
Alu:{//@plugin
//L42.is/connected/withAlu

class method //@private
This _private8() }
N:{ implements Outer1.S.ToS
class method 
This #apply(Library^binaryRepr//@private @consistent
) 
mut method //@private @consistent
Library #binaryRepr() 
read method //@private @consistent
Library binaryRepr() 
class method 
This #numberParser(Library that) This.#apply(binaryRepr:using Outer1.Alu check stringToInt32(that:that) error void)
method toS() Outer1.S.#stringParser(that:using Outer1.Alu check int32ToString(that:this.binaryRepr()) error void)
method 
This #plus(This that) This.#apply(binaryRepr:using Outer1.Alu check sumInt32(n1:this.binaryRepr(), n2:that.binaryRepr()) error void)
method 
This #less(This that) This.#apply(binaryRepr:using Outer1.Alu check subInt32(n1:this.binaryRepr(), n2:that.binaryRepr()) error void)
method 
This #times(This that) This.#apply(binaryRepr:using Outer1.Alu check mulInt32(n1:this.binaryRepr(), n2:that.binaryRepr()) error void)
method 
This #divide(This that) This.#apply(binaryRepr:using Outer1.Alu check divInt32(n1:this.binaryRepr(), n2:that.binaryRepr()) error void)
method 
Outer1.Bool #equalequal(This that) (
  Void unused=(
    Void unused0=using Outer1.Alu check ifInt32EqualDo(n1:this.binaryRepr(), n2:that.binaryRepr()) return Outer1.Bool.true()
    Void unused1=return Outer1.Bool.false()
    void
    )
  catch return result (
    on Outer1.Bool result
    )
  error {//@stringU
  //CurlyBlock-Should be unreachable code
  }
  )
method 
Outer1.Bool #left(This that) (
  Void unused=(
    Void unused0=using Outer1.Alu check ifInt32GrtDo(n1:this.binaryRepr(), n2:that.binaryRepr()) return Outer1.Bool.true()
    Void unused1=return Outer1.Bool.false()
    void
    )
  catch return result (
    on Outer1.Bool result
    )
  error {//@stringU
  //CurlyBlock-Should be unreachable code
  }
  )
method 
Outer1.Bool #leftequal(This that) (
  Void unused=(
    Void unused0=using Outer1.Alu check ifInt32GEqDo(n1:this.binaryRepr(), n2:that.binaryRepr()) return Outer1.Bool.true()
    Void unused1=return Outer1.Bool.false()
    void
    )
  catch return result (
    on Outer1.Bool result
    )
  error {//@stringU
  //CurlyBlock-Should be unreachable code
  }
  )
method 
Outer1.Bool #bangequal(This that) this.#equalequal(that:that).#bang()
method 
Outer1.Bool #right(This that) this.#leftequal(that:that).#bang()
method 
Outer1.Bool #rightequal(This that) this.#left(that:that).#bang()}
S:{ implements This.ToS
Varresult0:{
class method 
mut This #apply(Outer1^inner//@private @consistent
) 
mut method //@private @consistent
Void inner(Outer1 that) 
mut method //@private @consistent
Outer1 #inner() 
read method //@private @consistent
Outer1 inner() }
Vari0:{
class method 
mut This #apply(Outer2.N^inner//@private @consistent
) 
mut method //@private @consistent
Void inner(Outer2.N that) 
mut method //@private @consistent
Outer2.N #inner() 
read method //@private @consistent
Outer2.N inner() }
class method 
This #stringParser(Library that) This._private9(_binaryRepr2:that)
method 
Library binaryRepr() this._binaryRepr2()
ToS:{interface 
method 
Outer1 toS() }
method toS() this
method 
This #plusplus(This.ToS that) This.#stringParser(that:using Outer1.Alu check stringConcat(s1:this.binaryRepr(), s2:that.toS().binaryRepr()) error void)
method 
Outer1.Bool #bangequal(This that) this.#equalequal(that:that).#bang()
method 
Outer1.Bool #equalequal(This that) (
  Void unused=(
    Void unused0=using Outer1.Alu check ifStringEqualDo(s1:this.binaryRepr(), s2:that.binaryRepr()) return Outer1.Bool.true()
    Void unused1=return Outer1.Bool.false()
    void
    )
  catch return result (
    on Outer1.Bool result
    )
  error {//@stringU
  //CurlyBlock-Should be unreachable code
  }
  )
method 
This #apply(Outer1.N start, Outer1.N end) This.#stringParser(that:using Outer1.Alu check stringSubstring(that:this.binaryRepr(), start:start.binaryRepr(), end:end.binaryRepr()) error void)
method 
This #apply(Outer1.N that) this.#apply(start:that, end:that.#plus(that:Outer1.N.#numberParser(that:{//@stringU
//1
})))
method 
Outer1.N size() Outer1.N.#apply(binaryRepr:using Outer1.Alu check stringSize(that:this.binaryRepr()) error void)
class method 
This doubleQuote() This.#stringParser(that:{//@stringU
//"\u000a
}).#apply(that:Outer1.N.#numberParser(that:{//@stringU
//0
}))
method 
This replace(This that, This into) (
  Void unused=(//that must be of size 1
  
    Outer1.N i=Outer1.N.#numberParser(that:{//@stringU
    //0
    })
    This result=This.#stringParser(that:{//@stringU
    //
    })
    mut This.Vari0 vari=This.Vari0.#apply(inner:i)
    mut This.Varresult0 varresult=This.Varresult0.#apply(inner:result)
    Void unused0=(
      Void unused2=loop (
        Void unused3=vari.#inner().#left(that:this.size()).#checkTrue()
        (
          Void unused4=(
            This.#apply(that ) .#equalequal(that ) cond=this.#apply(that:vari.#inner()).#equalequal(that:that)
            (
              Void unused5=cond.#checkTrue()
              catch exception unused6 (
                on Void varresult.inner(that:varresult.#inner().#plusplus(that:this.#apply(that:vari.#inner())))
                )
              varresult.inner(that:varresult.#inner().#plusplus(that:into))
              )
            )
          vari.inner(that:vari.#inner().#plus(that:Outer1.N.#numberParser(that:{//@stringU
          //1
          })))
          )
        )
      catch exception unused7 (
        on Void void
        )
      void
      )
    Void unused1=return varresult.#inner()
    void
    )
  catch return result0 (
    on This result0
    )
  error {//@stringU
  //CurlyBlock-Should be unreachable code
  }
  )
class method //@private
This _private9(Library^_binaryRepr2//@private @consistent
) 
mut method //@private @consistent
Library #_binaryRepr2() 
read method //@private @consistent
Library _binaryRepr2() }
Debug:{
class method 
Void #apply(Outer1.S that) using Outer1.Alu check stringDebug(that:that.binaryRepr()) void
class method 
Void #apply(Outer1.S fileName, Outer1.S content) using Outer1.Alu check fileDebug(fileName:fileName.binaryRepr(), content:content.binaryRepr()) void
class method //@private
This _private10() }
IntrospectionPlugin:{//@plugin
//L42.is/connected/withItself

class method 
Library sumLib(Library l1, Library l2) using This check sumLib(l1:l1, l2:l2) error {
class method 
This sumLib() }
class method 
Library adaptLib(Library l1, Library l2) using This check adaptLib(l1:l1, l2:l2) error {
class method 
This adaptLib() }
class method 
Library sumComment(Library that, Library comment, Library adapter) using This check sumComment(that:that, comment:comment, adapter:adapter) error {
class method 
This sumComment() }
class method 
Library purgePrivates(Library that) using This check purgePrivates(that:that) error {
class method 
This purgePrivates() }
class method 
Library nameToAdapter(Library that) using This check nameToAdapter(that:that) error {
class method 
This nameToAdapter() }
class method 
Library typeNameToAdapter(class Any that) using This check typeNameToAdapter(that:that) error {
class method 
This typeNameToAdapter() }
class method 
Library getFreshName(Library that) using This check getFreshName(that:that) error {
class method 
This getFreshName() }
class method 
Library adapter(class Any that, Outer1.S name) (
  Void unused=(
    This.typeNameToAdapter(that ) name1=This.typeNameToAdapter(that:that)
    This.nameToAdapter(that ) name2=This.nameToAdapter(that:name.binaryRepr())
    Void unused0=return This.adaptLib(l1:name1, l2:name2)
    void
    )
  catch return result (
    on Library result
    )
  error {//@stringU
  //CurlyBlock-Should be unreachable code
  }
  )
class method 
Library adapter(Outer1.S nameDest, Outer1.S nameSrc) (
  Void unused=(
    This.nameToAdapter(that ) name1=This.nameToAdapter(that:nameDest.binaryRepr())
    This.nameToAdapter(that ) name2=This.nameToAdapter(that:nameSrc.binaryRepr())
    Void unused0=return This.adaptLib(l1:name1, l2:name2)
    void
    )
  catch return result (
    on Library result
    )
  error {//@stringU
  //CurlyBlock-Should be unreachable code
  }
  )
class method //@private
This _private11() }
Collections:{
ListCode:{
class method 
Library #apply() {// generic linked list class, elements of class Elem

Varres:{
class method 
mut This #apply(Outer1^inner//@private @consistent
) 
mut method //@private @consistent
Void inner(Outer1 that) 
mut method //@private @consistent
Outer1 #inner() 
read method //@private @consistent
Outer1 inner() }
Varres0:{
class method 
mut This #apply(Outer1.#apply() ^inner//@private @consistent
) 
mut method //@private @consistent
Void inner(Outer1.#apply() that) 
mut method //@private @consistent
Outer1.#apply() #inner() }
class method 
This _new(This.Cell^head//@private @consistent
) 
mut method //@private @consistent
This.Cell #head() 
read method //@private @consistent
This.Cell head() 
class method 
This #apply() This._new(head:This.CellEnd.#apply())
method 
Outer3.Bool isEmpty() (
  Void unused=(
    Void unused0=(
      This.head() x=this.head()
      (
        This.CellEnd x0=(
          Void unused1=return x
          catch return casted (
            on This.CellEnd casted
            
            on Any exception void
            )
          error {//@stringU
          //CastT-Should be unreachable code
          }
          )
        catch exception unused2 (
          on Void return Outer3.Bool.false()
          )
        (
          Void unused3=return Outer3.Bool.true()
          void
          )
        )
      )
    void
    )
  catch return result (
    on Outer3.Bool result
    )
  error {//@stringU
  //CurlyBlock-Should be unreachable code
  }
  )
method 
This.Elem top() this.head().#inner()
method 
mut This.Iterator vals() this.head().vals(terminate:Outer3.Bool.true())
method 
mut This.Iterator valsCut() this.head().vals(terminate:Outer3.Bool.false())
method 
This pop() (
  Void unused=(
    Void unused0=return This._new(head:this.head().#next())
    catch exception unused1 (
      on Void error Outer3.S.#stringParser(that:{//@stringU
      //PopOnEmpyList
      })
      )
    void
    )
  catch return result (
    on This result
    )
  error {//@stringU
  //CurlyBlock-Should be unreachable code
  }
  )
method 
This #plusplus(This that) (
  Void unused=(
    This res=this
    mut This.Varres varres=This.Varres.#apply(inner:res)
    Void unused0=(
      This.vals() e=that.vals()
      (
        Void unused2=(
          Void unused3=(
            Void unused4=loop (
              Void unused5=e.#next()
              catch exception unused6 (
                on Void (
                  Void unused7=(
                    Void unused8=e.#checkEnd()
                    catch exception unused9 (
                      on Void void
                      )
                    void
                    )
                  exception void
                  )
                )
              varres.inner(that:varres.#inner().#add(that:e.#inner()))
              )
            catch exception unused10 (
              on Void void
              )
            void
            )
          catch exception propagated (
            on Any (
              Void unused11=e.#close()
              exception propagated
              )
            )
          void
          )
        catch return propagated0 (
          on This (
            Void unused12=e.#close()
            return propagated0
            )
          )
        e.#close()
        )
      )
    Void unused1=return varres.#inner()
    void
    )
  catch return result (
    on This result
    )
  error {//@stringU
  //CurlyBlock-Should be unreachable code
  }
  )
class method 
This #begin() This.#apply()
method 
This #add(This.Elem that) This._new(head:This.CellNext.#apply(elem:that, nextCell:this.head()))
method 
This #end() (
  This.#apply() res=This.#apply()
  mut This.Varres0 varres=This.Varres0.#apply(inner:res)
  Void unused=(
    This.vals() elem=this.vals()
    (
      Void unused0=(
        Void unused1=(
          Void unused2=loop (
            Void unused3=elem.#next()
            catch exception unused4 (
              on Void (
                Void unused5=(
                  Void unused6=elem.#checkEnd()
                  catch exception unused7 (
                    on Void void
                    )
                  void
                  )
                exception void
                )
              )
            varres.inner(that:varres.#inner().#add(that:elem.#inner()))
            )
          catch exception unused8 (
            on Void void
            )
          void
          )
        catch exception propagated (
          on Any (
            Void unused9=elem.#close()
            exception propagated
            )
          )
        void
        )
      catch return propagated0 (
        on Any (
          Void unused10=elem.#close()
          return propagated0
          )
        )
      elem.#close()
      )
    )
  varres.#inner()
  )
Elem:{}
Cell:{interface 
method 
mut Outer1.Iterator vals(This4.Bool terminate) 
method 
This #next() exception Void 
method 
Outer1.Elem #inner() 
method 
Void #checkEnd() }
CellEnd:{ implements Outer1.Cell
class method 
This #apply() 
method vals(terminate ) Outer1.Iterator.#apply(that:this, terminate:terminate)
method #next() exception void
method #inner() error This4.S.#stringParser(that:{//@stringU
//InnerOnCellEnd, should not happen
})
method #checkEnd() void}
CellNext:{ implements Outer1.Cell
class method 
This #apply(Outer1.Elem^elem//@private @consistent
, Outer1.Cell^nextCell//@private @consistent
) 
mut method //@private @consistent
Outer1.Elem #elem() 
read method //@private @consistent
Outer1.Elem elem() 
mut method //@private @consistent
Outer1.Cell #nextCell() 
read method //@private @consistent
Outer1.Cell nextCell() 
method vals(terminate ) (
  Void unused=(
    This.#apply(elem nextCell ) startPoint=This.#apply(elem:this.elem(), nextCell:this)
    Void unused0=return Outer1.Iterator.#apply(that:startPoint, terminate:terminate)
    void
    )
  catch return result (
    on This.vals(terminate ) result
    )
  error {//@stringU
  //CurlyBlock-Should be unreachable code
  }
  )
method #next() this.nextCell()
method #inner() this.elem()
method #checkEnd() (
  This.#checkEnd() .this.nextCell() cell=this.nextCell()
  (
    This cell0=(
      Void unused=return cell
      catch return casted (
        on This casted
        
        on Any exception void
        )
      error {//@stringU
      //CastT-Should be unreachable code
      }
      )
    catch exception unused0 (
      on Void void
      )
    (
      Void unused1=error This4.S.#stringParser(that:{//@stringU
      //IterationNotComplete,\u000a  use valsCut() to allows incomplete iterations\u000a
      })
      void
      )
    )
  )}
Iterator:{
class method 
mut This #apply(Outer1.Cell^that//@private @consistent
, This4.Bool^terminate//@private @consistent
) 
mut method //@private @consistent
Void that(Outer1.Cell that) 
mut method //@private @consistent
Outer1.Cell #that() 
read method //@private @consistent
Outer1.Cell that() 
mut method //@private @consistent
This4.Bool #terminate() 
read method //@private @consistent
This4.Bool terminate() 
mut method 
Void #next() exception Void (
  Void unused=(
    This.that() .#next() x=this.that().#next()
    Void unused0=(
      Outer1.CellEnd x0=(
        Void unused2=return x
        catch return casted (
          on Outer1.CellEnd casted
          
          on Any exception void
          )
        error {//@stringU
        //CastT-Should be unreachable code
        }
        )
      catch exception unused3 (
        on Void void
        )
      (
        Void unused4=exception void
        void
        )
      )
    Void unused1=return this.that(that:x)
    void
    )
  catch return result (
    on Void result
    )
  error {//@stringU
  //CurlyBlock-Should be unreachable code
  }
  )
read method 
Void #checkEnd() (
  This.terminate() cond=this.terminate()
  (
    Void unused=cond.#checkTrue()
    catch exception unused0 (
      on Void void
      )
    this.that().#checkEnd()
    )
  )
read method 
Outer1.Elem #inner() this.that().#inner()
read method 
Void #close() void}}
class method //@private
This _private13() }
class method 
Library list(class Any that) (
  Void unused=(
    Outer1.IntrospectionPlugin.typeNameToAdapter(that ) map=Outer1.IntrospectionPlugin.typeNameToAdapter(that:that)
    Outer1.IntrospectionPlugin.nameToAdapter(that ) tRen=Outer1.IntrospectionPlugin.nameToAdapter(that:Outer1.S.#stringParser(that:{//@stringU
    //Elem
    }).binaryRepr())
    Void unused0=return this.list(adapter:Outer1.IntrospectionPlugin.adaptLib(l1:map, l2:tRen))
    void
    )
  catch return result (
    on Library result
    )
  error {//@stringU
  //CurlyBlock-Should be unreachable code
  }
  )
class method 
Library list(Library adapter) Outer1.IntrospectionPlugin.adaptLib(l1:This.ListCode.#apply(), l2:adapter)
class method //@private
This _private12() }
Name:{//(Bool isExternal, Library adapter)
//external is "pointing out"
//internal is " A.B.C"
//not external and not internal is a method name

class method //@private
This new(Outer1.Bool^externalPath//@private @consistent
, Outer1.Bool^internalPath//@private @consistent
, Outer1.S^repr//@private @consistent
, Library^adapter//@private @consistent
) 
mut method //@private @consistent
Outer1.Bool #externalPath() 
read method //@private @consistent
Outer1.Bool externalPath() 
mut method //@private @consistent
Outer1.Bool #internalPath() 
read method //@private @consistent
Outer1.Bool internalPath() 
mut method //@private @consistent
Outer1.S #repr() 
read method //@private @consistent
Outer1.S repr() 
mut method //@private @consistent
Library #adapter() 
read method //@private @consistent
Library adapter() 
method 
Outer1.Bool isExternalPathName() this.externalPath()
method 
Outer1.Bool isInternalPathName() this.internalPath()
method 
Outer1.Bool isMethodName() this.externalPath().#bang().#and(that:this.internalPath().#bang())
class method 
This #stringParser(Library that) (
  Void unused=(
    Library adapter=using Outer1.IntrospectionPlugin check nameToAdapter(that:that) error {
    class method 
    This nameToAdapter() }
    Void unused0=return This.new(externalPath:Outer1.Bool.false(), internalPath:This.computeIsInternalPath(adapter:adapter), repr:Outer1.S.#stringParser(that:that), adapter:adapter)
    void
    )
  catch return result (
    on This result
    )
  error {//@stringU
  //CurlyBlock-Should be unreachable code
  }
  )
class method 
This #apply(class Any that) (
  Void unused=(
    Library adapter=using Outer1.IntrospectionPlugin check typeNameToAdapter(that:that) error {
    class method 
    This typeNameToAdapter() }
    Void unused0=return This.new(externalPath:Outer1.Bool.true(), internalPath:Outer1.Bool.false(), repr:Outer1.S.#stringParser(that:{//@stringU
    //ExternalPathName about 
    }).#plusplus(that:Outer1.Introspection.#apply(that:adapter).get()), adapter:adapter)
    void
    )
  catch return result (
    on This result
    )
  error {//@stringU
  //CurlyBlock-Should be unreachable code
  }
  )
class method 
This #apply(Library adapter) (
  Void unused=(
    This.getInternalAdapterStringOrEmpty(adapter ) internalName=This.getInternalAdapterStringOrEmpty(adapter:adapter)
    This.getInternalAdapterStringOrEmpty(adapter ) .size() .#equalequal(that ) isExternal=internalName.size().#equalequal(that:Outer1.N.#numberParser(that:{//@stringU
    //0
    }))
    Outer1.S repr=(
      Void unused1=(
        Void unused2=(
          Void unused4=isExternal.#checkTrue()
          catch exception unused5 (
            on Void void
            )
          return Outer1.S.#stringParser(that:{//@stringU
          //ExternalPathName about 
          }).#plusplus(that:Outer1.Introspection.#apply(that:adapter).get())
          )
        Void unused3=return internalName
        void
        )
      catch return result0 (
        on Outer1.S result0
        )
      error {//@stringU
      //CurlyBlock-Should be unreachable code
      }
      )
    Void unused0=return This.new(externalPath:isExternal, internalPath:isExternal.#bang(), repr:repr, adapter:adapter)
    void
    )
  catch return result (
    on This result
    )
  error {//@stringU
  //CurlyBlock-Should be unreachable code
  }
  )
class method //@private
Outer1.S getInternalAdapterStringOrEmpty(Library adapter) (
  Void unused=(
    Library result=using Outer1.IntrospectionPlugin check getInternalAdapterPathOrElse(that:adapter) return Outer1.S.#stringParser(that:{//@stringU
    //
    })
    Void unused0=return Outer1.S.#stringParser(that:result)
    void
    )
  catch return result0 (
    on Outer1.S result0
    )
  error {//@stringU
  //CurlyBlock-Should be unreachable code
  }
  )
class method //@private
Outer1.Bool computeIsInternalPath(Library adapter) (
  Void unused=(
    Outer1.Introspection.#apply(that node ) .methods() ms=Outer1.Introspection.#apply(that:adapter, node:Outer1.S.#stringParser(that:{//@stringU
    //%o_0%
    })).methods()
    Void unused0=return ms.isEmpty()
    void
    )
  catch return result (
    on Outer1.Bool result
    )
  error {//@stringU
  //CurlyBlock-Should be unreachable code
  }
  )
method 
Outer1.Bool #equalequal(Any that) (
  Void unused=(
    Void unused0=(
      This that0=(
        Void unused2=return that
        catch return casted (
          on This casted
          
          on Any exception void
          )
        error {//@stringU
        //CastT-Should be unreachable code
        }
        )
      catch exception unused3 (
        on Void void
        )
      (
        Void unused4=return this.innerEquals(that:that0)
        void
        )
      )
    Void unused1=return Outer1.Bool.false()
    void
    )
  catch return result (
    on Outer1.Bool result
    )
  error {//@stringU
  //CurlyBlock-Should be unreachable code
  }
  )
method 
Outer1.Bool innerEquals(This that) Outer1.Introspection.#apply(that:this.adapter()).get().#equalequal(that:Outer1.Introspection.#apply(that:that.adapter()).get())}
Introspection:{
VarnNum:{
class method 
mut This #apply(Outer2.N^inner//@private @consistent
) 
mut method //@private @consistent
Void inner(Outer2.N that) 
mut method //@private @consistent
Outer2.N #inner() 
read method //@private @consistent
Outer2.N inner() }
Varns:{
class method 
mut This #apply(Outer1.Names^inner//@private @consistent
) 
mut method //@private @consistent
Void inner(Outer1.Names that) 
mut method //@private @consistent
Outer1.Names #inner() 
read method //@private @consistent
Outer1.Names inner() }
VarmNum:{
class method 
mut This #apply(Outer2.N^inner//@private @consistent
) 
mut method //@private @consistent
Void inner(Outer2.N that) 
mut method //@private @consistent
Outer2.N #inner() 
read method //@private @consistent
Outer2.N inner() }
Varms:{
class method 
mut This #apply(Outer1.Methods^inner//@private @consistent
) 
mut method //@private @consistent
Void inner(Outer1.Methods that) 
mut method //@private @consistent
Outer1.Methods #inner() 
read method //@private @consistent
Outer1.Methods inner() }
class method 
This #apply(Library^that//@private @consistent
, Outer1.S^node//@private @consistent
) 
mut method //@private @consistent
Library #that() 
read method //@private @consistent
Library that() 
mut method //@private @consistent
Outer1.S #node() 
read method //@private @consistent
Outer1.S node() 
class method 
This #apply(Library that) This.#apply(that:that, node:Outer1.S.#stringParser(that:{//@stringU
//This
}))
method 
Outer1.S get() Outer1.S.#stringParser(that:using Outer1.IntrospectionPlugin check get(that:this.that(), node:this.node().binaryRepr()) error {
class method 
This getThatNode() })
method 
Library getIfExists(Outer1.N interfaceNum) exception Void using Outer1.IntrospectionPlugin check getOrElse(that:this.that(), interfaceNum:interfaceNum.binaryRepr(), node:this.node().binaryRepr()) exception void
method 
This.Method get(Outer1.N methodNum) exception Void (
  Void unused=(
    Library name=using Outer1.IntrospectionPlugin check getNameOrElse(that:this.that(), methodNum:methodNum.binaryRepr(), node:this.node().binaryRepr()) exception void
    Void unused0=return This.Method.#apply(myClass:this, num:methodNum, name:Outer1.S.#stringParser(that:name))
    void
    )
  catch return result (
    on This.Method result
    )
  error {//@stringU
  //CurlyBlock-Should be unreachable code
  }
  )
method 
Outer1.Name get(Outer1.N nestedClassNum) exception Void (
  Void unused=(
    Library name=using Outer1.IntrospectionPlugin check getNameOrElse(that:this.that(), nestedClassNum:nestedClassNum.binaryRepr(), node:this.node().binaryRepr()) exception void
    Void unused0=return Outer1.Name.#stringParser(that:name)
    void
    )
  catch return result (
    on Outer1.Name result
    )
  error {//@stringU
  //CurlyBlock-Should be unreachable code
  }
  )
Method:{
VarpNum:{
class method 
mut This #apply(Outer3.N.#numberParser(that ) ^inner//@private @consistent
) 
mut method //@private @consistent
Void inner(Outer3.N.#numberParser(that ) that) 
mut method //@private @consistent
Outer3.N.#numberParser(that ) #inner() }
Varps:{
class method 
mut This #apply(Outer2.Parameters.#begin() .#end() ^inner//@private @consistent
) 
mut method //@private @consistent
Void inner(Outer2.Parameters.#begin() .#end() that) 
mut method //@private @consistent
Outer2.Parameters.#begin() .#end() #inner() }
class method 
This #apply(Outer1^myClass//@private @consistent
, Outer2.N^num//@private @consistent
, Outer2.S^name//@private @consistent
) 
mut method //@private @consistent
Outer1 #myClass() 
read method //@private @consistent
Outer1 myClass() 
mut method //@private @consistent
Outer2.N #num() 
read method //@private @consistent
Outer2.N num() 
mut method //@private @consistent
Outer2.S #name() 
read method //@private @consistent
Outer2.S name() 
method 
Outer2.S get() Outer2.S.#stringParser(that:using Outer2.IntrospectionPlugin check getOrElse(that:this.myClass().that(), methodNum:this.num().binaryRepr(), node:this.myClass().node().binaryRepr()) error {
class method 
This invalidMethodNumber() })
method 
Outer2.S getMdf() Outer2.S.#stringParser(that:using Outer2.IntrospectionPlugin check getMdfOrElse(that:this.myClass().that(), methodNum:this.num().binaryRepr(), node:this.myClass().node().binaryRepr()) error {
class method 
This invalidMethodNumber() })
method 
Outer2.Name returnClass() (
  Void unused=(
    Library adapter=using Outer2.IntrospectionPlugin check getTypePathOrElse(that:this.myClass().that(), methodNum:this.num().binaryRepr(), node:this.myClass().node().binaryRepr()) error {
    class method 
    This invalidMethodNumber() }
    Void unused0=return Outer2.Name.#apply(adapter:adapter)
    void
    )
  catch return result (
    on Outer2.Name result
    )
  error {//@stringU
  //CurlyBlock-Should be unreachable code
  }
  )
method 
Outer2.Name getName() Outer2.Name.#stringParser(//get name? unuseful! -- why unuseful?
that:using Outer2.IntrospectionPlugin check getNameOrElse(that:this.myClass().that(), methodNum:this.num().binaryRepr(), node:this.myClass().node().binaryRepr()) error {
class method 
This invalidMethodNumber() })
method 
Outer2.Bool isAbstract() (
  Void unused=(
    Void unused0=using Outer2.IntrospectionPlugin check ifIsAbstractDo(that:this.myClass().that(), methodNum:this.num().binaryRepr(), node:this.myClass().node().binaryRepr()) return Outer2.Bool.true()
    Void unused1=return Outer2.Bool.false()
    void
    )
  catch return result (
    on Outer2.Bool result
    )
  error {//@stringU
  //CurlyBlock-Should be unreachable code
  }
  )
method 
Outer1.Parameter get(Outer2.N parameterNum) exception Void (
  Void unused=(
    Library name=using Outer2.IntrospectionPlugin check getNameOrElse(that:this.myClass().that(), methodNum:this.num().binaryRepr(), parameterNum:parameterNum.binaryRepr(), node:this.myClass().node().binaryRepr()) exception void
    Void unused0=return Outer1.Parameter.#apply(myMethod:this, num:parameterNum, name:Outer2.S.#stringParser(that:name))
    void
    )
  catch return result (
    on Outer1.Parameter result
    )
  error {//@stringU
  //CurlyBlock-Should be unreachable code
  }
  )
method 
Outer1.Parameters parameters() (
  Void unused=(
    Outer1.Parameters.#begin() .#end() ps=Outer1.Parameters.#begin().#end()
    Outer2.N.#numberParser(that ) pNum=Outer2.N.#numberParser(that:{//@stringU
    //0
    })
    mut This.Varps varps=This.Varps.#apply(inner:ps)
    mut This.VarpNum varpNum=This.VarpNum.#apply(inner:pNum)
    Void unused0=(
      Void unused2=loop (
        Void unused3=Outer2.Bool.true().#checkTrue()
        (
          Void unused4=varps.inner(that:varps.#inner().#add(that:this.get(parameterNum:varpNum.#inner())))
          varpNum.inner(that:varpNum.#inner().#plus(that:Outer2.N.#numberParser(that:{//@stringU
          //1
          })))
          )
        )
      catch exception unused5 (
        on Void void
        )
      void
      )
    Void unused1=return varps.#inner()
    void
    )
  catch return result (
    on Outer1.Parameters result
    )
  error {//@stringU
  //CurlyBlock-Should be unreachable code
  }
  )}
Parameter:{
class method 
This #apply(Outer1.Method^myMethod//@private @consistent
, Outer2.N^num//@private @consistent
, Outer2.S^name//@private @consistent
) 
mut method //@private @consistent
Outer1.Method #myMethod() 
read method //@private @consistent
Outer1.Method myMethod() 
mut method //@private @consistent
Outer2.N #num() 
read method //@private @consistent
Outer2.N num() 
mut method //@private @consistent
Outer2.S #name() 
read method //@private @consistent
Outer2.S name() 
method 
Outer2.Name class() (
  Void unused=(
    Library adapter=using Outer2.IntrospectionPlugin check getTypePathOrElse(that:this.myMethod().myClass().that(), methodNum:this.myMethod().num().binaryRepr(), parameterNum:this.num().binaryRepr(), node:this.myMethod().myClass().node().binaryRepr()) error {
    class method 
    This invalidMethodNumber() }
    Void unused0=return Outer2.Name.#apply(adapter:adapter)
    void
    )
  catch return result (
    on Outer2.Name result
    )
  error {//@stringU
  //CurlyBlock-Should be unreachable code
  }
  )}
Parameters:{// generic linked list class, elements of class Elem

Varres:{
class method 
mut This #apply(Outer1^inner//@private @consistent
) 
mut method //@private @consistent
Void inner(Outer1 that) 
mut method //@private @consistent
Outer1 #inner() 
read method //@private @consistent
Outer1 inner() }
Varres0:{
class method 
mut This #apply(Outer1.#apply() ^inner//@private @consistent
) 
mut method //@private @consistent
Void inner(Outer1.#apply() that) 
mut method //@private @consistent
Outer1.#apply() #inner() }
class method 
This _new(This.Cell^head//@private @consistent
) 
mut method //@private @consistent
This.Cell #head() 
read method //@private @consistent
This.Cell head() 
class method 
This #apply() This._new(head:This.CellEnd.#apply())
method 
Outer2.Bool isEmpty() (
  Void unused=(
    Void unused0=(
      This.head() x=this.head()
      (
        This.CellEnd x0=(
          Void unused1=return x
          catch return casted (
            on This.CellEnd casted
            
            on Any exception void
            )
          error {//@stringU
          //CastT-Should be unreachable code
          }
          )
        catch exception unused2 (
          on Void return Outer2.Bool.false()
          )
        (
          Void unused3=return Outer2.Bool.true()
          void
          )
        )
      )
    void
    )
  catch return result (
    on Outer2.Bool result
    )
  error {//@stringU
  //CurlyBlock-Should be unreachable code
  }
  )
method 
Outer1.Parameter top() this.head().#inner()
method 
mut This.Iterator vals() this.head().vals(terminate:Outer2.Bool.true())
method 
mut This.Iterator valsCut() this.head().vals(terminate:Outer2.Bool.false())
method 
This pop() (
  Void unused=(
    Void unused0=return This._new(head:this.head().#next())
    catch exception unused1 (
      on Void error Outer2.S.#stringParser(that:{//@stringU
      //PopOnEmpyList
      })
      )
    void
    )
  catch return result (
    on This result
    )
  error {//@stringU
  //CurlyBlock-Should be unreachable code
  }
  )
method 
This #plusplus(This that) (
  Void unused=(
    This res=this
    mut This.Varres varres=This.Varres.#apply(inner:res)
    Void unused0=(
      This.vals() e=that.vals()
      (
        Void unused2=(
          Void unused3=(
            Void unused4=loop (
              Void unused5=e.#next()
              catch exception unused6 (
                on Void (
                  Void unused7=(
                    Void unused8=e.#checkEnd()
                    catch exception unused9 (
                      on Void void
                      )
                    void
                    )
                  exception void
                  )
                )
              varres.inner(that:varres.#inner().#add(that:e.#inner()))
              )
            catch exception unused10 (
              on Void void
              )
            void
            )
          catch exception propagated (
            on Any (
              Void unused11=e.#close()
              exception propagated
              )
            )
          void
          )
        catch return propagated0 (
          on This (
            Void unused12=e.#close()
            return propagated0
            )
          )
        e.#close()
        )
      )
    Void unused1=return varres.#inner()
    void
    )
  catch return result (
    on This result
    )
  error {//@stringU
  //CurlyBlock-Should be unreachable code
  }
  )
class method 
This #begin() This.#apply()
method 
This #add(Outer1.Parameter that) This._new(head:This.CellNext.#apply(elem:that, nextCell:this.head()))
method 
This #end() (
  This.#apply() res=This.#apply()
  mut This.Varres0 varres=This.Varres0.#apply(inner:res)
  Void unused=(
    This.vals() elem=this.vals()
    (
      Void unused0=(
        Void unused1=(
          Void unused2=loop (
            Void unused3=elem.#next()
            catch exception unused4 (
              on Void (
                Void unused5=(
                  Void unused6=elem.#checkEnd()
                  catch exception unused7 (
                    on Void void
                    )
                  void
                  )
                exception void
                )
              )
            varres.inner(that:varres.#inner().#add(that:elem.#inner()))
            )
          catch exception unused8 (
            on Void void
            )
          void
          )
        catch exception propagated (
          on Any (
            Void unused9=elem.#close()
            exception propagated
            )
          )
        void
        )
      catch return propagated0 (
        on Any (
          Void unused10=elem.#close()
          return propagated0
          )
        )
      elem.#close()
      )
    )
  varres.#inner()
  )
Cell:{interface 
method 
mut Outer1.Iterator vals(Outer3.Bool terminate) 
method 
This #next() exception Void 
method 
Outer2.Parameter #inner() 
method 
Void #checkEnd() }
CellEnd:{ implements Outer1.Cell
class method 
This #apply() 
method vals(terminate ) Outer1.Iterator.#apply(that:this, terminate:terminate)
method #next() exception void
method #inner() error Outer3.S.#stringParser(that:{//@stringU
//InnerOnCellEnd, should not happen
})
method #checkEnd() void}
CellNext:{ implements Outer1.Cell
class method 
This #apply(Outer2.Parameter^elem//@private @consistent
, Outer1.Cell^nextCell//@private @consistent
) 
mut method //@private @consistent
Outer2.Parameter #elem() 
read method //@private @consistent
Outer2.Parameter elem() 
mut method //@private @consistent
Outer1.Cell #nextCell() 
read method //@private @consistent
Outer1.Cell nextCell() 
method vals(terminate ) (
  Void unused=(
    This.#apply(elem nextCell ) startPoint=This.#apply(elem:this.elem(), nextCell:this)
    Void unused0=return Outer1.Iterator.#apply(that:startPoint, terminate:terminate)
    void
    )
  catch return result (
    on This.vals(terminate ) result
    )
  error {//@stringU
  //CurlyBlock-Should be unreachable code
  }
  )
method #next() this.nextCell()
method #inner() this.elem()
method #checkEnd() (
  This.#checkEnd() .this.nextCell() cell=this.nextCell()
  (
    This cell0=(
      Void unused=return cell
      catch return casted (
        on This casted
        
        on Any exception void
        )
      error {//@stringU
      //CastT-Should be unreachable code
      }
      )
    catch exception unused0 (
      on Void void
      )
    (
      Void unused1=error Outer3.S.#stringParser(that:{//@stringU
      //IterationNotComplete,\u000a  use valsCut() to allows incomplete iterations\u000a
      })
      void
      )
    )
  )}
Iterator:{
class method 
mut This #apply(Outer1.Cell^that//@private @consistent
, Outer3.Bool^terminate//@private @consistent
) 
mut method //@private @consistent
Void that(Outer1.Cell that) 
mut method //@private @consistent
Outer1.Cell #that() 
read method //@private @consistent
Outer1.Cell that() 
mut method //@private @consistent
Outer3.Bool #terminate() 
read method //@private @consistent
Outer3.Bool terminate() 
mut method 
Void #next() exception Void (
  Void unused=(
    This.that() .#next() x=this.that().#next()
    Void unused0=(
      Outer1.CellEnd x0=(
        Void unused2=return x
        catch return casted (
          on Outer1.CellEnd casted
          
          on Any exception void
          )
        error {//@stringU
        //CastT-Should be unreachable code
        }
        )
      catch exception unused3 (
        on Void void
        )
      (
        Void unused4=exception void
        void
        )
      )
    Void unused1=return this.that(that:x)
    void
    )
  catch return result (
    on Void result
    )
  error {//@stringU
  //CurlyBlock-Should be unreachable code
  }
  )
read method 
Void #checkEnd() (
  This.terminate() cond=this.terminate()
  (
    Void unused=cond.#checkTrue()
    catch exception unused0 (
      on Void void
      )
    this.that().#checkEnd()
    )
  )
read method 
Outer2.Parameter #inner() this.that().#inner()
read method 
Void #close() void}}
Methods:{// generic linked list class, elements of class Elem

Varres:{
class method 
mut This #apply(Outer1^inner//@private @consistent
) 
mut method //@private @consistent
Void inner(Outer1 that) 
mut method //@private @consistent
Outer1 #inner() 
read method //@private @consistent
Outer1 inner() }
Varres0:{
class method 
mut This #apply(Outer1.#apply() ^inner//@private @consistent
) 
mut method //@private @consistent
Void inner(Outer1.#apply() that) 
mut method //@private @consistent
Outer1.#apply() #inner() }
class method 
This _new(This.Cell^head//@private @consistent
) 
mut method //@private @consistent
This.Cell #head() 
read method //@private @consistent
This.Cell head() 
class method 
This #apply() This._new(head:This.CellEnd.#apply())
method 
Outer2.Bool isEmpty() (
  Void unused=(
    Void unused0=(
      This.head() x=this.head()
      (
        This.CellEnd x0=(
          Void unused1=return x
          catch return casted (
            on This.CellEnd casted
            
            on Any exception void
            )
          error {//@stringU
          //CastT-Should be unreachable code
          }
          )
        catch exception unused2 (
          on Void return Outer2.Bool.false()
          )
        (
          Void unused3=return Outer2.Bool.true()
          void
          )
        )
      )
    void
    )
  catch return result (
    on Outer2.Bool result
    )
  error {//@stringU
  //CurlyBlock-Should be unreachable code
  }
  )
method 
Outer1.Method top() this.head().#inner()
method 
mut This.Iterator vals() this.head().vals(terminate:Outer2.Bool.true())
method 
mut This.Iterator valsCut() this.head().vals(terminate:Outer2.Bool.false())
method 
This pop() (
  Void unused=(
    Void unused0=return This._new(head:this.head().#next())
    catch exception unused1 (
      on Void error Outer2.S.#stringParser(that:{//@stringU
      //PopOnEmpyList
      })
      )
    void
    )
  catch return result (
    on This result
    )
  error {//@stringU
  //CurlyBlock-Should be unreachable code
  }
  )
method 
This #plusplus(This that) (
  Void unused=(
    This res=this
    mut This.Varres varres=This.Varres.#apply(inner:res)
    Void unused0=(
      This.vals() e=that.vals()
      (
        Void unused2=(
          Void unused3=(
            Void unused4=loop (
              Void unused5=e.#next()
              catch exception unused6 (
                on Void (
                  Void unused7=(
                    Void unused8=e.#checkEnd()
                    catch exception unused9 (
                      on Void void
                      )
                    void
                    )
                  exception void
                  )
                )
              varres.inner(that:varres.#inner().#add(that:e.#inner()))
              )
            catch exception unused10 (
              on Void void
              )
            void
            )
          catch exception propagated (
            on Any (
              Void unused11=e.#close()
              exception propagated
              )
            )
          void
          )
        catch return propagated0 (
          on This (
            Void unused12=e.#close()
            return propagated0
            )
          )
        e.#close()
        )
      )
    Void unused1=return varres.#inner()
    void
    )
  catch return result (
    on This result
    )
  error {//@stringU
  //CurlyBlock-Should be unreachable code
  }
  )
class method 
This #begin() This.#apply()
method 
This #add(Outer1.Method that) This._new(head:This.CellNext.#apply(elem:that, nextCell:this.head()))
method 
This #end() (
  This.#apply() res=This.#apply()
  mut This.Varres0 varres=This.Varres0.#apply(inner:res)
  Void unused=(
    This.vals() elem=this.vals()
    (
      Void unused0=(
        Void unused1=(
          Void unused2=loop (
            Void unused3=elem.#next()
            catch exception unused4 (
              on Void (
                Void unused5=(
                  Void unused6=elem.#checkEnd()
                  catch exception unused7 (
                    on Void void
                    )
                  void
                  )
                exception void
                )
              )
            varres.inner(that:varres.#inner().#add(that:elem.#inner()))
            )
          catch exception unused8 (
            on Void void
            )
          void
          )
        catch exception propagated (
          on Any (
            Void unused9=elem.#close()
            exception propagated
            )
          )
        void
        )
      catch return propagated0 (
        on Any (
          Void unused10=elem.#close()
          return propagated0
          )
        )
      elem.#close()
      )
    )
  varres.#inner()
  )
Cell:{interface 
method 
mut Outer1.Iterator vals(Outer3.Bool terminate) 
method 
This #next() exception Void 
method 
Outer2.Method #inner() 
method 
Void #checkEnd() }
CellEnd:{ implements Outer1.Cell
class method 
This #apply() 
method vals(terminate ) Outer1.Iterator.#apply(that:this, terminate:terminate)
method #next() exception void
method #inner() error Outer3.S.#stringParser(that:{//@stringU
//InnerOnCellEnd, should not happen
})
method #checkEnd() void}
CellNext:{ implements Outer1.Cell
class method 
This #apply(Outer2.Method^elem//@private @consistent
, Outer1.Cell^nextCell//@private @consistent
) 
mut method //@private @consistent
Outer2.Method #elem() 
read method //@private @consistent
Outer2.Method elem() 
mut method //@private @consistent
Outer1.Cell #nextCell() 
read method //@private @consistent
Outer1.Cell nextCell() 
method vals(terminate ) (
  Void unused=(
    This.#apply(elem nextCell ) startPoint=This.#apply(elem:this.elem(), nextCell:this)
    Void unused0=return Outer1.Iterator.#apply(that:startPoint, terminate:terminate)
    void
    )
  catch return result (
    on This.vals(terminate ) result
    )
  error {//@stringU
  //CurlyBlock-Should be unreachable code
  }
  )
method #next() this.nextCell()
method #inner() this.elem()
method #checkEnd() (
  This.#checkEnd() .this.nextCell() cell=this.nextCell()
  (
    This cell0=(
      Void unused=return cell
      catch return casted (
        on This casted
        
        on Any exception void
        )
      error {//@stringU
      //CastT-Should be unreachable code
      }
      )
    catch exception unused0 (
      on Void void
      )
    (
      Void unused1=error Outer3.S.#stringParser(that:{//@stringU
      //IterationNotComplete,\u000a  use valsCut() to allows incomplete iterations\u000a
      })
      void
      )
    )
  )}
Iterator:{
class method 
mut This #apply(Outer1.Cell^that//@private @consistent
, Outer3.Bool^terminate//@private @consistent
) 
mut method //@private @consistent
Void that(Outer1.Cell that) 
mut method //@private @consistent
Outer1.Cell #that() 
read method //@private @consistent
Outer1.Cell that() 
mut method //@private @consistent
Outer3.Bool #terminate() 
read method //@private @consistent
Outer3.Bool terminate() 
mut method 
Void #next() exception Void (
  Void unused=(
    This.that() .#next() x=this.that().#next()
    Void unused0=(
      Outer1.CellEnd x0=(
        Void unused2=return x
        catch return casted (
          on Outer1.CellEnd casted
          
          on Any exception void
          )
        error {//@stringU
        //CastT-Should be unreachable code
        }
        )
      catch exception unused3 (
        on Void void
        )
      (
        Void unused4=exception void
        void
        )
      )
    Void unused1=return this.that(that:x)
    void
    )
  catch return result (
    on Void result
    )
  error {//@stringU
  //CurlyBlock-Should be unreachable code
  }
  )
read method 
Void #checkEnd() (
  This.terminate() cond=this.terminate()
  (
    Void unused=cond.#checkTrue()
    catch exception unused0 (
      on Void void
      )
    this.that().#checkEnd()
    )
  )
read method 
Outer2.Method #inner() this.that().#inner()
read method 
Void #close() void}}
Names:{// generic linked list class, elements of class Elem

Varres:{
class method 
mut This #apply(Outer1^inner//@private @consistent
) 
mut method //@private @consistent
Void inner(Outer1 that) 
mut method //@private @consistent
Outer1 #inner() 
read method //@private @consistent
Outer1 inner() }
Varres0:{
class method 
mut This #apply(Outer1.#apply() ^inner//@private @consistent
) 
mut method //@private @consistent
Void inner(Outer1.#apply() that) 
mut method //@private @consistent
Outer1.#apply() #inner() }
class method 
This _new(This.Cell^head//@private @consistent
) 
mut method //@private @consistent
This.Cell #head() 
read method //@private @consistent
This.Cell head() 
class method 
This #apply() This._new(head:This.CellEnd.#apply())
method 
Outer2.Bool isEmpty() (
  Void unused=(
    Void unused0=(
      This.head() x=this.head()
      (
        This.CellEnd x0=(
          Void unused1=return x
          catch return casted (
            on This.CellEnd casted
            
            on Any exception void
            )
          error {//@stringU
          //CastT-Should be unreachable code
          }
          )
        catch exception unused2 (
          on Void return Outer2.Bool.false()
          )
        (
          Void unused3=return Outer2.Bool.true()
          void
          )
        )
      )
    void
    )
  catch return result (
    on Outer2.Bool result
    )
  error {//@stringU
  //CurlyBlock-Should be unreachable code
  }
  )
method 
Outer2.Name top() this.head().#inner()
method 
mut This.Iterator vals() this.head().vals(terminate:Outer2.Bool.true())
method 
mut This.Iterator valsCut() this.head().vals(terminate:Outer2.Bool.false())
method 
This pop() (
  Void unused=(
    Void unused0=return This._new(head:this.head().#next())
    catch exception unused1 (
      on Void error Outer2.S.#stringParser(that:{//@stringU
      //PopOnEmpyList
      })
      )
    void
    )
  catch return result (
    on This result
    )
  error {//@stringU
  //CurlyBlock-Should be unreachable code
  }
  )
method 
This #plusplus(This that) (
  Void unused=(
    This res=this
    mut This.Varres varres=This.Varres.#apply(inner:res)
    Void unused0=(
      This.vals() e=that.vals()
      (
        Void unused2=(
          Void unused3=(
            Void unused4=loop (
              Void unused5=e.#next()
              catch exception unused6 (
                on Void (
                  Void unused7=(
                    Void unused8=e.#checkEnd()
                    catch exception unused9 (
                      on Void void
                      )
                    void
                    )
                  exception void
                  )
                )
              varres.inner(that:varres.#inner().#add(that:e.#inner()))
              )
            catch exception unused10 (
              on Void void
              )
            void
            )
          catch exception propagated (
            on Any (
              Void unused11=e.#close()
              exception propagated
              )
            )
          void
          )
        catch return propagated0 (
          on This (
            Void unused12=e.#close()
            return propagated0
            )
          )
        e.#close()
        )
      )
    Void unused1=return varres.#inner()
    void
    )
  catch return result (
    on This result
    )
  error {//@stringU
  //CurlyBlock-Should be unreachable code
  }
  )
class method 
This #begin() This.#apply()
method 
This #add(Outer2.Name that) This._new(head:This.CellNext.#apply(elem:that, nextCell:this.head()))
method 
This #end() (
  This.#apply() res=This.#apply()
  mut This.Varres0 varres=This.Varres0.#apply(inner:res)
  Void unused=(
    This.vals() elem=this.vals()
    (
      Void unused0=(
        Void unused1=(
          Void unused2=loop (
            Void unused3=elem.#next()
            catch exception unused4 (
              on Void (
                Void unused5=(
                  Void unused6=elem.#checkEnd()
                  catch exception unused7 (
                    on Void void
                    )
                  void
                  )
                exception void
                )
              )
            varres.inner(that:varres.#inner().#add(that:elem.#inner()))
            )
          catch exception unused8 (
            on Void void
            )
          void
          )
        catch exception propagated (
          on Any (
            Void unused9=elem.#close()
            exception propagated
            )
          )
        void
        )
      catch return propagated0 (
        on Any (
          Void unused10=elem.#close()
          return propagated0
          )
        )
      elem.#close()
      )
    )
  varres.#inner()
  )
Cell:{interface 
method 
mut Outer1.Iterator vals(Outer3.Bool terminate) 
method 
This #next() exception Void 
method 
Outer3.Name #inner() 
method 
Void #checkEnd() }
CellEnd:{ implements Outer1.Cell
class method 
This #apply() 
method vals(terminate ) Outer1.Iterator.#apply(that:this, terminate:terminate)
method #next() exception void
method #inner() error Outer3.S.#stringParser(that:{//@stringU
//InnerOnCellEnd, should not happen
})
method #checkEnd() void}
CellNext:{ implements Outer1.Cell
class method 
This #apply(Outer3.Name^elem//@private @consistent
, Outer1.Cell^nextCell//@private @consistent
) 
mut method //@private @consistent
Outer3.Name #elem() 
read method //@private @consistent
Outer3.Name elem() 
mut method //@private @consistent
Outer1.Cell #nextCell() 
read method //@private @consistent
Outer1.Cell nextCell() 
method vals(terminate ) (
  Void unused=(
    This.#apply(elem nextCell ) startPoint=This.#apply(elem:this.elem(), nextCell:this)
    Void unused0=return Outer1.Iterator.#apply(that:startPoint, terminate:terminate)
    void
    )
  catch return result (
    on This.vals(terminate ) result
    )
  error {//@stringU
  //CurlyBlock-Should be unreachable code
  }
  )
method #next() this.nextCell()
method #inner() this.elem()
method #checkEnd() (
  This.#checkEnd() .this.nextCell() cell=this.nextCell()
  (
    This cell0=(
      Void unused=return cell
      catch return casted (
        on This casted
        
        on Any exception void
        )
      error {//@stringU
      //CastT-Should be unreachable code
      }
      )
    catch exception unused0 (
      on Void void
      )
    (
      Void unused1=error Outer3.S.#stringParser(that:{//@stringU
      //IterationNotComplete,\u000a  use valsCut() to allows incomplete iterations\u000a
      })
      void
      )
    )
  )}
Iterator:{
class method 
mut This #apply(Outer1.Cell^that//@private @consistent
, Outer3.Bool^terminate//@private @consistent
) 
mut method //@private @consistent
Void that(Outer1.Cell that) 
mut method //@private @consistent
Outer1.Cell #that() 
read method //@private @consistent
Outer1.Cell that() 
mut method //@private @consistent
Outer3.Bool #terminate() 
read method //@private @consistent
Outer3.Bool terminate() 
mut method 
Void #next() exception Void (
  Void unused=(
    This.that() .#next() x=this.that().#next()
    Void unused0=(
      Outer1.CellEnd x0=(
        Void unused2=return x
        catch return casted (
          on Outer1.CellEnd casted
          
          on Any exception void
          )
        error {//@stringU
        //CastT-Should be unreachable code
        }
        )
      catch exception unused3 (
        on Void void
        )
      (
        Void unused4=exception void
        void
        )
      )
    Void unused1=return this.that(that:x)
    void
    )
  catch return result (
    on Void result
    )
  error {//@stringU
  //CurlyBlock-Should be unreachable code
  }
  )
read method 
Void #checkEnd() (
  This.terminate() cond=this.terminate()
  (
    Void unused=cond.#checkTrue()
    catch exception unused0 (
      on Void void
      )
    this.that().#checkEnd()
    )
  )
read method 
Outer3.Name #inner() this.that().#inner()
read method 
Void #close() void}}
method 
This.Names nestedClasses() (
  Void unused=(
    This.Names ns=This.Names.#begin().#end()
    Outer1.N nNum=Outer1.N.#numberParser(that:{//@stringU
    //0
    })
    mut This.Varns varns=This.Varns.#apply(inner:ns)
    mut This.VarnNum varnNum=This.VarnNum.#apply(inner:nNum)
    Void unused0=(
      Void unused2=loop (
        Void unused3=Outer1.Bool.true().#checkTrue()
        (
          Void unused4=varns.inner(that:varns.#inner().#add(that:this.get(nestedClassNum:varnNum.#inner())))
          varnNum.inner(that:varnNum.#inner().#plus(that:Outer1.N.#numberParser(that:{//@stringU
          //1
          })))
          )
        )
      catch exception unused5 (
        on Void void
        )
      void
      )
    Void unused1=return varns.#inner()
    void
    )
  catch return result (
    on This.Names result
    )
  error {//@stringU
  //CurlyBlock-Should be unreachable code
  }
  )
method 
This.Methods methods() (
  Void unused=(
    This.Methods ms=This.Methods.#begin().#end()
    Outer1.N mNum=Outer1.N.#numberParser(that:{//@stringU
    //0
    })
    mut This.Varms varms=This.Varms.#apply(inner:ms)
    mut This.VarmNum varmNum=This.VarmNum.#apply(inner:mNum)
    Void unused0=(
      Void unused2=loop (
        Void unused3=Outer1.Bool.true().#checkTrue()
        (
          Void unused4=varms.inner(that:varms.#inner().#add(that:this.get(methodNum:varmNum.#inner())))
          varmNum.inner(that:varmNum.#inner().#plus(that:Outer1.N.#numberParser(that:{//@stringU
          //1
          })))
          )
        )
      catch exception unused5 (
        on Void void
        )
      void
      )
    Void unused1=return varms.#inner()
    void
    )
  catch return result (
    on This.Methods result
    )
  error {//@stringU
  //CurlyBlock-Should be unreachable code
  }
  )
method 
This.Parameters fields() (
  Void unused=(
    This.methods() ms=this.methods()
    This.Method ctor=(
      Void unused1=(
        Void unused2=(
          This.methods() .vals() m=ms.vals()
          (
            Void unused4=(
              Void unused5=(
                Void unused6=loop (
                  Void unused7=m.#next()
                  catch exception unused8 (
                    on Void (
                      Void unused9=(
                        Void unused10=m.#checkEnd()
                        catch exception unused11 (
                          on Void void
                          )
                        void
                        )
                      exception void
                      )
                    )
                  (
                    This.methods() .vals() .#inner() .isAbstract() .#and(that ) cond=m.#inner().isAbstract().#and(that:m.#inner().getMdf().#equalequal(that:Outer1.S.#stringParser(that:{//@stringU
                    //Type
                    })))
                    (
                      Void unused12=cond.#checkTrue()
                      catch exception unused13 (
                        on Void void
                        )
                      return m.#inner()
                      )
                    )
                  )
                catch exception unused14 (
                  on Void void
                  )
                void
                )
              catch exception propagated (
                on Any (
                  Void unused15=m.#close()
                  exception propagated
                  )
                )
              void
              )
            catch return propagated0 (
              on This.Method (
                Void unused16=m.#close()
                return propagated0
                )
              )
            m.#close()
            )
          )
        Void unused3=error Outer1.S.#stringParser(that:{//@stringU
        //Not an instantiable class
        })
        void
        )
      catch return result0 (
        on This.Method result0
        )
      error {//@stringU
      //CurlyBlock-Should be unreachable code
      }
      )
    Void unused0=return ctor.parameters()
    void
    )
  catch return result (
    on This.Parameters result
    )
  error {//@stringU
  //CurlyBlock-Should be unreachable code
  }
  )}
Load:{
class method 
This #begin() 
method 
This #end() this
method 
Library #left(Library that) (
  Void unused=(//assume that have abstract Bool N and S
  
    Void unused0=return Outer1.Adapt.#begin().#add(that:Outer1.Name.#stringParser(that:{//@stringU
    //N
    }), into:Outer1.Name.#apply(that:Outer1.N)).#add(that:Outer1.Name.#stringParser(that:{//@stringU
    //S
    }), into:Outer1.Name.#apply(that:Outer1.S)).#add(that:Outer1.Name.#stringParser(that:{//@stringU
    //S.ToS
    }), into:Outer1.Name.#apply(that:Outer1.S.ToS)).#add(that:Outer1.Name.#stringParser(that:{//@stringU
    //Bool
    }), into:Outer1.Name.#apply(that:Outer1.Bool)).#add(that:Outer1.Name.#stringParser(that:{//@stringU
    //Debug
    }), into:Outer1.Name.#apply(that:Outer1.Debug)).#end().#left(that:that)
    void
    )
  catch return result (
    on Library result
    )
  error {//@stringU
  //CurlyBlock-Should be unreachable code
  }
  )}
Opt:{
class method 
This unused() 
class method 
Library #apply(class Any that) Outer1.Adapt.#begin().#add(that:Outer1.Name.#stringParser(that:{//@stringU
//T
}), into:Outer1.Name.#apply(that:that)).#end().#left(that:{
class method 
This #new(This.TOpt^that//@private @consistent
) 
mut method //@private @consistent
This.TOpt #that() 
read method //@private @consistent
This.TOpt that() 
T:{}
TOpt:{interface 
method 
Outer1.T get() }
TEmpty:{ implements Outer1.TOpt
class method 
This #apply() 
method get() error Outer3.S.#stringParser(that:{//@stringU
//Value not present
})}
TOf:{ implements Outer1.TOpt
class method 
This #apply(Outer1.T^that//@private @consistent
) 
mut method //@private @consistent
Outer1.T #that() 
read method //@private @consistent
Outer1.T that() 
method get() this.that()}
method 
This.T #bang() this.that().get()
method 
Outer2.Bool isPresent() (
  Void unused=(
    This.#bang() aux=this.#bang()
    Void unused0=return Outer2.Bool.true()
    catch error unused1 (
      on Any return Outer2.Bool.false()
      )
    void
    )
  catch return result (
    on Outer2.Bool result
    )
  error {//@stringU
  //CurlyBlock-Should be unreachable code
  }
  )
class method 
This #apply() This.#new(that:This.TEmpty.#apply())
class method 
This #apply(This.T that) This.#new(that:This.TOf.#apply(that:that))})}
Use:{
Varresult1:{
class method 
mut This #apply(Outer1.myLibs() .vals() .#inner() ^inner//@private @consistent
) 
mut method //@private @consistent
Void inner(Outer1.myLibs() .vals() .#inner() that) 
mut method //@private @consistent
Outer1.myLibs() .vals() .#inner() #inner() }
Varresult2:{
class method 
mut This #apply(Outer2.IntrospectionPlugin.sumLib(l1 l2 ) ^inner//@private @consistent
) 
mut method //@private @consistent
Void inner(Outer2.IntrospectionPlugin.sumLib(l1 l2 ) that) 
mut method //@private @consistent
Outer2.IntrospectionPlugin.sumLib(l1 l2 ) #inner() }
class method 
This #apply(This.Resolver^resolver//@private @consistent
, This.Libs^myLibs//@private @consistent
) 
mut method //@private @consistent
This.Resolver #resolver() 
read method //@private @consistent
This.Resolver resolver() 
mut method //@private @consistent
This.Libs #myLibs() 
read method //@private @consistent
This.Libs myLibs() 
Resolver:{
class method 
This #new(This.TOpt^that//@private @consistent
) 
mut method //@private @consistent
This.TOpt #that() 
read method //@private @consistent
This.TOpt that() 
TOpt:{interface 
method 
Library get() }
TEmpty:{ implements Outer1.TOpt
class method 
This #apply() 
method get() error Outer3.S.#stringParser(that:{//@stringU
//Value not present
})}
TOf:{ implements Outer1.TOpt
class method 
This #apply(Library^that//@private @consistent
) 
mut method //@private @consistent
Library #that() 
read method //@private @consistent
Library that() 
method get() this.that()}
method 
Library #bang() this.that().get()
method 
Outer2.Bool isPresent() (
  Void unused=(
    This.#bang() aux=this.#bang()
    Void unused0=return Outer2.Bool.true()
    catch error unused1 (
      on Any return Outer2.Bool.false()
      )
    void
    )
  catch return result (
    on Outer2.Bool result
    )
  error {//@stringU
  //CurlyBlock-Should be unreachable code
  }
  )
class method 
This #apply() This.#new(that:This.TEmpty.#apply())
class method 
This #apply(Library that) This.#new(that:This.TOf.#apply(that:that))}
Libs://@private
{// generic linked list class, elements of class Elem

Varres:{
class method 
mut This #apply(Outer1^inner//@private @consistent
) 
mut method //@private @consistent
Void inner(Outer1 that) 
mut method //@private @consistent
Outer1 #inner() 
read method //@private @consistent
Outer1 inner() }
Varres0:{
class method 
mut This #apply(Outer1.#apply() ^inner//@private @consistent
) 
mut method //@private @consistent
Void inner(Outer1.#apply() that) 
mut method //@private @consistent
Outer1.#apply() #inner() }
class method 
This _new(This.Cell^head//@private @consistent
) 
mut method //@private @consistent
This.Cell #head() 
read method //@private @consistent
This.Cell head() 
class method 
This #apply() This._new(head:This.CellEnd.#apply())
method 
Outer2.Bool isEmpty() (
  Void unused=(
    Void unused0=(
      This.head() x=this.head()
      (
        This.CellEnd x0=(
          Void unused1=return x
          catch return casted (
            on This.CellEnd casted
            
            on Any exception void
            )
          error {//@stringU
          //CastT-Should be unreachable code
          }
          )
        catch exception unused2 (
          on Void return Outer2.Bool.false()
          )
        (
          Void unused3=return Outer2.Bool.true()
          void
          )
        )
      )
    void
    )
  catch return result (
    on Outer2.Bool result
    )
  error {//@stringU
  //CurlyBlock-Should be unreachable code
  }
  )
method 
Library top() this.head().#inner()
method 
mut This.Iterator vals() this.head().vals(terminate:Outer2.Bool.true())
method 
mut This.Iterator valsCut() this.head().vals(terminate:Outer2.Bool.false())
method 
This pop() (
  Void unused=(
    Void unused0=return This._new(head:this.head().#next())
    catch exception unused1 (
      on Void error Outer2.S.#stringParser(that:{//@stringU
      //PopOnEmpyList
      })
      )
    void
    )
  catch return result (
    on This result
    )
  error {//@stringU
  //CurlyBlock-Should be unreachable code
  }
  )
method 
This #plusplus(This that) (
  Void unused=(
    This res=this
    mut This.Varres varres=This.Varres.#apply(inner:res)
    Void unused0=(
      This.vals() e=that.vals()
      (
        Void unused2=(
          Void unused3=(
            Void unused4=loop (
              Void unused5=e.#next()
              catch exception unused6 (
                on Void (
                  Void unused7=(
                    Void unused8=e.#checkEnd()
                    catch exception unused9 (
                      on Void void
                      )
                    void
                    )
                  exception void
                  )
                )
              varres.inner(that:varres.#inner().#add(that:e.#inner()))
              )
            catch exception unused10 (
              on Void void
              )
            void
            )
          catch exception propagated (
            on Any (
              Void unused11=e.#close()
              exception propagated
              )
            )
          void
          )
        catch return propagated0 (
          on This (
            Void unused12=e.#close()
            return propagated0
            )
          )
        e.#close()
        )
      )
    Void unused1=return varres.#inner()
    void
    )
  catch return result (
    on This result
    )
  error {//@stringU
  //CurlyBlock-Should be unreachable code
  }
  )
class method 
This #begin() This.#apply()
method 
This #add(Library that) This._new(head:This.CellNext.#apply(elem:that, nextCell:this.head()))
method 
This #end() (
  This.#apply() res=This.#apply()
  mut This.Varres0 varres=This.Varres0.#apply(inner:res)
  Void unused=(
    This.vals() elem=this.vals()
    (
      Void unused0=(
        Void unused1=(
          Void unused2=loop (
            Void unused3=elem.#next()
            catch exception unused4 (
              on Void (
                Void unused5=(
                  Void unused6=elem.#checkEnd()
                  catch exception unused7 (
                    on Void void
                    )
                  void
                  )
                exception void
                )
              )
            varres.inner(that:varres.#inner().#add(that:elem.#inner()))
            )
          catch exception unused8 (
            on Void void
            )
          void
          )
        catch exception propagated (
          on Any (
            Void unused9=elem.#close()
            exception propagated
            )
          )
        void
        )
      catch return propagated0 (
        on Any (
          Void unused10=elem.#close()
          return propagated0
          )
        )
      elem.#close()
      )
    )
  varres.#inner()
  )
Cell:{interface 
method 
mut Outer1.Iterator vals(Outer3.Bool terminate) 
method 
This #next() exception Void 
method 
Library #inner() 
method 
Void #checkEnd() }
CellEnd:{ implements Outer1.Cell
class method 
This #apply() 
method vals(terminate ) Outer1.Iterator.#apply(that:this, terminate:terminate)
method #next() exception void
method #inner() error Outer3.S.#stringParser(that:{//@stringU
//InnerOnCellEnd, should not happen
})
method #checkEnd() void}
CellNext:{ implements Outer1.Cell
class method 
This #apply(Library^elem//@private @consistent
, Outer1.Cell^nextCell//@private @consistent
) 
mut method //@private @consistent
Library #elem() 
read method //@private @consistent
Library elem() 
mut method //@private @consistent
Outer1.Cell #nextCell() 
read method //@private @consistent
Outer1.Cell nextCell() 
method vals(terminate ) (
  Void unused=(
    This.#apply(elem nextCell ) startPoint=This.#apply(elem:this.elem(), nextCell:this)
    Void unused0=return Outer1.Iterator.#apply(that:startPoint, terminate:terminate)
    void
    )
  catch return result (
    on This.vals(terminate ) result
    )
  error {//@stringU
  //CurlyBlock-Should be unreachable code
  }
  )
method #next() this.nextCell()
method #inner() this.elem()
method #checkEnd() (
  This.#checkEnd() .this.nextCell() cell=this.nextCell()
  (
    This cell0=(
      Void unused=return cell
      catch return casted (
        on This casted
        
        on Any exception void
        )
      error {//@stringU
      //CastT-Should be unreachable code
      }
      )
    catch exception unused0 (
      on Void void
      )
    (
      Void unused1=error Outer3.S.#stringParser(that:{//@stringU
      //IterationNotComplete,\u000a  use valsCut() to allows incomplete iterations\u000a
      })
      void
      )
    )
  )}
Iterator:{
class method 
mut This #apply(Outer1.Cell^that//@private @consistent
, Outer3.Bool^terminate//@private @consistent
) 
mut method //@private @consistent
Void that(Outer1.Cell that) 
mut method //@private @consistent
Outer1.Cell #that() 
read method //@private @consistent
Outer1.Cell that() 
mut method //@private @consistent
Outer3.Bool #terminate() 
read method //@private @consistent
Outer3.Bool terminate() 
mut method 
Void #next() exception Void (
  Void unused=(
    This.that() .#next() x=this.that().#next()
    Void unused0=(
      Outer1.CellEnd x0=(
        Void unused2=return x
        catch return casted (
          on Outer1.CellEnd casted
          
          on Any exception void
          )
        error {//@stringU
        //CastT-Should be unreachable code
        }
        )
      catch exception unused3 (
        on Void void
        )
      (
        Void unused4=exception void
        void
        )
      )
    Void unused1=return this.that(that:x)
    void
    )
  catch return result (
    on Void result
    )
  error {//@stringU
  //CurlyBlock-Should be unreachable code
  }
  )
read method 
Void #checkEnd() (
  This.terminate() cond=this.terminate()
  (
    Void unused=cond.#checkTrue()
    catch exception unused0 (
      on Void void
      )
    this.that().#checkEnd()
    )
  )
read method 
Library #inner() this.that().#inner()
read method 
Void #close() void}}
class method 
This #apply() This.#apply(resolver:This.Resolver.#apply(), myLibs:This.Libs.#begin().#end())
method 
This #add(Library that) (
  This.myLibs() .#add(that ) ls=this.myLibs().#add(that:that)
  This.#apply(resolver:this.resolver(), myLibs:ls)
  )
method 
This #add(Library resolver) This.#apply(resolver:This.Resolver.#apply(that:resolver), myLibs:this.myLibs())
class method 
This #begin() This.#apply()
method 
This #end() this
method 
Library #left(Library that) (
  Void unused=(
    This.myLibs() .vals() it=this.myLibs().vals()
    Void unused0=it.#next()
    catch exception unused1 (
      on Void return that
      )
    (
      This.myLibs() .vals() .#inner() result=it.#inner()
      mut This.Varresult1 varresult=This.Varresult1.#apply(inner:result)
      Void unused2=(
        This.myLibs() .vals() libi=it
        (
          Void unused4=(
            Void unused5=(
              Void unused6=loop (
                Void unused7=libi.#next()
                catch exception unused8 (
                  on Void (
                    Void unused9=(
                      Void unused10=libi.#checkEnd()
                      catch exception unused11 (
                        on Void void
                        )
                      void
                      )
                    exception void
                    )
                  )
                varresult.inner(that:this.accumulate(l1:varresult.#inner(), l2:libi.#inner()))
                )
              catch exception unused12 (
                on Void void
                )
              void
              )
            catch exception propagated (
              on Any (
                Void unused13=libi.#close()
                exception propagated
                )
              )
            void
            )
          catch return propagated0 (
            on Library (
              Void unused14=libi.#close()
              return propagated0
              )
            )
          libi.#close()
          )
        )
      Void unused3=return this.accumulate(l1:varresult.#inner(), l2:that)
      void
      )
    )
  catch return result0 (
    on Library result0
    )
  error {//@stringU
  //CurlyBlock-Should be unreachable code
  }
  )
method 
Library accumulate(Library l1, Library l2) (
  Void unused=(
    Void unused0=return Outer1.IntrospectionPlugin.sumLib(l1:l1, l2:l2)
    catch error x (
      on Any (
        Void unused1=(
          This.resolver() .isPresent() .#bang() cond=this.resolver().isPresent().#bang()
          (
            Void unused5=cond.#checkTrue()
            catch exception unused6 (
              on Void void
              )
            error x
            )
          )
        Outer1.Introspection.#apply(that ) .methods() ms=Outer1.Introspection.#apply(that:this.resolver().#bang()).methods()
        Outer1.S _name=ms.pop().pop().top().name()
        Outer1.S _nameLeft=ms.pop().top().name()
        Outer1.S _nameRight=ms.top().name()
        Outer1.Name name=Outer1.Name.#stringParser(that:_name.binaryRepr())
        Outer1.Name nameLeft=Outer1.Name.#stringParser(that:_nameLeft.binaryRepr())
        Outer1.Name nameRight=Outer1.Name.#stringParser(that:_nameRight.binaryRepr())
        Outer1.Adapt.#begin() .#add(that into ) .#end() .#left(that ) l1A=Outer1.Adapt.#begin().#add(that:name, into:nameLeft).#end().#left(that:l1)
        Outer1.Adapt.#begin() .#add(that into ) .#end() .#left(that ) l2A=Outer1.Adapt.#begin().#add(that:name, into:nameRight).#end().#left(that:l2)
        Outer1.IntrospectionPlugin.sumLib(l1 l2 ) result=Outer1.IntrospectionPlugin.sumLib(l1:l1A, l2:l2A)
        mut This.Varresult2 varresult=This.Varresult2.#apply(inner:result)
        Void unused2=varresult.inner(that:Outer1.IntrospectionPlugin.sumLib(l1:this.resolver().#bang(), l2:varresult.#inner()))
        Void unused3=varresult.inner(that:Outer1.MakePrivate.#apply(that:nameLeft, into:varresult.#inner()))
        Void unused4=varresult.inner(that:Outer1.MakePrivate.#apply(that:nameRight, into:varresult.#inner()))
        return varresult.#inner()
        )
      )
    void
    )
  catch return result0 (
    on Library result0
    )
  error {//@stringU
  //CurlyBlock-Should be unreachable code
  }
  )
method 
This #plusplus(This that) (
  Void unused=(
    This.myLibs() .#plusplus(that ) list=this.myLibs().#plusplus(that:that.myLibs())
    This.Resolver res=(
      Void unused1=(
        Void unused2=(
          This.resolver() .isPresent() cond=that.resolver().isPresent()
          (
            Void unused4=cond.#checkTrue()
            catch exception unused5 (
              on Void void
              )
            return that.resolver()
            )
          )
        Void unused3=return this.resolver()
        void
        )
      catch return result0 (
        on This.Resolver result0
        )
      error {//@stringU
      //CurlyBlock-Should be unreachable code
      }
      )
    Void unused0=return This.#apply(resolver:res, myLibs:list)
    void
    )
  catch return result (
    on This result
    )
  error {//@stringU
  //CurlyBlock-Should be unreachable code
  }
  )}
Adapt:{
class method //@private
This #apply(Library^adapter//@private @consistent
) 
mut method //@private @consistent
Library #adapter() 
read method //@private @consistent
Library adapter() 
class method 
This #apply() This.#apply(adapter:{})
method 
This #add(Outer1.Name that, Outer1.Name into) (
  Void unused=(
    Void unused0=(
      Outer1.Name.isExternalPathName() cond=that.isExternalPathName()
      (
        Void unused3=cond.#checkTrue()
        catch exception unused4 (
          on Void void
          )
        error Outer1.S.#stringParser(that:{//@stringU
        //start name must be internal
        })
        )
      )
    Void unused1=(
      Outer1.Name.isInternalPathName() .#bang() cond0=that.isInternalPathName().#bang()
      (
        Void unused5=cond0.#checkTrue()
        catch exception unused6 (
          on Void void
          )
        return this.#add(that:that, of:Outer1.Name.#stringParser(that:{//@stringU
        //This
        }), into:into)
        )
      )
    Outer1.IntrospectionPlugin.adaptLib(l1 l2 ) map=Outer1.IntrospectionPlugin.adaptLib(l1:into.adapter(), l2:that.adapter())
    Outer1.IntrospectionPlugin.sumLib(l1 l2 ) lib=Outer1.IntrospectionPlugin.sumLib(l1:this.adapter(), l2:map)
    Void unused2=return This.#apply(adapter:lib)
    void
    )
  catch return result (
    on This result
    )
  error {//@stringU
  //CurlyBlock-Should be unreachable code
  }
  )
method 
This #add(Outer1.Name that, Outer1.Name of, Outer1.Name into) (
  Void unused=(
    Outer1.IntrospectionPlugin.adaptLib(l1 l2 ) map1=Outer1.IntrospectionPlugin.adaptLib(l1:into.adapter(), l2:that.adapter())
    Outer1.IntrospectionPlugin.adaptLib(l1 l2 ) map2=Outer1.IntrospectionPlugin.adaptLib(l1:map1, l2:of.adapter())
    Outer1.IntrospectionPlugin.sumLib(l1 l2 ) lib=Outer1.IntrospectionPlugin.sumLib(l1:this.adapter(), l2:map2)
    Void unused0=return This.#apply(adapter:lib)
    void
    )
  catch return result (
    on This result
    )
  error {//@stringU
  //CurlyBlock-Should be unreachable code
  }
  )
class method 
This #begin() This.#apply()
method 
This #end() this
method 
This #plusplus(This that) (
  Outer1.IntrospectionPlugin.sumLib(l1 l2 ) lib=Outer1.IntrospectionPlugin.sumLib(l1:this.adapter(), l2:that.adapter())
  This.#apply(adapter:lib)
  )
method 
Library #left(Library that) Outer1.IntrospectionPlugin.adaptLib(l1:that, l2:this.adapter())}
MakePrivate:{
class method 
Library #apply(Outer1.Name that, Library into) (
  Void unused=(
    Void unused0=(
      Outer1.Name.isExternalPathName() cond=that.isExternalPathName()
      (
        Void unused3=cond.#checkTrue()
        catch exception unused4 (
          on Void void
          )
        error Outer1.S.#stringParser(that:{//@stringU
        //start name must be internal
        })
        )
      )
    Void unused1=(
      Outer1.Name.isInternalPathName() .#bang() cond0=that.isInternalPathName().#bang()
      (
        Void unused5=cond0.#checkTrue()
        catch exception unused6 (
          on Void void
          )
        return This.#apply(that:that, of:Outer1.Name.#stringParser(that:{//@stringU
        //This
        }), into:into)
        )
      )
    Outer1.IntrospectionPlugin.sumComment(that comment adapter ) res=Outer1.IntrospectionPlugin.sumComment(that:into, comment:{//@private      
    }, adapter:that.adapter())
    Outer1.Name.#apply(adapter ) fName=Outer1.Name.#apply(adapter:Outer1.IntrospectionPlugin.getFreshName(that:that.adapter()))
    Void unused2=return Outer1.Adapt.#begin().#add(that:that, into:fName).#end().#left(that:res)
    void
    )
  catch return result (
    on Library result
    )
  error {//@stringU
  //CurlyBlock-Should be unreachable code
  }
  )
class method 
Library #apply(Outer1.Name that, Outer1.Name of, Library into) (
  Void unused=(
    Outer1.IntrospectionPlugin.adaptLib(l1 l2 ) pName=Outer1.IntrospectionPlugin.adaptLib(l1:that.adapter(), l2:of.adapter())
    Outer1.IntrospectionPlugin.sumComment(that comment adapter ) res=Outer1.IntrospectionPlugin.sumComment(that:into, comment:{//@private      
    }, adapter:pName)
    Outer1.Name.#apply(adapter ) fName=Outer1.Name.#apply(adapter:Outer1.IntrospectionPlugin.getFreshName(that:that.adapter()))
    Void unused0=return Outer1.Adapt.#begin().#add(that:that, of:of, into:fName).#end().#left(that:res)
    void
    )
  catch return result (
    on Library result
    )
  error {//@stringU
  //CurlyBlock-Should be unreachable code
  }
  )}
Data:{
Vardecorator:{
class method 
mut This #apply(Outer2.Use.#begin() .#end() ^inner//@private @consistent
) 
mut method //@private @consistent
Void inner(Outer2.Use.#begin() .#end() that) 
mut method //@private @consistent
Outer2.Use.#begin() .#end() #inner() }
Varaccumulator:{
class method 
mut This #apply(Outer2.Use.#begin() ^inner//@private @consistent
) 
mut method //@private @consistent
Void inner(Outer2.Use.#begin() that) 
mut method //@private @consistent
Outer2.Use.#begin() #inner() }
class method 
This #apply() 
class method 
This #begin() This.#apply()
method 
This #end() this
method 
Library #left(Library that) Outer1.Use.#begin().#add(that:this.addEquals(l:that)).#end().#left(that:that)
method 
Library equalsOnField(Outer1.Name c, Outer1.Name n) Outer1.Adapt.#begin().#add(that:Outer1.Name.#stringParser(that:{//@stringU
//T
}), into:c).#add(that:Outer1.Name.#stringParser(that:{//@stringU
//f
}), into:n).#end().#left(that:{
T:{
method 
Outer3.Bool #equalequal(Any that) }
read method 
This.T f() 
method 
Outer2.Bool current(This that) this.f().#equalequal(that:that.f())})
method 
Library addEquals(Library l) (
  Void unused=(
    Outer1.Use.#begin() .#end() decorator=(
      Outer1.Use.#begin() accumulator=Outer1.Use.#begin()
      mut This.Varaccumulator varaccumulator=This.Varaccumulator.#apply(inner:accumulator)
      Void unused2=(
        Outer1.Introspection.#apply(that ) .fields() .vals() field=Outer1.Introspection.#apply(that:l).fields().vals()
        (
          Void unused3=(
            Void unused4=(
              Void unused5=loop (
                Void unused6=field.#next()
                catch exception unused7 (
                  on Void (
                    Void unused8=(
                      Void unused9=field.#checkEnd()
                      catch exception unused10 (
                        on Void void
                        )
                      void
                      )
                    exception void
                    )
                  )
                varaccumulator.inner(that:varaccumulator.#inner().#add(that:this.equalsOnField(c:field.#inner().class(), n:Outer1.Name.#stringParser(that:field.#inner().name().binaryRepr()))))
                )
              catch exception unused11 (
                on Void void
                )
              void
              )
            catch exception propagated (
              on Any (
                Void unused12=field.#close()
                exception propagated
                )
              )
            void
            )
          catch return propagated0 (
            on Library (
              Void unused13=field.#close()
              return propagated0
              )
            )
          field.#close()
          )
        )
      varaccumulator.#inner().#end()
      )
    mut This.Vardecorator vardecorator=This.Vardecorator.#apply(inner:decorator)
    Void unused0=vardecorator.inner(that:vardecorator.#inner().#plusplus(that:Outer1.Use.#begin().#add(resolver:{
    method 
    Outer2.Bool current(This that) this.left(that:that).#and(that:this.right(that:that))
    method 
    Outer2.Bool left(This that) 
    method 
    Outer2.Bool right(This that) }).#end()))
    Outer1.Use.#begin() .#end() .#left(that ) result=vardecorator.#inner().#left(that:{
    method 
    Outer2.Bool current(This that) 
    method 
    Outer2.Bool #equalequal(Any that) (
      Void unused=(
        Void unused0=(
          This that0=(
            Void unused1=return that
            catch return casted (
              on This casted
              
              on Any exception void
              )
            error {//@stringU
            //CastT-Should be unreachable code
            }
            )
          catch exception unused2 (
            on Void return Outer2.Bool.false()
            )
          (
            Void unused3=return this.current(that:that0)
            void
            )
          )
        void
        )
      catch return result (
        on Outer2.Bool result
        )
      error {//@stringU
      //CurlyBlock-Should be unreachable code
      }
      )})
    Void unused1=return Outer1.MakePrivate.#apply(that:Outer1.Name.#stringParser(that:{//@stringU
    //current(that)
    }), into:result)
    void
    )
  catch return result0 (
    on Library result0
    )
  error {//@stringU
  //CurlyBlock-Should be unreachable code
  }
  )}}