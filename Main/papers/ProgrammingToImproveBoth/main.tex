\AtBeginDocument{\paperdetails{
		submitted=2018-10-01,
		published=2019-02-01,
		year=2019,
		volume=3,
		issue=3,
		articlenumber=12,
}}
\documentclass[english]{programming}
\usepackage[backend=biber]{biblatex} % Use Biblatex
\addbibresource{main.bib}
\usepackage{mathpartir}
\usepackage{amsmath}
\usepackage{amsthm}
%\usepackage[normalem]{ulem}
\usepackage{wrapfig}
\theoremstyle{plain}
\newcounter{definition}
\newtheorem{Definition}[definition]{Definition}
\newcounter{assumption}
\newtheorem{Assumption}[assumption]{Assumption}
\newcounter{lemma}
\newtheorem{Lemma}[lemma]{Lemma}
\input{LocalDef}
\begin{document}
\paperdetails{
perspective=theoretical,
area={Type systems}
}
%\title{Validation}
\title{Separating Use and Reuse to Improve Both}
%\author{Authors omitted for double-blind review.}

\author{Hrshikesh Arora}
\author{Marco Servetto}
%\affiliation{Victoria University of Wellington}
%\email{marco.servetto@ecs.vuw.ac.nz}
\affiliation{Victoria University of Wellington}
%\email{alex@ecs.vuw.ac.nz}
\author{Bruno C. d. S. Oliveira}
\affiliation{The University of Hong Kong}
\keywords{trait composition,subtyping,code reuse}

\begin{CCSXML}
<ccs2012>
	<concept>
		<concept_id>10003752.10010124.10010138.10010139</concept_id>
		<concept_desc>Theory of computation~Invariants</concept_desc>
		<concept_significance>500</concept_significance>
	</concept>
	<concept>
		<concept_id>10003752.10010124.10010138.10010142</concept_id>
		<concept_desc>Theory of computation~Program verification</concept_desc>
		<concept_significance>500</concept_significance>
	</concept>
	<concept>
		<concept_id>10011007.10011006.10011008.10011009.10011011</concept_id>
		<concept_desc>Software and its engineering~Object oriented languages</concept_desc>
		<concept_significance>500</concept_significance>
	</concept>
	<concept>
		<concept_id>10011007.10010940.10010992.10010998.10011001</concept_id>
		<concept_desc>Software and its engineering~Dynamic analysis</concept_desc>
		<concept_significance>300</concept_significance>
	</concept>
	<concept>
		<concept_id>10011007.10011006.10011008.10011024.10011032</concept_id>
		<concept_desc>Software and its engineering~Constraints</concept_desc>
		<concept_significance>300</concept_significance>
	</concept>
</ccs2012>
\end{CCSXML}

\ccsdesc[500]{Theory of computation~Formalism}
\ccsdesc[500]{Software and its engineering~Object oriented languages}
\ccsdesc[300]{Software and its engineering~Designing software}
\ccsdesc[300]{Software and its engineering~Formal language definitions}

\maketitle

\begin{abstract}
\textit{Context:} % What is the broad context of the work? What is the importance of the general research area?
Trait composition has inspired new research in the area of code reuse for object oriented (OO) languages.
One of the main advantages of this kind of composition is that 
it makes possible to separate subtyping from subclassing; 
which is good for code-reuse, design and reasoning~\cite{cook}.
%%For example, some works on trait composition allow renaming of methods, which breaks structural subtyping.
However, handling of state within traits is difficult, verbose or inelegant.


\textit{Inquiry:} %What problem or question does the paper address? How has this problem or question been addressed by others (if at all)?
We identify the 
\emph{this-leaking problem} as the fundamental limitation that
prevents the separation of subtyping from subclassing
in conventional OO languages. We explain that the concept of trait composition addresses this problem,
by distinguishing code designed for use (as a type)
from code designed for reuse (i.e. inherited).
We are aware of at least $3$ concrete independently designed research
languages following this methodology: TraitRecordJ~\cite{Bettini:2010:ISP:1774088.1774530},
Package Templates~\cite{KrogdahlMS09}
and DeepFJig~\cite{deep}.


\textit{Approach:} %What was done that unveiled new knowledge?
In this paper, we design \name, a new language, where
we improve use and reuse and support the \Q@This@ type and family polymorphism
 by distinguishing code designed for use
from code designed for reuse.
In this way 
\name synthesise the 3 approaches above, and improves them with \emph{abstract state operations}:
a new elegant way to handle state composition in trait based languages.


\textit{Knowledge and Grounding:}
%What new facts were uncovered? If the research was not results oriented, what new capabilities are enabled by the work?
%What argument, feasibility proof, artifacts, or results and evaluation support this work?
Using case studies, we show that \name's model of traits with abstract state operations
 is more usable and compact than prior work.
We formalise our work and prove that type errors cannot arise from composing well typed code.


\textit{Importance:} %Why does this work matter?
This work is the logical core of the programming language 42. This shows that 
the ideas presented in this paper can be applicable to a full general purpose language.
This form of composition is very flexible and could be used in many new languages.


%show that subtyping can be added after the fact
%if the User/A/B example was to show a case where subyping is bad it could be stronger
%
	
\end{abstract}
\input{Intro}
\input{section2}
\input{section3}
\input{section4}
\input{Extensions}
\input{RelatedWork}
\input{Conclusion}

\printbibliography
\input{appendix}
\end{document}