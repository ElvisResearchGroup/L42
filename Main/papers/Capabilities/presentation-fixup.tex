%% LyX 2.3.1 created this file.  For more info, see http://www.lyx.org/.
%% Do not edit unless you really know what you are doing.
\documentclass[t,11pt,twoside,british,handout]{beamer}
\usepackage{amstext}
\usepackage{xpatch}
%\usepackage{showframe}
%2.85cm
%2.54cm
%\usepackage{layout}
\usepackage{amssymb}
\usepackage{fontspec}
\usepackage{unicode-math}
\setmainfont[Mapping=tex-text]{TeX Gyre Schola}
\setsansfont[Scale=0.91,Mapping=tex-text]{Segoe UI}
\setmonofont[Scale=0.95]{Consolas}
\setcounter{secnumdepth}{3}
\setcounter{tocdepth}{3}
\setlength{\parskip}{\medskipamount}
\setlength{\parindent}{0pt}
\usepackage{endnotes}

\makeatletter

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% LyX specific LaTeX commands.
\pdfpageheight\paperheight
\pdfpagewidth\paperwidth


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Textclass specific LaTeX commands.
% this default might be overridden by plain title style
\newcommand\makebeamertitle{\frame{\maketitle}}%
% (ERT) argument for the TOC
\AtBeginDocument{%
  \let\origtableofcontents=\tableofcontents
  \def\tableofcontents{\@ifnextchar[{\origtableofcontents}{\gobbletableofcontents}}
  \def\gobbletableofcontents#1{\origtableofcontents}
}
\let\footnote=\endnote

\@ifundefined{date}{}{\date{}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% User specified LaTeX commands.
\usepackage{xcolor}
%\usepackage{scrlayer-scrpage}

%\newcommand{\lfoot}[1]{\ifoot{\textnormal{#1}}}
%\newcommand{\rfoot}[1]{\ofoot{\textnormal{#1}}}

\definecolor{AccentB80}{RGB}{197, 213, 255}
\definecolor{AccentB60}{RGB}{139, 171, 255}
\definecolor{AccentB40}{RGB}{81,  130, 255}
\definecolor{Accent}   {RGB}{0,   63,  221}
\definecolor{AccentD25}{RGB}{0,   46,  165}
\definecolor{AccentD50}{RGB}{0,   31,  110}

%\renewcommand\Huge{\@setfontsize\Huge{10pt}{26}} % Was 25?
%\renewcommand\Large{\@setfontsize\Large{10pt}{14}} % Was 14?
%\large	 10.5 % was 11?
%\newcommand{\StyleTitle}[1]{{\Huge{\textcolor{Accent}{{#1}}}}} % Expanded +0.5pt
%\newcommand{\StyleSubTitle}[1]{{\large{\textcolor{AccentB40}{{#1}}}\medskip}} % 25pt after , Expanded +0.5pt
%\renewcommand{\maketitle}{\StyleTitle{\@title}\\\StyleSubTitle{\@author}}
\newcommand{\zwnbsp}{}
%\renewcommand{\ensuremath}[1]{#1}

%\renewcommand{\thanks}[1]{\footnote{#1}}
\definecolor{blue}{HTML}{0000F0} % 
\definecolor{purple}{HTML}{700090}
\definecolor{orange}{HTML}{F07000}
\definecolor{teal}{HTML}{0090B0}
\definecolor{brown}{HTML}{A00000}
\definecolor{green}{HTML}{008000}
\definecolor{pink}{HTML}{F000F0}
\usecolortheme[named=pink]{structure}

\setbeamercolor{title}{fg=Accent}
\setbeamerfont{title}{size=\Huge}

\setbeamercolor{local structure}{fg=black}
\setbeamerfont{local structure}{size=\normalsize}
\setbeamertemplate{itemize item}{•}
\setbeamertemplate{itemize subitem}{◦}

\setlength{\labelsep}{0.63cm}
\setlength{\topsep}{0cm}
\setlength{\leftmargini}{0.63cm}
\setlength{\leftmarginii}{\leftmargini}
\newcommand{\linebox}[1]{%
	\parbox{\textwidth}{\rule{0cm}{1em}\strut\smash{#1}\strut}}

\xpatchcmd{\itemize}{\def\makelabel}{% Configure inside itemize
	\setlength{\topsep}{0pt}%
	\setlength{\itemsep}{0pt}%
	\def\makelabel}{}{}
\xpatchcmd{\itemize}{\llap}{\rlap}{}{}
\xpatchcmd{\beamer@enum@}{\llap}{\rlap}{}{}
\setbeamertemplate{itemize/enumerate body begin}{\parj}
\setbeamerfont{itemize/enumerate subbody}{size=\small}
\setbeamertemplate{itemize/enumerate body end}{\pars}
	
					\newlength{\heightofhw}%
\setbeamercolor{author}{fg=AccentB40}
\setbeamerfont{author}{size=\large}
\setbeamerfont{institute}{size=\normalsize}

\setbeamerfont{frametitle}{size=\Large} % 14pt
\setbeamercolor{frametitle}{fg=AccentD50}
\newlength{\parprefix}
\setbeamertemplate{frametitle}{%
	\begin{beamercolorbox}{frametitle}%
		\usebeamerfont{frametitle}%
		{\color{AccentD25} \hrule height 0.75pt \vspace{3pt} \hrule height 1.5pt}%
		\setlength{\fboxsep}{0pt}%
		\colorbox{AccentB60}{\linebox{\insertframetitle}}%
		{\color{AccentD25} \hrule height 1.5pt \vspace{3pt} \hrule height 0.75pt}%
	\end{beamercolorbox}}

%\usepackage{enumitem}
%\setlist{nolistsep}

\usepackage{fontspec} % To set xetex fonts
\setmainfont[Ligatures={Common, Discretionary}]{TeX Gyre Schola}
\setmonofont[Ligatures={Discretionary}, Scale=0.9545454545454545]{Consolas} % 10.5/11
\setsansfont[Ligatures={Discretionary}, Scale=0.9090909090909091]{Segoe UI} %10/11

\unimathsetup{math-style=ISO}
\setmathfont{TeX Gyre Schola Math}

\newcommand{\parj}{\setlength{\parskip}{0pt}}
\newcommand{\pars}{\setlength{\parskip}{\medskipamount}}
%\newcommand{\parj}{}
%\newcommand{\pars}{}
%\usepackage[para]{footmisc}
\usepackage{hyperref}

\hypersetup{colorlinks,urlcolor=[RGB]{0, 155, 240}}
\newcommand{\email}[1]{%
	\href{mailto:#1}{\texttt{#1}}
}
\raggedright
\usepackage{soul}
\newcommand{\comment}[1]{\note{\hl{#1}}}
\usefonttheme{professionalfonts}
%\setbeameroption{show notes on second screen}

\newcommand{\heading}[1]{%
	%3       Blue    /12pt   Blue    /1pt    +0.75pt
	{\vspace{5pt}\color{Accent}%
	\linebox{\large #1}%
	\hrule height 1pt}}

\beamertemplatenavigationsymbolsempty

\setbeamersize{text margin left=1.3333333333333333cm, text margin right=1.3333333333333333cm} % default is 1cm*1cm
\setbeamersize{sidebar width left=0pt, sidebar width right=0pt}
\geometry{papersize={16cm,12cm}, vmargin=1.3333333333333333cm}

%\newcommand{\StyleTitle}[1]{{\Huge{\textcolor{Accent}{{#1}}}}} % Expanded +0.5pt
%\newcommand{\StyleSubTitle}[1]{{\large{\textcolor{AccentB40}{{#1}}}\medskip}} % 25pt after , Expanded +0.5pt

%\geometry{ignoreall, vdivide={1.3333333333333cm, *, 6cm}}

%\geometry{
%	offset={1cm, 1cm},
%	hdivide={1.3333333333333333cm,  *, 1.3333333333333333cm},
%	vdivide={-1cm, *, -5.6666666666666666cm},
%	verbose,papersize={16cm,12cm} , noheadfoot, nomarginpar
%\geometry{reset, papersize={16cm,12cm}, 
%	tmargin=1.3333333333333333cm, % distance between top and body?
%	bmargin=1.3333333333333333cm, % Not working!
	%lmargin=2.54cm,
%	rmargin=2.54cm,
%	headheight=0.7cm,
%	headsep=0.7cm,
%	  hmargin=2.666666666666cm,%
%vmargin={-1.333333cm,-1.33333333cm},%
%head=0.5cm,% might be changed later
%headsep=0pt,%
%foot=5cm% might be changed later} % (4:3)*4cm scale, default is (4:3)*3cm


\makeatother

\usepackage{polyglossia}
\setdefaultlanguage[variant=british]{english}
\begin{document}
%	\layout
\title{Callability Control}
\author{By Isaac Oscar Gariano\textsuperscript{1} and Marco Servetto\textsuperscript{2}}
\institute{(Victoria University of Wellington)}

\makebeamertitle
\global\long\def\empty{\zwnbsp}%

\global\long\def\k#1{\textcolor{blue}{\texttt{#1}}}%
\global\long\def\t#1{\textcolor{teal}{#1}}%
\global\long\def\f#1{\textcolor{purple}{#1}}%
\global\long\def\l#1{\textcolor{brown}{#1}}%
\global\long\def\v#1{\textcolor{orange}{#1}}%
\global\long\def\m#1{\textcolor{green}{#1}}%

\global\long\def\c#1{\texttt{#1}}%
\global\long\def\ck#1{\c{\k{#1}}}%
\global\long\def\ct#1{\c{\t{#1}}}%
\global\long\def\cf#1{\c{\f{#1}}}%
\global\long\def\cv#1{\c{\v{#1}}}%
\global\long\def\cm#1{\c{\m{#1}}}%
\global\long\def\cl#1{\c{\l{#1}}}%

\global\long\def\tab{\texttt{\ \ \ \ }}%

\global\long\def\calls#1{\ck{calls[}#1\ck ]}%

\begin{frame}{Conventions}

We will consider C♯, since it
\begin{itemize}
\item is statically-typed,
\item supports named/identifiable functions (such as static/instance methods
or constructors),
\item supports dynamic dispatch (with interfaces, virtual methods, etc.),
\item supports dynamic code loading, and
\item supports dynamic function lookup and invocation (with reflection).
\end{itemize}
For brevity I will omit accessibility modifiers and allow free standing
static functions.
\end{frame}
%
\begin{frame}[<+->]{The Problem}
\begin{enumerate}
\item What \emph{could} this code do?

$\texttt{\ensuremath{\ck{static}} \ensuremath{\ck{void}} \ensuremath{\cf{M1(}\cf )} \{ \ensuremath{\cf{Abs(}\cl 0\cf )}; \}}$

\note{Well it looks like it does nothing, it just gets the absolute value
of 0 (which is 0) and discards the result. But how do we know Abs
won’t send sensitive information to a third-party?\comment{ I prefered my Russia version… }Well
the documentation dosn’t say it will, and we trust the implementer,
Microsoft, to follow it. But, if we didn’t trust it, what could we
do?}
\item What about this, what \emph{could} it do?

\comment{Note: I am now using a user-defined interface, so that I can freely
play with it’s declaration }

$\texttt{\ensuremath{\ck{interface}} \ensuremath{\ct I} \{ \ensuremath{\ck{void}} \ensuremath{\cf{Run()}}; \}}$

$\texttt{\ensuremath{\ck{static}} \ensuremath{\ck{void}} \ensuremath{\cf{M2(}\ct I} \ensuremath{\cv x\cf )} \{ \ensuremath{\cv x}.\ensuremath{\cf{Run()}}; \}}$

\note{This one can do anything the language will let it, so it is likely
to be memory and type safe. However it can still do all sorts of stuff,
like perform I/O or use reflection to inspect and invoke arbitrary
code. The reason why we don’t know what this can do is that I.Run,
is a virtual method, this means that it is dynamically dispatched
and in this case, literally anyone can override it. So we have to
trust the writer of every class that x could be at run-time.}
\item How about this?

$\texttt{\ensuremath{\ck{static}} \ensuremath{\ck{void}} \ensuremath{\cf{M3(}\ct{String}} \ensuremath{\cv{url}\cf )} \{}$

$\texttt{\ensuremath{\tab\ct{Assembly}} \ensuremath{\cv{code}} = \ensuremath{\ct{Assembly}}.\ensuremath{\cf{LoadFrom(}\cv{url}\cf )}; \ensuremath{\cm{// Load code (possibly from the internet)}}}$

$\texttt{\ensuremath{\tab\cv{\cv{code}.\cf{GetMethod(}\cl{"M"}\cf )}}.\ensuremath{\cf{Invoke(}\ck{null}}, \ensuremath{\ck{null}\cf )}; \} \ensuremath{\cm{// call \cf{M()}}}}$

\note{This is very problematic, url could refer to code written by anyone,
it might not have even been written yet when M3 was written. So we
cannot inspect the code or simply trust their authors.}
\end{enumerate}
\end{frame}
%
\begin{frame}{Callability}
\begin{itemize}
\item \emph{Callability} is the \emph{ability} to \emph{call} a function.
\item A function's callability is the set of things it can call.
\end{itemize}
\note{We will abstract away performing an ‘operation’ (such as reading a
file, create a new object, doing integer addition etc) as calling
a named function In this way we can look at a functions callability
to constrain what a function can do. /{*} Improve: For example if
it only has the ability to call functions we know wont read from the
file system, then we know it wont.{*}/}

\pause{}

\heading{Restatement of the Problem: }
\begin{enumerate}
\item What is the callability of $\cf{Abs}$? (Where $\cf{Abs}$is a static
method)
\item What is the callability of $\cv x.\cf{Run}$? (Where $\cv x$ is of
an interface type $\ct I$)
\item What is the callability of $\cf M$? (Where $\cf M$ was a dynamically
loaded static-method)
\end{enumerate}
\note{We will present a system that can answer these questions by constraining
their callabilities.}
\end{frame}
%
\begin{frame}{The Basics}

\heading{The $\calls{\f{\f f}_{\l 1},\dots,\f f_{\l n}}$ annotation}

\note{A function declaration can be suffixed with it, indicating that it
can call f, …, fn.}
\begin{exampleblock}{Example}

$\texttt{\ensuremath{\ck{static}} \ensuremath{\ck{void}} \ensuremath{\cf{Main(}\ct{String[]}} \ensuremath{\cv{argv}\cf )} \ensuremath{\calls{\cf{WriteLine}}} \{}$

$\texttt{\ensuremath{\tab\cf{WriteLine(}\cl{"Hello World!"}\cf )}; \}}$
\end{exampleblock}
\note{At first glance this looks like we have to list every single function
we want to call, however this is not what the annotation means, rather
it is the starting point of functions that can be called. In addition,
the system can in principle infer these annotations, but we will write
them out explicitly to aid explanation.}

\pause{}

\heading{The Can-Call Relation: }

\note{As part of typechecking, whenever their is a call to g from within
the body of a function f, we will check that f 'can call' g.}

$\f f\rightsquigarrow\f g$, i.e. a function $\f f$can call a function
$\f g$, iff:

\pause{}
\begin{enumerate}
\item $\f g\in Calls(\f f)\Rightarrow\f f\rightsquigarrow\f g$, i.e. $\f g$
is in the $\calls{\ldots}$ annotation of $\f f$.

\note{this is exactly what the calls annotation means}
\begin{exampleblock}{Example}

$\texttt{\ensuremath{\ck{static}} \ensuremath{\ck{void}} \ensuremath{\cf{Write(}\ct{String}} \ensuremath{\cv s\cf )} \ensuremath{\calls{\cf{WriteChar}}} \{}$

$\texttt{\ensuremath{\tab\ck{foreach (}\ct{Char}} \ensuremath{\cv c} \ensuremath{\ck{in}} \ensuremath{\cv s\ck )} \ensuremath{\cf{WriteChar(}\cv c\cf )}; \}}$
\end{exampleblock}
\end{enumerate}

\pause{}
\begin{enumerate}
\item $\forall\f h\in Calls(\f f)\bullet\f f\rightsquigarrow\f h)\Rightarrow\f f\rightsquigarrow\f g$,
i.e. if $\f f$ can call every function in the $\calls{\ldots}$ annotation
of $\f g$.

\note{this makes sense, since you could have just inlined the body of g,
so you're not really gaining any power. Note that if calls(f) is empty,
that this vacously holds}
\begin{exampleblock}{Example}

$\texttt{\ensuremath{\ck{static}} \ensuremath{\ck{void}} \ensuremath{\cf{WriteLine(}\ct{String}} \ensuremath{\cv s\cf )} \ensuremath{\calls{\cf{WriteChar}}} \{}$

$\texttt{\ensuremath{\tab\cf{Write(}\v s} \ensuremath{\cf +} \ensuremath{\cl{"\backslash n"}\cf )}; \}}$
\end{exampleblock}
\end{enumerate}

\pause{}

Note that the previous rules apply transitively, and always allow
for recursive calls.
\begin{exampleblock}{Example}

$\texttt{\ensuremath{\ck{static}} \ensuremath{\ck{void}} \ensuremath{\cf{HelloWorld(}\cf )} \ensuremath{\calls{\cf{WriteLine}}} \{}$

$\texttt{\ensuremath{\tab\cf{\cf{WriteLine(}}\cl{"Hello World!"}\cf )}; \}}$

$\texttt{\ensuremath{\ck{static}} \ensuremath{\ck{void}} \ensuremath{\cf{Main(}\ct{String[]}} \ensuremath{\v{args}\cf )} \ensuremath{\calls{\cf{WriteChar}}} \{}$

$\texttt{\ensuremath{\tab\cf{HelloWorld()}}; \}}$
\end{exampleblock}
\comment{TODO: Have an example for recursion?}
\end{frame}
%
\begin{frame}{Restricting Primitive Operations}

To simplify things we will assume that the language provides only
two intrinsic functions, $\cf{UnrestrictedPrimitive}$ and $\cf{RestrictedPrimitive}$.

\note{The idea being that we don’t care who can call UnrestrictedPrimitive,
but we do care about RestrictedPrimitive.}

\pause{}
\begin{enumerate}
\item $\cf{UnrestrictedPrimitive}$ can be called by any function:

$\texttt{\ensuremath{\ck{static}} \ensuremath{\ct{Object}} \ensuremath{\cf{UnrestrictedPrimitive(}\ct{String}} \ensuremath{\cv{op}}, \ensuremath{\ck{params}} \ensuremath{\ct{Object[]}} \ensuremath{\cv{args}\cf )} \ensuremath{\ck{calls[]}};}$

$\texttt{\ensuremath{\cm{// Example:}} \ensuremath{\cf{UnrestrictedPrimitive(}\cl{"Add"}}, \ensuremath{\cl 1}, \ensuremath{\cl 2\cf )}; \ensuremath{\cm{// Returns \cl 3}}}$

\note{The params keyword just makes the function work as a varaidic. Since
Rule 2 vacously applys.}
\end{enumerate}

\pause{}
\begin{enumerate}
\item $\cf{RestrictedPrimitive}$ can only be (directly) called by functions
annotated with $\calls{\cf{RestrictedPrimitive},\ldots}$:

$\texttt{\ensuremath{\ck{static}} \ensuremath{\ct{Object}} \ensuremath{\cf{RestrictedPrimitive(}\ct{String}} \ensuremath{\cv{op}}, \ensuremath{\ck{params}} \ensuremath{\ct{Object[]}} \ensuremath{\cv{args}\cf )} \ensuremath{\ck{calls[\f{RestrictedPrimitive}]}};}$

$\texttt{\ensuremath{\cm{// Example:}} \ensuremath{\cf{RestrictedPrimitive(}\cl{"CCall"}}, \ensuremath{\cl{"puts"}}, \ensuremath{\cl{"Hello World!"}\cf )}; \ensuremath{\cm{// Prints \cl{Hello} \cl{World!}}}}$

\note{RestrictedPrimitive would model VM primitives like reflection as well
as calling trusted foreign functions. We could also allow RestrictedPrimitive
to perform unsafe operations, such as executing arbitrary machine
code, however than we would need to be extra carefull that any code
that can call RestrictedPrimitive dosn’t use it to violate invariants
of the language such as bypassing our callability system.}

\note{Declaring RestrictedPrimitive as calling itself isn't necessary to
allow recursive calls. Instead it has the effect of allowing only
those explicitly declared to call it from calling it, effectively
disabling rule 2. The same approach can be used to create other restricted
functions.}
\end{enumerate}
\end{frame}
%
\begin{frame}{The Solution to Problem 1 (Static Dispatch) }

What can $\cf{Abs(}\cl 0\cf )$ do?

\note{To answer this question, we will have to look at the declaration of
Abs(0) for its calls annotation, consider the following possibilities:}

\pause{}
\begin{enumerate}
\item (indirectly) perform only $\cf{UnrestrictedPrimitive}$ operations:

$\texttt{\ensuremath{\ck{static}} \ensuremath{\ct{Int32}} \ensuremath{\cf{Abs(}\ct{Int32}} \ensuremath{\cv x\cf )} \ensuremath{\ck{calls[]}} \{…\}}$

\note{this is probably what you’d want for an Abs function, it could do
arithmetic negation and comparison, but not restricted operations
like I/O.}

\pause{}
\item also (indirectly) perform some $\f{\cf{RestrictedPrimitive}}$ operations: 

$\texttt{\ensuremath{\ck{static}} \ensuremath{\ck{void}} \ensuremath{\cf{WriteLine(}\ct{String}} \ensuremath{\cv s\cf )} \ensuremath{\ck{calls[\cf{RestrictedPrimitive}]}} \{}$

$\texttt{\ensuremath{\tab\cf{RestrictedPrimitive(}\cl{"CCall"}}, \ensuremath{\cl{"puts"}}, \ensuremath{\cv s\cf )}; \}}$

$\texttt{\ensuremath{\ck{static}} \ensuremath{\ct{Int32}} \ensuremath{\cf{Abs(}\ct{Int32}} \ensuremath{\cv x\cf )} \ensuremath{\ck{calls[\cf{WriteLine}]}} \{…\}}$

\note{By looking at the body of Print, we know that Abs can call a (trusted)
C function that prints to the terminal, but not any other crazy functions.
This works since the code of Print can not be overridden or modified.}
\end{enumerate}

\pause{}
\begin{enumerate}
\item also (indirectly) perform \emph{any} $\cf{RestrictedPrimitive}$ operation:

$\texttt{\ensuremath{\ck{static}} \ensuremath{\ct{Int32}} \ensuremath{\cf{Abs(}\ct{Int32}} \ensuremath{\cv x\cf )} \ensuremath{\ck{calls[\cf{RestrictedPrimitive}]}} \{…\}}$
\end{enumerate}

\pause{}

\heading{Benefits }
\begin{enumerate}
\item No need to look at the body of $\cf{Abs}$

\note{since the language will ensure that it is well-typed}
\item No need to look at every piece of code we are compiling with

\note{We only need to look at the functions mentioned by the declaration
of Abs}
\item Our reasoning is static and consistently sound 

\note{No matter what happens at run time, (including dynamic code loading),
our grantees still hold.}
\end{enumerate}
\end{frame}
%
\begin{frame}{How to Solve Problem 2 (Dynamic Dispatch) }

What can $\cv x.\cf{Run()}$ do?

\note{Well we just look at the static type of x}

\pause{}

$\texttt{\ensuremath{\ck{interface}} \ensuremath{\ct I} \{ \ensuremath{\ck{void}} \ensuremath{\cf{Run()}} \ensuremath{\ck{calls[]}}; \}}$

\note{And so it can only perform unrestricted primitive operations. 

Deciding what callability interface methods should have isn't easy,
so what if we could defer the choice latter?

The obvious solution is to add a layer of abstraction.}

\pause{}

\heading{Callability Polymorphism}

Consider this:

$\tab\texttt{\ensuremath{\ck{interface}} \ensuremath{\ct{I<}\cf{'a}\ct >} \{ \ensuremath{\ck{void}} \ensuremath{\cf{Run()}} \ensuremath{\ck{calls[\cf{'a}]}}; \}}$

\note{Here 'a is a generic callability paramter, it can be substiuited for
any list of functions.}
\begin{exampleblock}{Example Implementation:}

$\texttt{\ensuremath{\ck{class}} \ensuremath{\ct{HelloWorld}}: \ensuremath{\ct{I<\cf{[WriteLine]}>}} \{}$

$\texttt{\ensuremath{\tab\ck{void}} \ensuremath{\ct I}.\ensuremath{\cf{Run()}} \ensuremath{\ck{calls[\cf{WriteLine}]}} \{}$

$\texttt{\ensuremath{\tab\tab\cf{\cf{WriteLine(}}\cl{"HelloWorld!"}\cf )}; \}\}}$
\end{exampleblock}

\pause{}

Now to answer the question: what can $\cv x.\cf{Run()}$ do?
\begin{enumerate}
\item Only perform $\cf{UnrestrictedPrimitive}$ operations: 

$\texttt{\ensuremath{\ck{static}} \ensuremath{\ck{void}} \ensuremath{\cf{M2(}\ct{I<\cf{[]}>}} \ensuremath{\cv x}) \ensuremath{\ck{calls[]}} \{ \ensuremath{\cv x}.\ensuremath{\cf{Run()}}; \}}$
\item Also print lines to standard-output:

$\texttt{\ensuremath{\ck{static}} \ensuremath{\ck{void}} \ensuremath{\cf{M2(}\ct{I<\cf{[WriteLine]}>}} \ensuremath{\cv x}) \ensuremath{\ck{calls[\cf{WriteLine}]}} \{ \ensuremath{\cv x}.\ensuremath{\cf{Run()}}; \}}$
\item Perform any $\cf{RestrictedPrimitive}$ operation:

$\texttt{\ensuremath{\ck{static}} \ensuremath{\ck{void}} \ensuremath{\cf{M3(}\ct{I<\cf{[RestrictedPrimitive]}>}} \ensuremath{\cv x}) \ensuremath{\ck{calls[\cf{RestrictedPrimitive}]}} \{ \ensuremath{\cv x}.\ensuremath{\cf{Run()}}; \}}$
\item Defer the decision to the caller of $\cf{M3}$: 

$\texttt{\ensuremath{\ck{static}} \ensuremath{\ck{void}} \ensuremath{\cf{M3<'a>(}\ct{I<\cf{['a]}>}} \ensuremath{\cv x}) \ensuremath{\ck{calls[\cf{'a}]}} \{ \ensuremath{\cv x}.\ensuremath{\cf{Run()}}; \}}$
\end{enumerate}
\note{Callability generics are of course covariant in their callability
paramaters, so you can use and cast between different instanciations
of I like any other generic type.}
\end{frame}
%
\begin{frame}{How to solve Problem 3 (Dynamic Code Loading \& Invocation) }

In C♯ to dynamically invoke a static method, you simply write:

$\texttt{\ensuremath{\tab\cv{methInfo}}.\ensuremath{\cf{Invoke(}\cv{receiver}}, \ensuremath{\cv{args}\cf )} \ensuremath{\cm{// Where \cv{methodInfo} has type \ct{MethodInfo}}}}$

\note{To prevent this from being used as a backdoor into our callability
system, we will need to specify the callability of Invoke properly.}

\pause{}

In our system we will have to declare $\cf{Invoke}$like this:

$\tab\texttt{\ensuremath{\cm{/// Represents a method}} \textit{\ensuremath{\f m}}}$

$\tab\texttt{\ensuremath{\ck{class}} \ensuremath{\ct{MethodInfo}} \{}$

$\tab\texttt{\ensuremath{\tab}…}$

$\tab\texttt{\ensuremath{\tab\cm{/// Throws an exception if \cf{Invoke<'a>} \ensuremath{\not\rightsquigarrow} \textit{\ensuremath{\f m}}, otherwise calls \cv{receiver}.\f{\textit{\ensuremath{\f m}}(}\cv{args}\cf )}}}$


$\tab\texttt{\ensuremath{\tab\ct{Object}} \ensuremath{\cf{Invoke<'a>(}\ct{Object}} \ensuremath{\cv{receiver}}, \ensuremath{\ct{Object[]}} \ensuremath{\cv{args}\cf )} \ensuremath{\ck{calls[\cf{'a}]}} \{ … \}}$

$\tab\texttt{\ensuremath{\tab}… \}}$

\note{The idea being that Invoke will check that 'a is sufficient to call
the identified method. We can now use this to safely run code downloaded
from the internet!}

\pause{}

$\texttt{\ensuremath{\ck{static}} \ensuremath{\ck{void}} \ensuremath{\cf{M3(}\ct{String}} \ensuremath{\cv{url}\cf )} \{}$

$\texttt{\ensuremath{\tab\ct{Assembly}} \ensuremath{\cv{code}} = \ensuremath{\ct{Assembly}}.\ensuremath{\cf{LoadFrom(}\cv{url}\cf )}; \ensuremath{\cm{// Load code (possibly from the internet)}}}$

$\texttt{\ensuremath{\tab\cv{\cv{code}.\cf{GetMethod(}\cl{"M"}\cf )}}.\ensuremath{\cf{Invoke<[]>(}\ck{null}}, \ensuremath{\ck{null}\cf )}; \} \ensuremath{\cm{// call \cf{M()}, but only if it can only perform \cf{UnrestrictedPrimitive} operations}}}$
\end{frame}
%
\begin{frame}{Future Work}
\begin{itemize}
\item Make our annotations less verbose:
\begin{itemize}
\item inference of $\ck{calls}$ annotations
\item wild-cards? 
\item allow named groups of functions?
\end{itemize}
\item Soundly support performing unsafe operations (like executing arbitrary
machine code)
\item Improve the support for dynamic loading:
\begin{itemize}
\item Allow calling new functions, even if they have themselvs in their
$\ck{calls}$ annotation
\end{itemize}
\item Formalise the reasoning properties we want from the system
\begin{itemize}
\item Proof them!
\end{itemize}
\end{itemize}

\end{frame}

\end{document}
