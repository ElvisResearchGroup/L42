\section{Conclusions, extensions and practical applications}

In this paper we explained a simple model to 
radically decouple inheritance/code reuse and subtyping.
The model presented here is easy to extend.
For example nested classes can be easily added, giving us enough power
to easily solve the Expression Problem~\cite{EP}, as demonstrated previously in
DeepFJig~\cite{deep}. More composition operators can be added in addition to \use.
In particular all the sophisticated operators of DeepFJig can be added.
 Indeed we can add any operator respecting following criteria:

\begin{itemize}
\item As for \use, the operator does not need to be total, but if it fails it needs to provide an error that will be reported to the programmer.
\item When the operator takes in input only traits (they are going to be well typed), if a result is produced,
 such result is well typed.
\item When the operator takes in input also code literals, if a non-well typed result is produced,
the type error must be traced back to code in one of those not-yet typed code literals.
 \end{itemize}
 

 
 Our simplified model represents the conceptual core of  42: a novel full blown programming language,
which leverages on the ideas presented in this paper to obtain reliable and understandable metaprogramming.
Formalization (in progress) for full 42 can be found at
\url{http://}\footnote{Omitted for anonymous review}. 
%\verb@urlOmittedForDoubleBlindReview@.
%\verb@github.com/ElvisResearchGroup/L42/tree/master/Main/formal@.
42 extends our model allowing
flattening to execute arbitrary computations.
In such model we do not need an explicit notion of traits: they are encoded as method returning a code literal.
42 also have features less related to code composition, like
  a strong type system supporting aliasing mutability and circularity control,
   checked exceptions, errors (unchecked exceptions) with strong-exception-safety for errors.

\begin{comment}
42 do not have a finite set of composition operators; they can be
added using the built in support for native method calls. They can
be dynamically checked to verify that they are well behaved
according to our predicate, or they can be trusted to achieve
efficiency.
\end{comment}

