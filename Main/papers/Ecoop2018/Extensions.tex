\section{Extensions to our model}

\paragraph{Nested classes}${}_{}$\\*
A nested class is just another kind of member in the code literal.
The general idea is that by composing code with \use,
nested classes with the same name are recursively composed.
For simplicity, while we discuss nested classes,
here we do not consider nested traits nor nested composition,
and all traits and code composition expression are still at top level.

In this way all dependencies are about top level names, allowing the type system 
to consider the class table as a simple map from (nested) types\footnote{
as both \Q@A@ and \Q@A.B.C@}  to their definition.

%\paragraph{Redirect}${}_{}$\\*
%Redirect is another composition operator that
%leverage on nested classes to emulate generics;
%the main idea is that a (fully abstract) nested class can be redirect to
%another one external to the trait/code literal.
%For example a linked list can be implement as
%\begin{lstlisting}
%list:{ Elem:{}
%     Cell:{static method Cell of(Elem e,Cell c) 
%       method Elem e()  method Cell c()
%       }
%   method Elem get(int x) ...
%   ...more methods..
%   }
%ListString:list[redirect Elem to String]
%\end{lstlisting}
%Note how redirect only influence its input, not the rest of the program.

%An expressive form of Redirect can be multiple, that is, can redirect may interdependent classes at the same time.
%We show a graph example, where also we can show how to propagate generics:
%For example
%\begin{lstlisting}
%t:{ method boolean reachable(Node start, Node end)/*implements reachability*/
%     Node:{method ListEdge nodes()}
%     Edge:{method Node in()  method Node out()}
%     ListEdge:list[redirect Elem to Edge]
%     }
%\end{lstlisting}



\paragraph{Rename}${}_{}$\\*
There are a lots of different forms of rename in literature.
Here we will use a simple variant to rename nested types in other nested types.
For example 
\begin{lstlisting}
t:{ method B m() B:{ method B mb()} }
D: t[rename B into C]
\end{lstlisting}
would flatten to 
\begin{lstlisting}
t:{ method B m() B:{ method B mb()} }
D:{ method C m() C:{ method C mb()} }
\end{lstlisting}
Note how the rename only influence its argument.
Since traits do not induce nominal types, we can
consistently change their
internally used names without breaking any code.

%Here we present two variants: one to rename nested types in other nested types
%and one to rename methods; this also allows to rename an (nested) interface method
%and having all the implementations renamed as well.
%Thanks to our division of use and reuse, those renames need to work only inside
%of their input and global rewriting of the whole program is never needed.
%
%Rename modify the method headers, and also all the method calls inside of the input.
%At a first glimpse, this seems to be not always possible since we are considering to be able to apply those
%operators also to non well typed code.
%However, if the expression language is simple enough, it is possible to pre-process the code to
%annotate the expected receiver type on all method calls by doing a purely syntactic analysis
%on a single code literal in isolation. 
%All the expression whose type is guessed to be out of the border of the literal can stay unannotated; they are not going to be renamed anyway.
%
%\begin{lstlisting}
%t:{ I:{interface method int mI() }
%     A:{implements I  method int mI() 42}
%     B:{ method int mB(I i, A a, C c) i.mI()+a.mI()+c.mI()}
%     //mB would be annotated i[I].mI()+a[A].mI()+c.mI()
%     }
%D:t[rename A.mI kI]
%\end{lstlisting}
% Notice how we are sure that \Q@C@ does not implements \Q@I@ since it is invisible from the outside:
% traits does not introduce nominal types!
% 
% We expect the flattened version for \Q@D@ to be
%\begin{lstlisting}
%D:{ I:{interface method int kI() }
%     A:{implements I  method int kI() 42}
%     B:{ method int mB(I i, A a, C c) i.kI()+a.kI()+c.mI()}
%     }
%\end{lstlisting}
%
%Hide can be seen as a variation of rename, where the method/class is renamed to a fresh unguessable name.



\paragraph{Application to the expression problem}${}_{}$\\*
The above extensions lets us challenge the expression problem~\cite{wadler1998expression},
with the requirements exposed in~\cite{scala}.
In the expression problem we have data variants and operations and we can
\textbf{extend our solution in both dimensions},
by adding new datavariants and adding new operations.
We also aim to \textbf{combine independently developed extensions} so
that they can be used jointly.

To be really modular, we want our extensions to
preserve \textbf{type safety}
and allow \textbf{separate compilation} (no re-type-checking),
while avoiding \textbf{duplication of source code}.

Following closely
the example of~\cite{},
we consider a language where the
expressions \Q@Exp@ can
be \Q@Num@ (for number literal)
\Q@Plus@ (for binary plus operator)
and \Q@Neg@ (for unary minus).
We then proceed defining operation
\Q@show@ to print it as a string,
 \Q@eval@ to compute the numeric value and 
\Q@double@ to double the value of each \Q@Num@.

We thus have 3 classes, 1 interface,
the definition of the state and 3 operations.
We can model this
as a table of features, as in~\cite{Deepfjig}:
a (3classes+1interface)*(1state+3operations)
table composed by 16 traits.
They are atomic: they deal with exactly 
declaring the state of a class
or defining a single operation for a single class.
In \name we can be very compact,
 as we can avoid a large amount of abstract declarations,
that clutters the solution in~\cite{Deepfjig}.
Intuitively, we would like our traits to look like the following 
\begin{lstlisting}
evalPlus=Use plus, {  
  Exp:{interface
    method Size eval()}
  Plus:{implements Exp
    method Size eval()
      this.left().eval()+this.right().eval()}}
\end{lstlisting}
\Q@basePlus@ uses the trait \Q@plus@ to import the state (\Q@left()@ and \Q@right()@)
and defines the \Q@eval()@ method from interface \Q@Exp@.

But, if we was to declare those
explicitly, we would repeat \Q@Exp@, the abstract
declaration of \Q@eval()@ and \Q@implements Exp@
for al the data-variant.
Our more abstract solution, to avoid this duplication is to write 
the trait \Q@eval @with a place-holder \Q@T@ nested class, that can then be renamed
onto the corresponding data variant.
Thus, our source code is as follow;
First we declare the 4 traits to represent the state:
\begin{lstlisting}
exp={
  Exp={interface}
  T={implements Exp}}
num=Use exp[rename T into Num],{//T renamed in Num is summed with the current Num
  Num={method Size value()  static method Num of(Size value)}}
plus=exp[rename T into Plus], {
  Plus={method Exp left()  method Exp right()  static method Plus of(Exp left,Exp right)}}
neg=Use exp[rename T into Neg],{
  Neg={method Exp term()  static method Neg of(Exp term)}}
\end{lstlisting}
Here we define a trait for each datavariant.
Each trait will contain its version of \Q@Exp@
and a specific case of expression, with its state.
Next, we define the operation \Q@eval@ for all the datavariants.
The former solutions in~\cite{deepfjig}
required to repeat the state declaration of the 
datavariant in each operation, while were we can just import it.

\begin{lstlisting}
eval={//concept of Exp.eval() declared once
  Exp={interface      method Size eval()}
  T={implements Exp}}
baseNum=Use num, base[rename T into Num],{
  //just the implementation of the specific method
  Num={ method Size eval() this.value() }}
basePlus=Use plus, base[rename T into Num], {
  Plus={ method Size eval() this.left().eval()+this.right().eval() }}
baseNeg=Use neg, base[rename T into Neg], {Neg={ method Size eval()..}}
\end{lstlisting}

The \Q@show@ operation can be trivially defined
following exactly the same design (omitted here for space reasons).
The operation \Q@double@ is is a challenge for some proposed solution to the expression problem.~\cite{}.
It is called a \emph{transformation}: an operation from \Q@Exp@ to \Q@Exp@.
Thanks to the separation between use and reuse, and the support
for self-instantiation of every nested class in a given trait,
in \name, it do not need any special attention
and can be coded is just exactly like \Q@eval@ and \Q@show@.
\begin{lstlisting}
double={
  Exp={interface
    method Exp double()}
  T={implements Exp}}
doubleNum= Use num, double[rename T in Num],{
  Num={ method Exp double() Num.of(this.value()*2) }}
doublePlus=Use plus,double[rename T in num],{
  Plus={ method Exp double() Plus.of(this.left().double(),this.right().double())}}
doubleNeg:...
\end{lstlisting}
Here we define a trait for each datavariant implementing the operation \Q@double()@.
Again, each trait will contain its version of \Q@Exp@ with \Q@double()@
and a specific case of expression, with the implementation for \Q@double()@
for that specific case.
%We can express \Q@double@ with this level of simplicity
%thanks to the separation between use and reuse:
%every trait have its own \Q@Exp@,
%and there is no subtyping between those \Q@Exp@, they can not even
%see each other.

In our third case study we compare our results with the ones presented
in scala.~\cite{}
The proposed solution is not fully modularized as a table,
so in order to make a more close comparison, we provide an alternative
version where we isolate all the units of behaviour as we
have done in \name.
\begin{minipage}{0.4\textwidth}
\begin{tabular}{l |l |l}
&                              lines  &   methods\\
original scala          & 95     &  12+3=15\\
scala  isolated units   & 149    &  12+3=15\\
scala  glue-code        &   41   &     3\\
42 traits               &   97   &    4*3+7=19\\
42 class                &   3    &     0\\
\end{tabular}
\end{minipage}
\begin{minipage}{0.6\textwidth}
Scala uses 12=4*3 methods plus 3 extra factory methods (for \Q@double@).
We use 12=4*3 methods plus our abstract state: 4 fields and 3 constructors.

\end{minipage}

As you can see, to encode fully isolated units in scala is
more verbose,
but more importantly,
in \name we can just define a class supporting any subset of operations
and data-variants by listing the desired traits:
For example, a solution for \Q@Num@ and \Q@Plus@ (but not \Q@Neg@)
with \Q@eval@ and \Q@double@ would look like:
\begin{lstlisting}
Example=Use evalNum,evalPlus,doubleNum,doublePlus
\end{lstlisting}
The composition of all our traits would just require to list all
of the relevant behaviour;reasonably formatted, it can takes 3 lines (so a full \name solution would be 97+3=100 lines).

On the other side, the presented solution in Scala requires
41 lines of glue code to put the traits together
(so a full scala solution would be 149+41=190 lines).

Following~\cite{}, after \Q@double@ we present an implementation of \Q@equals@.
In~\cite{}, involved double dispatch is used to avoid casting.
To show understandable code, we show a simpler solution 
with a guarded cast (sometime called a typecase).%
\footnote{
The interested reader can find a \name implementation of \Q@equals@ with double dispatch
in the appendix.
}

The main idea is that  every datavariant would contains
 the "cast" logic; thus
 we can modularize that into a \Q@equals@ trait.
\begin{lstlisting}
equals:{
  Exp:{interface
    method Bool equals(Exp that)}
  T:{implements Exp
    method Bool exactEquals(T that)
    method equals(that) 
      if(T instanceof This) then this.exactEquals(that)
      else Bool.false()}}
equalsNum:Use num, equals[rename T into Num],{
  Num:{method Bool exactEquals(Num that) this.value().equals(that.value())}}
equalsPlus:Use plus, equals[rename T into Plus],{
  Plus:{method Bool exactEquals(Plus that)
    this.left().equals(that.left()) && this.right().equals(that.right())}}
equalsNeg:Use neg, equals2[rename T into Neg],{
  Neg:{method Bool exactEquals(Neg that) this.term().equals(that.term())}}
\end{lstlisting}

This simple implementation of \Q@equals@
is much simple than the one proposed by scala
 and can be instantiated without any glue code.

\begin{minipage}{0.4\textwidth}
\begin{tabular}{l |l |l}
&                              lines  &   methods\\
original scala eq           &    51   &   10\\
isolated scala eq           &   58    &   10\\
scala eq instance           &    43   &    3\\
42 trait eq d-dispatch      &    34   &    6\\
42 class dd instance        &    25   &   11\\
42 traits eq Cast            &    21   &    6\\
42 class cast instance      &     3   &    0\\
\end{tabular}
\end{minipage}
\begin{minipage}{0.6\textwidth}
Here the scala code can be made fully isolated for a very little
extra syntactic cost.
To merge all the operations together in scala, it
takes 42 lines of glue code. Note that this
is mostly the same glue code from before (41 lines), that
needs to be manually adapted.
In 42 we are
more compact than Scala both when using the double dispatch (25 vs 58)
or the guarded cast (21 vs 58).
\end{minipage}

However, to instantiate the double dispatch 
version in \name we need 25 lines of glue code.
We could remove such glue code using 
features from the full 42 language, but here we stick to only the features presented in this paper.
The interesting point is that the nature of our needed glue code 
is different with respect to the Scala glue code:
Scala requires lots of trait multiple inheritance declarations to explicitly merge
nested traits with the same name, while in \name we mostly need 
to add the negative cases for the double dispatch (as in
\Q@Sum={method Bool equalToNum(Num that){return false;}}@).


%\paragraph{Transformations (and queries)}${}_{}$\\*
%
%The expression problem presented up to now is the traditional
% challenge proposed by~\cite{wadler1998expression};
%this has been criticized to not really address the fundamental issues
%since if many transformations have to be defined,
%it is hard to share common code between them.
%For example, we shown the \Q@double@ transformation.
%An equivalent transformation \Q@triple@ (tripling the
%values of the literals) should be easy to define by
%reusing all the traversal code and just redefining the
%case of \Q@Num@.
%When modularity is not a concern, this
%can be obtained in Java using the visitor pattern,
%defining a \Q@CloneVisitor@  and then overriding 
%only the relevant cases.
%Consider the Java code below:
%\begin{lstlisting}
%class CloneVisitor{
%  Exp visit(Num n){return new Num(n.value);}
%  Exp visit(Plus p){return new Plus(p.left.accept(this),p.right.accept(this);}
%  }
%class Double extends CloneVisitor{
%  Exp visit(Lit l){return new Lit(l.inner+1);}
%  }
%\end{lstlisting}
%In \name we can obtain the same kind of code reuse, without the need of introducing 
%the concepts related to the Visitor Pattern.
%With redirect, rename and restrict we can have the general operator propagator:
%\begin{lstlisting}
%operation:Use lit, sum, {//for sum and lit, easy to extends as before
%  Arg:{}
%  Exp:{interface method Exp op(Arg x)}
%  Lit:{
%    method Exp op(Arg x){return this}
%    }
%  Sum:{
%    method Exp op(Arg x){
%      return Sum.of(this.left().op(x),this.right().op(x))
%      }
%    }
%\end{lstlisting}
%
%Now, to have \Q@addN@ we can do the following.
%
%\begin{lstlisting}
%opAddn:Use operation
%  [redirect Arg to Int]
%  [rename Exp.op(x) to addN(x)]
%  [restrict Lit.op(x)], {
%  Lit:{
%    method Exp addN(Int x){ return Lit.of(inner())+x}
%    }
%  }
%\end{lstlisting}  



%\paragraph{Full power of redirect}${}_{}$\\*
%An expressive form of Redirect can be multiple, that is, can redirect may interdependent classes at the same time.
%We show an example where a specific kind of \Q@Service@ can produce a \Q@Report@, and 
%\Q@Report@s can be combined together.
%The goal is to execute a list of such services and produce a collated report.
%This example also show how to propagate generics:
%
%\begin{lstlisting}
%Service:{interface method Void performService()}
%serviceCombinator:{
%  S:{implements Service method R report()  }
%  
%  R:{method R combine(R that)   class method R empty() }
%  
%  ListS:list[redirect Elem to S]
%  
%  class method R doAll(ListS ss){//here we use extended java like syntax
%    R r=R.empty()
%    for(S s in ss){
%      s.performService();
%      r=r.combine(s.report())
%      }
%    return r;
%  }
%}
%PaintingService:serviceCombinator[redirect S to PaintingService]
%PaintingService:{... method PaintingReport report()..}
%PaintingReport:{..}
%\end{lstlisting}
%
%The flattened version of \Q@PaintingService@ would look like:
%\begin{lstlisting}
%PaintingService:{
%  ListS:/*the expansion of list[redirect Elem to PaintingService]*/
%  
%  class method PaintingReport doAll(ListS ss){
%    PaintingReport r=PaintingReport.empty()
%    for(PaintingService s in ss){
%      s.performService();
%      r=r.combine(s.report())
%      }
%    return r;
%  }
%}
%\end{lstlisting}
%Where you can note how redirect figured out \Q@R=PaintingReport@ by comparing the structural shape of
%classes \Q@PaintingService@ and \Q@S@.
%
%To encode the former generic code in java you need to write
%the following headeche inducing interfaces for RService and Report.
%and require that the services you want to serve implement those.
%\begin{lstlisting}
%interface Service{ void performService();}
%interface Report<R extends Report<R>>{R combine(R that);}
%interface RService<R extends Report<R>> extends Service{ R report();}
%\end{lstlisting}
%Note how we still can not encode the method \Q@empty@.
