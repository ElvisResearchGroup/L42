\saveSpace\saveSpace
\section{Conclusions, extensions and practical applications}
\saveSpace
In this paper we explained a simple model to 
radically decouple inheritance/code reuse and subtyping.
One important point is that our decoupling does not
makes the language more complex:
% since
%interfaces (subtyping without subclassing)
%exists in both Java and C\#.
we \textbf{replace the concept} of abstract classes with
the concept of traits, while keeping the concepts of
interfaces and final classes.
Concrete non final classes are simply not needed in our model.
Thus, we believe that \name benefits
code reuse in important cases 
without having negative impacts on the general programming experience.
The interested reader can find a detailed discussion about this in the appendix.


The model presented here is easy to extend.
More composition operators can be added in addition to \use.
In particular variants of the sophisticated operators of DJ are
included in the full 42 language.
 Indeed we can add any operator respecting the following criteria:

\begin{itemize}
\item When the operator fails it needs to provide an error that will be reported to the programmer.
\item When only well typed code is took as input, if a result is produced,
 such result is also well typed.
\item When the result is not well typed,
the type error must be traced back to
a fault in the input.
 \end{itemize}
 

Our simplified model represents the conceptual core of  42: a novel full blown programming language,
In full 42 code literals are first class values, thus we
do not need explicit names
for traits: they are encoded as methods
 returning a code literal.

\begin{comment}
using the ideas presented in this paper to obtain reliable and understandable metaprogramming.
Formalization (in progress) for full 42 can be found at
\url{http://}\footnote{Omitted for anonymous review}. 
%\verb@urlOmittedForDoubleBlindReview@.
%\verb@github.com/ElvisResearchGroup/L42/tree/master/Main/formal@.
42 extends our model allowing
flattening to execute arbitrary computations.
In such model we do not need an explicit notion of traits: they are encoded as methods returning a code literal.
42 also has features less related to code composition, like
  a strong type system supporting aliasing mutability and circularity control,
   checked exceptions, and errors (unchecked exceptions) with strong-exception-safety.


42 do not have a finite set of composition operators; they can be
added using the built in support for native method calls. They can
be dynamically checked to verify that they are well behaved
according to our predicate, or they can be trusted to achieve
efficiency.
\end{comment}

