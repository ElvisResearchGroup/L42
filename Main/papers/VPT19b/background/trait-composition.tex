\subsection{Trait Composition}
The idea behind \emph{trait composition} is to seperate the notions of \emph{subtyping} and \emph{inheritence}. Only \emph{traits} can be inherited, and only \emph{classes} can be used as types. A \emph{trait} is like an anonymous class, in particular it can contain methods, but because it is anonymous, one cannot directly use it as a type or create instances of it. A class can then be declared from a trait, effectively giving it a name, but such a class will be unrelated to other classes defined from the same trait. Traits can then be `composed` to produce other traits, however since traits cannot be used as types, we are free to perform operations that would break the LSV. Consider the following example:
\begin{lstlisting}
Trait pair = class {
  String target();
  String hello() { return "Hello " + this.target(); }
};
// Defines a class called 'HelloWorld'
HelloWorld: pair.extend(class {
  String target() { return "World"; }
  String hello() { this.super_print() + "!"; } // prints "Hello World!"
});
\end{lstlisting}
We use the type /Trait/ as the types of traits, and a class-declaration (without a name) as a \emph{trait literal} expression. Here /trait1.extend(trait2)/ adds all the methods in trait2 to trait1, if their is conflict, methods in /trait2/ will override those in /trait1/. In addition, /trait2/ can declare and call methods in /trait1/ by prefixing their name with /super_/, however they are considered `private' to /trait2/, i.e. only code in /trait2/ itself can see them, not /code/ added in later.

In this paper, we will use the \emph{flattening} semantics of traits~\cite{?}, in which trait operations produce a flattened result, equivalent to a trait literal, with no references to any of the input traits to the operation. Thus the above definition for /HelloWorld/ is identical to:
\begin{lstlisting}
HelloWorld: class {
	private String super_hello() { return "Hello " + this.target(); }
	String target() { return "World"; }
	String print() { this.super_print() + "!"; }
};
\end{lstlisting}

The main advantage of trait composition over conventional inheritance is that trait composition does \emph{not} induce subtyping:
\begin{itemize}
	\item Trait operations that would be unsound in a subtyping environment are allowed, such as removing methods or changing their types.
	\item The way code is reused in order to construct a class is not exposed to users of the class. This allows the code reuse mechanism to be changed without breaking any uses of a class.
\end{itemize}
In addition, this makes traits much simpler to reason about, making it easier to compose them in more complicated ways~\cite{?}.