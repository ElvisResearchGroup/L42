\section{Background}
\subsection{Static Verification in OO}
There is a wealth of research in static verification, they usually follow the conventional notions of pre and post-conditions~\cite{?}: a method is annotated with a precondition which must hold when the method is called, and a postcondition which must hold when the method returns. In this paper, we will use the annotation /@requires($predicate$)/ to specify a precondition, and /@ensures($predicate$)/ to specify a postcondition; here $predicate$ is a boolean expression in terms of /this/, and the parameters of the method, and for the /@ensures/ case, the /result/ of the method call. For example one could write an implementation of exponentiation using repeated squaring like this:
\begin{lstlisting}
@requires(x != 0 || exp != 0) // since 0**0 is undefined.
@ensures(result == x**exp)
Int pow(Int x, Nat exp) {
	if (exp == 0)           return 1;
	else if (exp == 1)      return x;
	else if (exp % 2 == 0)  return pow(x * x, exp / 2); // even power
	else                    return x*pow(x, exp - 1);   // odd power
\end{lstlisting}
This says that for /pow/ to be `correct', whenever we don't have /x == 0/ and /exp == 0/, /pow(x, exp)/ must equal /x**exp/\footnote{We use the notation /x**y/ to mean `/x/ to the power of /y/'.}. For a \emph{call} /pow(x, exp)/ to be valid, either /x/ or /y/ must be non-zero.

The concepts of pre and post conditions can be extended to object oriented programming~\cite{?}, consider for example:
\begin{lstlisting}
interface List {
	@requires(this.contains(o))
	@ensures(this.get(result) == o)
	Nat find(Object o);
	...
}
\end{lstlisting}
This means that in order for a call /a_list.find(o)/ to be correct, /a_list/ must contain /o/. In order for an implementation of /List.find/ to be correct, /this.find(o)/ must return an index that corresponds to /o/, assuming that /this/ contains /o/. Note that \emph{abstract} methods (such as /List.find/), are always trivially correct, however the type system of the language should ensure that the methods of all \emph{objects} are implemented.

For simplicity, we only consider pre and post conditions in a purely functional OO language. Static verification can be extended to other cases, such as to verify class invariants~\cite{?}, termination~\cite{?}, function purity (where the language is otherwise imperative language) ~\cite{?}, aliasing~\cite{?} etc. However such properties are still typically encoded as pre and post-conditions.

The mechanism by which such programs are verified to be correct is also a large research area, one common approach is \emph{automated static verification}, where a tool tries to automatically verify code is correct during compilation, such tools typically encode the correctness of a program as a mathematical theorem, and use an SMT solver to verify it. Automated static verification is often easier to use and provides stronger guarantees compared to computer aided theorem proving~\cite{?} and runtime verification~\cite{?} (respectively). 

For simplicity, we will only consider automated static verification. The details as to how this is done is also out of scope of this paper. However, our approach should be easily extendible to other mechanisms of verification.

\subsection{Trait Composition}
Trait composition~\cite{?} uses \emph{traits} to represent the \emph{body} of a class, and allows composing traits together. Traits are similar to the conventional OO concept of classes, however they are not types. In this paper, we use the concept of \emph{flattening}~\cite{?} where trait operations flatten into a new AST. Their are multiple operators that can be applied to traits...

%TODO: Very bad example of inheritence! can easilly be acomplished with just pow1.pow.... come up with something better
\begin{lstlisting}
Trait pow1 = static class {
Int pow(Int x) {
return x; 
}
}

Trait pow2 = pow1.extend(static class {
Int pow(Int x) {
Int y = super_pow(x);
return y*y;
}
}
...
Pow2: pow2;
\end{lstlisting}

(a `static` class, )

\begin{lstlisting}
class Pow1 {
Int pow(Int x) {
return x; 
}
}

class Pow2 extends Pow1 {
Int pow(Int x) {
Int y = super.pow(x);
return y*y;
}
}
...
Pow2: pow2;
\end{lstlisting}

The main advantage of trait composition over conventional inheritance is that trait composition does \emph{not} induce sub-typing:
\begin{itemize}
	\item Trait operations that would be unsound in a sub-typing environment are allowed, such as removing methods or changing their types.
	\item The way the class is constructed is not exposed to users, this allows classes to be rewritten in a totally different way.
\end{itemize}
In addition, this makes traits much simpler to reason about, making it easier to compose them i'm more complicated ways~\cite{?}.

\subsection{Iterative Composition}
Iterative composition~\cite{?} takes the concept of trait composition one step forward, by treating traits as first class objects, and allowing arbitrary code to execute at meta-time. This allows for fully met-circular meta-programming. In this way, classes can be declared from arbitrary expressions (of type /Trait/), and methods can take and return /Trait/s. Consider again our /pow/ example:
\begin{lstlisting}
Pow: static class {
	Trait pow0 = static class {
		Int pow(Int x) { return 1; }
	}

	Trait pow1 = static class {
		Int pow(Int x) { return x; }
	}

	Trait powEven = static class {
		Int super_pow(Int x);
		Int pow(Int x) { return super_pow(x * x); }
	}
	Trait powOdd = static class {
		Int super_pow(Int x);
		Int pow(Int x) { return x*super_pow(x); }
	}

	Trait generate(Nat exp) {
		if (exp == 0)          { return pow0; }
		else if (exp == 1)     { return pow1; }
		else if (exp % 2 == 0) { return generate(exp / 2).extend(powEven);
		else                   { return generate(exp - 1).extend(powOdd); }}
}
\end{lstlisting}

In the above code, we have a normal looking recursive /generate/ method, however it returns a /trait/. The above method can now be called to generate the body of a class:

\begin{lstlisting}
Pow7: Pow.generate(7);
// Equivalent to:
Pow7: static class {
	Int pow(Int x) { return x*super1_pow(x); } // x ** 7

	private Int super1_pow(Int x) { return super2_pow(x * x); } // x ** 6
	private Int super2_pow(Int x) { return x*super3_pow(x); } // x ** 3
	private Int super3_pow(Int x) { return super4_pow(x * x); } // x ** 2
	private Int super4_pow(Int x) { return x; } // x ** 1
}
// Which could then be inlined to:
Pow7: static class {
	Int pow(Int x) { 
		Int x2 = x*x; // x**2
		Int x4 = x2*x2; // x**4
		return x*x2*x4; } // Since 7 = 1 + 2 + 4
}
\end{lstlisting}