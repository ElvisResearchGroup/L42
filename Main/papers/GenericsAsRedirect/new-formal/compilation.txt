Define DEs ==> DE's
=========================================================
(main-top) Ds id=EV DEs ==> Ds id=L Des
    EV not of form L
    Ds' is some subset of Ds
    Ds' |- Ok
    Ds' | EV -->* L

(main-enter) Ds id=CtxV[L] DEs ==> Ds id=CtxV[LV] Des
    L not of form LV
    C' = ToC(id)
    C' = L'; Ds ==>* C' = LV; Ds

Define p ==> p'
=========================================================
(top) C = L; Dz ==> C = L[C' := L'], cls; Dz:
		L = {interface? implements Pz MVz C' = EV Ms}
		EV not of form L
		C = L, cls; Dz | EV -->* L'

(enter) C = L, cls; Dz ==> C = L[C' := CtxV[LV]], cls; Dz:
	L = {interface? implements Pz MVz C' = CtxV[L'] Ms}
    L' not of form LV
    C'=L', C = L, cls; Dz ==>* C'=LV  C = L, cls; Dz
    // TODO? Use fresh C' or not?

Define S ==> S'
=========================================================

            DEs ==>* Ds
            Ds |- Ok
            Ds; empty |- e : T
            Ds | e -->* e'
(main e)------------------------------ for some type T
            DEs e --> Ds e'


Define p |- EV --> EV'
=========================================================

(trait) -----------------------------------
          p |- t -> p[t]

         C = LV3, p |- LV1 <+ LV2 = LV3
(sum) -------------------------------------- for fresh C
        p |- LV1 <+ LV2 --> LV3

(redirect) ------------------------------------LV'=redirect(p, LV, Cs, P)
            p |- LV(Cs=P) -> LV'



Define p |- LV1 <+ LV2 = LV3
========================================================================================
p |- {implements Tz1 CVz1 mtz1 K?1} <+ {implements Tz2 CVz2 mtz2 K?2} = {implements Tz CVz mtz K?}
  Tz = minimize(p; Tz1 U Tz2)
  p |- CVz1,MTz1 + CVz2,MTz2 = CVz,CVz
  {empty, K?1, K?2} = {empty, K?} //may be too sophisticated?

p|- interface{implements Tz1 amtz,amtz'} <+ interface?{implements Tz2 amtz} = interface {implements Tz amtz}
  Tz = minimize(p; Tz1 U Tz2)
  if interface? = interface then amtz'=empty

p |- Mz + Mz' = Mz' + Mz
p |- Mz + empty = Mz
p |- (M, Mz) + Mz' = mt, (Mz + Mz')
    M.Mid not in dom(Mz')

p |- (T m(Txs) e?, Mz) + (T m(Txs), Mz') = T m(Txs) e?, (Mz + Mz')
p |- (C = LV, Mz) + (C = LV', Mz')      = C = LV", (Mz + Mz'):
    p.push(C) |- LV <+ LV' = LV"
