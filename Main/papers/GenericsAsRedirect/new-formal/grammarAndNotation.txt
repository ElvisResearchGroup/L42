id  ::= t | C
T,P ::= Thisn.Cs

CD  ::= C = E  // class declaration
CV  ::= C = LV // evaluated class declaration
D   ::= id = E // declaration
DL  ::= id = L // partially-evaluated-declaration
DV  ::= id = LV // evaluated-declaration

L   ::= interface {Tz;; amtz;} | {Tz; CDs; mtz; K?}  // literal
LV  ::= interface {Tz;; amtz;} | {Tz; CVs; mtz; K?}  // literal value

amt ::= T m(Txs) // abstract method
mt  ::= T m(Txs) e? // method
Tx  ::= T x // paramater-declaration
M   ::= CD | mt // member
Mid ::= C | m // member-id
K   ::= constructor(Txs) // constructor
e   ::= x | this | e.m(es) | this.x | new T(es) // expression

E   ::= L  |  t  |  E <+ E    |  E(Cs=T) // library-expression
Ec  ::= LV |  t  |  Ec <+ Ec  |  Ec(Cs=T) // compiled library-expression

CtxV ::= [] | CtxV <+ E| LV <+ CtxV | CtxV(Cs=T) // Context of library-evaluation
CtxL ::= interface? {Pz; CVs, [], CDs; mtz; K?} // Context of nested-class evaluation

p   ::= DLs; DVs // program
S   ::= Ds e // Source Code
=====================================================================================
Define ToC(id) = C
-----------------------------
ToC(t) = C:
    for fresh C
ToC(C) = C

Define p(P) = LV
-----------------------------------
(; _, C = L, _)(This0.C.Cs) = L(Cs)
(id = L, p)(This0.Cs)   = L(Cs)
(id = L, p)(Thisn+1.Cs) = p(Thisn.Cs)
(DLs; _, t = LV, _)[t] = LV[from This(#DLs)]
p[P] = p(P)[from P]

Define L(Cs) = L
--------------------------------------
L(empty) = L
L(C.Cs) = L(Cs)
    L = interface? {_; _, C = L, _; _ ; _}

Define operations on p
--------------------------------------
p.evilPush(L) = (C = L, p)
	for fresh C

p.push(id) = (id = L, p)
    p = (id' = {_;_, id = L, _ ;_;_}, _; DVs)

(id = L, p).pop() = p
(id = L, p).top() = L

p.minimize(Thisn+1.idn.Cs) = p.minimize(Thisn.Cs):
  p = id0 = L0, ..., idn = Ln, _; DVs
  p(Thisn.Cs) = LV
  // TODO: Check that Ln is an LV instead?
otherwise p.minimize(P) = P

define dom(Mz) = Midz
===========================================
dom(empty) = empty
dom(C = E, Mz) = C, dom(Mz)
dom(T m(Txs), Mz) = m, dom(Mz)
