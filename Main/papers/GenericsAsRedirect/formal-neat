------------- // TODO: Change V to 'R' ? Or perhaps 'M'?
Module V: defines V, V(Cs)=P, V(L)=L', dom(V);
using auxiliary V_Cs(e)=e', V_Cs(T)=T', V_Cs(M)=M', V(Cs=L)=L'

V ::= (Cs->P)z // Redirection map
// A V is a methematical partial function from the set of Cs to the set of P

//______
//Define V.minimize(p)
//(Cs1->P1,...,Csn->Pn).minimize(p)=Cs1->p.minimize(P1), ..., Csn->p.minimize(Pn)
 
______
Define dom(V)
dom(Cs1->P1, ..., Csn->Pn) = Cs1, ..., Csn

______
Define V(Cs)=P 
V(Cs) = P
  Cs->P in V // Cs renamed using V
______
// Apply V to all references to the class-names in dom(L)
// Note: this only applies to references (i.e. P's), the nested classes themselves (if present) are not redirected
Define  V(L)=V(empty=L) // Note: the top-level 'class' has no name, so we use 'empty'

// Note: that Ls found found inside expressions (i.e. es) have no names, whereas the RHS of a nested-class definition do
// However even an unanamed L may be inside a named L, and we need this information to understand what a path refers to.
// As such we will just geneerate fresh names for unnamaed Ls, thus simplifying things by giving all L's a name.

// We could also just use V_Cs(C: L) and V_Cs(L) to apply V to nested classes and L expressions (respectivley),
// however this general V(Cs = L) function prevents duplication, and so the above two just forward to it
_________
// Apply V to class 'Cs' which has body 'L'
// We need to keep track of the Cs since paths are relative, in order to know if they refer to something in dom(V)
// we need to know where the is
AuxDefine V(Cs = L)=L'

// Simply apply V to the Pz and Mz
V(Cs = {interface? implements Pz Mz}) = {interface? implements V_Cs(Pz) V_Cs(Mz)}
  
_________
// Apply V to a member M that was found in nested class Cs
AuxDefine V_Cs(M)=M'

// Case for methods, apply V to all types, paths and expressions
V_Cs(refine? mdf method T m(T1 x1,..,Tn xn) exception Pz e?) =
  refine? mdf method V_Cs(T) m(V_Cs(T1) x1,..,V_Cs(Tn) xn) exception V_Cs(Pz) V_Cs(e?)

// Case for nested classes, apply V to the library literal, giving it the appropriate name
V_Cs(C: L) = C: V(Cs.C = L) // Apply V to a nested class, which has name C and is in Cs
_________
// Apply V to an e, which was found in nested class Cs
AuxDefine V_Cs(e)=e'
V_Cs(L) = V(Cs.C = L), for fresh C
// TODO: Other kinds of expressions (just apply V_Cs to all e, L, T and P inside)

_________
AuxDefine V_Cs(T)=T'
// Apply V to a type, by just applying it to the mentioned path
V_Cs(mdf P) = mdf V_Cs(P)

_________
// Apply V to the path P that we found in Cs
// If a prefix of P refers to something in the domain of V, we will redirect it
// Otherwise we will leave it untouched
AuxDefine V_Cs(P)=P' // P found in Cs is renamed to P'

// We found P in Cs (of length k), so give it to V (which is defined relative to This0, but we are in This0.Cs)
// and from the result (since the start, This0, is actually Thisk from the point of view of This0.Cs,
// which is where we found the original P)
V_Cs(P) = V(Cs')[from Thisk]
    where Cs = C1...Ck
    P[from This0.CS] = This0.Cs'

otherwise
V(P in Cs) = P

// Csz' is the set of nested class names that will be redirected when all the Csz are redirected from L
// It is the names of the nested classes transitivley mentioned in the 'signature' of each Csz
Define RedirectSet(L; Csz)=Csz':
-----------------------------
// If we are redirecting Csz, then we need to redirect Csz
Csz subseteq RedirectSet(L; Csz)

// Redirect the nested classes of redirected classes
Cs1.C in RedirectSet(L; Csz)
  Cs1 in RedirectSet(L; Csz)
  C in dom(L[Cs1])

// Redirect the nested class mentioned in the signature of a redirected class
// We won't however be redirecting references to external paths (i.e. things outside of This0)
Cs2 in RedirectSet(L; Csz)
  Cs1 in RedirectSet(L; Csz)
  This0.Cs2 in Paths(L[Cs1])[from This0.Cs1] // TODO: Do a p.minimize?

// The set of paths referenced in the signatures of L and mwt (excluding nested classes)
Define RedirectPaths(L) = Pz, RedirectPaths(mwt) = Pz
-----------------------------------------------------------------------
// The set of implemented interfaces
RedirectPaths({interface? implements Pz mwtz ncz}) = Pz, RedirectPaths(mwtz)

// The set of paths used in the type of a method
RedirectPaths(mwt) = Ts.Ps, T.P, Pz
  mwt.mt = Ts->T;Pz

==================================================================
// Perform and compute a redirect, using a choice function 'ChooseRedirect' to compute the V mapping
Define Redirect(p; L; Cs1, P1, ..., Csn, Pn) = V'(p'.top()[remove Csz]) // Remove the things that will be redirected away
  empty not in Cs1 ... Csn // We can't redirect This0, as that does not make sense
  p' = p.evilPush(L) // to simplify everything, just make L the new top
  forall Cs in RedirectSet(L, Cs1, ..., Csn):
    Redirectable(L[Cs]) // Check that the source is valid

  // Chose a mapping, simplifying the input, and update the paths to be relative to our evil-pushed program
  ChooseRedirect(p'; Cs1, p'.minimize(P1[from This1]), ..., Csn, p'.minimize(Pn[from This1])) = V'

// Whether the class This0.Cs can be redirected away
// Namely: that the class contains no implemented methods or anything private
Define Redirectable(L)
  forall mwt in L.mwtz:
    mwt.e = empty
    not Private(mwt.m)

  forall C in dom(L.ncz)
    not Private(C)

// Starting from V and operating on p, is V' a valid redirect mapping?
Define ValidRedirect(p; V; V') iff
    empty not in dom(V') // If this weren't true, L[remove Csz] would be undefined
    V subseteq V'
    // V' redirects exactly what it's supposed to
    dom(V') = RedirectSet(p.top(); dom(V)) // TODO: Do we need this? Why?

    // V' consistantly redirects nested classes, if one dosn't want this, they can redirect the nested classes individualy
    forall Cs.C1.C2 in dom(V'): V'(Cs.C1.C2) = V'(Cs.C1).C2
    // Everything redirected is both minimized and a structural-supertype of the target
    forall Cs in dom(V'):
      V'(Cs)=p.minimize(V'(Cs))
      // Note: we apply V' to the source of the redirect,
      p|- Cs; V'(p[Cs]) >= V'(Cs); p[V'(Cs)]

// Is the LHS (whose name is 'This0.Cs') a structural supertype of the RHS (whose name is P)
// We say that A is a structural supertype of B if any code written with respect to A
// would also type-check against B
Define p|- Cs; {interface? implements Pz mwtz, ncz} >= P; {interafce?' implements Pz' mwtz', ncz'}
  // Check that all the interfaces the LHS implements are also implemented by the RHS
  Pz subseteq_p Pz',P //Note: The P on the RHS very important, so that F-bound polimoprhism can work TODO: explain what this means

  // If the LHS is not an interface
  if interface?=empty:
    // Check that each method-type of the RHS is a subtype of the LHS
    // (So that it any well-typed call to a method on the LHS would also typecheck if it were to call a method on the RHS)
    forall MS in dom(mwtz):
      p |- mwtz'(MS).mt <= mwt(MS).mt

    // One can only call class methods on a non-interface, so if the LHS has any, than the RHS can't be an interface
    if interface?' = interface then class not in mwtz.mdfz

  // If the LHS is an interface, we need to ensure that any valid implementation of the LHS
  // Is a valid implemention of the RHS, which requires that the RHS have the exact same method signatures as the LHS
  else:
    interface? = interface?' // You can't implement non-interfaces
    // We ignore the presence of the 'refine' keyword, since this is irealvent to any implementing classes
    mwtz[with refine?s=empty] = mwtz'[with refine?s=empty]

--------------------------------------------
// Choose a valid completion for the V1 redirect map
Define ChooseRedirect(p; V1) = V2
  // Choose the unique greatest valid V2
  V2 is the unique V such that ValidRedirect(p; V1; V2) and
    for all V3 such that ValidRedirect(p; V1; V3),  p |- V2 > V3

// We say that V1 is strictly better than V2
// When V2 is not better than V1 in any way,
// But V1 is better than V2 in some way
p |- V1 > V2 iff
  p |- V1 >= V2
  p |/- V2 >= V1

// Get the path of the i'th return/paramater type of a method
Define mwt.Pi = P'i
    where mwt.mt = mdf1 P'0 ... mdfn P'n -> mdf0 P'0; Pz

// V1 is at least as good as V2, if V1 is strictly better than V2 in some way
Define p |- V1 >= V2
  // Is their a case where V1 maps a method type closer than V2 does to the type p.top expects it to have?
  for some MS, i, Cs, and Cs' // Note: Cs could be the same as Cs'
  p[This0.Cs'](MS).Pi = This0.Cs
  distance(p, p[V1(Cs')](MS).Pi, V2(Cs)) <= distance(p, p[V2(Cs')](MS).Pi, V2(Cs))
=======================================================
// Some utility functions about Paths/Classes

// P1 < P2 if P1 is a proper subpath of P2
Define p |- P1 < P2 iff
    p |- P1 <= P2
    p |/- P2 <= P1

// The distance between two equivalent paths is 0
distance(p, P1, P2) = 0
    p.equiv(P1, P2)

// How far apart P1 and P2 are on a Hasse-diagram of the subtyping relation
distance(p, P1, P2) = n
  n is the length of the longest non-empty path between P1 and P2, formed by using the 'p |- <' relation

// To make distance easier to use, we make it symmetric
distance(p, P1, P2) = distance(p, P2, P1)

=====================================================
// This checks if the choice function is valid
// NOTE: It is uncomputable! Importantly, I cannot come up with a computable function 'f' such that:
//  * for all g, ValidChooser(f(g))
//  * for all g such that ValidChooser(g), f(g) = g
// (I.e. one that turns any chooser into a valid one, but leaves allready valid ones untouched)
Defien ValidChooser(ChooseRedirect) iff for all p and V
    if for all Cs->P in V, // for all valid inputs to ChooseRedirect
        P = p.minimize(P)
        P not of the form This0.Cs' // That would be a 'rename' not a 'redirect'
        Cs not empty
        // TODO: Add some requirement that each P is allready compiled/type-checked/whatever?
    then:
    // needed for stability to make sense
    ChooseRedirect(p; V) is defined iff ChooseRedirect(ReduceProblem(p; V); V) is defined
    if ChooseRedirect(p; V) = V' then
      ChooseRedirect(p; V') = V'               // idempotence
      V' = ChooseRedirect(ReduceProblem(p; V)) // stability
      ValidRedirect(p; V; V')                  // validity

// We should try and prove that the above definition is equivalent to one where we replace the 'validity' check
// with a meta-level soudness check (I'm not certain though)

// Auxilarry operation used by the above
Define L[only Csz] = L' // Removes everything not in Csz

L[only Cs,Csz] = L[only Cs] U L[only Csz]
L[only empty] = {}
L[only C1...Cn] = {C1: ... {Cn: L(Cs)[with ncz = empty]} ... }

// U above is a 'dumb' sum, namely:
{interface?1 Pz C: L ... Cn: Ln Mz} U {interface?2 Pz' C1: L1' ... Cn: Ln' Mz'} =
        {interface?1 + interface?2 Pz Pz' C1: L1 U L1' ... Cn: Ln U Ln' Mz Mz'}
    dom(Mz) disjoint dom(Mz')