-------------
Module V: defines V, V(Cs)=P, V(L)=L', dom(V);
using auxiliary V_Cs(e)=e', V_Cs(T)=T', V_Cs(M)=M', V(Cs=L)=L'

V ::= (Cs->P)z // Redirection/renaming map

//______
//Define V.minimize(p)
//(Cs1->P1,...,Csn->Pn).minimize(p)=Cs1->p.minimize(P1), ..., Csn->p.minimize(Pn)
 
______
Define dom(V)
dom(Cs1->P1, ..., Csn->Pn) = Cs1, ..., Csn

______
Define V(Cs)=P 
V(Cs) = P
  Cs->P in V // Cs renamed using V

______
Define  V(L)=V(empty=L) // Apply V to L

_________
AuxDefine V(Cs = L)=L'  // Apply V to L, where L is named Cs
V(Cs = {interface? implements Pz Mz}) = {interface? implements V_Cs(Pz) V_Cs(Mz)}
  
_________
AuxDefine V_Cs(M)=M'

V_Cs(refine? mdf method T m(T1 x1,..,Tn xn) exception Pz e?) =
  refine? mdf method V_Cs(T) m(V_Cs(T1) x1,..,V_Cs(Tn) xn) exception V_Cs(Pz) V_Cs(e?)
V_Cs(C: L) = C: V(Cs.C = L) // Apply V to a nested class, which has name C and is in Cs
_________
AuxDefine V_Cs(e)=e // means apply V to 'e', where e was found in nested class 'Cs'
V_Cs(L) = V(Cs.C = L), for fresh C // Rename a library literal expression

//Note the difference w.r.t. V_Cs(C: L) above. This is why we need both V_Cs(_) and V(Cs=_)
// TODO: Other kinds of expressions (just apply V_Cs to all e, L, T and P inside)

_________
AuxDefine V_Cs(T)=T'
V_Cs(mdf P) = mdf V_Cs(P)

_________
AuxDefine V_Cs(P)=P' // P found in Cs is renamed to P'
V(Thisk.Cs' in Cs.C1...Ck) = V(Cs.Cs') + #Cs + k
otherwise
V(P in Cs) = P

Define RedirectSet(L; Csz)=Csz':
// Csz' is the set of nested class names that will be redirected when all the Csz are redirected from L
-----------------------------
Cs in RedirectSet(L; Cs, Csz)

Cs1.C in RedirectSet(L; Csz)
  Cs1 in RedirectSet(L; Csz)
  C in dom(L[Cs1])

Cs2 in RedirectSet(L; Csz)
  Cs1 in RedirectSet(L; Csz)
  This0.Cs2 in Paths(L[Cs1])[from This0.Cs1]

Define RedirectPaths(L) = Pz, RedirectPaths(mwt) = Pz
// The set of paths referenced in the signatures of L and mwt (excluding nested classes)
-----------------------------------------------------------------------
RedirectPaths({interface? implements Pz mwtz ncz}) = Pz, RedirectPaths(mwtz)

RedirectPaths(mwt) = Ts.Ps, T.P, Pz
  mwt.mt = Ts->T;Pz

==================================================================
Define Redirect(p; L; Cs1, P1, ..., Csn, Pn) = V'(p'.top()[remove Csz])
  where p' = p.evilPush(L)
  ChooseRedirect(p'; Cs1, p'.minimize(P1+1), ..., Csn, p'.minimize(Pn+1)) = V'

// This checks if the choice function is valid
// NOTE: It is uncomputable! Importantly, I cannot come up with a computable function 'f' such that:
//  * for all g, ValidChooser(f(g))
//  * for all g such that ValidChooser(g), f(g) = g
// (I.e. one that turns any chooser into a valid one, but leaves allready valid ones untouched)
Defien ValidChooser(ChooseRedirect) iff for all p and V
    // needed for stability to make sense
    ChooseRedirect(p; V) is defined iff ChooseRedirect(ReduceProblem(p; V); V) is defined
    if ChooseRedirect(p; V) = V' then
      V' = ChooseRedirect(ReduceProblem(p; V)) // stability
      ChooseRedirect(p; V') = V'               // idempotence
      ValidRedirect(p; V; V')                  // validity

// We should try and prove that the above definition is equivalent to one where we replace the 'validity' check
// with a meta-level soudness check (I'm not certain though)

Define ValidRedirect(p; V; V') iff
    empty not in dom(V') // If this weren't true, L[remove Csz] would be undefined
    V subseteq V'
    dom(V') = RedirectSet(p.top(); dom(V)) // TODO: Do we need this? Why?

    forall Cs.C1.C2 in dom(V'): V'(Cs.C1.C2) = V'(Cs.C1).C2
    forall Cs in dom(V'):
      V'(Cs)=p.minimize(V'(Cs))
      p|- Cs; V'(p[Cs]) >= V'(Cs); p[V'(Cs)]

Define p|- Cs; {interface? implements Pz mwtz, ncz} >= P; {interafce?' implements Pz' mwtz', ncz'}
  Pz subseteq_p Pz',P//Note: very important, so that F-bound polimoprhism can work
  if interface?=empty:
    forall MS in dom(mwtz): //Note: adding a method to an interface would break all implementer
      p |- mwtz'(MS).mt <= mwt(MS).mt
    if interface?' = interface then class not in mwtz.mdfz
  else:
    interface? = interface?'
    mwtz[with refine?s=empty] = mwtz'[with refine?s=empty]

  forall mwt in mwtz:
    mwt.e = empty
    not Private(mwt.m)

  forall C in dom(ncz)
    not Private(C)
--------------------------------------------
// Any other definition of this function would make a sane redirect!
Define ChooseRedirect(p; V1) = V2
  V2 is the unique V such that ValidRedirect(p; V1; V2) and
    for all V3 such that ValidRedirect(p; V1; V3),  p |- V2 > V3
  // i.e. V' is the unique 'greatest' valid redirection
--------------------------
Define p |- P1 < P2 iff
    p |- P1 <= P2
    p |/- P2 <= P1

distance(p, P1, P2) = 0
    p.equiv(P1, P2)

distance(p, P1, P2) = n
  n is the length of the longest non-empty path between P1 and P2, formed by using the 'p |- <' relation

distance(p, P1, P2) = distance(p, P2, P1)

====================================================
Definition for 'V' ordering

p |- V1 > V2 iff // i.e. V1 is strictly better than V2
  p |- V1 >= V2
  p |/- V2 >= V1

Define mwt.Pi = P'i
    where mwt.mt = mdf1 P'0 ... mdfn P'n -> mdf0 P'0; Pz

Define p |- V1 >= V2 // i.e. V1 is at least as good as V2
  for some ms, i, Cs, and Cs' // Note: Cs could be the same as Cs'
  p[This0.Cs'](ms).Pi = This0.Cs
  distance(p, p[V1(Cs')](ms).Pi, V2(Cs)) <= distance(p, p[V2(Cs')](ms).Pi, V2(Cs))

-----------------------------------------------
Define L[only Csz] = L' // Removes everything not in Csz

L[only Cs,Csz] = L[only Cs] U L[only Csz]
L[only empty] = {}
L[only C1...Cn] = {C1: ... {Cn: L(Cs)[with ncz = empty]} ... }

// U above is a 'dumb' sum, namely:
{Pz C1: L1 ... Cn: Ln Mz} U {interface? Pz' C1: L1' ... Cn: Ln' Mz'} = {interface? Pz Pz' C1: L1 U L1' ... Cn: Ln U Ln' Mz Mz'}
    dom(Mz) disjoint dom(Mz')

TODO: Remove everything bellow this line!
=====================================================
---------------------------------------------
Computability: thanks to RedirectSet we know the dom(V)
we can compute a part of the mapping by looking to method types.
All that is left is implements and exceptions
however, we can match, for example
A:{implements Cs1..Csn Ms} 
with the corresponding 
EB:{implements P1..Pk Ms'} 
by method names.
To pass, for each Csi there must be at least 1 Pi with (exactly) the same ms
in order to be still ambiguos:
there must be a P,P' in P1..Pk with the same ms.
For this to be the case, either there are interfaces with no methods
in Cs1..Csn or P must implement P' and P must add no methods
Thus, the only case where it may be hard is the degenerate case
of an interface without methods


A:{class method T m() exception A1,A2,A3}

EA:{class method T m() exception EA1,EA2}

A1:{}, A2: {}
A:{
  T m() exception A1  T f() exception A1, A2
}

EA: { 
  T m exception EA1 ...
  T f exception EA1 ...
}
EA1: {}

interface A {  }
interface B {  }
class C implements A,B{ }

interface EA {  }
interface EB {  }
class EC implements EA,EB{ }




EI1:{interface}
EI2:{interface implements EI1}

L={  
I1:{interface}
I2:{interface implements I1}
}[I2=EI2]
I2=EI2,I1=EI1
I2=EI2,I1=EI2


------

L: {A1: {interface implements A2, ..., An}
A2: {interface implements A3, ..., An}
...
An: {interface}
}

B1: {interface implements B2, ..., Bn}
B2: {interface implements B3, ..., Bn}
...
Bn: {interface}

L[A1 = B1]

================================//may be move in rename
L[PathRename Cs->Cs']p = V(L)
  V = collectV(p.evilPush(L); Cs->This0.Cs')

collectV(p; Cs->P, V) = collectV(p; Cs.C->P.C, Cs->P, V)
  Cs.C not in dom(V)
  C in dom(p(This0.Cs))
otherwise
  collectV(p; V) = V


-----------------------------------------------------------------------------------------
Kind of errors in current implementation
1 p.equiv
3 interface with different methods
2 ambiguity resolution with interface
1 exception spec coalscing...
1 self implementation

-----------------------------------------------------------------------------------------


Usefull examples that need to go in paper
---------------------
EA:{interface XX} 
EA2:{implements EA XX YY}
EC:{EA m()}
----
{
A:{XX} 
C:{ A m()}
}
C=EC
---------
one could redirect A=EA, and C=EC after
but C=EC is ambiguis A=EA or A=EA2
worst, there could me many "EA2" everywhere in the system; want EA

---------

EA2: {interface}
EA: {interface implements EA2}
EB: {EA foo()}

{A: {interface} B: {A foo()}}[ B = EB] // A = EA
---//Also good to go in paper, ambiguos EAA and EA, want EA
EAA: {interface +}
EA: {interface implements EAA  +}
EA1: {interface implements EA  +}
EA2: {interface implements EA  +}
EB: {EA1 foo() EA2 bar()}

{A: {MEAA} B: {A foo() A bar()}}[ B = EB] 
===========================
Common:{interface }
EAA1: {interface +}
EAA2: {interface +}
EA1: {interface implements EAA1 EAA2  +}
EA2: {interface implements EAA1 EAA2  +}
EB: {EA1 foo() EA2 bar()}
{A: {} B: {A foo() A bar()}}[ B = EB] 
//here we obviusly can not chose a best result between EAA1 and EAA2, however Common

one of the difficulties is the model of multiple subtyping
in java, I1 and I2 with same method can be both implementend, in C# too, and ....
for a clean reasoning.... 42



Define  p|-V1< V2

p |- V <= V

p |- V1 <= V1' 
p |- V2 <= V2'
-----------------------
p|- V1,V2 <= V1',V2'

case1: return type the same
p |- Cs->P1,Cs'->P1'<= Cs->P2
  This0.Cs=p.top()[Cs'].ms.T
  p[P1'].ms.T=P1
  
case2: param type the same
p |- Cs->P1,V<= Cs->P2,V
  This0.Cs =p.top()[Cs'].ms.Ts.i
  p[V(Cs')].ms.Ts.i=P1

case3: return type subtype
p |- Cs->P1,V<= Cs->P2,V
  This0.Cs =p.top()[Cs'].ms.T
  p[V(Cs')].ms.T=P
  not p.equiv(P,P1) and not p.equiv(P,P2)
  p|-P1<=P2

case4: param type supertype
p |- Cs->P1,V<= Cs->P2,V
  This0.Cs =p.top()[Cs'].ms.Ts.i
  p[V(Cs')].ms.Ts.i=P
  not p.equiv(P,P1) and not p.equiv(P,P2)
  p|-P1>= P2

-------------------

EB: {}
A: {EB foo C.Z bar}
C: {B: {} X:{B foo} Z: {}}[X=A]
C = {B: {}}

ValidR(p,V) iff
    dom(V) = RedirectSet(p.top(); dom(V)) // maybe unnecessary
    forall Cs in dom(V):
      V(Cs)=p.minimize(V(Cs))
      p|- Cs; V(p[Cs]) >= V(Cs); p[V(Cs)]

given a r function, we can preserve 1 by filtering the output with ValidR

r is a partial function from (p;V)->V'
such that 
  p.minimize(V)=V,
  p.minimize(V')=V'
  V'=V,_
  forall P in range(V'), p(P) is a well typed L

and V' = p.minimize(V')
we find redirect:r
0- redirect(p,redirect(p,V))=redirect(p,V)
1- if redirect(p,V')=V and p.pop()|-p.top():ok
   then p.pop()|-V(p.top()):ok
  // if redirect apply V on well typed L input, well typed result
2--Stability://formal after seams broken?
 if redirect(p,V')=V and p'=p[with p.top()[Css=Ls]] and Css disjoint dom(V)
 then redirect(p',V')=V
 //if redirect chose V on L, it would chose the same V on
 //L with different members not in dom(V), this would include privates
3 - minimilaty
  if r(p, V) = V' then dom(V') <= RedirectSet(p.top(); dom(V))

Fact--forall r' such that 0,1,2 holds, 
    forall V,V',p, if  r'(p;V) = V' then ValidR(V', p) holds
//this is an example showing why 2 is needed in Fact above
//{F: {class method Void bar()} ...}[F = Void]


UniqueR(p, V, V')
  true iff their is no V'' such that V <= V' and V'' != V' and validR(p, V')

possible rs satisfing 0,1,2,3

Singleton sets:
  0-r(p, V) is always undefined
  1- if r(p, V) = V', V = V'
  2- r(p, V) = V' IFF UniqueR(p, V, V') and 0,1,2,3

Infinite sets:
  3- if r(p, V) is undefined, their is no V' such that ValidR(p, V') and 0,1,2,3
    // always suceeds if possible
  4- if r(p, V) = V' then UniqueR(p, V, V') and not 2// weaker than 2
    // if it suceeds, the answer is unqiue
  5- if UniqueR(p, V, V') then r(p, V) = V' and not 2 and 1// stronger than 2
    // it always suceeds if their is a unique result
    // but solves some ambiguites
  5a- range(V') do not P out of thin air but rely on type mentioned in the targets
  6- other
    // sometimes it fails, even if their is a solution
    // and sometimes it resolves ambiguities but not always
