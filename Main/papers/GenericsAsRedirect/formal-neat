-------------
Module R: defines R, R(Cs)=P, R(L)=L', dom(R);
using auxiliary R_Cs(e)=e', R_Cs(T)=T', R_Cs(M)=M', R(Cs=L)=L'

R ::= (Cs->P)z // Redirection map
// A R is a methematical partial function from the set of Cs to the set of P

//______
//Define R.minimize(p)
//(Cs1->P1,...,Csn->Pn).minimize(p)=Cs1->p.minimize(P1), ..., Csn->p.minimize(Pn)

______
Define dom(R)
dom(Cs1->P1, ..., Csn->Pn) = Cs1, ..., Csn

______
Define R(Cs)=P
R(Cs) = P
  Cs->P in R // Cs renamed using R
______
// Apply R to all references to the class-names in dom(L)
// Note: this only applies to references (i.e. P's), the nested classes themselves (if present) are not redirected
Define  R(L)=R(empty=L) // Note: the top-level 'class' has no name, so we use 'empty'

// Note: that Ls found found inside expressions (i.e. es) have no names, whereas the RHS of a nested-class definition do
// However even an unanamed L may be inside a named L, and we need this information to understand what a path refers to.
// As such we will just geneerate fresh names for unnamaed Ls, thus simplifying things by giving all L's a name.

// We could also just use R_Cs(C: L) and R_Cs(L) to apply R to nested classes and L expressions (respectivley),
// however this general R(Cs = L) function prevents duplication, and so the above two just forward to it
_________
// Apply R to class 'Cs' which has body 'L'
// We need to keep track of the Cs since paths are relative, in order to know if they refer to something in dom(R)
// we need to know where the is
AuxDefine R(Cs = L)=L'

// Simply apply R to the Pz and Mz
R(Cs = {interface? implements Pz Mz}) = {interface? implements R_Cs(Pz) R_Cs(Mz)}

_________
// Apply R to a member M that was found in nested class Cs
AuxDefine R_Cs(M)=M'

// Case for methods, apply R to all types, paths and expressions
R_Cs(refine? mdf method T m(T1 x1,..,Tn xn) exception Pz e?) =
  refine? mdf method R_Cs(T) m(R_Cs(T1) x1,..,R_Cs(Tn) xn) exception R_Cs(Pz) R_Cs(e?)

// Case for nested classes, apply R to the library literal, giving it the appropriate name
R_Cs(C: L) = C: R(Cs.C = L) // Apply R to a nested class, which has name C and is in Cs
_________
// Apply R to an e, which was found in nested class Cs
AuxDefine R_Cs(e)=e'
R_Cs(L) = R(Cs.C = L), for fresh C
// TODO: Other kinds of expressions (just apply R_Cs to all e, L, T and P inside)

_________
AuxDefine R_Cs(T)=T'
// Apply R to a type, by just applying it to the mentioned path
R_Cs(mdf P) = mdf R_Cs(P)

_________
// Apply R to the path P that we found in Cs
// If a prefix of P refers to something in the domain of R, we will redirect it
// Otherwise we will leave it untouched
AuxDefine R_Cs(P)=P' // P found in Cs is renamed to P'

// We found P in Cs (of length k), so give it to R (which is defined relative to This0, but we are in This0.Cs)
// and from the result (since the start, This0, is actually Thisk from the point of view of This0.Cs,
// which is where we found the original P)
R_Cs(P) = R(Cs')[from Thisk]
    where Cs = C1...Ck
    P[from This0.CS] = This0.Cs'

otherwise
R(P in Cs) = P

// Csz' is the set of nested class names that will be redirected when all the Csz are redirected from L
// It is the transitive closure of apply 'Reachables' to each class mentioned in Csz
Define RedirectSet(L; Csz)=Csz':
-----------------------------
// If we are redirecting Csz, then we need to redirect Csz
Csz subseteq RedirectSet(L; Csz)

// Redirect the nested class mentioned in the signature of a redirected class
// We won't however be redirecting references to external paths (i.e. things outside of This0)
Internal(Reachables(L[Cs1])) subseteq RedirectSet(L; Csz)
  Cs1 in RedirectSet(L; Csz)
  // TODO: Do a p.minimize?

==================================================================
// Perform and compute a redirect, using a choice function 'ChooseRedirect' to compute the R mapping
Define Redirect(p; L; Cs1, P1, ..., Csn, Pn) = R(p'.top()[remove Csz]) // Remove the things that will be redirected away
  empty not in Cs1 ... Csn // We can't redirect This0, as that does not make sense
  p' = p.evilPush(L) // to simplify everything, just make L the new top
  Redirectable(RedirectSet(L, Cs1, ..., Csn); L) // Check that the source is valid

  // Chose a mapping, simplifying the input, and update the paths to be relative to our evil-pushed program
  ChooseRedirect(p'; Cs1, p'.minimize(P1[from This1]), ..., Csn, p'.minimize(Pn[from This1])) = R

Required properties of a ChooseRedirect function:
ChooseRedirect is a function from p*R->R' such that
  ChooseRedirect(p,R')=R'
  forall p' ~R~ p: ChooseRedirect(p',R)=R'
  ValidRedirect(p,R')
  // We should try and prove that the above definition is equivalent to one where we replace the ValidRedirect check
  // with a meta-level soudness check (I'm not certain though)
______
Define ValidRedirect(p,R,R')
  R subseteq R'
  dom(R') = RedirectSet(p.top(); dom(R))
  forall P in ran(R'):
    p.minimize(P)=P
    P not of form This0._
    p|-p[P]:OK //P well typed
  forall Cs in dom(R'):
    p|- R'(Cs); p[R'(Cs)] <= Cs; R'(p[Cs])
  Redirectable(dom(R'); p.top())

// Whether the class This0.Cs can be redirected away
// Namely: that the class contains no implemented methods or anything private
Define Redirectable(Csz; L)
  forall Cs in Csz
    Cs not empty
    forall C in Cs: not Private(Cs)
    forall mwt in L[Cs].mwtz:
        mwt.e = empty
        not Private(mwt.m)

    forall C in dom(L[Cs])
        Cs.C in Csz

// Is the LHS (whose name is 'This0.Cs') a structural supertype of the RHS (whose name is P)
// We say that A is a structural supertype of B if any code written with respect to A
// would also type-check against B
Define p|- P; {interafce?' implements Pz' mwtz', ncz'} <= Cs; {interface? implements Pz mwtz, ncz}
  // Check that all the interfaces the LHS implements are also implemented by the RHS
  p.minimize(Pz) subseteq SuperClasses(p; P) //Note: Using SuperClasses (and not Pz') is very important, so that F-bound polimoprhism can work TODO: explain what this means

  // If the LHS is not an interface
  if interface?=empty:
    // Check that each method-type of the RHS is a subtype of the LHS
    // (So that it any well-typed call to a method on the LHS would also typecheck if it were to call a method on the RHS)
    forall MS in dom(mwtz):
      p |- mwtz'(MS).mt <= mwt(MS).mt

    // One can only call class methods on a non-interface, so if the LHS has any, than the RHS can't be an interface
    if interface?' = interface then class not in mwtz.mdfz

  // If the LHS is an interface, we need to ensure that any valid implementation of the LHS
  // Is a valid implemention of the RHS, which requires that the RHS have the exact same method signatures as the LHS
  else:
    interface? = interface?' // You can't implement non-interfaces
    // We ignore the presence of the 'refine' keyword, since this is irealvent to any implementing classes
    mwtz[with refine?s=empty] = mwtz'[with refine?s=empty] // TODO: A p.equiv!!

--------------------------------------------

p' ~R~ p  iff  ReduceProblem(p; R)=ReduceProblem(p'; R)
ReduceProblem(p; R) = p[only This0.Cs1, ..., This0.Csn, ReachableSet(p; ran(R))]
    Cs1, ..., Csn = RedirectSet(p.top(); dom(R))

// The set of paths referenced in the signatures of each P, L and mwt (excluding nested classes)
Define Reachables(p; P) = Pz, Reachables(L) = Pz, Reachables(Mz) = Pz
-----------------------------------------------------------------------
// Find's all paths that are reachable from the declaration of 'P' in p
// (i.e. ignoring methods bodies and meta-expressions)
ReachableSet(p; Pz):
    Pz subseteq ReachableSet(p; Pz)
    Pz' subseteq ReachableSet(p; Pz)
        P in ReachableSet(p; Pz)
        Pz' = p.minimize(Paths(p[P]))

Reachables({interface? implements Pz Mz}) = Pz, Paths(Mz)
Reachables(C: L) = Paths(L)[from This0.C]
Reachables(mwt) = mwt.mt.Ts.Ps, mwt.mt.T.P, mwt.mt.Pz

Define p[only Pz] = p', and L[only Pz]=L'
-----------------------------------------------
// I don't know a 42 equivalent formalisim, but who cares...
(id = L, p)[only Pz] = (id = L[only Internals(Pz)], p[only (Pz[from This0.ToC(id)])])
(empty; DVs)[only Pz] = (empty; DVs[only Pz])

(C = LV)[only Pz] = (C = LV[only Pz[From This]])
    This0.C.Cs in Pz // Something inside C is to be kept, so we need C

(DV)[only Pz] = empty
    otherwise // A trait, or a class that is to be discareded

ToC(C) = C
ToC(t) = CF
    for fresh C

L[only Cs,Csz] = L[only Cs] U L[only Csz]
L[only empty] = {}
// Discard method bodies!, we don't want people looking in them, or do we?
L[only C1...Cn] = {C1: ... {Cn: L(Cs)[with ncz = empty, with mwtz.ez = empty]} ... }
------------------------
// Returns all the nested classes that are accesed from This0 (works best if Pz is minimized)
Define Internal(Pz) = Csz
    Internal(This0.Cs, Pz) = Cs, Internal(Pz)
    Internal(P, Pz) = Internal(Pz)
        otherwise

// U above is a 'dumb' sum, namely:
{interface?1 Pz C: L ... Cn: Ln Mz} U {interface?2 Pz' C1: L1' ... Cn: Ln' Mz'} =
        {interface?1 U interface?2 Pz Pz' C1: L1 U L1' ... Cn: Ln U Ln' Mz Mz'}
---------------------------------------
//// TODO: Check we are the new R4...
// TODO: Special rules for redirecting to Any?
// TODO: Handle exception clauses (BUT DON't complicate anything unrelated)

// Note: I do not assume that all paths mentioned in a CCz have been p.minimized

// Note: the 'interface' constraint currently only benifits early error detection, as we can't use it to infer any more constraints (or can we?)

CCInit(Cs1->P1, ..., Csn->Pn) = Cs1 <= P1, P1 <= Cs1, ..., Csn <= Pn, Pn <= Csn

ChooseRedirect(p; R) = ChooseR(p; CollectAll(p; CCInit(R)))

CC ::= Cs <= P | P <= Cs

MustInterface(p; Cs) = p(Cs).interface? = interface
MustClass(p; Cs) = p(Cs).interface? = empty and class in p(Cs).mwtz.mdfZ

// CollectAll is the main function that collects all constraints
CollectAll(p; CCz,CCz') := CollectAll(p; CCz'')
  CCz'' = (CCz, CCz') U Collect(p; CCz)
  CCz'' != CCz,CCz'
CollectAll(p; CCz) := CCz
  Otherwise

Define p[P.ms] = p[P](ms)
Define p[Cs.ms] = p[This0.Cs.ms]
Define mwt.P = mwt.mt.T.P
Define mwt.Pi = mwt.mt.Ts.i.P

Define mwt.Cs = Cs
  This0.Cs = mwt.mt.T.P
Define mwt.Csi = Cs
  This0.Cs = mwt.mt.Ts.i.P
Define L.Csz = Internal(L.Pz)


// Note: Collect isn't a function, but a relation,
// I.e. Collect(p; CCz) = Ccz' for multiple different CCz' (even with the same p; CCz)
Define Collect(p; CCz) := CCz':
1: Collect(p; Cs <= P) = P <= Cs
    p[P].interface = empty //since all classes are final

3a: Collect(p; P <= Cs) = MostSpecific(p; Pz) <= Cs'
    Cs' in p[Cs].Csz
    Pz = {P' in SuperClasses(p; P) | PossibleTarget(p; Cs; P')}

3b: Collect(p; P <= Cs) = Cs' <= MostGeneral(p; Pz)
    Cs' in p[Cs].Csz
    Pz = {P' in SuperClasses(p; P) | PossibleTarget(p; Cs; P')}

3c: Collect(p; P <= Cs, Cs' <= P') = Cs <= P' // TODO: Proove this is neccessary
    Cs' in p[Cs].Pz

3d: Collect(p; P <= Cs) = P <= Cs'
    Cs' in p[Cs].Pz


4: Collect(p; P <= Cs) = p[P.ms].P <= p[Cs.ms].Cs
5: Collect(p; CC) = p[Cs.ms].Csi <= p[P.ms].Pi
     CC = P <= Cs or  CC = Cs <= P

6: Collect(p; Cs <= P) = p[Cs.ms].Cs <= p[P.ms].P:
    MustInterface(p; Cs)

7: Collect(p; Cs <= P) = p[P.ms].Pi <= p[Cs.ms].Csi:
    MustInterface(p; Cs)

  // The ? rules
8a:  Collect(p; Cs <= P) = P' <= p[Cs.sel].Cs
    P' = p[P.sel].P
    p[P'].interface?=empty

8d:  Collect(p; Cs <= P) = Cs' <= Origin(p; sel'; P')
    Cs' = p[Cs.sel].Cs
    P' = p[P.sel].P
    sel' in dom(p[Cs']) intersect dom(p[P'])

8'd:  Collect(p; Cs <= P) = Cs' <= Origin(p; sel'; P') // TODO: Proove this is neccessary
    Cs' in p[Cs].Pz
    P' in SuperClasses(p; P)
    sel' in dom(p[Cs']) intersect dom(p[P'])

11a: Collect(p; CCz) = Cs <= P  // TODO: Prove this is neccessary
    RChoices(p; CCz; Cs) = {P}

11b: Collect(p; CCz) = MostSpecific(p; Pz) <= Cs   // TODO: Prove this is neccessary
    RChoices(p; CCz; Cs) = Pz

R satisfies_p CC1,...,CCn iff
    R satisfies_p CC1
    ...
    R satisfies_p CCn

R satisfies_p Cs <= P iff p |- R(Cs) <= P
R satisfies_p P <= Cs iff p |- P <= R(Cs)

SatisfiedRedirect(p; R0; R) iff R satisfies_p CollectAll(p; CCInit(R0)) && PossibleRedirect(p; R0; R)

UniqueR(p; R1) = R2: iff forall p' superset p, R2 = MostSpecific(p'; {R | ValidRedirect(p'; R1; R)})


ChosenR(p; R1) = R2: iff  forall p' superset p, R2 = MostSpecific(p'; {R | SatisfiedRedirect(p'; R1; R)})

----------------------------------------
TOO Proove:
* Our ChooseRedirect == ChosenR:
    just proove that ChooseR(p; CCz) = R2 iff
        forall p' superset p, R2 = MostSpecific(p'; {R | satisfies_p CCz && PossibleRedirect(p; R0; R)})


* forall p,R1,R: SatisfiedRedirect(p; R1; R) ==> ValidRedirect(p; R1; R) // Hard, might not be true
* forall p,R1,R: ValidRedirect(p; R1; R) ==> SatisfiedRedirect(p; R1; R) //easy and true


Therefore ChooseRedirect == UniqueR
-----------------------------------------------------

Origin(p; sel; P) = P'
  forall P'' in Supertypes(p; P) where sel in dom [P'']
     p |- P'' <= P'

Auxilary: SuperClasses(p; Pz) = intersect {p.minimize(p[P].Pz U {P, Any}) | P in Pz}

MostSpecific(p; Pz) = P
   P in p.minimize(Pz)
   p.minimize(Pz) subseteq SuperClasses(p; P)
   // Note: P will be unique in terms of p.equiv, since any other solution P' is in Pz
   // so P' in SuperClasses(p; P), and since P in Pz, P in SuperClasses(p; P')
   // Thus P <= P', and P' <= P

MostGeneral(p; Pz) = P
   {P} = SuperClasses(p; Pz) intersect p.minimize(Pz)

Define ChooseR(p; CCz) := R
   Cs1 -> MostSpecific(p; RChoices(p; CCz1))
   ...
   Csn -> MostSpecific(p; RChoices(p; CCzn))

// forall p, CCz, Cs
// If exists Pz such that forall p' supereset p: {P | Cs->P satisfies CCz} = Pz
//    then RChoices(p; CCz; Cs) = Pz
// Otherwise, RChoices(p; CCz; Cs) is undefined

RChoices(p; CCz, CCz'; Cs) = RChoices(p; CCz)
  P <= Cs in CCz
  Cs <= P not in CCz'
  P <= Cs not in CCz'

RChoices(p; P1 <= Cs, ..., Pn <= Cs, Cs <= P'1, ..., Cs <= P'k) = Pz''
    Pz = SuperClasses(p; P1, ..., Pn) // This internally does a p.minize, and so Pz'' will also be p.minized
    Pz' = {P in Pz | {P'1, ..., P'k} subseteq SuperClasses(p; P)}
    Pz'' = {P in Pz' | PossibleTarget(p; Cs; P)}

// Could Cs be redirected to P? (ignoring any other redirections that may or may not happen...)

CheckRedirect(p; Cs1->P1, ..., Csn->Pn) iff
    forall P in P1..Pn:
      p.minimize(P)=P
      P not of form This0._
      p|-p[P]:OK //P well typed //by construction in L42
    Redirectable(Cs1, ..., Csn; p.top())  

PossibleResult(p; Cs1->P1, ..., Csn->Pn; R) iff
    R0 subseteq R
    dom(R) = RedirectSet(p.top(); dom(R0))
    forall P in P1..Pn:
      p.minimize(P)=P
      P not of form This0._
      p|-p[P]:OK //P well typed //by construction in L42
    Redirectable(Cs1, ..., Csn; p.top())
    // TODO: Proove our algorith ensures this!

PossibleTargets(p; Cs1->P1, ..., Csn->Pn) iff
    PossibleTarget(p; Cs1; P1)
    ...
    PossibleTarget(p; Csn; Pn)

PossibleTarget(p; Cs; P) iff
    L1 = p[Cs]
    L2 = p[P]

    MustClass(p; Cs) --> L2.interface? = empty
    MustInterface(p; Cs) --> L2.interface? = interface

    msdom(L1) subseteq msdom(L2)
    MustInterface(p; Cs) --> msdom(L2) subseteq msdom(L1)

    p.minimize({P' in L1.Pz | P' not of form This0.Cs}) subseteq SuperClasses(p; P)
    forall ms in msdom(L1):
      p |- L2(ms).mt <~ L1(ms).mt //method subtyping ignoring internal paths
      MustInterface(p; Cs) --> p |- L1(ms).mt <~ L2(ms).mt


p |- P <~ P' iff p |- P <= P' //todo define internal(P)
    P not of form This0.Cs
    P' not of form  This0.Cs

p |- P <~ P'
    otherwise

p |- T <~ T' iff
    T.mdf <= T'.mdf
    p |- T.P <~ T.P'

p |- mdf T1,...,Tn->T'0; Pz <= mdf' T'1,...,T'n->T0; Pz'
    mdf' <= mdf
    p |- T'0 <~ T0   ...   p |- T'n <~ Tn
    forall P in Pz:
        exists P' in Pz' such that p |- P <~ P'

-------------------------------------------------------------------------------------------------
// Some classes of ChooseRedirect functions

UniqueR(p, R1) = R2
  forall p' ~R1~ p, R2 = MostSpecific(p'; {R | ValidRedirect(p'; R1; R)})
  forall p' superset p, R2 = MostSpecific(p'; {R | ValidRedirect(p'; R1; R)})

define MostSpecific(p; Rz) = R //for the proof, make it call the other MostSpecific
  R in Rz,
  forall Cs in dom(R), R' in Rz:
    p |- R(Cs) <= R'(Cs)

R0: always undefined

R1: r(p, R) = R' IFF R = R' and ValidRedirect(p; R; R)// assert ValidRedirect(ReduceProblem(p; R); R; R)

R2: if r(p, R) = R' then R' = UniqueR(p, R) and not R3// weaker than 3
  // if it suceeds, the answer is unqiue

R3: r(p; R) = UniqueR(p, R) // what we now want?

R4: if UniqueR(p, R) = R' then r(p, R) = R'
  // it always suceeds if their is a unique result but solves some ambiguites
  // same as if r(p, R) is undefined, exists a p' ~R~p such that there is no *unique* R' such that ValidRedirect(p',R, R')

------------------
==================
For nested classes and exceptions?


// Here Csz is the redirect set
9:  Collect(p; Csz; Cs <= P, P <= Cs) = Cs.C <= P.C, P.C <= Cs.C
    C in dom(p[Cs])
10: Collect(p; Cs,Csz; Cs.C <= P.C, P.C <= Cs.C) = Cs <= P, P <= Cs


// TODO: Do something with exception specs,
// Specifically if we define:
//   p |- Pz throws Pz' iff
//     forall P in Pz: SuperClasses(p; P) intersects Pz'
// Then:
//    p |- R(p[Cs.ms].Pz) throws p[R(Cs).ms].Pz
//    if p |- P <= P', then p |- p[P.ms].Pz throws p[P'.ms].Pz


Apply CompleteR(p;..) to the result of ChooseR

CompleteR(p; Cs -> P, R') = Cs->P, CompleteR(p; Cs.C1 -> P.C1, ..., Cs.Cn -> P.Cn, R')
    {C1, ..., Cn} = { C in dom(p[Cs]) | p[P.C] is defined }

In ValidRedirect:
  forall C in dom(p(Cs)): R'(Cs.C) = R'(Cs).C

In PossibleTarget:
  forall C in dom(p[Cs]): C in dom(p[P]) and PossibleTarget(p; Cs.C; P.C)

=========================
CollectTop(p; R) = CollectAll(p; CCInit(R))

//SatisfiedRedirect(p; R0; R)  iff R satisfies_p CollectAll(p; CCInit(R0)) && PossibleRedirect(p; R)
SatisfiedRedirect(p; R0; R) iff SatisfiedRedirect1(p; CollectTop(p; R0); R) 
SatisfiedRedirect1(p; CCz; R) iff R satisfies_p CCz && PossibleTargets(p; R) && PossibleResult(p; R0; R)


  ChooseRedirect1(P; CCz1,..,CCzn) =
    Cs1 -> MostSpecific(p; RChoices(p; CCz1)) //RChoices taks the section of CCz with singleton Cs1
    ..
    Csn -> MostSpecific(p; RChoices(p; CCzn))

alias ChooseRedirect1=ChooseR
ChooseRedirect(p; R) = ChooseRedirect1(p; CollectTop(p; R))

ChosenR(p; R) = ChosenR1(p; CollectTop(p; R))

ChosenR1(p; CCz) = R2: iff  forall p' superset p, R2 = MostSpecific(p'; {R | SatisfiedRedirect1(p';
  CCz; R)})

UniqueR(p; R1) = R2: iff forall p' superset p, R2 = MostSpecific(p'; {R | ValidRedirect(p'; R1; R)})



Proof that ChooseRedirect == UniqueR
Forall p and R, (such that p is 'valid'?, R is well-formed, and CheckRedirect(p; R))
1. ChooseRedirect == ChosenR
1a. Proof: If CCz = CollectTop(p; R)
    then ChosenR1(p; CCz) == ChooseRedirect1(p; CCz) since the rest is the same
     // hard part of this proof?
        // proving that ChosenRedirect1 --> PossibleResult // 2nd hardest part!
        // the forall p' superset p, MostSpecific... bullshit, is the same as our MostSpecific(p; Pz) thing...
          // Proving that its ok to ignore it when their are no P <= Cs constraints....

  

2. SatisfiedRedirect == ValidRedirect
  2a. SatisfiedRedirect ==> ValidRedirect // Hard
  2b. ValidRedirect ==> SatisfiedRedirect // Easy




//CCz implies_p CCz' iff forall P: P satisfies CCz --> P satisfies CCz'
(TODO: Talk about infinite programs)

================================================
