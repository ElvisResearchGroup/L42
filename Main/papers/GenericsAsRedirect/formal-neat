------------- // TODO: Change V to 'R' ? Or perhaps 'M'?
Module V: defines V, V(Cs)=P, V(L)=L', dom(V);
using auxiliary V_Cs(e)=e', V_Cs(T)=T', V_Cs(M)=M', V(Cs=L)=L'

V ::= (Cs->P)z // Redirection map
// A V is a methematical partial function from the set of Cs to the set of P

//______
//Define V.minimize(p)
//(Cs1->P1,...,Csn->Pn).minimize(p)=Cs1->p.minimize(P1), ..., Csn->p.minimize(Pn)
 
______
Define dom(V)
dom(Cs1->P1, ..., Csn->Pn) = Cs1, ..., Csn

______
Define V(Cs)=P 
V(Cs) = P
  Cs->P in V // Cs renamed using V
______
// Apply V to all references to the class-names in dom(L)
// Note: this only applies to references (i.e. P's), the nested classes themselves (if present) are not redirected
Define  V(L)=V(empty=L) // Note: the top-level 'class' has no name, so we use 'empty'

// Note: that Ls found found inside expressions (i.e. es) have no names, whereas the RHS of a nested-class definition do
// However even an unanamed L may be inside a named L, and we need this information to understand what a path refers to.
// As such we will just geneerate fresh names for unnamaed Ls, thus simplifying things by giving all L's a name.

// We could also just use V_Cs(C: L) and V_Cs(L) to apply V to nested classes and L expressions (respectivley),
// however this general V(Cs = L) function prevents duplication, and so the above two just forward to it
_________
// Apply V to class 'Cs' which has body 'L'
// We need to keep track of the Cs since paths are relative, in order to know if they refer to something in dom(V)
// we need to know where the is
AuxDefine V(Cs = L)=L'

// Simply apply V to the Pz and Mz
V(Cs = {interface? implements Pz Mz}) = {interface? implements V_Cs(Pz) V_Cs(Mz)}
  
_________
// Apply V to a member M that was found in nested class Cs
AuxDefine V_Cs(M)=M'

// Case for methods, apply V to all types, paths and expressions
V_Cs(refine? mdf method T m(T1 x1,..,Tn xn) exception Pz e?) =
  refine? mdf method V_Cs(T) m(V_Cs(T1) x1,..,V_Cs(Tn) xn) exception V_Cs(Pz) V_Cs(e?)

// Case for nested classes, apply V to the library literal, giving it the appropriate name
V_Cs(C: L) = C: V(Cs.C = L) // Apply V to a nested class, which has name C and is in Cs
_________
// Apply V to an e, which was found in nested class Cs
AuxDefine V_Cs(e)=e'
V_Cs(L) = V(Cs.C = L), for fresh C
// TODO: Other kinds of expressions (just apply V_Cs to all e, L, T and P inside)

_________
AuxDefine V_Cs(T)=T'
// Apply V to a type, by just applying it to the mentioned path
V_Cs(mdf P) = mdf V_Cs(P)

_________
// Apply V to the path P that we found in Cs
// If a prefix of P refers to something in the domain of V, we will redirect it
// Otherwise we will leave it untouched
AuxDefine V_Cs(P)=P' // P found in Cs is renamed to P'

// We found P in Cs (of length k), so give it to V (which is defined relative to This0, but we are in This0.Cs)
// and from the result (since the start, This0, is actually Thisk from the point of view of This0.Cs,
// which is where we found the original P)
V_Cs(P) = V(Cs')[from Thisk]
    where Cs = C1...Ck
    P[from This0.CS] = This0.Cs'

otherwise
V(P in Cs) = P

// Csz' is the set of nested class names that will be redirected when all the Csz are redirected from L
// It is the names of the nested classes transitivley mentioned in the 'signature' of each Csz
Define RedirectSet(L; Csz)=Csz':
-----------------------------
// If we are redirecting Csz, then we need to redirect Csz
Csz subseteq RedirectSet(L; Csz)

// Redirect the nested classes of redirected classes
Cs1.C in RedirectSet(L; Csz)
  Cs1 in RedirectSet(L; Csz)
  C in dom(L[Cs1])

// Redirect the nested class mentioned in the signature of a redirected class
// We won't however be redirecting references to external paths (i.e. things outside of This0)
Cs2 in RedirectSet(L; Csz)
  Cs1 in RedirectSet(L; Csz)
  This0.Cs2 in Paths(L[Cs1])[from This0.Cs1] // TODO: Do a p.minimize?

// The set of paths referenced in the signatures of L and mwt (excluding nested classes)
Define RedirectPaths(L) = Pz, RedirectPaths(mwt) = Pz
-----------------------------------------------------------------------
// The set of implemented interfaces
RedirectPaths({interface? implements Pz mwtz ncz}) = Pz, RedirectPaths(mwtz)

// The set of paths used in the type of a method
RedirectPaths(mwt) = Ts.Ps, T.P, Pz
  mwt.mt = Ts->T;Pz

==================================================================
// Perform and compute a redirect, using a choice function 'ChooseRedirect' to compute the V mapping
Define Redirect(p; L; Cs1, P1, ..., Csn, Pn) = V(p'.top()[remove Csz]) // Remove the things that will be redirected away
  empty not in Cs1 ... Csn // We can't redirect This0, as that does not make sense
  p' = p.evilPush(L) // to simplify everything, just make L the new top
  forall Cs in RedirectSet(L, Cs1, ..., Csn):
    Redirectable(L[Cs]) // Check that the source is valid

  // Chose a mapping, simplifying the input, and update the paths to be relative to our evil-pushed program
  ChooseRedirect(p'; Cs1, p'.minimize(P1[from This1]), ..., Csn, p'.minimize(Pn[from This1])) = V

Required properties of a ChooseRedirect function: 
ChooseRedirect is a function from p*V->V' such that
  ChooseRedirect(p,V')=V'
  forall p' ~V~ p: ChooseRedirect(p',V)=V'
  ValidRedirect(p,V')
  // We should try and prove that the above definition is equivalent to one where we replace the ValidRedirect check
  // with a meta-level soudness check (I'm not certain though)
______
Define ValidRedirect(p,V,V')
  V subseteq V'
  dom(V') = RedirectSet(p.top(); dom(V))
  forall P in ran(V'):
    p.minimize(P)=P 
    P not of form This0._
    p|-p(P):OK //P well typed
  forall Cs in dom(V'):
    Cs not empty
    p|- Cs; V'(p[Cs]) >= V'(Cs); p[V'(Cs)]
    forall C in dom(p(Cs)): V'(Cs.C) = V'(Cs).C
    Redirectable(p.top()(Cs))

// Whether the class This0.Cs can be redirected away
// Namely: that the class contains no implemented methods or anything private
Define Redirectable(L) // L42 only
  forall mwt in L.mwtz:
    mwt.e = empty
    not Private(mwt.m)

  forall C in dom(L.ncz)
    not Private(C)

// Is the LHS (whose name is 'This0.Cs') a structural supertype of the RHS (whose name is P)
// We say that A is a structural supertype of B if any code written with respect to A
// would also type-check against B
Define p|- Cs; {interface? implements Pz mwtz, ncz} >= P; {interafce?' implements Pz' mwtz', ncz'}
  // Check that all the interfaces the LHS implements are also implemented by the RHS
  Pz subseteq_p Pz',P //Note: The P on the RHS very important, so that F-bound polimoprhism can work TODO: explain what this means

  // If the LHS is not an interface
  if interface?=empty:
    // Check that each method-type of the RHS is a subtype of the LHS
    // (So that it any well-typed call to a method on the LHS would also typecheck if it were to call a method on the RHS)
    forall MS in dom(mwtz):
      p |- mwtz'(MS).mt <= mwt(MS).mt

    // One can only call class methods on a non-interface, so if the LHS has any, than the RHS can't be an interface
    if interface?' = interface then class not in mwtz.mdfz

  // If the LHS is an interface, we need to ensure that any valid implementation of the LHS
  // Is a valid implemention of the RHS, which requires that the RHS have the exact same method signatures as the LHS
  else:
    interface? = interface?' // You can't implement non-interfaces
    // We ignore the presence of the 'refine' keyword, since this is irealvent to any implementing classes
    mwtz[with refine?s=empty] = mwtz'[with refine?s=empty]

--------------------------------------------




p' ~V~ p  iff  ReduceProblem(p; V)=ReduceProblem(p'; V)
ReduceProblem(p; V) = p.updateTop(p.top()[only RedirectSet(p.top(); dom(V))])[only Reachables(ran(V)]

// TODO: Define Reachables(p; Pz)
// TODO: Define p[only Pz]

// Auxilarry operation used by the above
Define L[only Csz] = L' // Removes everything not in Csz

L[only Cs,Csz] = L[only Cs] U L[only Csz]
L[only empty] = {}
L[only C1...Cn] = {C1: ... {Cn: L(Cs)[with ncz = empty]} ... }

// U above is a 'dumb' sum, namely:
{interface?1 Pz C: L ... Cn: Ln Mz} U {interface?2 Pz' C1: L1' ... Cn: Ln' Mz'} =
        {interface?1 U interface?2 Pz Pz' C1: L1 U L1' ... Cn: Ln U Ln' Mz Mz'}
---------------------------------------
//// TODO: Check we are the new R4...
// TODO: Special rules for redirecting to Any?
// TODO: Handle exception clauses (BUT DON't complicate anything unrelated)

// Note: I assume that all paths mentioned in a CCz have been p.minimized
// Note: the 'interface' constraint currently only benifits early error detection, as we can't use it to infer any more constraints (or can we?)

ChooseRedirect(p; V) = V'
  CCz = CollectAll(p; InitiliseCCz(p; V))
  V' = ChooseV(p; CCz) 
  ValidRedirect(p; V; V') // TODO: Do something more efficient?

CC ::= Cs <= P | P <= Cs | Cs in Pz | interface Cs 
   | class Cs | Cs.MS <= mt //p |- V(Cs)(Ms).mt <= V(mt)

InitiliseCCz(p; V) := CCz // TODO: Define this, just use the defintion of ValidRedirect

// CollectAll is the main function that collects all constraints
CollectAll(p; CCz,CCz') := CollectAll(p; CCz'')
  CCz'' = (CCz, CCz') U Collect(p; CCz)
  CCz'' != CCz,CCz'
CollectAll(p; CCz) := CCz
  Otherwise

// Note: Collect isn't a function, but a relation,
// I.e. Collect(p; CCz) = Ccz' for multiple different CCz' (even with the same p; CCz)

Define Collect(p; CCz) := CCz':
  Collect(p; Cs <= P) = P <= Cs
    p[P].interface = empty //since all classes are final
  Collect(p; P <= Cs, class Cs) = Cs <= P
  Collect(p; Cs in P,Pz) = Cs <= P
    dom(p[Cs].mwtz) intersect dom(p[P].mwtz) != empty
  Collect(p; Cs.ms <= mt, Cs <= P) = Cs' <= p.minimize(P')
    mt.Ts.i.P = This0.Cs'
    p[P](ms).mt.Ts.i = _ P'
  Collect(p; Cs.ms <= mt, Cs <= P) = p.minimize(P') <= Cs'
    mt.T.i = _ This0.Cs'
    p[P](ms).mt.T= _ P
  Collect(p; Cs <= P, P <= Cs) = Cs.C <= p.minimize(P.C), p.minimize(P.C) <= Cs.C 
    //TODO: is unclear if minimize needed: can wwe be in This1.C
    C in dom(p[Cs])
  Collect(p; Cs <= P) = Cs.MS <= p.minimize(p[P](MS).mt)
    // TODO: define p.minimize(mt), the definition should be obvious
    // Only usefull if we can refine method types when implementing an interface
    MS in dom(p[Cs])

Auxilary: 
Supertypes(p; Pz) = intersect {p.minimize(p[P].Pz U {P}) | P in Pz} // TODO: include 'any'?

MostSpecific(p; Pz) = P
   P in Pz
   Pz subseteq Supertypes(p; P)
   // Note: P will be unique in terms of p.equiv, since any other solution Pj
  // must satisfy Pj <= Pi, and Pi <= Pj (since Pi is also a solution)


Define ChooseV(p; CCz) := V
  // Note: these definitions use well-formdness of V's, namely V1, V2 is ill-formed
  // if dom(V1) and dom(V2) are not disjoint, thus only one rule below can be applied
  // for each Cs

 ChooseV(p; Cs <= P0, ..., Cs <= Pn, CCz) := Cs -> P, ChooseV(p; CCz) 
    P = MostSpecific(p; P0,...,Pn)

  ChooseV(P; P1 <= Cs, ..., Pn <= Cs, Cs <= P'1, ..., Cs <= P'k, CCz), Cs -> P, ChooseV(p; CCz)
    Pz = Supertypes(p; P1, ..., Pn)
    Pz' = { P in Pz | {P'1, ..., P'k} subseteq Supertypes(p; P)} 
    // if k = 0, then Pz' = Pz
    // Pz' is the set of possible solutions
    P = MostSpecific(p; Pz')
  
   ChooseV(p; CCz) = empty
     otherwise

--------------------------
// Some classes of ChooseRedirect functions

UniqueR(p, V1) = V2
  forall p' ~V~ p, V2 is the unique V such that ValidRedirect(p'; V1; V2)

R0: always undefined

R1: r(p, V) = V' IFF V = V' and ValidRedirect(p; V; V)// assert ValidRedirect(ReduceProblem(p; V); V; V)

R2: if r(p, V) = V' then V' = UniqueR(p, V) and not R3// weaker than 3
  // if it suceeds, the answer is unqiue

R3: r(p; V) = UniqueR(p, V)

R4: if UniqueR(p, V) = V' then r(p, V) = V'
  // it always suceeds if their is a unique result but solves some ambiguites
  // same as if r(p, V) is undefined, exists a p' ~V~p such that there is no *unique* V' such that ValidRedirect(p',V, V')

------------------
