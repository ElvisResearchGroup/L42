-------------
Module V: defines V, V(Cs)=P, V(L)=L', dom(V);
using auxiliary V_Cs(e)=e', V_Cs(T)=T', V_Cs(M)=M', V(Cs=L)=L'

V ::= (Cs->P)z // Redirection/renaming map

//______
//Define V.minimize(p)
//(Cs1->P1,...,Csn->Pn).minimize(p)=Cs1->p.minimize(P1), ..., Csn->p.minimize(Pn)
 
______
Define dom(V)
dom(Cs1->P1, ..., Csn->Pn) = Cs1, ..., Csn

______
Define V(Cs)=P 
V(Cs) = P
  Cs->P in V // Cs renamed using V

______
Define  V(L)=V(empty=L) // Apply V to L

_________
AuxDefine V(Cs = L)=L'  // Apply V to L, where L is named Cs
V(Cs = {interface? implements Pz Mz}) = {interface? implements V_Cs(Pz) V_Cs(Mz)}
  
_________
AuxDefine V_Cs(M)=M'

V_Cs(refine? mdf method T m(T1 x1,..,Tn xn) exception Pz e?) =
  refine? mdf method V_Cs(T) m(V_Cs(T1) x1,..,V_Cs(Tn) xn) exception V_Cs(Pz) V_Cs(e?)
V_Cs(C: L) = C: V(Cs.C = L) // Apply V to a nested class, which has name C and is in Cs
_________
AuxDefine V_Cs(e)=e // means apply V to 'e', where e was found in nested class 'Cs'
V_Cs(L) = V(Cs.C = L), for fresh C // Rename a library literal expression

//Note the difference w.r.t. V_Cs(C: L) above. This is why we need both V_Cs(_) and V(Cs=_)
// TODO: Other kinds of expressions (just apply V_Cs to all e, L, T and P inside)

_________
AuxDefine V_Cs(T)=T'
V_Cs(mdf P) = mdf V_Cs(P)

_________
AuxDefine V_Cs(P)=P' // P found in Cs is renamed to P'
V(Thisk.Cs' in Cs.C1...Ck) = V(Cs.Cs') + #Cs + k
otherwise
V(P in Cs) = P

Define RedirectSet(L; Csz)=Csz':
// Csz' is the set of nested class names that will be redirected when all the Csz are redirected from L
-----------------------------
Cs in RedirectSet(L; Cs, Csz)

Cs1.C in RedirectSet(L; Csz)
  Cs1 in RedirectSet(L; Csz)
  C in dom(L[Cs1])

Cs2 in RedirectSet(L; Csz)
  Cs1 in RedirectSet(L; Csz)
  This0.Cs2 in Paths(L[Cs1])[from This0.Cs1]

Define RedirectPaths(L) = Pz, RedirectPaths(mwt) = Pz
// The set of paths referenced in the signatures of L and mwt (excluding nested classes)
-----------------------------------------------------------------------
RedirectPaths({interface? implements Pz mwtz ncz}) = Pz, RedirectPaths(mwtz)

RedirectPaths(mwt) = Ts.Ps, T.P, Pz
  mwt.mt = Ts->T;Pz

==================================================================
Define Redirect(p; L; Cs1, P1, ..., Csn, Pn) =
    Redirect(p'; Cs1, p'.minimize(P1+1), ..., Csn, p'.minimize(Pn+1))
  where p' = p.evilPush(L)

Define Redirect(p; V) = V'(p.top()[remove dom(V)])
  where ValidRedirect(p; V; V') and ChooseRedirect(p; V) = V'

Define ValidRedirect(p; V; V') iff
    V subseteq V'
    dom(V') = RedirectSet(p.top(); dom(V))

    forall Cs.C in dom(V'): V'(Cs.C) = V'(Cs).C
    forall Cs in dom(V'):
      V'(Cs)=p.minimize(V'(Cs))
      p|- Cs; V'(p[Cs]) >= V'(Cs); p[V'(Cs)]

Define p|- Cs; {interface? implements Pz mwtz, ncz} >= P; {interafce?' implements Pz' mwtz', ncz'}
  Pz subseteq_p Pz',P//Note: very important, so that F-bound polimoprhism can work
  if interface?=empty:
    forall MS in dom(mwtz): //Note: adding a method to an interface would break all implementer
      p |- mwtz'(MS).mt <= mwt(MS).mt
    if interface?' = interface then class not in mwtz.mdfz
  else:
    interface? = interface?'
    mwtz[with refine?s=empty] = mwtz'[with refine?s=empty]

  forall mwt in mwtz:
    mwt.e = empty
    not Private(mwt.m)

  forall C in dom(ncz)
    not Private(C)
--------------------------------------------
// Any other definition of this function would make a sane redirect!
Define ChooseRedirect(p; V) = V'
  V' is the unique V' such that ValidRedirect(p; V; V') and
    for all V'' such that ValidRedirect(p; V; V''),  p |- V' < V''
  // i.e. V' is the unique 'least' valid redirection
--------------------------
Some helpfull definitions to compute the distance between two paths, so that 'closer' paths have less classes in between them in the subtypining hiearchy.

// Some help for subtyping
Define p |- P1 = P2 iff
    p |- P1 <= P2
    p |- P2 <= P1

Define p |- P1 < P2 iff
    p |- P1 <= P2
    p |/- P2 <= P1

define distance(p, P1, P2) = n
------------------------------------
distance(p, P1, P2) = 0
    p |- P1 = P2

distance(p, P1, P2) = n - 1
    n is the largest number such that there exists P1', ..., Pn' where
        n >= 2
        p |- P1' = P1
        p |- Pn' = P2
        p |- P1' < P2'
        ...
        p |- Pn-1' < Pn'

distance(p, P1, P2) = distance(p, P2, P1)
====================================================
Definition for 'V' ordering

p |- V1 < V2 iff
  p |- V1 <= V2
  p |/- V2 <= V1

p |- V <= V


p |- V1 U V2 <= V1' U V2' if
  p |- V1 < V1'
  p |- V2 <= V2'

// I have written the rules such that V1 <= V2 only if
// V1 is better than V2 in at least one way,
// As opposed to simply saying that V1 is at least as good as V2
// This makes the definition for '<' much more uesefull,

Define mwt.P = P'
    where mwt.mt = _ -> mdf P'; _
Define mwt.Pi = Pi'
    where mwt.mt = mdf1 P1' ... mdf1 P1' -> _; _

// Return path is 'closer'
p |- Cs->P1, Cs'->P1' <= Cs->P2, Cs'->P2' if
  for some ms
  p[This0.Cs'](ms).P = This0.Cs
  distance(p[P1'](ms).P, P1) <= distance(p[P2'](ms).P, P2)

// Argument path is 'closer'
p |- Cs->P1, Cs'->P1' <= Cs->P2, Cs'->P2' if
  for some ms and i
  p[This0.Cs'](ms).Pi = This0.Cs
  distance(p[P1'](ms).Pi, P1) <= distance(p[P2'](ms).Pi, P2)


---------------------------------------------
Computability: thanks to RedirectSet we know the dom(V)
we can compute a part of the mapping by looking to method types.
All that is left is implements and exceptions
however, we can match, for example
A:{implements Cs1..Csn Ms} 
with the corresponding 
EB:{implements P1..Pk Ms'} 
by method names.
To pass, for each Csi there must be at least 1 Pi with (exactly) the same ms
in order to be still ambiguos:
there must be a P,P' in P1..Pk with the same ms.
For this to be the case, either there are interfaces with no methods
in Cs1..Csn or P must implement P' and P must add no methods
Thus, the only case where it may be hard is the degenerate case
of an interface without methods


A:{class method T m() exception A1,A2,A3}

EA:{class method T m() exception EA1,EA2}

A1:{}, A2: {}
A:{
  T m() exception A1  T f() exception A1, A2
}

EA: { 
  T m exception EA1 ...
  T f exception EA1 ...
}
EA1: {}

interface A {  }
interface B {  }
class C implements A,B{ }

interface EA {  }
interface EB {  }
class EC implements EA,EB{ }




EI1:{interface}
EI2:{interface implements EI1}

L={  
I1:{interface}
I2:{interface implements I1}
}[I2=EI2]
I2=EI2,I1=EI1
I2=EI2,I1=EI2


------

L: {A1: {interface implements A2, ..., An}
A2: {interface implements A3, ..., An}
...
An: {interface}
}

B1: {interface implements B2, ..., Bn}
B2: {interface implements B3, ..., Bn}
...
Bn: {interface}

L[A1 = B1]

================================//may be move in rename
L[PathRename Cs->Cs']p = V(L)
  V = collectV(p.evilPush(L); Cs->This0.Cs')

collectV(p; Cs->P, V) = collectV(p; Cs.C->P.C, Cs->P, V)
  Cs.C not in dom(V)
  C in dom(p(This0.Cs))
otherwise
  collectV(p; V) = V


-----------------------------------------------------------------------------------------
Kind of errors in current implementation
1 p.equiv
3 interface with different methods
2 ambiguity resolution with interface
1 exception spec coalscing...
1 self implementation

-----------------------------------------------------------------------------------------


Usefull examples that need to go in paper
---------------------
EA:{interface XX} 
EA2:{implements EA XX YY}
EC:{EA m()}
----
{
A:{XX} 
C:{ A m()}
}
C=EC
---------
one could redirect A=EA, and C=EC after
but C=EC is ambiguis A=EA or A=EA2
worst, there could me many "EA2" everywhere in the system; want EA

---------

EA2: {interface}
EA: {interface implements EA2}
EB: {EA foo()}

{A: {interface} B: {A foo()}}[ B = EB] // A = EA
---//Also good to go in paper, ambiguos EAA and EA, want EA
EAA: {interface +}
EA: {interface implements EAA  +}
EA1: {interface implements EA  +}
EA2: {interface implements EA  +}
EB: {EA1 foo() EA2 bar()}

{A: {MEAA} B: {A foo() A bar()}}[ B = EB] 
===========================
Common:{interface }
EAA1: {interface +}
EAA2: {interface +}
EA1: {interface implements EAA1 EAA2  +}
EA2: {interface implements EAA1 EAA2  +}
EB: {EA1 foo() EA2 bar()}
{A: {} B: {A foo() A bar()}}[ B = EB] 
//here we obviusly can not chose a best result between EAA1 and EAA2, however Common

one of the difficulties is the model of multiple subtyping
in java, I1 and I2 with same method can be both implementend, in C# too, and ....
for a clean reasoning.... 42



Define  p|-V1< V2

p |- V <= V

p |- V1 <= V1' 
p |- V2 <= V2'
-----------------------
p|- V1,V2 <= V1',V2'

case1: return type the same
p |- Cs->P1,Cs'->P1'<= Cs->P2
  This0.Cs=p.top()[Cs'].ms.T
  p[P1'].ms.T=P1
  
case2: param type the same
p |- Cs->P1,V<= Cs->P2,V
  This0.Cs =p.top()[Cs'].ms.Ts.i
  p[V(Cs')].ms.Ts.i=P1

case3: return type subtype
p |- Cs->P1,V<= Cs->P2,V
  This0.Cs =p.top()[Cs'].ms.T
  p[V(Cs')].ms.T=P
  not p.equiv(P,P1) and not p.equiv(P,P2)
  p|-P1<=P2

case4: param type supertype
p |- Cs->P1,V<= Cs->P2,V
  This0.Cs =p.top()[Cs'].ms.Ts.i
  p[V(Cs')].ms.Ts.i=P
  not p.equiv(P,P1) and not p.equiv(P,P2)
  p|-P1>= P2

-------------------

EB: {}
A: {EB foo C.Z bar}
C: {B: {} X:{B foo} Z: {}}[X=A]
C = {B: {}}

ValidR(p,V) iff
    dom(V) = RedirectSet(p.top(); dom(V)) // maybe unnecessary
    forall Cs in dom(V):
      V(Cs)=p.minimize(V(Cs))
      p|- Cs; V(p[Cs]) >= V(Cs); p[V(Cs)]

given a r function, we can preserve 1 by filtering the output with ValidR

r is a partial function from (p;V)->V'
such that 
  p.minimize(V)=V,
  p.minimize(V')=V'
  V'=V,_
  forall P in range(V'), p(P) is a well typed L

and V' = p.minimize(V')
we find redirect:r
0- redirect(p,redirect(p,V))=redirect(p,V)
1- if redirect(p,V')=V and p.pop()|-p.top():ok
   then p.pop()|-V(p.top()):ok
  // if redirect apply V on well typed L input, well typed result
2--Stability://formal after seams broken?
 if redirect(p,V')=V and p'=p[with p.top()[Css=Ls]] and Css disjoint dom(V)
 then redirect(p',V')=V
 //if redirect chose V on L, it would chose the same V on
 //L with different members not in dom(V), this would include privates
3 - minimilaty
  if r(p, V) = V' then dom(V') <= RedirectSet(p.top(); dom(V))

Fact--forall r' such that 0,1,2 holds, 
    forall V,V',p, if  r'(p;V) = V' then ValidR(V', p) holds
//this is an example showing why 2 is needed in Fact above
//{F: {class method Void bar()} ...}[F = Void]


UniqueR(p, V, V')
  true iff their is no V'' such that V <= V' and V'' != V' and validR(p, V')

possible rs satisfing 0,1,2,3

Singleton sets:
  0-r(p, V) is always undefined
  1- if r(p, V) = V', V = V'
  2- r(p, V) = V' IFF UniqueR(p, V, V') and 0,1,2,3

Infinite sets:
  3- if r(p, V) is undefined, their is no V' such that ValidR(p, V') and 0,1,2,3
    // always suceeds if possible
  4- if r(p, V) = V' then UniqueR(p, V, V') and not 2// weaker than 2
    // if it suceeds, the answer is unqiue
  5- if UniqueR(p, V, V') then r(p, V) = V' and not 2 and 1// stronger than 2
    // it always suceeds if their is a unique result
    // but solves some ambiguites
  5a- range(V') do not P out of thin air but rely on type mentioned in the targets
  6- other
    // sometimes it fails, even if their is a solution
    // and sometimes it resolves ambiguities but not always
