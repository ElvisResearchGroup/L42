V ::= (Cs->P)z

dom(Cs1->P, ..., Csn->P) = Cs1,...,Csn
V(Cs) = P:
	Cs->P in V
--------------------------------------

V(L) = V(empty L)

V(Cs{interface? implements Pz mwtz, ncz}) =
  {interface? implements V(Pz in Cs) V(mwtz in Cs) V(ncz in Cs)}

V(refine? mdf method T m(T1 x1,..,Tn xn) exception Pz e?) =
  refine? mdf method V(T in Cs) m(V(T1 in Cs) x1,..,V(Tn in Cs) xn) exception V(Pz in Cs) V(e? in Cs)

V(C:  L in Cs) = C: V(Cs.C L)
V(    L in Cs) =    V(Cs.C L), for fresh C
// TODO: Other kinds of expressions (just apply V(P in Cs) for all paths)
V(mdf P in Cs) = mdf V(P in Cs)

//we assume the trivial sequence propagation over
//V(es in Cs), V(mwts in Cs) and so on.

V(X, Xz in Cs) = V(X in Cs), V(Xz in Cs)
  for all metavariables X

V(empty in Cs) = empty

V(Thisk.Cs' in Cs.C1...Ck) = V(Cs.Cs') + #Cs + k
V(P in Cs) = P:
	otherwise

Define L[remove Csz] = L[remove Csz in empty]
	empty not in Csz

Define L[remove Csz in Cs] = L0
--------------------------------------------------------
{interface? implements Pz mwtz ncz}[remove Csz in Cs] =
	{interface? implements Pz mwtz ncz[remove Csz in Cs]}
	where empty not in Csz

empty[remove Csz in Cs] = empty
(C:L, ncz)[remove Cs.C,Csz in Cs] = ncz[remove Csz in Cs]
(C:L, ncz)[remove Csz in Cs] = C:L[remove Csz in C.Cs], ncz[remove Csz in Cs]
  Cs.C not in Csz
----------------------------------------------

p|- Ts->T;Pz <= Ts'->T';Pz':
  p|- T <= T'
  p|- Ts' <= Ts
  forall P in Pz: exists P' in Pz': p|- P <= P'

Define RedirectSet(L, Cs)=Csz:
-----------------------------
Cs    in RedirectSet(L, Cs)

Cs1.C in RedirectSet(L, Cs):
  Cs1 in RedirectSet(L, Cs)
  C in dom(L[Cs1])

Cs2   in RedirectSet(L, Cs):
  Cs1 in Csz
  This0.Cs2 in Paths(L[Cs1])[from This0.Cs1]
---------------------------------------------------------

Paths({interface? implements Pz; mwt0, ..., mwtn; ncz}) = Pz,Paths(mwt0.mt),...,Paths(mwtn.mt)
  Paths(Ts->T;Pz) = Ts.Ps, T.P, Pz

minize(p; Thisn+1.C.Cs) = minize(p: Thisn.Cs):
  p.pop(n+1).ctxL(C) = ctxC

minimize(p; P) = P
	otherwise

minimize(p; Cs1->P1,...,Csn->Pn) = Cs1->minimize(p; P1), ..., Csn->minimize(p; Pn)
minimize(p; P, Pz) = minimize(p; P), minimize(p; Pz)

Define Redirect(p, L, Cs, P) = Redirect(p', Cs, minimize(p'; P+1)):
	p' = p.evilPush(L)

Define Redirect(p, Cs, P) = L0:
  exists a unique V such that: //if more then one V exists, is ambiguos redirect
  	V = minimize(p; V)
    P = V(Cs)
    dom(V) = RedirectSet(p.top(), Cs)
    L0     = V(p.top())[remove dom(V)]
    forall Cs' in dom(V):
      P' = V(Cs')
      V(Cs' p(This0.Cs')[from This0.Cs']) >=p P' p(P')[from P'])

Define Cs {interface? implements Pz mwtz ncz} >=p P {interafce?' implements Pz' mwtz' ncz'}:
  minimize(p; Pz) subseteq minimize(p; Pz',P)
  if interface?=empty:
    forall MS in dom(mwtz):
      p |- mwtz'(MS).mt <= mwtz(MS).mt
    if class in mwtz.mdfz then interface?'=empty
  else:
    interface? = interface?'
    mwtz[with refine?s=empty] = mwtz'[with refine?s=empty]

  forall mwt in mwtz:
  	mwt.e = empty
  	not Private(mwt.MS.m)

  forall C in dom(ncz)
  	not Private(C)
    V(Cs.C) = P.C

================================
L[PathRename Cs->Cs']p = V(L):
	V = collectV(p.evilPush(L); Cs->This0.Cs')

collectV(p; Cs->P, V) = collectV(p; Cs.C->P.C, Cs->P, V)
	Cs.C not in dom(V)
	C in dom(p(This0.Cs))

collectV(p; V) = V:
	otherwise