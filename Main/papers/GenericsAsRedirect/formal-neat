V ::= (Cs->P)z

dom(Cs1->P, ..., Csn->P) = Cs1,...,Csn
V(Cs) = P:
	Cs->P in V
--------------------------------------

V(L) = V(empty L)

V(Cs{interface? implements Pz Mz}) =
  {interface? implements V(Pz in Cs) V(Mz in Cs)}

V(refine? mdf method T m(T1 x1,..,Tn xn) exception Pz e?) =
  refine? mdf method V(T in Cs) m(V(T1 in Cs) x1,..,V(Tn in Cs) xn) exception V(Pz in Cs) V(e? in Cs)

V(C:  L in Cs) = C: V(Cs.C L)
V(    L in Cs) =    V(Cs.C L), for fresh C
// TODO: Other kinds of expressions (just apply V(P in Cs) for all paths)
V(mdf P in Cs) = mdf V(P in Cs)

//we assume the trivial sequence propagation over
//V(es in Cs), V(mwts in Cs) and so on.

V(X, Xz in Cs) = V(X in Cs), V(Xz in Cs)
  for all metavariables X

V(empty in Cs) = empty

V(Thisk.Cs' in Cs.C1...Ck) = V(Cs.Cs') + #Cs + k
V(P in Cs) = P:
	otherwise

Define L[remove Csz] = L[remove Csz in empty]
	empty not in Csz

Define L[remove Csz in Cs] = L0
--------------------------------------------------------
{interface? implements Pz Mz}[remove Csz in Cs] =
	{interface? implements Pz Mz[remove Csz in Cs]}
	where empty not in Csz

empty[remove Csz in Cs] = empty
(C:L, Mz)[remove Cs.C,Csz in Cs] = Mz[remove Csz in Cs]
(C:L, Mz)[remove Csz in Cs] = C:L[remove Csz in C.Cs], Mz[remove Csz in Cs]
  Cs.C not in Csz
(mwt, Mz)[remove Csz in Cs] = mwt, Mz[remove Csz in Cs]
----------------------------------------------

p|- Ts->T;Pz <= Ts'->T';Pz':
  p|- T <= T'
  p|- Ts' <= Ts
  forall P in Pz: exists P' in Pz': p|- P <= P'

Define RedirectSet(L, Csz)=Csz':
-----------------------------
Cs    in RedirectSet(L, Csz):
  Cs in Csz

Cs1.C in RedirectSet(L, Csz):
  Cs1 in RedirectSet(L, Csz)
  C in dom(L[Cs1])

Cs2   in RedirectSet(L, Csz):
  Cs1 in Csz
  This0.Cs2 in Paths(L[Cs1])[from This0.Cs1]

Define Paths(..) = Pz
------------------------------------------------------
Paths({interface? implements Pz; Mz}) = Pz, Paths(Mz)

Paths(mwt, Mz) = Ts.Ps, T.P, Pz
	mwt.mt = Ts->T;Pz

Paths(nc, Mz) = Paths(Mz)
Paths(empty) = empty

==================================================================
p.minimize(Thisn+1.C.Cs) = p.minimize(Thisn.Cs):
  p.pop(n+1).ctxL(C) = ctxC
  p(Thisn+1.C) is of form LV

p.minimize(P) = P
	otherwise

p.minimize(Cs1->P1,...,Csn->Pn) = Cs1->p.minimize(P1), ..., Csn->p.minimize(Pn)
p.minimize(P, Pz) = p.minimize(P), p.minimize(Pz)

Define Redirect(p, L, Cs1, P1, ..., Csn, Pn) = Redirect(p', Cs1, p'.minimize(P1+1), ..., Csn, p'.minimize(Pn+1)):
	p' = p.evilPush(L)

Define Redirect(p, Cs1, P1, ..., Csn, Pn) = L0:
  exists a unique V such that: //if more then one V exists, is ambiguos redirect
  	V = p.minimize(V)

    Pi = V(Csi)
    dom(V) = RedirectSet(p.top(), Cs1, ..., Csn)
    L0     = V(p.top())[remove dom(V)]
    forall Cs' in dom(V):
      P' = V(Cs')
      V(Cs' p(This0.Cs')[from This0.Cs']) >=p P' p(P')[from P'])

Define Cs {interface? implements Pz mwtz, ncz} >=p P {interafce?' implements Pz' mwtz', ncz'}:
  Pz subseteq_p Pz',P
  if interface?=empty:
    forall MS in dom(mwtz):
      p |- mwtz'(MS).mt <= mwt(MS).mt

    if interface?' = interface then class not in mwtz.mdfz
  else:
    interface? = interface?'
    mwtz[with refine?s=empty] = mwtz'[with refine?s=empty]

  forall mwt in mwtz:
  	mwt.e = empty
  	not Private(mwt.m)

  forall C in dom(ncz)
  	not Private(C)
    V(Cs.C) = P.C

================================
L[PathRename Cs->Cs']p = V(L):
	V = collectV(p.evilPush(L); Cs->This0.Cs')

collectV(p; Cs->P, V) = collectV(p; Cs.C->P.C, Cs->P, V)
	Cs.C not in dom(V)
	C in dom(p(This0.Cs))

collectV(p; V) = V:
	otherwise
