V ::= (Cs->P)z

dom(Cs1->P, ..., Csn->P) = Cs1,...,Csn
--------------------------------------
//P' = V(Cs') // Actually a redirected path...

V(L) = V(empty L)

V(Cs{interface? implements Pz mwtz, ncz}) =
  {interface? implements V(Pz in Cs) V(mwtz in Cs) V(ncz in Cs)}

V(refine? mdf method T m(T1 x1,..,Tn xn) exception Pz e?) =
  refine? mdf method V(T in Cs) m(V(T1 in Cs) x1,..,V(Tn in Cs) xn) exception V(Pz in Cs) V(e? in Cs)

V(C:  L in Cs) = C: V(Cs.C L)
V(    L in Cs) =    V(Cs.C L), for fresh C
// TODO: Other kinds of expressions (just apply V(P in Cs) for all paths)
V(mdf P in Cs) = mdf V(P in Cs)

//we assume the trivial sequence propagation over
//V(es in Cs), V(mwts in Cs) and so on.

V(X, Xz in Cs) = V(X in Cs), V(Xz in Cs)
  for all metavariables X

V(empty in Cs) = empty

// Ok, here are the path thingys
V(Thisk.Cs' in Cs.C1...Ck) =
	V(Cs.Cs')[from This(#Cs+k)]
/*
V(P0 in Cs0)
	n = #Cs0
	P0 = Thisk.Cs'
	Cs0 = Cs.C1...Ck

	//Cs = Cs.Cs'
	/*
	find a Cs"->P"
	*/
*/
V(Thisk.Cs' in Cs.C1...Ck) =
	P.Cs' + (#Cs+k)
	Where Cs->P in V

V(Thisk.Cs' in Cs.C1...Ck) = Thisk.Cs'
	where V(Cs.Cs') is undefined

V(P+n+1 in C1,...,Cn) = P+n+1


V(Cs) = V(P in empty)

// Note: The Cs' part is only needed for rename
// This also assumes that if Cs.Cs'->P' is in V
// and Cs->P in V, then P' = P.Cs', which is true for redirect

"".Cs->P'
	""->P
	P'="".C

//good example, what is supposed to happen
Foo: {implements Any}
{A:{interface      B:{implements A}}}[A.B=>Foo, A=>Any,]





V(Cs.Cs') = P.Cs':
  Cs->P in V

V(This0.Cs) = V(Cs)
V(This0.Cs) = This0.Cs
	where V(Cs) is undefined

V(P+1) = P+1


Define L[remove Csz] = L[remove Csz in empty]
	empty not in Csz

Define L[remove Csz in Cs] = L0
--------------------------------------------------------
{interface? implements Pz mwtz ncz}[remove Csz in Cs] =
	{interface? implements Pz mwtz ncz[remove Csz in Cs]}
	where empty not in Csz

empty[remove Csz in Cs] = empty
(C:L, ncz)[remove Cs.C,Csz in Cs] = ncz[remove Csz in Cs]
(C:L, ncz)[remove Csz in Cs] = C:L[remove Csz in C.Cs], ncz[remove Csz in Cs]
  Cs.C not in Csz
----------------------------------------------

p|- Ts->T;Pz <= Ts'->T';Pz':
  p|- T <= T'
  p|- Ts' <= Ts
  forall P in Pz: exists P' in Pz': p|- P <= P'

Define RedirectSet(L, Cs)=Csz:
-----------------------------
Cs    in RedirectSet(L, Cs)

Cs1.C in RedirectSet(L, Cs):
  Cs1 in RedirectSet(L, Cs)
  C in dom(L[Cs1])

Cs2   in RedirectSet(L, Cs):
  Cs1 in Csz
  This0.Cs2 in Paths(L[Cs1])[from This0.Cs1]
---------------------------------------------------------

Paths({interface? implements Pz; mwt0, ..., mwtn; ncz}) = Pz,Paths(mwt0.mt),...,Paths(mwtn.mt)
  Paths(Ts->T;Pz) = Ts.Ps, T.P, Pz

minimize(p; P) = P'
	where P' is the shortest path such that // TODO: Define formally
		p.equiv(P, P')

minimize(p; Cs1->P1,...,Csn->Pn) = Cs1->minimize(p; P1), ..., Csn->minimize(p; Pn)
minimize(p; P, Pz) = minimize(p; P), minimize(p; Pz)

Define Redirect(p, L, Cs, P) = Redirect(p', Cs, minimize(p'; P+1)):
	p' = p.evilPush(L)

Define Redirect(p, Cs, P) = L0:
  exists a unique V such that: //if more then one V exists, is ambiguos redirect
  	V = minimize(p; V)
    P = V(Cs)
    dom(V) = RedirectSet(p.top(), Cs)
    L0     = V(p.top())[remove dom(V)]
    forall Cs' in dom(V):
      P' = V(Cs')
      V(Cs' p(This0.Cs')[from This0.Cs']) >=p P' p(P')[from P'])

Define Cs {interface? implements Pz mwtz ncz} >=p P {interafce?' implements Pz' mwtz' ncz'}:
  minimize(p; Pz) subseteq minimize(p; Pz',P)
  if interface?=empty:
    forall MS in dom(mwtz):
      p |- mwtz'(MS).mt <= mwtz(MS).mt
    if class in mwtz.mdfz then interface?'=empty
  else:
    interface? = interface?'
    mwtz = mwtz' //note: may be we can relax by ignoring 'refine?'

  forall mwt in mwtz:
  	mwt.e = empty
  	not Private(mwt.MS.m)

  forall C in dom(ncz)
  	not Private(C)
    V(Cs.C) = P.C


 {A:{This5.A.B.C }B:{} B foo()}[B => This2.C.A]
 {B:{} B foo()}[B => This2.C.A]
 	==>{This1.A foo()}

