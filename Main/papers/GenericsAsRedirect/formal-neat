------------- // TODO: Change V to 'R' ? Or perhaps 'M'?
Module V: defines V, V(Cs)=P, V(L)=L', dom(V);
using auxiliary V_Cs(e)=e', V_Cs(T)=T', V_Cs(M)=M', V(Cs=L)=L'

V ::= (Cs->P)z // Redirection map
// A V is a methematical partial function from the set of Cs to the set of P

//______
//Define V.minimize(p)
//(Cs1->P1,...,Csn->Pn).minimize(p)=Cs1->p.minimize(P1), ..., Csn->p.minimize(Pn)

______
Define dom(V)
dom(Cs1->P1, ..., Csn->Pn) = Cs1, ..., Csn

______
Define V(Cs)=P
V(Cs) = P
  Cs->P in V // Cs renamed using V
______
// Apply V to all references to the class-names in dom(L)
// Note: this only applies to references (i.e. P's), the nested classes themselves (if present) are not redirected
Define  V(L)=V(empty=L) // Note: the top-level 'class' has no name, so we use 'empty'

// Note: that Ls found found inside expressions (i.e. es) have no names, whereas the RHS of a nested-class definition do
// However even an unanamed L may be inside a named L, and we need this information to understand what a path refers to.
// As such we will just geneerate fresh names for unnamaed Ls, thus simplifying things by giving all L's a name.

// We could also just use V_Cs(C: L) and V_Cs(L) to apply V to nested classes and L expressions (respectivley),
// however this general V(Cs = L) function prevents duplication, and so the above two just forward to it
_________
// Apply V to class 'Cs' which has body 'L'
// We need to keep track of the Cs since paths are relative, in order to know if they refer to something in dom(V)
// we need to know where the is
AuxDefine V(Cs = L)=L'

// Simply apply V to the Pz and Mz
V(Cs = {interface? implements Pz Mz}) = {interface? implements V_Cs(Pz) V_Cs(Mz)}

_________
// Apply V to a member M that was found in nested class Cs
AuxDefine V_Cs(M)=M'

// Case for methods, apply V to all types, paths and expressions
V_Cs(refine? mdf method T m(T1 x1,..,Tn xn) exception Pz e?) =
  refine? mdf method V_Cs(T) m(V_Cs(T1) x1,..,V_Cs(Tn) xn) exception V_Cs(Pz) V_Cs(e?)

// Case for nested classes, apply V to the library literal, giving it the appropriate name
V_Cs(C: L) = C: V(Cs.C = L) // Apply V to a nested class, which has name C and is in Cs
_________
// Apply V to an e, which was found in nested class Cs
AuxDefine V_Cs(e)=e'
V_Cs(L) = V(Cs.C = L), for fresh C
// TODO: Other kinds of expressions (just apply V_Cs to all e, L, T and P inside)

_________
AuxDefine V_Cs(T)=T'
// Apply V to a type, by just applying it to the mentioned path
V_Cs(mdf P) = mdf V_Cs(P)

_________
// Apply V to the path P that we found in Cs
// If a prefix of P refers to something in the domain of V, we will redirect it
// Otherwise we will leave it untouched
AuxDefine V_Cs(P)=P' // P found in Cs is renamed to P'

// We found P in Cs (of length k), so give it to V (which is defined relative to This0, but we are in This0.Cs)
// and from the result (since the start, This0, is actually Thisk from the point of view of This0.Cs,
// which is where we found the original P)
V_Cs(P) = V(Cs')[from Thisk]
    where Cs = C1...Ck
    P[from This0.CS] = This0.Cs'

otherwise
V(P in Cs) = P

// Csz' is the set of nested class names that will be redirected when all the Csz are redirected from L
// It is the transitive closure of apply 'Reachables' to each class mentioned in Csz
Define RedirectSet(L; Csz)=Csz':
-----------------------------
// If we are redirecting Csz, then we need to redirect Csz
Csz subseteq RedirectSet(L; Csz)

// Redirect the nested class mentioned in the signature of a redirected class
// We won't however be redirecting references to external paths (i.e. things outside of This0)
Cs2 in RedirectSet(L; Csz)
  Cs1 in RedirectSet(L; Csz)
  This0.Cs2 in Reachables(L[Cs1]) // TODO: Do a p.minimize?

==================================================================
// Perform and compute a redirect, using a choice function 'ChooseRedirect' to compute the V mapping
Define Redirect(p; L; Cs1, P1, ..., Csn, Pn) = V(p'.top()[remove Csz]) // Remove the things that will be redirected away
  empty not in Cs1 ... Csn // We can't redirect This0, as that does not make sense
  p' = p.evilPush(L) // to simplify everything, just make L the new top
  forall Cs in RedirectSet(L, Cs1, ..., Csn):
    Redirectable(L[Cs]) // Check that the source is valid

  // Chose a mapping, simplifying the input, and update the paths to be relative to our evil-pushed program
  ChooseRedirect(p'; Cs1, p'.minimize(P1[from This1]), ..., Csn, p'.minimize(Pn[from This1])) = V

Required properties of a ChooseRedirect function:
ChooseRedirect is a function from p*V->V' such that
  ChooseRedirect(p,V')=V'
  forall p' ~V~ p: ChooseRedirect(p',V)=V'
  ValidRedirect(p,V')
  // We should try and prove that the above definition is equivalent to one where we replace the ValidRedirect check
  // with a meta-level soudness check (I'm not certain though)
______
Define ValidRedirect(p,V,V')
  V subseteq V'
  dom(V') = RedirectSet(p.top(); dom(V))
  forall P in ran(V'):
    p.minimize(P)=P
    P not of form This0._
    p|-p(P):OK //P well typed
  forall Cs in dom(V'):
    Cs not empty
    p|- V'(Cs); p[V'(Cs)] <= Cs; V'(p[Cs])
    forall C in dom(p(Cs)): V'(Cs.C) = V'(Cs).C
    Redirectable(p.top()(Cs))

// Whether the class This0.Cs can be redirected away
// Namely: that the class contains no implemented methods or anything private
Define Redirectable(L) // L42 only
  forall mwt in L.mwtz:
    mwt.e = empty
    not Private(mwt.m)

  forall C in dom(L.ncz)
    not Private(C)

// Is the LHS (whose name is 'This0.Cs') a structural supertype of the RHS (whose name is P)
// We say that A is a structural supertype of B if any code written with respect to A
// would also type-check against B
Define p|- P; {interafce?' implements Pz' mwtz', ncz'} <= Cs; {interface? implements Pz mwtz, ncz}
  // Check that all the interfaces the LHS implements are also implemented by the RHS
  Pz,Any subseteq_p Supertypes(p; Pz') //Note: Using supertypes (and not Pz') is very important, so that F-bound polimoprhism can work TODO: explain what this means

  // If the LHS is not an interface
  if interface?=empty:
    // Check that each method-type of the RHS is a subtype of the LHS
    // (So that it any well-typed call to a method on the LHS would also typecheck if it were to call a method on the RHS)
    forall MS in dom(mwtz):
      p |- mwtz'(MS).mt <= mwt(MS).mt

    // One can only call class methods on a non-interface, so if the LHS has any, than the RHS can't be an interface
    if interface?' = interface then class not in mwtz.mdfz

  // If the LHS is an interface, we need to ensure that any valid implementation of the LHS
  // Is a valid implemention of the RHS, which requires that the RHS have the exact same method signatures as the LHS
  else:
    interface? = interface?' // You can't implement non-interfaces
    // We ignore the presence of the 'refine' keyword, since this is irealvent to any implementing classes
    mwtz[with refine?s=empty] = mwtz'[with refine?s=empty]

--------------------------------------------

p' ~V~ p  iff  ReduceProblem(p; V)=ReduceProblem(p'; V)
ReduceProblem(p; V) = p[only This0.Cs1, ..., This0.Csn, ReachableSet(p; ran(V))]
    Cs1, ..., Csn = RedirectSet(p.top(); dom(V))

// The set of paths referenced in the signatures of each P, L and mwt (excluding nested classes)
Define Reachables(p; P) = Pz, Reachables(L) = Pz, Reachables(Mz) = Pz
-----------------------------------------------------------------------
// Find's all paths that are reachable from the declaration of 'P' in p
// (i.e. ignoring methods bodies and meta-expressions)
ReachableSet(p; Pz):
    Pz subseteq ReachableSet(p; Pz)
    Pz' subseteq ReachableSet(p; Pz)
        P in ReachableSet(p; Pz)
        Pz' = p.minimize(Paths(p[P]))

Reachables({interface? implements Pz Mz}) = Pz, Paths(Mz)
Reachables(C: L) = Paths(L)[from This0.C]
Reachables(mwt) = mwt.mt.Ts.Ps, mwt.mt.T.P, mwt.mt.Pz

Define p[only Pz] = p', and L[only Pz]=L'
-----------------------------------------------
// I don't know a 42 equivalent formalisim, but who cares...
(id = L, p)[only Pz] = (id = L[only Internals(Pz)], p[only (Pz[from This0.ToC(id)])])
(empty; DVs)[only Pz] = (empty; DVs[only Pz])

(C = LV)[only Pz] = (C = LV[only Pz[From This]])
    This0.C.Cs in Pz // Something inside C is to be kept, so we need C

(DV)[only Pz] = empty
    otherwise // A trait, or a class that is to be discareded

ToC(C) = C
ToC(t) = C
    for fresh C

L[only Cs,Csz] = L[only Cs] U L[only Csz]
L[only empty] = {}
// Discard method bodies!, we don't want people looking in them, or do we?
L[only C1...Cn] = {C1: ... {Cn: L(Cs)[with ncz = empty, with mwtz.ez = empty]} ... }
------------------------
// Returns all the nested classes that are accesed from This0 (works best if Pz is minimized)
Define Internal(Pz) = Csz
    Internal(This0.Cs, Pz) = Cs, Internal(Pz)
    Internal(P, Pz) = Internal(Pz)
        otherwise

// U above is a 'dumb' sum, namely:
{interface?1 Pz C: L ... Cn: Ln Mz} U {interface?2 Pz' C1: L1' ... Cn: Ln' Mz'} =
        {interface?1 U interface?2 Pz Pz' C1: L1 U L1' ... Cn: Ln U Ln' Mz Mz'}
---------------------------------------
//// TODO: Check we are the new R4...
// TODO: Special rules for redirecting to Any?
// TODO: Handle exception clauses (BUT DON't complicate anything unrelated)

// Note: I assume that all paths mentioned in a CCz have been p.minimized
// Note: the 'interface' constraint currently only benifits early error detection, as we can't use it to infer any more constraints (or can we?)

ChooseRedirect(p; Cs1->P1, ..., Csn->Pn) = V'
  CCz0 = {Cs1 <= P1, P1 <= Cs1, ..., Csn <= Pn, Pn <= Csn}
  CCz = CollectAll(p; CCz0)
  V' = ChooseV(p; CCz)
  ValidRedirect(p; V; V') // TODO: Do something more efficient?

CC ::= Cs <= P | P <= Cs // | Cs in Pz  | interface Cs | class Cs

MustInterface(p; Cs) = p(Cs).interface? = interface
MustClass(p; Cs) = p(Cs).interface? = empty and class in p(Cs).mwtz.mdfZ

// CollectAll is the main function that collects all constraints
CollectAll(p; CCz,CCz') := CollectAll(p; CCz'')
  CCz'' = (CCz, CCz') U Collect(p; CCz)
  CCz'' != CCz,CCz'
CollectAll(p; CCz) := CCz
  Otherwise

Define p[P.ms] = p.minimize(p[P](ms))
// where p.minimize(mwt) minimizes everything in the method signature
Define p[Cs.ms] = p[This0.Cs.ms]
Define mwt.P = mwt.mt.P
Define mwt.Pi = mwt.mt.Ts.i.P

// Note: Collect isn't a function, but a relation,
// I.e. Collect(p; CCz) = Ccz' for multiple different CCz' (even with the same p; CCz)
Define Collect(p; CCz) := CCz':
  Collect(p; Cs <= P) = P <= Cs
    p[P].interface = empty //since all classes are final
 Collect(p; P <= Cs) = Cs <= P
	 MustClass(p; Cs)

  Collect(p; P <= Cs) = Cs <= P'
  	This0.Cs' in p[Cs].Pz
    P' in Supertypes(p; P)
    dom(p[Cs'].mwtz) intersects dom(p[P'].mwtz)

  Collect(p; P <= Cs) = p[P.ms].P <= Cs'
    p[Cs.ms].P = This0.Cs'

  Collect(p; CC) = Cs' <= p[P.ms].Pi
     CC = P <= Cs or  CC = Cs <= P
     p[Cs.ms].Pi = This0.Cs'

  Collect(p; Cs <= P) = Cs' <= p[P.ms].P:
  	MustInterface(p; Cs)
    p[Cs.ms].P = This0.Cs'

  Collect(p; Cs <= P) = p[P.ms].Pi <= Cs':
    MustInterface(p; Cs)
    p[Cs.ms].Pi = This0.Cs'

  // The ? rule
  Collect(p; Cs <= P) = P' <= Cs'
    This0.Cs' = p[Cs.sel].P
    P' = p[P.sel].P
    p[P'].interface?=empty and


  Collect(p; Cs <= P) = Cs' <= p[P.sel].P
    This0.Cs' = p[Cs.sel].P
    MustClass(Cs')

  Collect(p; Cs <= P, P' <= Cs') = Cs'<=p[P.sel].P
    This0.Cs' = p[Cs.sel].P
    p[P'].interface?=empty


  Collect(p; Cs <= P) = Cs' <= Origin(p; sel'; P')
    This0.Cs' = p[Cs.sel].P
    P' = p[P.sel].P
    sel' in dom(p[Cs']) intersect dom(p[P'])


  // Is this rulle insufficient? What if we have Cs <= P,
  // And P' < P, and P has no C, but P' does,
  // Therefore should we deduce that Cs <= P'?
  Collect(p; Cs <= P, P <= Cs) = Cs.C <= P.C, P.C <= Cs.C
    C in dom(p[Cs])

// TODO: Do something with exception specs,
// Specifically if we define:
//   p |- Pz throws Pz' iff
//     forall P in Pz: Supertypes(p; P) intersects Pz'
// Then:
//    p |- V(p[Cs.ms].Pz) throws p[V(Cs).ms].Pz
//    if p |- P <= P', then p |- p[P.ms].Pz throws p[P'.ms].Pz

Auxilary: Supertypes(p; Pz) = intersect {p.minimize(p[P].Pz U {P, Any}) | P in Pz}

MostSpecific(p; Pz) = P
   P in Pz
   Pz subseteq Supertypes(p; P)
   // Note: P will be unique in terms of p.equiv, since any other solution P' is in Pz
   // so P' in Supertypes(p; P), and since P in Pz, P in Supertypes(p; P')
   // Thus P <= P', and P' <= P

Define ChooseV(p; CCz) := V
  // Note: these definitions use well-formdness of V's, namely V1, V2 is ill-formed
  // if dom(V1) and dom(V2) are not disjoint, thus only one rule below can be applied
  // for each Cs
  // Marco wants to delete this rule, Isaac dosn't
  ChooseV(p; Cs <= P0, ..., Cs <= Pn, CCz) := Cs -> P, ChooseV(p; CCz)
    P = MostSpecific(p; P0,...,Pn)

  ChooseV(P; P1 <= Cs, ..., Pn <= Cs, Cs <= P'1, ..., Cs <= P'k, CCz), Cs -> P, ChooseV(p; CCz)
    Pz = Supertypes(p; P1, ..., Pn)
    Pz' = { P in Pz | {P'1, ..., P'k} subseteq Supertypes(p; P)}
    // Pz' is the set of possible solutions to the above constraints
    // if k = 0, then Pz' = Pz

    Pz'' = {P in Pz' | PossibleRedirect(p; Cs; P)}
    P = MostSpecific(p; Pz'')

   ChooseV(p; CCz) = empty
     otherwise

// Could Cs be redirected to P? (ignoring any other redirections that may or may not happen...)
PossibleRedirect(p; Cs; P) iff
    if MustInterface(p; Cs)
        p[P].interface? = interface
        dom(p[P].mwtz) = dom(p[Cs].mwtz) // No extra methods
    if MustClass(p; Cs)
        p[P].interface? = empty
    dom(p[Cs]) subseteq dom(p[P])
    // TODO: Refine this more?
--------------------------
// Some classes of ChooseRedirect functions

UniqueR(p, V1) = V2
  forall p' ~V1~ p, V2 = MostSpecific(p'; {V | ValidRedirect(p'; V1; V)})
  forall p' superset p, V2 = MostSpecific(p'; {V | ValidRedirect(p'; V1; V)})

define MostSpecific(p; Vz) = V
  V in Vz,
  forall Cs in dom(V), V' in Vz:
    p |- V(Cs) <= V'(Cs)

R0: always undefined

R1: r(p, V) = V' IFF V = V' and ValidRedirect(p; V; V)// assert ValidRedirect(ReduceProblem(p; V); V; V)

R2: if r(p, V) = V' then V' = UniqueR(p, V) and not R3// weaker than 3
  // if it suceeds, the answer is unqiue

R3: r(p; V) = UniqueR(p, V) // what we now want?

R4: if UniqueR(p, V) = V' then r(p, V) = V'
  // it always suceeds if their is a unique result but solves some ambiguites
  // same as if r(p, V) is undefined, exists a p' ~V~p such that there is no *unique* V' such that ValidRedirect(p',V, V')

------------------
