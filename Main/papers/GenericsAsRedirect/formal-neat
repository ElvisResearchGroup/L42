-------------
Module R: defines R, R(Cs)=P, R(L)=L', dom(R);
using auxiliary R_Cs(e)=e', R_Cs(T)=T', R_Cs(M)=M', R(Cs=L)=L'

R ::= (Cs->P)z // Redirection map
// A R is a methematical partial function from the set of Cs to the set of P

//______
//Define R.minimize(p)
//(Cs1->P1,...,Csn->Pn).minimize(p)=Cs1->p.minimize(P1), ..., Csn->p.minimize(Pn)

______
Define dom(R)
dom(Cs1->P1, ..., Csn->Pn) = Cs1, ..., Csn

______
Define R(Cs)=P
R(Cs) = P
  Cs->P in R // Cs renamed using R
______
// Apply R to all references to the class-names in dom(L)
// Note: this only applies to references (i.e. P's), the nested classes themselves (if present) are not redirected
Define  R(L)=R(empty=L) // Note: the top-level 'class' has no name, so we use 'empty'

// Note: that Ls found found inside expressions (i.e. es) have no names, whereas the RHS of a nested-class definition do
// However even an unanamed L may be inside a named L, and we need this information to understand what a path refers to.
// As such we will just geneerate fresh names for unnamaed Ls, thus simplifying things by giving all L's a name.

// We could also just use R_Cs(C: L) and R_Cs(L) to apply R to nested classes and L expressions (respectivley),
// however this general R(Cs = L) function prevents duplication, and so the above two just forward to it
_________
// Apply R to class 'Cs' which has body 'L'
// We need to keep track of the Cs since paths are relative, in order to know if they refer to something in dom(R)
// we need to know where the is
AuxDefine R(Cs = L)=L'

// Simply apply R to the Pz and Mz
R(Cs = {interface? implements Pz Mz}) = {interface? implements R_Cs(Pz) R_Cs(Mz)}

_________
// Apply R to a member M that was found in nested class Cs
AuxDefine R_Cs(M)=M'

// Case for methods, apply R to all types, paths and expressions
R_Cs(refine? mdf method T m(T1 x1,..,Tn xn) exception Pz e?) =
  refine? mdf method R_Cs(T) m(R_Cs(T1) x1,..,R_Cs(Tn) xn) exception R_Cs(Pz) R_Cs(e?)

// Case for nested classes, apply R to the library literal, giving it the appropriate name
R_Cs(C: L) = C: R(Cs.C = L) // Apply R to a nested class, which has name C and is in Cs
_________
// Apply R to an e, which was found in nested class Cs
AuxDefine R_Cs(e)=e'
R_Cs(L) = R(Cs.C = L), for fresh C
// TODO: Other kinds of expressions (just apply R_Cs to all e, L, T and P inside)

_________
AuxDefine R_Cs(T)=T'
// Apply R to a type, by just applying it to the mentioned path
R_Cs(mdf P) = mdf R_Cs(P)

_________
// Apply R to the path P that we found in Cs
// If a prefix of P refers to something in the domain of R, we will redirect it
// Otherwise we will leave it untouched
AuxDefine R_Cs(P)=P' // P found in Cs is renamed to P'

// We found P in Cs (of length k), so give it to R (which is defined relative to This0, but we are in This0.Cs)
// and from the result (since the start, This0, is actually Thisk from the point of view of This0.Cs,
// which is where we found the original P)
R_Cs(P) = R(Cs')[from Thisk]
    where Cs = C1...Ck
    P[from This0.CS] = This0.Cs'

otherwise
R(P in Cs) = P

// Csz' is the set of nested class names that will be redirected when all the Csz are redirected from L
// It is the transitive closure of apply 'Reachables' to each class mentioned in Csz
Define RedirectSet(L; Csz)=Csz':
-----------------------------
// If we are redirecting Csz, then we need to redirect Csz
Csz subseteq RedirectSet(L; Csz)

// Redirect the nested class mentioned in the signature of a redirected class
// We won't however be redirecting references to external paths (i.e. things outside of This0)
Cs2 in RedirectSet(L; Csz)
  Cs1 in RedirectSet(L; Csz)
  This0.Cs2 in Reachables(L[Cs1]) // TODO: Do a p.minimize?

==================================================================
// Perform and compute a redirect, using a choice function 'ChooseRedirect' to compute the R mapping
Define Redirect(p; L; Cs1, P1, ..., Csn, Pn) = R(p'.top()[remove Csz]) // Remove the things that will be redirected away
  empty not in Cs1 ... Csn // We can't redirect This0, as that does not make sense
  p' = p.evilPush(L) // to simplify everything, just make L the new top
  forall Cs in RedirectSet(L, Cs1, ..., Csn):
    Redirectable(L[Cs]) // Check that the source is valid

  // Chose a mapping, simplifying the input, and update the paths to be relative to our evil-pushed program
  ChooseRedirect(p'; Cs1, p'.minimize(P1[from This1]), ..., Csn, p'.minimize(Pn[from This1])) = R

Required properties of a ChooseRedirect function:
ChooseRedirect is a function from p*R->R' such that
  ChooseRedirect(p,R')=R'
  forall p' ~R~ p: ChooseRedirect(p',R)=R'
  ValidRedirect(p,R')
  // We should try and prove that the above definition is equivalent to one where we replace the ValidRedirect check
  // with a meta-level soudness check (I'm not certain though)
______
Define ValidRedirect(p,R,R')
  R subseteq R'
  dom(R') = RedirectSet(p.top(); dom(R))
  forall P in ran(R'):
    p.minimize(P)=P
    P not of form This0._
    p|-p(P):OK //P well typed
  forall Cs in dom(R'):
    Cs not empty
    p|- R'(Cs); p[R'(Cs)] <= Cs; R'(p[Cs])
    forall C in dom(p(Cs)): R'(Cs.C) = R'(Cs).C
    Redirectable(p.top()(Cs))

// Whether the class This0.Cs can be redirected away
// Namely: that the class contains no implemented methods or anything private
Define Redirectable(L) // L42 only
  forall mwt in L.mwtz:
    mwt.e = empty
    not Private(mwt.m)

  forall C in dom(L.ncz)
    not Private(C)

// Is the LHS (whose name is 'This0.Cs') a structural supertype of the RHS (whose name is P)
// We say that A is a structural supertype of B if any code written with respect to A
// would also type-check against B
Define p|- P; {interafce?' implements Pz' mwtz', ncz'} <= Cs; {interface? implements Pz mwtz, ncz}
  // Check that all the interfaces the LHS implements are also implemented by the RHS
  Pz subseteq_p SuperClasses(p; Pz') //Note: Using SuperClasses (and not Pz') is very important, so that F-bound polimoprhism can work TODO: explain what this means

  // If the LHS is not an interface
  if interface?=empty:
    // Check that each method-type of the RHS is a subtype of the LHS
    // (So that it any well-typed call to a method on the LHS would also typecheck if it were to call a method on the RHS)
    forall MS in dom(mwtz):
      p |- mwtz'(MS).mt <= mwt(MS).mt

    // One can only call class methods on a non-interface, so if the LHS has any, than the RHS can't be an interface
    if interface?' = interface then class not in mwtz.mdfz

  // If the LHS is an interface, we need to ensure that any valid implementation of the LHS
  // Is a valid implemention of the RHS, which requires that the RHS have the exact same method signatures as the LHS
  else:
    interface? = interface?' // You can't implement non-interfaces
    // We ignore the presence of the 'refine' keyword, since this is irealvent to any implementing classes
    mwtz[with refine?s=empty] = mwtz'[with refine?s=empty]

--------------------------------------------

p' ~R~ p  iff  ReduceProblem(p; R)=ReduceProblem(p'; R)
ReduceProblem(p; R) = p[only This0.Cs1, ..., This0.Csn, ReachableSet(p; ran(R))]
    Cs1, ..., Csn = RedirectSet(p.top(); dom(R))

// The set of paths referenced in the signatures of each P, L and mwt (excluding nested classes)
Define Reachables(p; P) = Pz, Reachables(L) = Pz, Reachables(Mz) = Pz
-----------------------------------------------------------------------
// Find's all paths that are reachable from the declaration of 'P' in p
// (i.e. ignoring methods bodies and meta-expressions)
ReachableSet(p; Pz):
    Pz subseteq ReachableSet(p; Pz)
    Pz' subseteq ReachableSet(p; Pz)
        P in ReachableSet(p; Pz)
        Pz' = p.minimize(Paths(p[P]))

Reachables({interface? implements Pz Mz}) = Pz, Paths(Mz)
Reachables(C: L) = Paths(L)[from This0.C]
Reachables(mwt) = mwt.mt.Ts.Ps, mwt.mt.T.P, mwt.mt.Pz

Define p[only Pz] = p', and L[only Pz]=L'
-----------------------------------------------
// I don't know a 42 equivalent formalisim, but who cares...
(id = L, p)[only Pz] = (id = L[only Internals(Pz)], p[only (Pz[from This0.ToC(id)])])
(empty; DVs)[only Pz] = (empty; DVs[only Pz])

(C = LV)[only Pz] = (C = LV[only Pz[From This]])
    This0.C.Cs in Pz // Something inside C is to be kept, so we need C

(DV)[only Pz] = empty
    otherwise // A trait, or a class that is to be discareded

ToC(C) = C
ToC(t) = C
    for fresh C

L[only Cs,Csz] = L[only Cs] U L[only Csz]
L[only empty] = {}
// Discard method bodies!, we don't want people looking in them, or do we?
L[only C1...Cn] = {C1: ... {Cn: L(Cs)[with ncz = empty, with mwtz.ez = empty]} ... }
------------------------
// Returns all the nested classes that are accesed from This0 (works best if Pz is minimized)
Define Internal(Pz) = Csz
    Internal(This0.Cs, Pz) = Cs, Internal(Pz)
    Internal(P, Pz) = Internal(Pz)
        otherwise

// U above is a 'dumb' sum, namely:
{interface?1 Pz C: L ... Cn: Ln Mz} U {interface?2 Pz' C1: L1' ... Cn: Ln' Mz'} =
        {interface?1 U interface?2 Pz Pz' C1: L1 U L1' ... Cn: Ln U Ln' Mz Mz'}
---------------------------------------
//// TODO: Check we are the new R4...
// TODO: Special rules for redirecting to Any?
// TODO: Handle exception clauses (BUT DON't complicate anything unrelated)

// Note: I assume that all paths mentioned in a CCz have been p.minimized
// Note: the 'interface' constraint currently only benifits early error detection, as we can't use it to infer any more constraints (or can we?)

ChooseRedirect(p; Cs1->P1, ..., Csn->Pn) = R'
  CCz0 = {Cs1 <= P1, P1 <= Cs1, ..., Csn <= Pn, Pn <= Csn}
  CCz = CollectAll(p; CCz0)
  R' = ChooseR(p; CCz)
  ValidRedirect(p; R; R') // TODO: Do something more efficient?

CC ::= Cs <= P | P <= Cs // | Cs in Pz  | interface Cs | class Cs

MustInterface(p; Cs) = p(Cs).interface? = interface
MustClass(p; Cs) = p(Cs).interface? = empty and class in p(Cs).mwtz.mdfZ

// CollectAll is the main function that collects all constraints
CollectAll(p; CCz,CCz') := CollectAll(p; CCz'')
  CCz'' = (CCz, CCz') U Collect(p; CCz)
  CCz'' != CCz,CCz'
CollectAll(p; CCz) := CCz
  Otherwise

Define p[P.ms] = p.minimize(p[P](ms))
// where p.minimize(mwt) minimizes everything in the method signature
Define p[Cs.ms] = p[This0.Cs.ms]
Define mwt.P = mwt.mt.P
Define mwt.Pi = mwt.mt.Ts.i.P

// Note: Collect isn't a function, but a relation,
// I.e. Collect(p; CCz) = Ccz' for multiple different CCz' (even with the same p; CCz)
Define Collect(p; CCz) := CCz':
1: Collect(p; Cs <= P) = P <= Cs
    p[P].interface = empty //since all classes are final
2: Collect(p; P <= Cs) = Cs <= P
	 MustClass(p; Cs)

3: Collect(p; P <= Cs) = MostSpecific(p; Pz) <= Cs', Cs' <= MostGeneral(p; Pz)
       This0.Cs' in p[Cs].Pz
       Pz = {P' in SuperClasses(p; P) | msdom(p[P') = msdom(p[Cs'])}

4: Collect(p; P <= Cs) = p[P.ms].P <= Cs'
    p[Cs.ms].P = This0.Cs'

5: Collect(p; CC) = Cs' <= p[P.ms].Pi
     CC = P <= Cs or  CC = Cs <= P
     p[Cs.ms].Pi = This0.Cs'

6: Collect(p; Cs <= P) = Cs' <= p[P.ms].P:
  	MustInterface(p; Cs)
    p[Cs.ms].P = This0.Cs'

7: Collect(p; Cs <= P) = p[P.ms].Pi <= Cs':
    MustInterface(p; Cs)
    p[Cs.ms].Pi = This0.Cs'

  // The ? rule
8a:  Collect(p; Cs <= P) = P' <= Cs'
    This0.Cs' = p[Cs.sel].P
    P' = p[P.sel].P
    p[P'].interface?=empty and
8b:  Collect(p; Cs <= P) = Cs' <= p[P.sel].P
    This0.Cs' = p[Cs.sel].P
    MustClass(Cs')
8c:  Collect(p; Cs <= P, P' <= Cs') = Cs'<=p[P.sel].P
    This0.Cs' = p[Cs.sel].P
    p[P'].interface?=empty
8d:  Collect(p; Cs <= P) = Cs' <= Origin(p; sel'; P')
    This0.Cs' = p[Cs.sel].P
    P' = p[P.sel].P
    sel' in dom(p[Cs']) intersect dom(p[P'])

8'a:  Collect(p; Cs <= P) = P' <= Cs'
    This0.Cs' in p[Cs].Pz
    P' in SuperClass(p; P)
    p[P'].interface?=empty and
8'b:  Collect(p; Cs <= P) = Cs' <= P'
    This0.Cs' in p[Cs].Pz
    P' in SuperClass(p; P)
    MustClass(Cs')
8'c:  Collect(p; Cs <= P, P'' <= Cs') = Cs'<=P'
    This0.Cs' in p[Cs].Pz
    P' in SuperClass(p; P)
    p[P''].interface?=empty
8'd:  Collect(p; Cs <= P) = Cs' <= Origin(p; sel'; P')
    This0.Cs' in p[Cs].Pz
    P' in SuperClass(p; P)
    sel' in dom(p[Cs']) intersect dom(p[P'])

  // Is this rule insufficient? What if we have Cs <= P,
  // And P' < P, and P has no C, but P' does,
  // Therefore should we deduce that Cs <= P'?
9:  Collect(p; Cs <= P, P <= Cs) = Cs.C <= P.C, P.C <= Cs.C
    C in dom(p[Cs])

// Add a rule of the form?
//Collect(p; P <= Cs) = Cs <= P', P' <= Cs
//	P' is the unique element of SuperClasses(p; P) such that PossibleRedirect(p, P', Cs)
// Handle cases like:
//	EB: {}
//	{X: {interface}, B: {implements X}}<B=EB> // And so X goes to Any?

Origin(p; sel; P) = P'
  forall P'' in Supertypes(p; P) where sel in dom [P'']
     p |- P'' <= P'

// TODO: Do something with exception specs,
// Specifically if we define:
//   p |- Pz throws Pz' iff
//     forall P in Pz: SuperClasses(p; P) intersects Pz'
// Then:
//    p |- R(p[Cs.ms].Pz) throws p[R(Cs).ms].Pz
//    if p |- P <= P', then p |- p[P.ms].Pz throws p[P'.ms].Pz

Auxilary: SuperClasses(p; Pz) = intersect {p.minimize(p[P].Pz U {P, Any}) | P in Pz}

MostSpecific(p; Pz) = P
   P in Pz
   Pz subseteq SuperClasses(p; P)
   // Note: P will be unique in terms of p.equiv, since any other solution P' is in Pz
   // so P' in SuperClasses(p; P), and since P in Pz, P in SuperClasses(p; P')
   // Thus P <= P', and P' <= P

Define ChooseR(p; CCz) := R
  // Note: these definitions use well-formdness of R's, namely R1, R2 is ill-formed
  // if dom(R1) and dom(R2) are not disjoint, thus only one rule below can be applied
  // for each Cs
  // Marco wants to delete this rule, Isaac dosn't
  ChooseR(p; Cs <= P0, ..., Cs <= Pn, CCz) := Cs -> P, ChooseR(p; CCz)
    P = MostSpecific(p; P0,...,Pn)

  ChooseR(P; P1 <= Cs, ..., Pn <= Cs, Cs <= P'1, ..., Cs <= P'k, CCz), Cs -> P, ChooseR(p; CCz)
    Pz = SuperClasses(p; P1, ..., Pn)
    Pz' = { P in Pz | {P'1, ..., P'k} subseteq SuperClasses(p; P)}
    // Pz' is the set of possible solutions to the above constraints
    // if k = 0, then Pz' = Pz

    Pz'' = {P in Pz' | PossibleRedirect(p; Cs; P)}
    P = MostSpecific(p; Pz'')

   ChooseR(p; CCz) = empty
     otherwise

// Could Cs be redirected to P? (ignoring any other redirections that may or may not happen...)
PossibleRedirect(p; Cs; P) iff
    if MustInterface(p; Cs)
        p[P].interface? = interface
        dom(p[P].mwtz) = dom(p[Cs].mwtz) // No extra methods
    if MustClass(p; Cs)
        p[P].interface? = empty
    dom(p[Cs]) subseteq dom(p[P])
    // TODO: Refine this more? For example, e.g. by looking at external paths as well?
--------------------------
// Some classes of ChooseRedirect functions

UniqueR(p, R1) = R2
  forall p' ~R1~ p, R2 = MostSpecific(p'; {R | ValidRedirect(p'; R1; R)})
  forall p' superset p, R2 = MostSpecific(p'; {R | ValidRedirect(p'; R1; R)})

define MostSpecific(p; Rz) = R
  R in Rz,
  forall Cs in dom(R), R' in Rz:
    p |- R(Cs) <= R'(Cs)

R0: always undefined

R1: r(p, R) = R' IFF R = R' and ValidRedirect(p; R; R)// assert ValidRedirect(ReduceProblem(p; R); R; R)

R2: if r(p, R) = R' then R' = UniqueR(p, R) and not R3// weaker than 3
  // if it suceeds, the answer is unqiue

R3: r(p; R) = UniqueR(p, R) // what we now want?

R4: if UniqueR(p, R) = R' then r(p, R) = R'
  // it always suceeds if their is a unique result but solves some ambiguites
  // same as if r(p, R) is undefined, exists a p' ~R~p such that there is no *unique* R' such that ValidRedirect(p',R, R')

------------------
