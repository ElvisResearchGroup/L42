A ::= (Cs->Pz)z //fuctional, well formedness: Pz is never empty
V ::= (Cs->P)z  //fuctional
E ::= (Pz1,Pz2)z

Define GuessTargets(A; p; Cs; Pz) // TODO: New
	GuessTargets(A; p; Cs; P, Pz) = P, GuessTargets(p; Cs; Pz)
		where: exists A';E: computeMaps(p; Cs->P; A) = A'; E
			//dom(p(This0.Cs)) subseteq dom(p(P))

	GuessTargets(A; p; Cs; P, Pz) = GuessTargets(p; Cs; Pz) // otherwise
	GuessTargets(A; p; Cs; empty) = empty

Define A ++p Cs -> Pz = A0
  Cs -> Pz, A  ++p Cs -> Pz' = A,Cs -> Pz intersect GuessTargets(A; p; Cs; Pz') //well formedness influential here
  A ++p Cs -> Pz' = A, Cs -> GuessTargets(A; p; Cs; Pz')

Define Thisn.P=P'
  Thisn . Thisk.Cs = This(n+k).Cs
  Thisn . P = P otherwise //this includes Any,Void,Library

Define redirect(p,L,Cs,P)=L0
  V;E=computeMapsAll(p.evilPush(L) ; Cs ->{This1.P}; empty;empty)
  //former call will go to error if we can not reduce A to empty
  FOR (Pz1, Pz2) in E:
  ERROR if exists (Pz1, Pz2) in E :
    not Pz2 subsetof  {P | P in Pz1, Outer(P)} U {V(Cs) | This0.Cs in Pz1}

  Css=minimize(dom(V)) // NEW
  L0 = L[remove Css][rename V]

Define computeMapsAll(p;A0;V0;E0)=V;E
  computeMapsAll(p;empty;V;E)=V;E
  computeMapsAll(p;Cs->{P},A0;V0;E0)= computeMasAll(p;reduceAV(A;V);V;E0,E)
    A;E=computeMaps(p.evilPush(L);Cs ->P; A0)
    V=V0,{Cs -> P}

Define computeMaps(p;Cs->P;A)=A2;E
  ERROR IF Cs = empty or Private(Cs) or p(This0.Cs) undefined
  L  = p(This0.Cs)
  ERROR IF refine? mh_n e? in L or refine? mh e in L
  L' = p(P)
  ERROR IF L is interface and L' is not interface
  ERROR IF L is not interface, mwt in L, mwt.mdf=class and L' is interface // CHANGE
  This0.Cs1,..,This0.Csn, P1..Pk  =  L.Ps[from This0.Cs], where Pi.n>0
  Ps' = L'.Ps[from P]
  ERROR IF Ps' = empty and Ps != empty
  ERROR IF Pi notin Ps' //will need to use equiv or even subtyping
  A0=A ++p Cs1 -> Ps' ++p .. ++p Csn -> Ps'
  mwt1,..,mwtn,nc1,..,nck= L.Ms[from This0.Cs] //note: implementation does not need to from ncs
  ERROR IF mwti.ms not in Dom(L')
  A1=A0 ++p Cs.(nc1.C) -> P.(nc1.C) ++p .. ++p Cs.(nck.C) -> P.(nck.C)
  mwt'i = L'(mwti.ms)[from P] //note: implementation does not need to from the method body
  A2=A1 ++p computeMaps(p;mwt1,mwt'1)++p... ++p computeMaps(p;mwtn,mwt'n)
  E=(mwt1.Ps,mwt'1.Ps),..,(mwtn.Ps,mwt'n.Ps)

Define reduceAV(A;V) = A0
  reduceAV(Cs->{P, _},A; Cs->P,V) = reduceAV(A; V)
  reduceAV(A; Cs->P,V) = reduceAV(A; V), where Cs not in dom(A)
  reduceAV(A; empty) = A

Define computeMaps(p;mwt1,mwt2)=A0 ++p .. ++p An+Cs1->Ps'+..+Csk->Ps'
  refine? mdf method T0 m(T1 x1 ..Tn xn)exception This0.Cs1..This0.Csk,Ps
  refine? mdf' method T'0 m(T'1 x1 ..T'n xn)exception Ps'
  forall P in Ps, Outer(P)
  ERROR IF mdf != mdf'
  ERROR IF Ti.mdf != T'i.mdf
  ERROR IF Ti.P != T'i.P and Outer(Ti.P)
  if Outer(Ti.P) Ai={}
  otherwise Ai=Ti.P.Cs -> {T'i.P}

------------------------------------------------------------------
================================================================================================================
------------------------------------------------------------------
V ::= (Cs->P)z

Define V(Cs) = P:
	Cs->P in V

Define V(L) = L0
	// TODO

Define Remove(L, Csz) = L0
	// TODO: (remove the named classes)

Define p|- Ts->T;Pz <= Ts'->T';Pz':
	p|- T <= T'
	p|- Ts' <= Ts
	forall P in Pz: exists P' in Pz': p|- P <= P'

Define RedirectSet(L, Cs)=Csz:
-----------------------------
Cs    in RedirectSet(L, Cs)

Cs1.C in RedirectSet(L, Cs):
	Cs1 in RedirectSet(L, Cs)
	C in dom(L[Cs1])

Cs2   in RedirectSet(L, Cs):
	Cs1 in Csz
	This0.Cs2 in Paths(L[Cs1])[from This0.Cs1]

Define Paths({interface? implements Pz; Mwt0, ..., Mwtn; NCz}) = Pz,Paths(Mwt0.Mt),...,Paths(Mwtn.Mt)
	Paths(Ts->T;Pz) = Pz,Ts.Ps,T.P

Define Redirect(p, L, Cs, P) = L0:
	let Csz := RedirectSet(L, Cs)
	exists a unique V such that:
		P  = V(Cs)
		L0 = V(Remove(L, Csz))
		Csz = dom(V)

		forall Cs' in dom(V):
			let P' := V(Cs')
			V(L)(Cs')[from This0.Cs'] >=p P' p(P')[from P'])

Define {interface? implements Pz; Mwtz; NCz} >=p P{interafce?' implements Pz'; Mwtz'; NCz'}:
	if interface? != interface?':
		interface? = empty
		interface?' = interface
		class method_ not in Mwtz

	if interface? = interface:
		Mwtz = Mwtz'

	else: forall MS in dom(Mwtz):
       	p |- Mwtz'(MS).MT <= Mwtz(MS).MT

	Pz subseteq Pz',P
------------------------------------------------------------------
================================================================================================================
------------------------------------------------------------------
Define Cs{interface? implements Pz; Mwtz; NCz} >=LR;p P{interafce?' implements Pz'; Mwtz'; NCz'}:
	if interface? != interface?':
		interface? = empty
		interface?' = interface
		class method_ not in Mwtz

	forall MS in dom(Mwtz):
	        if Called(This0.Cs; MS; LR)
			        p |- Mwtz'(MS).MT <= Mwtz(MS).MT
            if Refined(This0.Cs; MS; LR)
                    p |- Mwtz(MS).MT <= Mwtz'(MS).MT

	if interface=empty and Coherent({implements Pz; Mwtz}):
		dom(Mwtz) = dom(Mwtz')

	Pz subseteq Pz',P
	//disjoint { {Mwt.MS | Mwt in p(P) and Mwt.refine = empty} | P in Pz'}
------------------------------------------------------
Implementation


A(Cs) = {P | Cs->P in CsPz}
CsP::=Cs -> P
A ::= CsPz
------------------

Outers(This0.Cs0, ...., This0.Csn, Ps) = Ps
	where This0.Cs not in Ps

Define
A;B ==>p A';B'

Cs -> P,A;B ==>p  Cs.C0->P.C0,...,Cs.Cn->P.Cn, Cs->P, A;B
	C0,...,Cn, MSs = dom(p(This0.Cs))
 	C0,...,Cn subseteq dom(p(P))

Cs -> P,A;B ==>p  A; Cs->P,B
	C0,...,Cn, MSs = dom(p(This0.Cs))
	exists i such that:
	  Cs.Ci->P.Ci in B or Ci notin dom(p(P))
----------------------------------------------------
If:		Ps ---> Ps'
Then for all P in Ps, V(P) in Ps',P0

----------------------------------------
Cs->P,A;B ==>p  Cs'->P',Cs->P,A;B
	let Ps := p(This0.Cs).Ps[from This0.Cs]
	let Ps' := p(P).Ps[from P]

	This0.Cs' in Ps
	P' in Ps'
	Outers(Ps) subseteq Ps'

Cs->P,A;B ==>p  A;Cs->P,B
	let Ps := p(This0.Cs).Ps[from This0.Cs]
	let Ps' := p(P).Ps[from P]
	Outers(Ps) not subseteq Ps'
	or for all P' in Ps',
		there exists no This0.Cs' in Ps, such that This0.Cs'->P' in B
--------------------------------------------------------

Cs -> P,A;B ==>p  Cs.C0->P.C0,...,Cs.Cn->P.Cn, Cs->P, A;B
	C0,...,Cn, MSs = dom(p(This0.Cs))
 	C0,...,Cn subseteq dom(p(P))

Cs -> P,A;B ==>p  A; Cs->P,B
	C0,...,Cn, MSs = dom(p(This0.Cs))
	exists i such that:
	  Cs.Ci->P.Ci in B or Ci notin dom(p(P))


Define RedirectSetA(L; CsP; p) = A
=====================================
CsP in RedirectSetA(L; CsP; p)

CsP'' in RedirectSetA(L; CsP; p):
  CsP' in RedirectSetA(L; CsP; p)
  CsP'' in RedirectSetA(L; CsP'; p)

Cs.C'->P.C' in RedirectSetA(L; Cs -> P; p):
	C' in dom(L(Cs)) and C' in dom(p(P))


Cs'->P' in RedirectSetA(L; Cs -> P; p):
	This0.Cs' in L(Cs).Ps[from This0.Cs]
	P' in p(P).Ps[from P]
	//if Outers(L(Cs).Ps[from This0.Cs]) subset eq p(P).Ps[from P]
	// then Cs->P could be elided

==============
E,A -> A
E,A -> E,E1,A

----------------------------------------------------------
	if Cs1->Pz1 in A then:
        for each Mwt in L[Cs1][from This0.Cs1]:
            Let Ts->T;Ps = Mwt.MT

            LOOP1: FOR EACH P in Pz1:
                IF LET Mwt' := p(P)(Mwt.MS)[from P]:
                    let Ts'->T';Ps' = Mwt'.MT

                    Cs0->P'0,...,Csn->P'n = FOR EACH (Tr,Tr') in Zip(T,Ts;T',Ts'):
                        IF Tr.mdf != Tr'.mdf:
                            CONTINUE LOOP1

                        IF Outer(Tr.P):
                            IF Tr != Tr': CONTINUE LOOP1
                        ELSE:
                            YIELD Tr.P.Cs -> Tr'.P;

                    // IGNORING EXCEPTION SUBTYPING
                    Csn+1,P'n+1,...,Csk->P'k = FOR EACH P' in Ps'
                        IF P' not in Ps:
                            FOR EACH This0.Cs IN Ps:
                                 YIELD Cs -> P'
                            ELSE:
                            	CONTINUE LOOP1;

                    Combine(Cs0->P'0, ..., Csk->P'k) subset eq A

Where:
	Paths({interface? implements Ps; Mwt0, ..., Mwtn; NCs})
		= Ps,Paths(Mwt0.Mt),...,Paths(Mwtn.Mt)
  Paths(Ts->T;Ps) = Ps,Ts.Ps,T.P



resolve(A)



resolve(p;V;empty)=V

resolve(p;V;Cs->P,A) = resolve(p; Cs->P,V; A)
	where Cs not in dom(A)


resolve(p; Cs->P,V; A)

resolve(p;Cs->P0..Pn,A)=Cs->P0,A
  for i in 1..n:
    p(This0.Cs)[from This0.Cs] incompatible Pi,p(Pi)[from Pi]

incompatible(L, L', P, p):
	....



A=redirectSrcA //fail redirect impossible
V=resolve(A) //failed to resolve ambiguity error
check(V)  // redirect imppssobile
then V was a valid map wrt formalization

EC1:{interface A:{ .. }}
EC2:{interface A:{ .. }}
ED:{implements EC1, EC2}

{IC:{interface A:{ .. }}ID:{implements IC}}[ID=ED]





