
The traits /base/, /even/, and /odd/ are the basic building blocks we will use to compute our result. They will be compiled, typechecked and statically verified before the method /generate(exp)/ can run.
As you can see in line /37/, a class body can be an expression in the language itself.
At compile time such an expression will be run and the resulting /Trait/ will be used as the body of the class.
For example, we could write /class Pow1: base/; this would generate a class such that /new Pow1().pow(x)==x**1/.
The other two traits have abstract methods; implementations for /$\_$pow(x)/ and /$\_$exp()/ must be provided. However, given the contract of /pow(x)/,
and the fact that /even/ and /odd/ have both been statically verified,
if we supply method bodies respecting these contracts, we will get \emph{correct} code, without the need for further static verification.
Many works in literature allow adapting traits by renaming or hiding methods\cite{servetto2014meta,reppy2007metaprogramming,liquori2008feathertrait}. Hiding a method may also trigger inlining if the method body is simple enough or used only once.
Since all occurrences of names are consistently renamed, \textbf{renaming and hiding preserve code correctness}.

The /compose(current,next)/ method starts by renaming the /exp()/ and /pow(x)/ methods of /current/
so that they satisfy the contracts in /next/ (which will be 
/even/ or /odd/).
The /+/ operator is the main way to compose traits%
~\cite{scharli2003traits,LagorioSZ09}.
The result of /+/ will contain all the methods from both operands. 

Crucially, it is possible to sum traits where a method is declared in both operands; in this case at least one of the two competing methods needs to be abstract, and the signatures of the two competing methods need to be \emph{compatible}.
To make sure that the traditional /+/ operator also handles contracts, we need to require that the contract annotations of the two competing methods  are \emph{compatible}.
For the sake of our example, we can just require them to be syntactically identical. Relaxing this constraint is an important future work.
Thanks to this constraint \textbf{the sum operator also preserves code correctness}. %\IO{There are many variations of the /+/ operator, in particular, we could easily extend our contract matching to work with an nary operator}.

The sum is executed when the method /compose/
%\IO{\footnote{\IO{a generic implementation of this method that renames and hides conflicting methods has been implemented L42~\cite{l42}}}}
runs: if the matched contracts are not identical an exception will be raised. A leaked exception during compile-time metaprogramming would become a compile-time error. 
Our approach is very similar to~\cite{servetto2014meta}, and does not guarantee the success of the code generation process, rather it guarantees that if it succeeds, correct code is generated.

Finally the /$\_$pow(x)/ and /$\_$exp()/ method are hidden, so that the structural shape of the result is
the same as /base/'s.
As you can see, /Trait/s are first class values and can be manipulated with a set of primitive operators that preserve code correctness and well-typedness.
In this way, by inductive reasoning, we can start from the /base/ case and then recursively compose /even/ and /odd/ until we get the desired code.
Note how the code of /generate(exp)/ follows the same scheme of the code of /pow(x,exp)/ in line 1.

To understand our example better, imagine executing the code of /generate(7)/ while keeping /compose/ in symbolic form. We would get the following (where /c/ is short for /compose/):
\vspace{-1ex}
\begin{lstlisting}[numbers=none]
generate(7) == c(generate(6),odd) == ...
 == c(c(c(c(base,even),odd),even),odd)
\end{lstlisting}
\vspace{-1ex}
As /base/ represents /pow1(x)/; /c(base,even)/ represents /pow2(x)/. Then \Q@c(/*pow2(x)*/,odd)@ represents \Q@pow3(x)@, \Q@c(/*pow3(x)*/,even)@ represents \Q@pow6(x)@, and finally,
\Q@c(/*pow6(x)*/,odd)@ represents \Q@pow7(x)@.
The code of each /$\_$pow(x)/ method is only executed once for each top-level /pow(x)/ call, so the /hide/ operator can inline them.
Thus, the result could be identical to the manually optimized code in line 7.

%\IO{We are investigation how an additional check can be performed to ensure the resulting code has specific contracts. However, our approach does guarantee that the result will be correct according to whatever contracts it contains.} 

Our approach, as presented in this extended abstract, only guarantees that code resulting from metaprogramming follows its own contracts, it does
not statically ensure what those contracts may be. As future work, we are investigating how the resulting contracts can be ensured to have a particular meaning or form.
To do so, we need to allow assertions on the contracts of /Trait/s to be used within pre//post conditions.
For example we could allow post conditions like\\*
%\begin{lstlisting}[numbers=none]
/@ensures(result.$\mathit{methName}$.ensures ==\ $\mathit{predicate}$)/ \\*
%\end{lstlisting}
to mean that the resulting /Trait/ has
a method
called $\mathit{methName}$, whose /@ensures/ clause is syntactically identical to  /$predicate$/; whilst
\\*
/@ensures(result.$\mathit{methName}$.ensures ==>\ $\mathit{predicate}$)/
\\*
would use a static verifier to ensure that $\mathit{methName}$'s /@ensures/ clause logically implies $\mathit{predicate}$.
With these two features we could annotate the method /generate(exp)/ in line 32 above as:
\begin{lstlisting}
@requires(exp>0)
@ensures(result.exp().ensures ==> (result==exp))
@ensures(result.pow(x).ensures == (result==x**exp()))
Trait generate(Int exp) {...}
\end{lstlisting}

\vspace{-1ex}
In this way, we could statically verify the /generate(exp)/ method, however we fear such verification will be too complex or impractical. 
We could instead automatically check the above postconditions after each call to /generate(exp)/. If /generate(exp)/ is used to define a class (such as /Pow7/ above), we will guarantee that such class has the expected contracts, before it is used. Thus
there is no need to ensure the correctness of the metaprogram itself: such runtime checks are sufficient to ensure that after compilation, the code produced by metaprogramming has its expected behaviour.
%\IODel{In this case we could defer those difficult//novel predicates to run-time checks, without losing much safety:
%Iterative Composition execute metaprogramming code at
%compile time, thus even run-time verification of metaprograms would happen at compile time. This consideration could result in a crucial design decision: code performing metaprogramming does not need to be verified by SV to produce code annotated with the desired contracts; it may be sufficient to apply some type of runtime verification during compile-time execution.} \IOComm{I did a major rewording since we actually have multiple compile-times and run-times, so your version is confusing, hopefully my version makes the point more clear.}
%For example, the following code:
%\vspace{-1ex}
%\begin{lstlisting}[numbers=none]
%@ensures(new Pow7().exp()==7&&Pow7.pow.ensures=="result==x**exp()")
%class Pow7: generate(7)
%\end{lstlisting}
%\vspace{-1ex}
%may require the static verifier to check that the execution of
%/new Pow7().exp()/ will deterministically reduce to /7/, and that the /ensures/ clause of 
%/Pow7.pow/ is syntactically equivalent to 
%/result==x**exp()/. Note how this final step of static verification does not need to re-verify the body of
%/Pow7.pow/ and only needs to do a coarse grained 
%determinism check on the implementation of /Pow7.exp()/, before symbolically executing it.

In conclusion, by leveraging over conventional OO static verification techniques, we have extended the Iterative Composition form of metaprogramming with a simple contract compatibility check, to statically ensure the correctness of code produced by such metaprogramming. In particular, our approach does not require static verification of the result of metaprogramming, but only requires verification of code present directly in source code.