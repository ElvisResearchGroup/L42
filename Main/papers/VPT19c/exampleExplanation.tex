The traits /base/, /even/, and /odd/ are the basic building blocks we will use to compute our result. They will be compiled, typechecked and SVed before the method /generate(exp)/ can run.
As you can see in line /37/, a class body can be an expression in the language itself.
At compile time such an expression will be run and the resulting /Trait/ will be used as the body of the class.
For example, we could write /class Pow1: base/; this would generate a class such that /new Pow1().pow(x)==x**1/.
The other two traits have abstract methods; implementations for /$\_$pow(x)/ and /$\_$exp()/ must be provided. However, given the contract of /pow(x)/,
and the fact that /even/ and /odd/ have both been SVed,
if we supply method bodies respecting these contracts, we will get \emph{correct} code, without the need for further SV.
Many works in literature allow adapting traits by renaming or hiding methods\cite{servetto2014meta,reppy2007metaprogramming,liquori2008feathertrait}. Hiding a method may also trigger inlining if the method body is simple enough or used only once.
Since all occurrences of names are consistently renamed, \textbf{renaming and hiding preserve code correctness}.

The /compose/ method starts by renaming the /exp/ and /pow/ methods of /current/
so that they satisfy the contracts in /next/ (which will be 
/even/ or /odd/).
The /+/ operator is the main way to compose traits%
~\cite{scharli2003traits,LagorioSZ09}.
The result of /+/ will contain all the methods from both operands. 

Crucially, it is possible to sum traits where a method is declared in both operands; in this case at least one of the two competing methods needs to be abstract, and the signatures of the two competing methods need to be \emph{compatible}.
To make sure that the traditional /+/ operator also handles contracts, we need to require that the contract annotations of the two competing methods  are \emph{compatible}.
For the sake of our example, we can just require them to be syntactically identical. Relaxing this constraint is an important future work.
Thanks to this constraint \textbf{the sum operator also preserves code correctness}. \IO{There are many variations of the /+/ operator, in particular, we could easily extend our contract matching to work with an nary operator}.

The sum is executed when the method /compose/\IO{\footnote{\IO{a generic implementation of this method that renames and hides conflicting methods has been implemented L42~\cite{l42}}}} runs, if the matched contracts are not identical an exception will be raised. A leaked exception during compile-time metaprogramming would become a compile-time error. 
Our approach is very similar to~\cite{servetto2014meta}, and does not guarantee the success of the code generation process, rather it guarantees that if it succeeds, correct code is generated.

Finally the /$\_$pow(x)/ and /$\_$exp()/ method are hidden, so that the structural shape of the result is
the same as /base/'s.
As you can see, /Trait/s are first class values and can be manipulated with a set of primitive operators that preserve code correctness and well-typedness.
In this way, by inductive reasoning, we can start from the /base/ case and then recursively compose /even/ and /odd/ until we get the desired code.
Note how the code of /generate(exp)/ follows the same scheme of the code of /pow(x,exp)/ in line 1.

To understand our example better, imagine executing the code of /generate(7)/ while keeping /compose/ in symbolic form. We would get the following (where /c/ is short for /compose/):
\vspace{-1ex}
\begin{lstlisting}[numbers=none]
generate(7) == c(generate(6),odd) == ...
 == c(c(c(c(base,even),odd),even),odd)
\end{lstlisting}
\vspace{-1ex}
As /base/ represents /pow1(x)/; /c(base,even)/ represents /pow2(x)/. Then \Q@c(/*pow2(x)*/,odd)@ represents \Q@pow3(x)@, \Q@c(/*pow3(x)*/,even)@ represents \Q@pow6(x)@, and finally,
\Q@c(/*pow6(x)*/,odd)@ represents \Q@pow7(x)@.
The code of each /$\_$pow/ method is only executed once for each top-level /pow/ call, so the /hide/ operator can inline them.
Thus, the result could be identical to the manually optimized code in line 7.

\IO{We are investigation how an additional check can be performed to ensure the resulting code has specific contracts. However, our approach does guarantee that the result will be correct according to whatever contracts it contains.} For example, the following code:
\vspace{-1ex}
\begin{lstlisting}[numbers=none]
@ensures(new Pow7().exp()==7&&Pow7.pow.ensures=="result==x**exp()")
class Pow7: generate(7)
\end{lstlisting}
\vspace{-1ex}
may require the static verifier to check that the execution of
/new Pow7().exp()/ will deterministically reduce to /7/, and that the /ensures/ clause of 
/Pow7.pow/ is syntactically equivalent to 
/result==x**exp()/. Note how this final step of static verification does not need to re-verify the body of
/Pow7.pow/ and only needs to do a coarse grained 
determinism check on the implementation of /Pow7.exp()/, before symbolically executing it.

In conclusion, static verification of metaprogramming is an exciting new area of research; we are attacking the problem by reusing conventional
object oriented static verification techniques coupled with trait composition, extended to also check contract compatibility. A crucial design decision is that code performing metaprogramming does not need to be SVed to produce code annotated with the desired contracts; it would be sufficient to apply some type of runtime verification during compile-time execution.