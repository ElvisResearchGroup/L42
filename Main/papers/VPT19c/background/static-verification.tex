\noindent Object oriented languages supporting static verification (SV) usually extend the syntax for method declarations
to support \emph{contracts} in the form of pre and post-conditions~\cite{Meyer:1988:OSC:534929}.
Correctness is defined only for code annotated with such contracts.

\IO{We say that a method is \emph{correct}, if whenever its precondition holds on entry, the precondition of every method it calls also holds, and the postcondition of the method holds on return.} Automated SV typically works by asking an automated theorem prover to verify that each method is correct individually, by assuming the correctness of every other method \IODel{and the method's own precondition}~\cite{barnett2004spec}. This process can be very slow \IO{and produce unexpected results, since SV is undecidable, correct code may not necessarily pass a SV. Making matters worse, the way an SV works is not easily understood by programmers, thus it is non trivial for them to transform or construct code that will be SVed.}

Metaprogramming is often used to programmatically generate faster specialised code when some parameters are known in advance\IO{, this is particularly useful where the specialisation mechanism is too complicated for a generic compiler to automatically derive~\cite{Ofenbeck:2017:SGP:3136040.3136060}}
\IO{We could use metaprogramming to generate code together with contracts, and then once the metaprogramming has been run, SV the resulting code, thus ensuring it's correctness. However, the resulting code could be much larger than the input to the metaprogramming, and so could take a long time to SV. Even if the generated code was produce by using straightforward transformations and compositions over the input code, a SV might not verify it's correctness. The aim of our work is to ensure that result of metaprogramming is correct by construction, and thus not require SV, as well as for it to be predictable weather such constructions will succeed.}

\IO{Here we use the} disciplined form of metaprogramming \IO{introduced} by Servetto \& Zucca \cite{servetto2014meta}, which is based on trait composition and adaptation~\cite{scharli2003traits}.
Here a /Trait/ is a unit of code: a set of method declarations with pre//post-conditions. \IOComm{REV2 wants us to properly define what a triat is}
They are well-typed and correct.
/Trait/s directly written in the source code, 
\IO{we extend prior work, by also requiring that they are \emph{proven correct by SV}.
We extend the checking performed by composition and adaptation of /Trait/s to also check that contracts preserved, ensuring the correctness of the result.}
\IOComm{I don't think my rewording makes our contribuition explicit enough..}
%
%The result of composing and adapting /Trait/s is also correct and well-typed.
%
\IO{In our style,} metaprogramming does not generate code directly, \IO{rather} code is only generated by composing and adapting traits\IO{, thus by induction, the result of metaprogramming is also correct.}
\IODel{However generated code may not be able to pass SV, since theorem provers are not complete.}

SV handles /extends/ and /implements/ by verifying that every 
time a method is implemented//overriden, 
the Liskov substitution principle~\cite{Liskov:1994:BNS:197320.197383} is satisfied\IO{: the implementation and any additional contracts must satisfy the contract of the method that is being implemented//overriden}. In this way, there is no need to re-verify
inherited code in the context of the derived class, \IO{nor verify each call to a class's method based on each possible implementation.}
This is easily adapted
to handle trait composition, which simply provides another way to implement an /abstract/ method.
When traits are composed,
it is sufficient
to match the contracts of the few composed methods
to ensure the whole result is correct.

In our examples we will use the notation /@requires($predicate$)/ 
to specify a precondition, and /@ensures($predicate$)/ 
to specify a postcondition; where $predicate$ is a boolean expression
in terms of the parameters of the method (including /this/), and for the /@ensures/ case, the /result/ of the method.
Suppose we want to implement an efficient exponentiation function, we could use recursion and the common technique of `repeated squaring':
\vspace{-1ex}
\begin{lstlisting}
@requires(exp > 0)
@ensures(result == x**exp) // Here x**y means x to the power of y
Int pow(Int x, Int exp) {
	if (exp == 1) return x;
	if (exp %2 == 0) return pow(x*x, exp/2); // exp is even
	return x*pow(x, exp-1); }  // exp is odd
\end{lstlisting}
If the exponent is known at compile time,
unfolding the recursion produces even more efficient code:
\vspace{-1ex}
\begin{lstlisting}[firstnumber=7]
@ensures(result == x**7) Int pow7(Int x) { 
  Int x2 = x*x; // x**2
  Int x4 = x2*x2; // x**4
  return x*x2*x4; } // Since 7 = 1 + 2 + 4
\end{lstlisting}
\vspace{-1ex}


Now we show how we can use the technique of iterative trait composition, together with our contract matching\IO{, to write a meta-programming, that given an exponent, produces} code like the above. \IO{Iterative trait composition} employing a technique called \emph{compile-time execution}~\cite{sheard2002template}\IO{, in which a meta-program is executed at compile time, and the result (a /Trait/) is treated as if it was directly written by the programmer.}
\vspace{-1ex}
\begin{lstlisting}[firstnumber=11]
Trait base=class {//induction base case: pow(x) == x**1
  @ensures(result>0) Int exp(){return 1;}  
  @ensures(result==x**exp()) Int pow(Int x){return x;}
  }
Trait even=class {//if _pow(x)== x**_exp(), pow(x) == x**(2*_exp())
  @ensures(result>0) Int $\_$exp();
  @ensures(result==2*$\_$exp()) Int exp(){return 2*$\_$exp();}
  @ensures(result==x**$\_$exp()) Int $\_$pow(Int x);
  @ensures(result==x**exp()) Int pow(Int x){return $\_$pow(x*x);}
}
Trait odd=class {//if _pow(x)== x**_exp(), pow(x) == x**(1+_exp())
  @ensures(result>0) Int $\_$exp();
  @ensures(result==1+$\_$exp()) Int exp(){return 1+$\_$exp();}
  @ensures(result==x**$\_$exp()) Int $\_$pow(Int x);
  @ensures(result==x**exp()) Int pow(Int x){return x*$\_$pow(x);}
}
//`compose' performs a step of iterative composition
Trait compose(Trait current, Trait next){
  current = current[rename exp->$\_$exp, pow->$\_$pow];
  return (current+next)[hide $\_$exp, $\_$pow];}
@requires(exp>0)//the entry point for our metaprogramming
Trait generate(Int exp) {
  if (exp==1) return base;
  if (exp%2==0) return compose(generate(exp/2),even);
  return compose(generate(exp-1),odd);
};
class Pow7: generate(7) //generate(7) is executed at compile time
//the body of class Pow7 is the result of generate(7)
/*example usage:*/new Pow7().pow(3)==2187//Compute 3**7
\end{lstlisting}
\vspace{-1ex}