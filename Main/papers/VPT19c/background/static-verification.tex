\noindent Object oriented languages supporting static verification usually extend the syntax for method declarations
to support \emph{contracts} in the form of pre and post-conditions~\cite{Meyer:1988:OSC:534929}.
Correctness is defined only for code annotated with such contracts.

We say that a method is \emph{correct}, if whenever its precondition holds on entry, the precondition of every directly invoked method holds, and the postcondition of the method holds when the method returns. Automated static verification typically works by asking an automated theorem prover to verify that each method is correct individually, by assuming the correctness of every other method~\cite{barnett2004spec}. This process can be very slow and can produce unexpected results: since static verification is undecidable correct code may not pass a particular static verifier.
Many static verification approaches are not resilient to
standard refactoring techniques like 
method inlining. Sometimes static verification even times out, making the behaviour even more sensitive to such refactoring techniques.

Metaprogramming is often used to programmatically generate faster specialised code when some parameters are known in advance, this is particularly useful where the specialisation mechanism is too complicated for a generic compiler to automatically derive~\cite{Ofenbeck:2017:SGP:3136040.3136060}.
We could use metaprogramming to generate code together with contracts, and then once the metaprogramming has been run,
% \MSDel{ensure the correctness of} 
statically verify the resulting code. 
However, the resulting code could be much larger than the input to the metaprogramming, and so it could take a long time to statically verify.
Moreover, one of the many goals of metaprogramming is to make it easier to generate many specialised versions of the same  code.
%, Even if the generated code was produced by using straightforward transformations and compositions over the input code, a SV might not verify it's correctness.
The aim of our work is to statically verify only the original source code itself, and not the code produced by metaprogramming.
Instead, we
ensure that the result of metaprogramming is correct by construction.

Here we use the disciplined form of metaprogramming introduced by Servetto and Zucca \cite{servetto2014meta}, which is based on trait composition and adaptation~\cite{scharli2003traits}.
Here a /Trait/ is a unit of code: a set of method declarations.
Such methods can be abstract and can be
mutually recursive by using the implicit parameter /this/.

As in~\cite{servetto2014meta}
we require that all the traits are well-typed
before they are used.
We extend this by allowing
methods to be annotated with pre//post-conditions, and 
ensuring that traits are correct in terms of such contracts.
/Trait/s directly written in the source code are statically verified, while traits resulting from metaprogramming are ensured correct by only providing trait operations that preserve correctness. 
In particular, we \textbf{only} need to extend the checking performed by the traditional trait composition (/+/)  operator to also check the compatibility of contracts.

%
%The result of composing and adapting /Trait/s is also correct and well-typed.
%
Our metaprogramming approach does not allow generating code from scratch, such as by directly generating ASTs, rather the language provides a specific set of primitive composition and adaptation operators which preserve correctness.
Thus the result of metaprogramming is guaranteed to be well typed and correct.
%Note that generated code may not be able to pass a particular static verifier.


Static verification usually handles /extends/ and /implements/ by verifying that every 
time a method is implemented//overriden, 
the Liskov substitution principle~\cite{Liskov:1994:BNS:197320.197383} is satisfied
by checking that the contracts of the method in the derived class implies the contract of any corresponding methods in its base classes. 
 In this way, there is no need to re-verify
inherited code in the context of the derived class.
This concept is easily adapted
to handle trait composition, which simply provides another way to implement an /abstract/ method.
When traits are composed,
it is sufficient
to match the contracts of the few composed methods
to ensure the whole result is correct.

In our examples we will use the notation /@requires($predicate$)/ 
to specify a precondition, and /@ensures($predicate$)/ 
to specify a postcondition; where $predicate$ is a boolean expression
in terms of the parameters of the method (including /this/), and for the /@ensures/ case, the /result/ of the method.
Suppose we want to implement an efficient exponentiation function, we could use recursion and the common technique of `repeated squaring':
\vspace{-1ex}
\begin{lstlisting}
@requires(exp > 0)
@ensures(result == x**exp) // Here x**y means x to the power of y
Int pow(Int x, Int exp) {
	if (exp == 1) return x;
	if (exp %2 == 0) return pow(x*x, exp/2); // exp is even
	return x*pow(x, exp-1); }  // exp is odd
\end{lstlisting}
If the exponent is known at compile time,
unfolding the recursion produces even more efficient code:
\vspace{-1ex}
\begin{lstlisting}
@ensures(result == x**7) Int pow7(Int x) { 
  Int x2 = x*x; // x**2
  Int x4 = x2*x2; // x**4
  return x*x2*x4; } // Since 7 = 1 + 2 + 4
\end{lstlisting}
\vspace{-1ex}


Now we show how the technique of \emph{Iterative Composition} (introduced in~\cite{servetto2014meta} and
enriched by the contract compatibility check we propose performing in trait composition) 
can be used to write a metaprogram that given an exponent, produces code like the above.
Iterative Composition is a metacircular metaprogramming technique relying on \emph{compile-time execution} (a form of execution also used by~\cite{sheard2002template}),
in our context this means that arbitrary expressions can be used as the right hand side of a class declaration; during compilation such expressions will be evaluated to produce a /Trait/, which provides the body of the class. In this way metaprograms can be represented as otherwise normal functions//methods that return a /Trait/, without requiring the use of any additional `meta language'.
 

%\vspace{-1ex}
\begin{lstlisting}
Trait base=class {//induction base case: pow(x)==x**1
  @ensures(result>0) Int exp(){return 1;}  
  @ensures(result==x**exp()) Int pow(Int x){return x;}
  }
Trait even=class {//if _pow(x)==x**_exp(), pow(x)==x**(2*_exp())
  @ensures(result>0) Int $\_$exp();
  @ensures(result==2*$\_$exp()) Int exp(){return 2*$\_$exp();}
  @ensures(result==x**$\_$exp()) Int $\_$pow(Int x);
  @ensures(result==x**exp()) Int pow(Int x){return $\_$pow(x*x);}
}
Trait odd=class {//if _pow(x)==x**_exp(), pow(x)==x**(1+_exp())
  @ensures(result>0) Int $\_$exp();
  @ensures(result==1+$\_$exp()) Int exp(){return 1+$\_$exp();}
  @ensures(result==x**$\_$exp()) Int $\_$pow(Int x);
  @ensures(result==x**exp()) Int pow(Int x){return x*$\_$pow(x);}
}
//`compose' performs a step of iterative composition
Trait compose(Trait current, Trait next){
  current = current[rename exp()->$\_$exp(), pow(x)->$\_$pow(x)];
  return (current+next)[hide $\_$exp(), $\_$pow(x)];}
@requires(exp>0)//the entry point for our metaprogramming
Trait generate(Int exp) {
  if (exp==1) return base;
  if (exp%2==0) return compose(generate(exp/2),even);
  return compose(generate(exp-1),odd);
};
class Pow7: generate(7) //generate(7) is executed at compile time
//the body of class Pow7 is the result of generate(7)
/*example usage:*/new Pow7().pow(3)==2187//Compute 3**7
\end{lstlisting}
%\vspace{-1ex}
