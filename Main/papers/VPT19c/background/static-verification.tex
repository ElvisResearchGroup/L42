\noindent Object oriented languages supporting static verification (SV) usually extend the syntax for method declarations
to support \emph{contracts} in the form of pre and post-conditions~\cite{Meyer:1988:OSC:534929}.
Correctness is defined only for code annotated with such contracts.
\REV{We say that such code is \emph{correct} if 
before a method is called, its precondition holds, and \REV{before a method returns, its postcondition holds}{3}{A typo: before --> immediately after}.}{2}{This is contradicted by the next sentence, where it is stated that the verifier "assumes the correctness of every other method and the method's own precondition". The original sentence should be "We say that such code is correct if, assuming that its precondition holds before the method is called, its post-condition holds when the method returns" (which would be the usual correctness condition for a contract).}
Automated SV typically works by asking an automated theorem prover to verify that each method is correct individually, by assuming the correctness of every other method and the method's own precondition~\cite{barnett2004spec}. This process can be very slow and \REV{unpredictable}{1}{What do you mean by ``SV is unpredictable"? I would be careful here because unpredictability may mean nondeterminism. That is, you verify a program once, and get "Correct"; then you verify it the second time, and get ``Buggy".},
as %that is, SV is a process that can be applied to annotated code to check if such code is correct, but
there may be correct code that does not pass SV on a certain theorem prover.

\REV{Metaprogramming is often used to programmatically generate faster specialised code 
when some parameters are known in advance. %This allows for user definable optimisations.
To use metaprogramming and SV together, we could generate code
containing contracts, and such code could be checked after metaprogramming has been completed.
SV could then be applied to the code resulting from the metaprogramming to ensure it is correct.
However this could be very time consuming, since it would require verifying all the generated code from scratch.
Even worse, since \REV{SV is unpredictable}{3}{It sounds strange. It seems to me that should be (here and, maybe, above) something like the following:  `in general SV is undecidable'.  Please consider revising this sentence.}, there would be no guarantee that the result of a given metaprogram will be verifiable, even if its result is correct by construction.}{2}{This paragraph seems to boil down to saying that it is preferable to verify the meta-program directly rather than the code
resulting from running the meta-program. This statement requires some
justification rather than that the latter would be "time consuming". In
some cases verification of the generated code could be much easier. The 
running example seems to be a case in point. }

We extend the disciplined form of metaprogramming of Servetto \& Zucca \cite{servetto2014meta}, which is based on trait composition and adaptation~\cite{scharli2003traits}.
Here a /Trait/ is a unit of code: a set of method declarations with pre//post-conditions.
They are well-typed and correct.
/Trait/s directly written in the source code
are proven correct by SV.
The composition and adaptation of /Trait/s is carefully defined to preserve correctness.
%
%The result of composing and adapting /Trait/s is also correct and well-typed.
%
Metaprogramming cannot generate code directly, code is only generated by composing and adapting traits, thus generated code is also correct.
However generated code may not be able to pass SV, since theorem provers are not complete.

SV handles /extends/ and /implements/ by verifying that every 
time a method is implemented//overriden, 
the \REV{Liskov substitution principle}{2}{Please explain or cite a reference} is satisfied. In this way, there is no need to re-verify
the inherited code in the context of the derived class.
This is easily adapted
to handle trait composition, which simply provides another way to implement an /abstract/ method.
When traits are composed,
it is sufficient
to match the contracts of the few composed methods
to ensure the whole result is correct.

In our examples we will use the notation /@requires($predicate$)/ 
to specify a precondition, and /@ensures($predicate$)/ 
to specify a postcondition; where $predicate$ is a boolean expression
in terms of the parameters of the method (including /this/), and for the /@ensures/ case, the /result/ of the method.
Suppose we want to implement an efficient exponentiation function, we could use recursion and the common technique of `repeated squaring':
\vspace{-1ex}
\begin{lstlisting}
@requires(exp > 0)
@ensures(result == x**exp) // Here x**y means x to the power of y
Int pow(Int x, Int exp) {
	if (exp == 1) return x;
	if (exp %2 == 0) return pow(x*x, exp/2); // exp is even
	return x*pow(x, exp-1); }  // exp is odd
\end{lstlisting}
If the exponent is known at compile time,
unfolding the recursion produces even more efficient code:
\vspace{-1ex}
\begin{lstlisting}[firstnumber=7]
@ensures(result == x**7) Int pow7(Int x) { 
  Int x2 = x*x; // x**2
  Int x4 = x2*x2; // x**4
  return x*x2*x4; } // Since 7 = 1 + 2 + 4
\end{lstlisting}
\vspace{-1ex}
\REV{Now we show how we can use the technique of iterative trait composition, together with our contract matching, to generate code like the above, employing a technique called \emph{compile-time execution}~\cite{sheard2002template}}{3}{But actually you use compile-time symbolic execution rather than compile-time execution, and even, speaking on technical details, program specialization method known as partial evaluation. Is it correct? But no reference to the corresponding papers is given. There is a huge literature relating to different methods of automated program specialization. Do you aware about? A number of such references should be included in the short reference list ending your extended abstract.\\\indent
There are also many works on verification by program specialization. Maybe they are useful for improving your methods. Just please pay attention to this subject.}:
\vspace{-1ex}
\begin{lstlisting}[firstnumber=11]
Trait base=class {//induction base case: pow(x) == x**1
  @ensures(result>0) Int exp(){return 1;}  
  @ensures(result==x**exp()) Int pow(Int x){return x;}
  }
Trait even=class {//if _pow(x)== x**_exp(), pow(x) == x**(2*_exp())
  @ensures(result>0) Int $\_$exp();
  @ensures(result==2*$\_$exp()) Int exp(){return 2*$\_$exp();}
  @ensures(result==x**$\_$exp()) Int $\_$pow(Int x);
  @ensures(result==x**exp()) Int pow(Int x){return $\_$pow(x*x);}
}
Trait odd=class {//if _pow(x)== x**_exp(), pow(x) == x**(1+_exp())
  @ensures(result>0) Int $\_$exp();
  @ensures(result==1+$\_$exp()) Int exp(){return 1+$\_$exp();}
  @ensures(result==x**$\_$exp()) Int $\_$pow(Int x);
  @ensures(result==x**exp()) Int pow(Int x){return x*$\_$pow(x);}
}
//`compose' performs a step of iterative composition
Trait compose(Trait current, Trait next){
  current = current[rename exp->$\_$exp, pow->$\_$pow];
  return (current+next)[hide $\_$exp, $\_$pow];}
@requires(exp>0)//the entry point for our metaprogramming
Trait generate(Int exp) {
  if (exp==1) return base;
  if (exp%2==0) return compose(generate(exp/2),even);
  return compose(generate(exp-1),odd);
};
class Pow7: generate(7) //generate(7) is executed at compile time
//the body of class Pow7 is the result of generate(7)
/*example usage:*/new Pow7().pow(3)==2187//Compute 3**7
\end{lstlisting}
\vspace{-1ex}