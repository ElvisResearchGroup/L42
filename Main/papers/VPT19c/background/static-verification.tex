\noindent Object oriented languages supporting static verification (SV) usually extend the syntax for method declarations
to support \emph{contracts} in the form of pre and post-conditions~\cite{Meyer:1988:OSC:534929}.
Correctness is defined only for code annotated with such contracts.

\IO{We say that a method is \emph{correct}, if whenever its precondition holds on entry, the precondition of every \MS{directly invoked method holds}, and the postcondition of the method holds \MS{when the method} returns.} Automated SV typically works by asking an automated theorem prover to verify that each method is correct individually, by assuming the correctness of every other method~\cite{barnett2004spec}. This process can be very slow \IO{and \MS{can} produce unexpected results}: \MS{since SV is undecidable correct code may not pass SV.
Many SV approaches are not resilient to
some standard refactoring techniques like 
method inlining. Sometimes SV even terminate for a time-out, exacerbating the impact of transformations like method inlining.}

Metaprogramming is often used to programmatically generate faster specialised code when some parameters are known in advance\IO{, this is particularly useful where the specialisation mechanism is too complicated for a generic compiler to automatically derive~\cite{Ofenbeck:2017:SGP:3136040.3136060}}
\IO{We could use metaprogramming to generate code together with contracts, and then once the metaprogramming has been run,} 
\MS{ensure the correctness of the resulting code
by applying SV.} However, the resulting code could be much larger than the input to the metaprogramming, and so it could take a long time to SV.
\MS{Moreover, one of the main goal of metaprogramming  is make it easy to generate many specialized versions of the same functionality}.
%, Even if the generated code was produced by using straightforward transformations and compositions over the input code, a SV might not verify it's correctness.
The aim of our work is to \MS{apply SV} only to the code manually wrote by the programmer, 
and to ensure that \MS{the} result of metaprogramming is \MS{instead} correct by construction.

\IO{Here we use the} disciplined form of metaprogramming \IO{introduced} by Servetto \& Zucca \cite{servetto2014meta}, which is based on trait composition and adaptation~\cite{scharli2003traits}.
Here a /Trait/ is a unit of code: a set of method declarations.
\MS{Those methods can be abstract, and they can
 be mutually recursive by using the implicit parameter /this/.}

\MS{As in~\cite{servetto2014meta}
we require that all the traits are well-typed
before they are used.
Moreover, in our proposed approach we 
annotating methods with pre//post-conditions, and 
we require that all traits are also correct.
/Trait/s directly written in the source code are proven correct by SV, while traits resulting from metaprogramming are correct by construction}.

\MS{Crucially, we improve the checking} performed by composition and adaptation of /Trait/s to also check that contracts \MS{are composed correctly}; thus ensuring the correctness of the result.
%
%The result of composing and adapting /Trait/s is also correct and well-typed.
%
\MS{Our metaprogramming approach} does not generate code \MS{from scratch}; \IO{rather} code is only generated by composing and adapting traits.
\MS{Each composition//adaptation step is guaranteed
to produce well typed and correct code}; \IO{thus also the result of metaprogramming is well typed and correct.}
Note that generated code may not be able to pass SV, since theorem provers are not complete.


SV handles /extends/ and /implements/ by verifying that every 
time a method is implemented//overriden, 
the Liskov substitution principle~\cite{Liskov:1994:BNS:197320.197383} is satisfied
by checking that the new contract implies the
overridden one. 
 In this way, there is no need to re-verify
inherited code in the context of the derived class.
This concept is easily adapted
to handle trait composition, which simply provides another way to implement an /abstract/ method.
When traits are composed,
it is sufficient
to match the contracts of the few composed methods
to ensure the whole result is correct.

In our examples we will use the notation /@requires($predicate$)/ 
to specify a precondition, and /@ensures($predicate$)/ 
to specify a postcondition; where $predicate$ is a boolean expression
in terms of the parameters of the method (including /this/), and for the /@ensures/ case, the /result/ of the method.
Suppose we want to implement an efficient exponentiation function, we could use recursion and the common technique of `repeated squaring':
\vspace{-1ex}
\begin{lstlisting}
@requires(exp > 0)
@ensures(result == x**exp) // Here x**y means x to the power of y
Int pow(Int x, Int exp) {
	if (exp == 1) return x;
	if (exp %2 == 0) return pow(x*x, exp/2); // exp is even
	return x*pow(x, exp-1); }  // exp is odd
\end{lstlisting}
If the exponent is known at compile time,
unfolding the recursion produces even more efficient code:
\vspace{-1ex}
\begin{lstlisting}[firstnumber=7]
@ensures(result == x**7) Int pow7(Int x) { 
  Int x2 = x*x; // x**2
  Int x4 = x2*x2; // x**4
  return x*x2*x4; } // Since 7 = 1 + 2 + 4
\end{lstlisting}
\vspace{-1ex}


Now we show how \MS{the technique of \emph{Iterative Composition} (introduced in~\cite{servetto2014meta} and
enriched by our contract composition check)
can be used to write a meta-\MS{program} that given an exponent, produces} code like the above.
\MS{Iterative Composition is a metacircular meta-programming technique relying on \emph{compile-time execution} (as ~\cite{sheard2002template}), thus a meta-program
 is just a function or a method wrote in the target programming language that is executed during compilation.}

\vspace{-1ex}
\begin{lstlisting}[firstnumber=11]
Trait base=class {//induction base case: pow(x) == x**1
  @ensures(result>0) Int exp(){return 1;}  
  @ensures(result==x**exp()) Int pow(Int x){return x;}
  }
Trait even=class {//if _pow(x)== x**_exp(), pow(x) == x**(2*_exp())
  @ensures(result>0) Int $\_$exp();
  @ensures(result==2*$\_$exp()) Int exp(){return 2*$\_$exp();}
  @ensures(result==x**$\_$exp()) Int $\_$pow(Int x);
  @ensures(result==x**exp()) Int pow(Int x){return $\_$pow(x*x);}
}
Trait odd=class {//if _pow(x)== x**_exp(), pow(x) == x**(1+_exp())
  @ensures(result>0) Int $\_$exp();
  @ensures(result==1+$\_$exp()) Int exp(){return 1+$\_$exp();}
  @ensures(result==x**$\_$exp()) Int $\_$pow(Int x);
  @ensures(result==x**exp()) Int pow(Int x){return x*$\_$pow(x);}
}
//`compose' performs a step of iterative composition
Trait compose(Trait current, Trait next){
  current = current[rename exp->$\_$exp, pow->$\_$pow];
  return (current+next)[hide $\_$exp, $\_$pow];}
@requires(exp>0)//the entry point for our metaprogramming
Trait generate(Int exp) {
  if (exp==1) return base;
  if (exp%2==0) return compose(generate(exp/2),even);
  return compose(generate(exp-1),odd);
};
class Pow7: generate(7) //generate(7) is executed at compile time
//the body of class Pow7 is the result of generate(7)
/*example usage:*/new Pow7().pow(3)==2187//Compute 3**7
\end{lstlisting}
\vspace{-1ex}