\noindent Object oriented languages supporting static verification (SV) usually extend the syntax for method declarations
to support \emph{contracts} in the form of pre and post conditions~\cite{Meyer:1988:OSC:534929}.
Correctness is defined only for code annotated with contracts.
We say that such code is \emph{correct} if 
before any method is called its precondition holds, and before a method returns, its post-condition holds.
Automated SV typically works by asking an automated theorem prover to verify each method is correct individually, by assuming the correctness of every other method and the methods own pre-condition~\cite{barnett2004spec}. This process can be very slow, and unpredictable;
that is, SV is a process that can be applied to annotated code
to check if such code is correct, but there may be correct code that does not pass static verification
 on a certain theorem prover.

Metaprogramming is often used to programmatically generate faster specialised code 
when some parameters are known in advance. %This allows for user definable optimisations.
To use metaprogramming and SV together, we could generate code
containing contracts, and such code could be checked after metaprogramming has been completed.
SV could then be applied to the code resulting from the metaprogramming to ensure it is correct.
However this could be very time consuming, since it would require verifying all the generated code from scratch.
Even worst, since SV is unpredictable, there would be no guarantee that the result of a given metaprogram will be verifiable, even if its result is correct by construction.

We propose a disciplined form of metaprogramming based on trait composition and adaptation~\cite{scharli2003traits,servetto2014meta}.
Here a /Trait/ is a class body which is well-typed and correct (according to the contracts of its methods).
/Trait/s directly written in the source code
are proven correct by SV.
The result of composing and adapting /Trait/s is also correct and well-typed.
Metaprogramming can not generate code directly, instead code is generated by composing and adapting traits, thus generated code is guaranteed correct.
However the code resulting from metaprogramming may not be able to pass SV, since theorem provers are usually not complete.

SV handles /extends/ and /implements/ by verifying that every 
time a method is implemented//overriden, 
the Liskov substitution principle is preserved. In this way, there is no need to re-verify
the inherited code in the context of the derived class.
This idea is easily adapted
to handle trait composition, which simply provides another way to implement an /abstract/ method.
When traits are composed,
it is sufficient
to check that the contracts of a few methods match 
to ensure the whole result is correct. \IOComm{which methods?}

In our examples we will use the notation /@requires($predicate$)/ 
to specify a precondition, and /@ensures($predicate$)/ 
to specify a postcondition; predicates are boolean expressions
in terms of the parameters of the method (including /this/), and for the /@ensures/ case, the /result/ of the method call.
Suppose we want to implement an efficient exponentiation function, we could use recursion and the common technique of `repeated squaring':
\vspace{-1ex}
\begin{lstlisting}
@requires(exp > 0)
@ensures(result == x**exp) // Here x**y means x to the power of y
Int pow(Int x, Int exp) {
	if (exp == 1) return x;
	if (exp %2 == 0) return pow(x*x, exp/2); // exp is even
	return x*pow(x, exp-1); }  // exp is odd
\end{lstlisting}
If the exponent, /exp/, is known at compile time,
unfolding the recursion produces even more efficient code:
\vspace{-1ex}
\begin{lstlisting}[firstnumber=7]
@ensures(result == x**7) Int pow7(Int x) { 
  Int x2 = x*x; // x**2
  Int x4 = x2*x2; // x**4
  return x*x2*x4; } // Since 7 = 1 + 2 + 4
\end{lstlisting}
Now we show how we can use the technique of iterative trait composition, together with our contract matching, to generate code like the above, employing a technique called compile-time-execution~\cite{sheard2002template}:
\vspace{-1ex}
\begin{lstlisting}[firstnumber=11]
Trait base=class {//induction base case: pow(x) == x**1
  @ensures(result>0) Int exp(){return 1;}  
  @ensures(result==x**exp()) Int pow(Int x){return x;}
  }
Trait even=class {//if _pow(x)== x**_exp(), pow(x) == x**(2*_exp())
  @ensures(result>0) Int $\_$exp();
  @ensures(result==2*$\_$exp()) Int exp(){return 2*$\_$exp();}
  @ensures(result==x**$\_$exp()) Int $\_$pow(Int x);
  @ensures(result==x**exp()) Int pow(Int x){return $\_$pow(x*x);}
}
Trait odd=class {//if _pow(x)== x**_exp(), pow(x) == x**(1+_exp())
  @ensures(result>0) Int $\_$exp();
  @ensures(result==1+$\_$exp()) Int exp(){return 1+$\_$exp();}
  @ensures(result==x**$\_$exp()) Int $\_$pow(Int x);
  @ensures(result==x**exp()) Int pow(Int x){return x*$\_$pow(x);}
}
//'compose' performs a step of iterative composition// whats up with `'
Trait compose(Trait current, Trait next){
  current = current[rename exp->$\_$exp, pow->$\_$pow];
  return (current+next)[hide $\_$exp, $\_$pow];}
@requires(exp>0)//the entry point for our metaprogramming
Trait generate(Int exp) {
  if (exp==1) return base;
  if (exp%2==0) return compose(generate(exp/2),even);
  return compose(generate(exp-1),odd);
};
class Pow7=generate(7) //generate(7) is executed at compile time
//the body of class Pow7 is the result of generate(7)
/*example usage:*/new Pow7().pow(3)==2187//Compute 3**7
\end{lstlisting}
\IOComm{/class Pow7 = generate(7)/ looks like your implictly converting a /Trait/ to a /class/, this is why I used a ':' to distinguish class creation from deaclearing a static variable of type /class/}