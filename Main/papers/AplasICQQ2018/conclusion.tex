\section{Case study: evaluation in the 42 language}
42
is an ambitious language, aiming to 
 allow thousands of libraries to work together in a safe and maintainable manner.
 To this aim
 the actual 42 syntax is a little different from the one presented here, that is focused on making IC easier to grasp.
 
For example, operations are properly packaged under libraries: indeed most operators
are accessed under \Q@Refactor@, as in \Q@Refactor.rename(...)@.
The super call mechanism is different: instead of user specified names, override
uses conventional names: for \Q@toS()@ they would be \Q@#1toS()@ and \Q@#2toS()@.

Another very important difference is that 42 sightly relaxes the requirement that all library literals are well typed whenever they are involved in execution.
 This carefully designed relaxation does not weaken the formal properties of the language, and provides two advantages:
 it facilitates the use of mutually recursive type declarations, as very common in OO languages, and it allows 
 to omit some abstract method declarations.
%A clear explanation of this technique would deserve a paper of its own. 

The core primitive operators include symmetric sum of code, redirect and rename.
Programmers rarely use such operators directly, favouring derived and more high level operators, similar
to \Q@Override@ as presented in this paper.

42 is \textbf{designed around meta-programming}, where
IC is the \textbf{only} way for code reuse and code adaptation.



Large practical experiments give us confidence that IC can be successfully and conveniently used
to replace both QQ and conventional core reuse features, as \Q@extends@ or generics.
An (anonymized) 42 tutorial can be found at \url{l42.is/tutorial.xhtml}, while
the GitHub project (not anonymized) can be reached at \url{github.com/ElvisResearchGroup/L42}.
At URL \url{github.com/ElvisResearchGroup/L42/tree/master/Tests/src}
you can find about 10k lines of 42 code.

To show that we can replace conventional code reuse,
we have implemented a minimal `collections' library
(\url{adamsTowel01/libProject/Collections/})\footnote{
For this and other links the full url looks like \url{github.com/ElvisResearchGroup/L42/tree/master/Tests/src/adamsTowel01/libProject/Collections}
}
 and a large `introspection' library
(\url{adamsTowel01/libProject/Location}), 
allowing to examine library literals.
The collection library uses IC instead of generics,
while the introspection library has many classes reusing common code, and this reuse is obtained using IC instead of
\Q@extends@.
To show that we can replace QQ, we developed
a (quite compact thanks to IC) `units of measure' library
(\url{adamsTowel02/libProject/Units})
, and a sophisticated \Q@Data@ decorator
(\url{adamsTowel02/libProject/Data})
that adds equality, \Q@toS()@, run time invariant checking and other features to library literals.

Finally, to show that IC can scale to work with large units of code,
we have implemented a non-trivial `library loading' library
(\url{adamsTowel02/libProject/Load} and
\url{adamsTowel02/libProject/DeployLibrary}), that 
automatically tweaks libraries to use different implementations for their dependencies;
this allows, for example, to change what kind of numbers and 
strings are internally used by a 42 third party library.
This is obtained by smart usage of the \Q@Redirect@ and \Q@Rename@ operators.



\section{Conclusion}
Quasi Quotation offers the maximum possible expressive power, since it can generate any possible AST.
We argue that our approach can generate any behaviour, but not any AST.
For example, we have no direct control on the way local variables, private methods 
and in-lining are handled.
We believe this is a good thing: fine control of the structure of expressions requires
the (meta-)programmer to understand and handle scope, scope-extrusion, variable hiding and similar
representation related issues.

%In our approach, every code literal is self contained, and could be understood as an independent piece of
%code.
%This means that while we can referred to other classes in the program, all variables always have a precise scope,
%and code literals are \textbf{not} closures; that is, the following is invalid:
%\begin{lstlisting}
%C:{
%  method Library foo(Num x)=
%    {method Num getX()=x}
%  }$\Comment{ill typed: x not a parameter of method getX()}$
%\end{lstlisting}

Practical experience shows that by using nested classes our approach allows generation of large chunks of code,
by generating many interconnected classes at the same time. While, QQ is mostly used to generate single method bodies/functions.

We show that IC can be used to design highly abstract code generation, with a
clear declarative feel,
while QQ requires (by design) to keep in mind the concrete shape of the generated code.


We also speculate how conventional OO verification techniques can be
used to verify code generated with IC. To the best of our knowledge, there is no
equivalent verification for QQ.

Due to space limitations we cannot include an extensive related work section,
but we tried to discuss other approaches during the exposition.
The interested reader may refer to the good survey by Smaragdakis~\cite{smaragdakis2015structured}.

Others proposed to use traits and code composition to perform meta-programming~\cite{reppy2007metaprogramming}.

The very popular Scala library LMS~(\url{scala-lms.github.io}), in addition to conventional QQ offers
more abstract techniques for AST rewriting and manipulation/simplification,
to go towards the kind of abstraction offered by IC;
thus recognizing QQ is, at least sometimes, too low level.

We wonder if Ur~\cite{chlipala2010ur} could be extended to represent our \Q@inductive()@ concept:
Ur is a QQ system focused on guaranteeing generation of well-typed records,
and it may be possible to extend it to records with abstract members.
