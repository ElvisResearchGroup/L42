%-----------------------------------------------------------
%define simple objects
%show solution  for simple person: requires 3 properties
%show solution is sound --> proof in appendix
%naive is unsound - person 3 bugs
\section{Our Invariant Protocol}
\label{s:protocol}
All classes contain a \Q@read method Bool invariant() {..}@, if no \Q!invariant! method is explicitly present, a trivial one returning \Q!true! is assumed.

Our invariant protocol guarantees that the whole ROG of any object involved in execution (formally, in a redex) is \emph{valid}: if you can call methods on an object, calling \Q@invariant@ on it is guaranteed to return \Q@true@ in a finite number of steps.

Our system have a clear scope:
\Q@invariant@ methods can only access the immutable and encapsulated state of the object.
We put restrictions in place so that they are semantically equivalent to a static method
taking in input only the values of the \Q@imm@ and \Q@capsule@ fields.
Indeed, we could have a simpler formalism by encoding invariants using static methods, but we think an instance method is more friendly for the user.

Thus, a calls to \Q!invariant! may receive a broken \Q@this@; but since it is equivalent to a static method taking those fields in input, we 
do not consider such \Q@this@ object to be involved in execution; it is just a tool to extract the field values.

To this aim, while in a normal method \Q@this@ can be used to access all the fields and methods of the class,\footnote{Some languages allows the \Q@this@ receiver to be implicit. For clarity here we assume \Q@this@ to be always used explicit.} \Q@invariant@ methods are limited in their usage of \Q@this@:
\Q@this.f@ is allowed only if \Q@f@ is \Q!imm! or \Q!capsule!, and 
\Q@this.m(..)@ is allowed only if \Q@m@ is a final or private\footnote{Only non-overridable methods are allowed, so that the semantic of the invariant can not be tweaked by subclasses.}
method whose body respects the same restriction on the usage of \Q@this@.
Finally, since the invariant is a \Q@read@ method,
\Q@this.f=..@ is never allowed, and \Q@this@ can not be used as a standalone expression, thus preventing passing \Q@this@ to other objects.

The requirement that invariants only refer to immutable and encapsulated state means that while we can easily verify that a doubly linked list of immutable elements
is correctly linked up,
we can not do the same for a doubly linked lists of mutable elements. We do not obstacle correctly implementing such data structures, but the invariant would be unable to access the list's nodes, since they would contain \Q@mut@ references to shared objects.
There is a line of work in literature[] striving to allow invariants over other forms of state.
It would not be technically difficult to 
integrate the solutions of those works, but 
it would make our system more complex and ad hoc, probably requiring numerous specialized kinds of RCs.
That is, we traded some expressive power in order to preserve safety and simplicity.


\subheading{Purity}\label{s:purity}
Invariant methods have only one parameter: \Q@this@, and such parameter is \Q@read@.
L42 enforcement of OCs statically guarantees that any method with only \Q!read! or \Q!imm! parameters (including the receiver) is \emph{pure}; we define pure
as being deterministic and not mutating existing memory. Such methods are pure because
(1) the ROG of the parameters (including \Q!this!) is only accessible as \Q@read@ (or \Q@imm@), thus it cannot be mutated\footnote{This is even true in the concurrent environments of Pony and Gordon \etal, since they ensure that no other thread/actor has access to a \Q@mut@/\Q@capsule@ alias of \Q@this@. 
	Thus, since such methods do not write to memory accessible by another thread, nor read memory that could be mutated by another thread, they are atomic.};
(2) if a capability object is in the ROG of any of the arguments (including the receiver), then it can only be accessed as \Q@read@, preventing calling any non deterministic (capability) methods;
(3) no other preexisting objects are accessible (as L42 does not have global variables). 
%\footnote{%
%		If L42 did have static variables, getters and setters for them would be capability methods.
%		Even allowing unrestricted access to \Q@imm@
%		static variables would prevent reasoning over
%		determinism, due to the possibility of global %variable
%		updates; however constant/final globals of an 
%		\Q@imm@ type would not cause such problems.%
%}
%We are unsure about the exact details of Gorodn \etal's and Pony's OC style, and if they can be used to enforce purity.

%Methods that perform non-deterministic \emph{input} shouldn't be white-listed.%, including methods that read information passed to white-listed output methods.


%Here we combine RCs with OCs to guarantee 
%\MS{determinism of} any method that can not access a \Q@mut@ reference to a capability object:
%all non deterministic primitive operations are instance methods requiring a \Q@mut@ receiver, and
%	\item all non-deterministic primitives (like native calls) require a \Q@mut@ receiver,
%instances of capability classes containing such methods can only be created by a \Q@mut@ method of another capability class
%	\begin{itemize}
%		\item the runtime-system\footnote{as 42 has no standard-library, we treat meta-code as the runtime-system} before main begins,
%		\item within a \Q@mut@ method on such a class
%	\end{itemize}
%	\item all non-deterministic operations require a \Q@mut@ receiver,
%	\item all classes 
%	\item there are no global variables\footnote{Note: even just allowing \Q@imm@
%global variables would prevent reasoning over determinism due to the possibility of global variable updates; however constant/final globals of an \Q@imm@ type would not cause such problems.},
% \item user code cannot directly create a capability object: they can only indirectly do so through an existing \Q@mut@ capability object reference.

% NOTE: SOMEWHERE MAKE IT CLEAR THAT NON-DETERMINISM CAN ONLY OCCUR THROUGH A CAPABILITY OBJECT
%\end{itemize}



% However, the \Q!invariant! method itself needs to be able to operate on a potentially invalid \Q!this!, this will only happen when it is automatically called by the language itself, not by explicit calls present in the source code.
% Clearly the \Q@invariant@ method must be able to take an invalid \Q@this@, since the purpose of such method is to distinguish valid and invalid objects. On a first look this may seem an open contradiction
% with the aim of this work, however only calls to \Q@invariant@ inserted by the language semantics can take an invalid \Q@this@. As for any other method, when the application code can call \Q@invariant@, \Q@this@ is guaranteed to be valid.
%

%Logically, there are two reasons to access a field: we may wish to read the information stored in such object or we wish to mutate the object contained in the field.
%For the first case, we can type the field access as \Q@read@, but in the second case we
%need to type it as \Q@mut@. 
%We call `capsule mutators' a method accessing as \Q@mut@ a \Q!capsule! field referenced in the invariant.
%We will show how capsule mutators are analogous of the pack/unpack/expose~\cite{???}.
%In order for a class to have an invariant under our protocol,
%\Q@invariant@ method the form 
% Can  a program write say mut method invariant or is it syntactically [???]

%We will later explain how these and other restrictions can be partially relaxed, as in the code examples.

% In order to prevent passing an invalid \Q@this@ to other methods.
%and unrelated code cannot break the invariant
%s of arbitrary objects,
%since a \Q!read! or \Q!mut! field could be modified through arbitrary aliases 
%(see Section \ref{s:immutable}). 

%To ensure that invariants cannot be broken by unrelated code (see Section \ref{s:immutable})  %
\subheading{Capsule Fields}
%L42 \Q@capsule@ fields are designed around syntactic restrictions over mutable fields~\cite{??}.
	%	THEY ARE NOT SYNTACTIC
%They can be initialized and updated only with 
%\Q@capsule@ references, but they can be accessed in
%controlled ways.
%L42 \Q@capsule@ access restriction are designed to be extensible; 
%here we add a new kind of \Q@capsule@ field
%access restriction designed to prevent representation exposure
%and to be allowed within invariants.
As we discussed before, while most approaches agree on the exact properties of a capsule reference,
capsule fields are handled in different ways in different approaches. L42 handle state in a very flexible way; this allows to define multiple ways to handle capsule fields. A detailed explanation on how this work and the limits of this flexibility is out of the scope of the paper.
We used this L42 support to define a novel kind of \Q!capsule! field,
whose properties suits well verification of invariants over complex (cyclic) mutable objects,
rather than allowing the values of such fields to be shared between threads/actors.
This new kind of \Q!capsule! field prevents representation exposure, as does the very similar concept of owner-as-modifier~\cite{Dietl05universes:lightweight,10.1007/978-3-540-92188-2_4}, where we could consider an object to be the `owner' of all the mutable objects in the ROG of its \Q!capsule! fields.\footnote{In L42, our new kind of \Q!capsule! can coexists with another kinds of \Q!capsule! field, such as those designed for safe parallelism~\cite{GordonEtAl12,clebsch2015deny,GIANNINI2019145}}





%\footnote{
%Our L42 implementation for our invariant protocol supports these fields by enforcing syntactic
%restrictions over constructors, getters, setters, and capsule mutators.},
% which can be accessed within invariants.
%To ensure that an object has control over the mutation of its \Q!capsule! fields
%To be able to easily detect when an objects invariant could be violated, we define the following rules on \Q!capsule! fields:
%Because the mutation of the ROG of objects \Q!capsule! field could violate its invariant, we ensure that an object has control over such mutation of its \Q!capsule! fields: this is preserved by the our rules on \Q!capsule! fields:
\SSI\begin{itemize}
	\item A \Q!capsule! field can only be initialised/updated with a \Q!capsule! expression.
	\item Access to a \Q!capsule! field on a \Q@mut@ receiver will return a \Q!mut!. Since fields are instance private\footnote{Getters and setters could be used to simulate public fields. Alternatively, if fields was allowed to be public, access to a \Q!capsule! field on a \Q!mut! receiver other than \Q!this! would have to be typed as \Q!read!.}, this access will be on \Q!this! and within a \Q!mut! method. We call such methods \emph{capsule mutators}, they must:
\begin{itemize}
		\item use \Q!this! exactly once in their body, namely to access the \Q!capsule! field,
		\item have no \Q!mut! or \Q!read! parameters (excluding the \Q!mut! receiver),
		\item not have a \Q!mut! return type, and
		\item be declared as not throwing any checked exception\footnote{To allow capsule mutators to leak checked exceptions, we would need to check the invariant when such exceptions are leaked. However, this would make the runtime semantics of checked exceptions inconsistent with unchecked ones.}.
	\end{itemize}	
	%The restrictions on \emph{capsule mutators} ensure that a \Q!mut!/\Q!capsule! reference to the ROG of the \Q!capsule! field is not returned, stored in the ROG of a parameter, or in any other field of the method's receiver. We also ensure that no reference.
	\item Any other \Q!capsule! field access behaves like a \Q!mut! field access: if the receiver is \Q!imm!, the field access will return \Q!imm!, if the receiver is \Q!read!, it will return \Q!read!, if the receiver is \Q!capsule!, it will return \Q!capsule! and
the \Q@capsule@ receiver object can then be directly garbage collected; so we do not need to preserve its invariant any more. % On the other hand, a \Q!capsule! reference may be freely used to gain mutable alias to one of its \Q!capsule! fields, since the receiver is \Q!capsule!, it cannot be referenced anywhere else.
	
\end{itemize}
%\IO{These restrictions ensure that an object has control over the mutation of its \Q!capsule! fields.}

\noindent This ensure that for all non garbage objects $o$, and \Q!capsule! field's $f$ of that object:
$o$ is not in the ROG of $o.f$ and
%		\item $o.f$ must have been initialised/updated with a \Q!capsule! expression, which couldn't alias $o$, since $o$ was used in the same expressions as the new value of $o.f$.
%		\item an alias to $o$ cannot be used inside capsule mutators (see below), such an alias could not be stored in the ROG of $o.f$.
%\item Only a capsule mutator can see $o.f$ as \Q!mut!; this means that the only way to mutate the ROG of $o.f$ is through a capsule mutator on $o$.
only a capsule mutator on $o$ that reads $f$ can see $o.f$ as \Q!mut!; this means that the only way to mutate the ROG of $o.f$ is through such methods. When they are not executing, no object in the ROG of $o.f$ can be seen as \Q!mut! or \Q!capsule!, using any sequence of field accesses on a local variable.
%no object in the ROG of $o.f$ can be reached (using field access expression) from a local variable as \Q!mut! or \Q!capsule!.
%x.b = o.f;
%x is not a reference to the ROG of o.f.
%T is the only \Q@mut@ reference 
%every path of \Q!mut!/\Q!capsule! fields, starting from a \Q!mut!/\Q!capsule! reference, refers to the ROG of $o.f$, then it must pass through $o$. 
%
%If we are not executing a capsule mutator on $o$ that reads $f$, 
%\IO{if a path of \Q!mut!/\Q!capsule! fields, starting from a \Q!mut!/\Q!capsule! reference, refers to the ROG of $o.f$, then it must pass through $o$. Since only a capsule mutator can see $o.f$ as \Q!mut!, this means that the only way to mutate the ROG of $o.f$ is through a capsule mutator on $o$.}
%	the ROG of $o.f$ is only mutable thanks to $o$, i.e. deleting $o$ will prevent the ROG of $o.f$ from ever being mutated again.
%		\item Capsule mutators preserve this property since they cannot return a \Q!mut!, they have no \Q!mut! parameters to which they could store such an alias in, and they cannot store such an alias somewhere else in the ROG of $o$, since $o$ is not usable within the capsule mutator (see below).
 %used at most once, which will be to access $f$. 
%
% This holds since $o$ cannot alias $o.f$, \Q!this! is used only once (to access $f$), and none of the methods parameters can alias $this$ (since only \Q!imm!/\Q!capsule! parameters are allowed, and \Q!this! is \Q!mut!, our TM system guarantees the former does not alias the latter).
%\end{itemize} 
If execution is (indirectly) in such a capsule mutator, then $o$ is only used as the receiver of the \Q!this.f! expression in the capsule mutator.
Thus we can be sure that the ROG of $o.f$ will only mutate within a capsule mutator, and only after the single use of $o$ to access $o.f$; such mutation could invalidate the invariant of $o$; so we simply check it at the end of the method before $o$ can be used again. Provided that the invariant is re-established before the capsule mutator returns, no invariant failure will be thrown, even if the invariant was broken \emph{during} the method call.

%As the expression is \Q!capsule!, we can be sure that the object being initialised/updated will have the only external alias to the ROG of the field's new value. In addition, since the reference was \Q!capsule!, the initialised/updated object could not already alias it, thus after the initialisation/update, the initilised/updated \Q!capsule! field will not alias the object.

Note that these properties are \emph{weaker} than those of \Q!capsule! \emph{references}: we do not need to prevent arbitrary \Q!read! aliases to the ROG of a \Q!capsule! field, and we do allow arbitrary \Q!mut! aliases  to exist during the execution of a capsule mutator. In particular, unrestricted readonly access to \Q!capsule! fields can be allowed by writing getters of the form \Q!read method read C f() { return this.f; }!. Such getters are already a fundamental part of the L42 language~\cite{DBLP:journals/programming/AroraSO19}. Since \Q!mut! is a subtype of \Q!read!, such a method can be called on a \Q!mut! \Q!this!, without making the method a capsule mutator.

Note that \Q!capsule! methods (methods with a \Q@capsule@ \Q@this@) are not considered capsule mutators since \Q!capsule! variables can only be used once. This means that \Q!this! will not be reachable from anywhere else including the \Q!capsule! field itself; thus immediately after the single use of \Q!this! to read the \Q!capsule! field, \Q!this! will be garbage collectable.

%\subheading{Capsule mutators}
%\IODel{In order to allow complex mutations of objects with invariants we, introduce the notion of \emph{capsule mutator}}. A \emph{capsule mutator} can perform an arbitrarily complex mutation of the ROG of a \Q!capsule! field. We use TMs to ensure that the object containing the \Q!capsule! field is not usable whilst the field's ROG is mutated, and its invariant is checked immediately afterwards. 
%Formally, \emph{capsule mutators} are \Q@mut@ methods whose body accesses a \Q@capsule@ field. 


%\end{itemize}
%Our type system will ensure that such methods are \Q!mut method!s, and the \Q!capsule! field will be seen as \Q!mut!.
%As \Q@capsule@ mutators use \Q!this! only once, and have no \Q!read! or \Q!mut! parameters, \Q!this! will not be accessible during execution, this is important as mutating the ROG of the \Q@capsule@ field may violate the invariant of \Q!this!.  Preventing \Q!mut! return types ensures that such methods cannot \REV{leak out a mutable alias to the \Q!capsule! field}{D}{why would it otherwise be possible ... Even doing this locally violates the soundness semantics for every reference immutability system I've see}, which could then be used to break the invariant.

%\footnote{This is sound provided \Q!this! can be used only once. This is already enforced by L42, since \Q!this! will be a \Q!capsule! variable, which L42 only allows to be used once.}. By the the properties of \Q!capsule!}




\subheading{Monitoring}
The language runtime will insert automatic calls to \Q!invariant!, if such a call returns \Q!false!, an unchecked exception will be thrown. Such calls are inserted in the following points:
\SSI\begin{itemize}
	\item After a constructor call, on the newly created object.
	\item After a field update, on the receiver.
	\item After a capsule mutator method returns, on the receiver of the method\footnote{The invariant is not checked if the call was terminated via an an unchecked exception, since strong exception safety guarantees the object will be unreachable anyway.}.
\end{itemize}
\noindent In Section \ref{s:formalism}, we show that these checks, together with our aforementioned restrictions, are sufficient to ensure our guarantee that all objects involved in execution (except as part of an invariant check) are valid.

\subheading{Traditional constructors and subclassing}
L42 constructors directly initialize all fields using the parameters; and the code reuse model is different from the traditional extends.
This behaviour cooperate naturally with with our invariant protocol as described this far.
However, our invariant protocol can work with Pony and Gordon \etal's language which have traditional constructors and subclassing:
In constructors bodies we require \Q!this! to be only used as the receiver of field initialisations. L42 itself does not support user-written constructors, instead one would just write a static factory method that behaves equivalently.
Subclassing can be supported by forcing the subclass invariant method to implicitly start with a check that \Q@super.invariant()@ returns \Q@true@. Note that invariant checks would not be performed at the end of \Q@super(..)@ constructor calls, but only at the end of \Q@new@ expressions, as happens in~\cite{feldman2006jose}.
We do not model personalized constructors and traditional subclassing in our formalism as they would make the proof more complicated, without making it more interesting.