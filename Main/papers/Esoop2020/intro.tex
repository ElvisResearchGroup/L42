\section{Introduction}
\label{s:intro}
%\newpage
%\LINE
Representation invariants (sometimes called class invariants or object invariants) are
a useful concept when reasoning about software correctness in Object Oriented (OO) languages. Such invariants are predicates on the state of an object and its ROG (reachable object graph).
They can be presented as documentation, checked as part of static verification, or, as we do in this paper, monitored for violations using runtime verification.
In our system, a class specifies its invariant by defining a boolean returning method called \Q@invariant@.
We say that an object's invariant holds when its \Q@invariant@ method would return \Q@true@.\footnote{We do this (as in Dafny~\cite{DBLP:conf/sigada/Leino12}) to minimise the special treatment of invariants, whereas other approaches often treat invariants as a special annotation with its own syntax.}

Invariants are designed to hold most of the time, however it is commonly required to (temporarily) violate invariants in order to perform complex mutations of objects with such invariants.
To support this behaviour, the invariants as present in the literature allow invariants to be (temporarily) broken and observed broken.
The two main protocols are the \emph{visible state semantics} \cite{Meyer:1988:OSC:534929} and the \emph{Pack-Unpack/Boogie methodology}~\cite{DBLP:journals/jot/BarnettDFLS04}.
In the visible state semantics, invariants can be broken when a method on the object is active (that is, one of the objects methods is currently executing on the stack).
Some interpretations of the visible state semantics are more permissive, requiring the invariants of receivers to hold only before and after every public method call, and after constructors. 
In the pack-unpack approach, objects are either in a `packed' or `unpacked' state, 
`packed' objects are guaranteed to have their invariant hold, whereas unpacked objects can be broken.

%------------
In this paper we propose a much stricter invariant protocol: at all times, the invariant of every object involved in execution must hold; thus they can be broken when the object is not (currently) involved in execution. An object is \emph{involved in execution} when it is in the ROG of any of the objects mentioned in the currently executing "redex" (a field access, field update or method call that is about to be reduced), we state this more formally later in the paper.

Our strict invariant protocol clearly supports easier reasoning; however 
at first glance it may look overly restrictive, preventing the expression of useful program behaviour.
Consider the iconic example of a \Q@Range@ class, with a \Q@min@ and \Q@max@
value, where the invariant requires that \Q@min<=max@:
% ISAAC: I changed the example to not use getters and setters as our latter examples often don't and it dosn't add anything extra; in addition, this may fall foul of some visibile state semantics of the setters are considered public.
\begin{lstlisting}
class Range{ private field min; private field max;
  method invariant(){return min<max;}
  method set(min, max){
    if(min>=max){throw new Error(/**/);}
    this.min = min;
    this.max = max; }}
\end{lstlisting}
In this first example we omit types to focus on the runtime semantics.
The code of \Q@set@ cannot violate visible state semantics:
\Q@this.min = min@ may temporarily break the invariant of \Q!this!, however it will be fixed after executing \Q!this.max = max@. Visible state allows such temporary breaking of invariants since we are inside a method on \Q!this!, and by the time it returns, the invariant will be re-established.
However, this, if \Q!min@ is $\geq$ \Q@this.max@, \Q@set@ will violate our stricter approach. The execution of
\Q@this.min = min@ will break the invariant of \Q@this@ and \Q@this.max = max@ would then involve a broken object. In addition, if we were to inject a call
\Q@Do.stuff(this);@ between the two field updates, arbitrary user code could observe a broken object; whereas such a call would be allowed by visible state semantics.

Using the \emph{box pattern}\footnote{Due to its simplicity and versatility, we do not claim this pattern to be a contribution of our work, as we expect others to have used it before. We have however not been able to find it referenced with a specific name in the literature, though technically speaking, it is a simplification of the Decorator, but with a different goal.}, we can provide a modified
\Q@Range@ class with the desired client interface, while respecting the principles of our strict protocol:
\begin{lstlisting}
class BoxRange{//no invariant in BoxRange
  field min; field max;
  BoxRange(min, max){ this.set(min, max); }
  method Void set(min, max){
    if(min>=max){throw new Error(/**/);}
    this.min = min; this.max = max; }  }
class Range{ private field box; //box contains a BoxRange
  Range(min, max){ this.box = new BoxRange(min, max); }
  method invariant(){
    return this.box.min < this.box.max;}
  method set(min, max){
    return this.box.set(min,max); } }
\end{lstlisting}
The code of \Q@Range.set@ does not violate our invariant protocol: since \Q@this@ is not in the ROG of \Q@this.box@, \Q!min!, or \Q!max!; the call to
\Q@BoxRange.set@ works in a context where the enclosing \Q@Range@ object is
reachable, and so not involved in execution, thus the invariant of the \Q!Range! can be temporarily broken.
In particular, using the \Q@box@ field as an extra level of indirection, we restricted the set of objects involved in execution while the state of the \Q@Range@ was modified.
\footnote{While in very specific situations the overhead of creating such additional box object may be unacceptable, 
we designed our work for environments where such fine performance differences are negligible.
Many VMs and compilers optimize away wrapper objects in many circumstances.~\cite{help}} % ISAAC: Fix citation, or delete your claim!

With appropriate type annotations, the code of \Q@Range@ and \Q@BoxRange@ is accepted as correct by our system, in particular no matter how \Q@Range@ objects are used, a broken \Q@Range@ objects will never be involved in execution.

\subheading{Summary}
In the remainder of this paper, we discuss how we can use Reference and Object Capabilities to determine appropriate points to insert runtime checks that soundly enforces our strict invariant protocol; even in the presence of code performing mutation, I/O, non-determinism, and exceptions, all under an open world assumption, assuming that all code is well-typed.
We formalise our approach and, in Appendix~\ref{s:proof} prove that our use of Reference and Object Capabilities soundly enforces our invariant protocol.

We have fully implemented our protocol in L42\footnote{
Our implementation is implemented by checking that a given class conforms to our protocol, and injecting invariant checks in the appropriate places.
An anonymised version of L42, supporting the protocol described in this paper, together with the full code of our case studies, is available at \url{http://l42.is/InvariantArtifact.zip}. %We believe it would be easy to port our work on Pony and Gordon \etal's language.
}, we used this implementation to implement many case studies, showing that our protocol is more succinct than the pack/unpack approach and much more efficient then the visible state semantic.
It is important to note that unlike most prior work, we soundly handle catching of invariant failures and I/O.
%In our case study we show that
%we can still encode most of the examples explored in ~\cite{???} (including for example mutable collections of immutable objects) whilst having a significantly lower annotation-burden.
%--I think we can avoid this to save space
%Section \ref{s:TMsAndOCs} explains the pre-existing \emph{type modifier} features we use for this work.
%Section \ref{s:protocol} explains the details of our invariant protocol, and Section \ref{s:formalism} formalises a language enforcing this protocol.
%Sections \ref{s:immutable} and \ref{s:encapsulated} explain and motivate how our protocol can handle invariants over immutable and encapsulated mutable data, respectively.
%Section \ref{s:case-study} presents our GUI case study and compares it against visible state semantics and Spec\#: they performed 5 orders of magnitude more invariant checks, and required 60\% more annotations, respectively.
%Sections \ref{s:related} and \ref{s:conclusion} provide related work and conclusions.
We describe one of our case studies in the body of the paper and explore more case studies in the Appendix.

At first glance, our approach may seem very restrictive; in Appendix~\ref{s:patterns}, we show
programming patterns demonstrating that these restrictions do not significantly hamper expressivity, in particular we show how batch mutation operations can be performed with a single invariant check, and how the state of a `broken' object can be safely passed around.
% In Appendix \ref{s:runtime-verification}, we discuss more related work on runtime verification.


%you see this already later on... I wanted to avoid repating it
%to perform batch operations with a single invariant check, as well as how the state of `broken' objects can be passed around.}	
%http://www.cs.cmu.edu/~NatProg/papers/p496-coblenz-Glacier-ICSE-2017.pdf
