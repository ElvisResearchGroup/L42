// This contains definitions used to define properties we want our redirect to satisfy

Required properties of a ChooseRedirect function:
ChooseRedirect is a function from p*R->R' such that
  ChooseRedirect(p,R')=R'
  forall p' ~R~ p: ChooseRedirect(p',R)=R'
  ValidRedirect(p,R')
  // We should try and prove that the above definition is equivalent to one where we replace the ValidRedirect check
  // with a meta-level soudness check (I'm not certain though)
______
Define ValidRedirect(p,R,R')
  R subseteq R'
  dom(R') = RedirectSet(p.top(); dom(R))
  forall P in ran(R'):
    p.minimize(P)=P
    P not of form This0._
    p|-p[P]:OK //P well typed
  forall Cs in dom(R'):
    p|- R'(Cs); p[R'(Cs)] <= Cs; R'(p[Cs])
  Redirectable(dom(R'); p.top())


// Is the LHS (whose name is 'This0.Cs') a structural supertype of the RHS (whose name is P)
// We say that A is a structural supertype of B if any code written with respect to A
// would also type-check against B
Define p|- P; {interface?' implements Pz' mwtz', ncz'} <= Cs; {interface? implements Pz mwtz, ncz}
  // Check that all the interfaces the LHS implements are also implemented by the RHS
  p.minimize(Pz) subseteq SuperClasses(p; P) //Note: Using SuperClasses (and not Pz') is very important, so that F-bound polimoprhism can work TODO: explain what this means

  // Check that each method-type of the RHS is a subtype of the LHS
  // (So that it any well-typed call to a method on the LHS would also typecheck if it were to call a method on the RHS)
  forall MS in dom(mwtz): // This implicity checks the msdom
    p |- mwtz'(MS).mt <= mwtz(MS).mt

  // If the LHS is not an interface
  if interface?=empty:
    // One can only call class methods on a non-interface, so if the LHS has any, than the RHS can't be an interface
    if interface?' = interface then class not in mwtz.mdfz

  // If the LHS is an interface, we need to ensure that any valid implementation of the LHS
  // Is a valid implemention of the RHS, which requires that the RHS have the exact same method signatures as the LHS
  else:
    interface? = interface?' // You can't implement non-interfaces

    forall MS in dom(mwtz'): // This implicity checks the msdom
      p |- mwtz(MS).mt <= mwtz'(MS).mt

=======================================================================================
p' ~R~ p  iff  ReduceProblem(p; R)=ReduceProblem(p'; R)
ReduceProblem(p; R) = p[only This0.Cs1, ..., This0.Csn, ReachableSet(p; ran(R))]
  Cs1, ..., Csn = RedirectSet(p.top(); dom(R))

// The set of paths referenced in the signatures of each P, L and mwt (excluding nested classes)
Define Reachables(p; P) = Pz, Reachables(L) = Pz, Reachables(Mz) = Pz
-----------------------------------------------------------------------
// Find's all paths that are reachable from the declaration of 'P' in p
// (i.e. ignoring methods bodies and meta-expressions)
ReachableSet(p; Pz):
  Pz subseteq ReachableSet(p; Pz)
  Pz' subseteq ReachableSet(p; Pz)
    P in ReachableSet(p; Pz)
    Pz' = p.minimize(Paths(p[P]))

Reachables({interface? implements Pz Mz}) = Pz, Paths(Mz)
Reachables(C: L) = Paths(L)[from This0.C]
Reachables(mwt) = mwt.mt.Ts.Ps, mwt.mt.T.P, mwt.mt.Pz


--------------------------------------------
Define p[only Pz] = p', and L[only Pz]=L'
-----------------------------------------------
// I don't know a 42 equivalent formalisim, but who cares...
(id = L, p)[only Pz] = (id = L[only Internals(Pz)], p[only (Pz[from This0.ToC(id)])])
(empty; DVs)[only Pz] = (empty; DVs[only Pz])

(C = LV)[only Pz] = (C = LV[only Pz[From This]])
  This0.C.Cs in Pz // Something inside C is to be kept, so we need C

(DV)[only Pz] = empty
  otherwise // A trait, or a class that is to be discareded

ToC(C) = C
ToC(t) = CF
  for fresh C

L[only Cs,Csz] = L[only Cs] U L[only Csz]
L[only empty] = {}
// Discard method bodies!, we don't want people looking in them, or do we?
L[only C1...Cn] = {C1: ... {Cn: L(Cs)[with ncz = empty, with mwtz.ez = empty]} ... }
------------------------
// Returns all the nested classes that are accesed from This0 (works best if Pz is minimized)
Define Internal(Pz) = Csz
  Internal(This0.Cs, Pz) = Cs, Internal(Pz)
  Internal(P, Pz) = Internal(Pz)
    otherwise

// U above is a 'dumb' sum, namely:
{interface?1 Pz C: L ... Cn: Ln Mz} U {interface?2 Pz' C1: L1' ... Cn: Ln' Mz'} =
  {interface?1 U interface?2 Pz Pz' C1: L1 U L1' ... Cn: Ln U Ln' Mz Mz'}
---------------------------------------

// TODO! Define p' superset p