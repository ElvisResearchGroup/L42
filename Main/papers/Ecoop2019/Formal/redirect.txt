// This file defines the core Redirect operator, it and it's definitions should be implemented in L42
// Util contains some utility definitions used for this formalisism, some of which are implemented in L42 (but shouldn't be too interesting)

// Perform and compute a redirect, using a choice function 'CollectRedirect' to compute the R mapping
Define Redirect(p; L; Cs1, P1, ..., Csn, Pn) = R(L[remove Csz]) // Remove the things that will be redirected away
  p' = p.evilPush(L) // to simplify everything, just make L the new top
  Redirectable(L; RedirectSet(L, Cs1, ..., Csn)) // Check that the source is valid

  // Chose a mapping, simplifying the input, and update the paths to be relative to our evil-pushed program
  CollectRedirect(p'; Cs1, p'.minimize(P1[from This1]), ..., Csn, p'.minimize(Pn[from This1])) = R

================================================================================
// Whether the class This0.Cs can be redirected away
// Namely: that the class contains no implemented methods or anything private
Define Redirectable(L; Csz)
  forall Cs in Csz
    Cs not empty
    L[Cs] is defined
    forall C in Cs: not Private(Cs)
    forall mwt in L[Cs].mwtz:
      mwt.e = empty
      not Private(mwt.m)

    forall C in dom(L[Cs])
      Cs.C in Csz

--------------------------------------------------------------
// If we are redirecting Csz, then we need to redirect Csz
Csz subseteq RedirectSet(L; Csz)

// Redirect the nested class mentioned in the signature of a redirected class
// We won't however be redirecting references to external paths (i.e. things outside of This0)
Internals(Reachables(L[Cs])) subseteq RedirectSet(L; Csz)
  Cs in RedirectSet(L; Csz)
  // Note: because the top of the program will be evil pushed, there's no need to p.minimize the result of Reachables

Reachables({interface? implements Pz Mz}) = Pz, Paths(Mz)
Reachables(C: L) = Paths(L)[from This0.C]
Reachables(mwt) = mwt.mt.Ts.Ps, mwt.mt.T.P, mwt.mt.Pz
==================================================================================================================
CC ::= Cs <= P | P <= Cs
CollectRedirect(p; R) = CollectSolution(p; CollectConstraints(p; R))
CollectConstraints(p; Cs1->P1, ..., Csn->Pn) = CollectAll(p; Cs1 <= P1, P1 <= Cs1, ..., Csn <= Pn, Pn <= Csn)
----------------------------
// Utils
dom(Cs <= P) = Cs
dom(P <= C) = Cs
dom(CC1,...,CCn) = dom(CC1), ..., dom(CCn)

MustInterface(p; Cs) = p(Cs).interface? = interface
MustClass(p; Cs) = p(Cs).interface? = empty and class in p(Cs).mwtz.mdfZ

Define p[P.ms] = p[P](ms)
Define p[Cs.ms] = p[This0.Cs.ms]
Define mwt.P = mwt.mt.T.P
Define mwt.Pi = mwt.mt.Ts.i.P

Define mwt.Cs = Internal(mwt.mt.T.P)
Define mwt.Csi = Internal(mwt.mt.Ts.i.P)
Define L.Csz = Internals(L.Pz)

// CollectAll is the main function that collects all constraints
CollectAll(p; CCz,CCz') := CollectAll(p; CCz'')
  CCz'' = (CCz, CCz') U Collect(p; CCz)
  CCz'' != CCz,CCz'
CollectAll(p; CCz) := CCz
  Otherwise
=========================================================================
// Note: Collect isn't a function, but a relation,
// I.e. Collect(p; CCz) = Ccz' for multiple different CCz' (even with the same p; CCz)
Define Collect(p; CCz) := CCz':
1: Collect(p; Cs <= P) = P <= Cs
  p[P].interface = empty //since all classes are final

3a: Collect(p; P <= Cs) = MostSpecific(p; Pz) <= Cs'
  Cs' in p[Cs].Csz
  Pz = {P' in SuperClasses(p; P) | PossibleTarget(p; Cs; P')}

3b: Collect(p; P <= Cs) = Cs' <= MostGeneral(p; Pz)
  Cs' in p[Cs].Csz
  Pz = {P' in SuperClasses(p; P) | PossibleTarget(p; Cs; P')}

3c: Collect(p; P <= Cs, Cs' <= P') = Cs <= P' // TODO: Proove this is neccessary
  Cs' in p[Cs].Pz

3d: Collect(p; P <= Cs) = P <= Cs'
  Cs' in p[Cs].Pz


4: Collect(p; P <= Cs) = p[P.ms].P <= p[Cs.ms].Cs
5: Collect(p; CC) = p[Cs.ms].Csi <= p[P.ms].Pi
   CC = P <= Cs or  CC = Cs <= P

6: Collect(p; Cs <= P) = p[Cs.ms].Cs <= p[P.ms].P:
  MustInterface(p; Cs)

7: Collect(p; Cs <= P) = p[P.ms].Pi <= p[Cs.ms].Csi:
  MustInterface(p; Cs)

  // The ? rules
8a:  Collect(p; Cs <= P) = P' <= p[Cs.sel].Cs
  P' = p[P.sel].P
  p[P'].interface?=empty

8d:  Collect(p; Cs <= P) = Cs' <= Origin(p; sel'; P')
  Cs' = p[Cs.sel].Cs
  P' = p[P.sel].P
  sel' in dom(p[Cs']) intersect dom(p[P'])

8'd:  Collect(p; Cs <= P) = Cs' <= Origin(p; sel'; P') // TODO: Proove this is neccessary
  Cs' in p[Cs].Pz
  P' in SuperClasses(p; P)
  sel' in dom(p[Cs']) intersect dom(p[P'])

11a: Collect(p; CCz) = Cs <= P  // TODO: Prove this is neccessary
  CollectTargets(p; CCz; Cs) = {P}

11b: Collect(p; CCz) = MostSpecific(p; Pz) <= Cs  // TODO: Prove this is neccessary
  CollectTargets(p; CCz; Cs) = Pz

===================================================================
Define CollectSolution(p; CCz) := Cs1->P1, ..., Csn->Pn
  dom(CCz) = Cs1, ..., Csn
  Pi = MostSpecific(p; CollectTargets(p; CCz; Cs))

CollectTargets(p; P1 <= Cs, ..., Pn <= Cs, Cs <= P'1, ..., Cs <= P'k, CCz; Cs) = Pz''
  Cs not in dom(CCz)
  Pz = SuperClasses(p; P1, ..., Pn) // This internally does a p.minize, and so Pz'' will also be p.minized
  Pz' = {P in Pz | {P'1, ..., P'k} subseteq SuperClasses(p; P)}
  Pz'' = {P in Pz' | PossibleTarget(p; Cs; P)}
---------------------------------------------
Origin(p; sel; P) = P' // TODO: Define this using the refine keyword? (as in the code)
  forall P'' in Supertypes(p; P) where sel in dom [P'']
    p |- P'' <= P'

SuperClasses(p; Pz) = intersect {p.minimize(p[P].Pz U {P, Any}) | P in Pz}

MostSpecific(p; Pz) = P
  P in p.minimize(Pz)
  p.minimize(Pz) subseteq SuperClasses(p; P)
  // Note: P will be unique in terms of p.equiv, since any other solution P' is in Pz
  // so P' in SuperClasses(p; P), and since P in Pz, P in SuperClasses(p; P')
  // Thus P <= P', and P' <= P

MostGeneral(p; Pz) = P
  {P} = SuperClasses(p; Pz) intersect p.minimize(Pz)

PossibleTargets(p; Cs1->P1, ..., Csn->Pn) iff
  PossibleTarget(p; Cs1; P1)
  ...
  PossibleTarget(p; Csn; Pn)

PossibleTarget(p; Cs; P) iff
  L1 = p[Cs]
  L2 = p[P]

  MustClass(p; Cs) --> L2.interface? = empty
  MustInterface(p; Cs) --> L2.interface? = interface

  msdom(L1) subseteq msdom(L2)
  MustInterface(p; Cs) --> msdom(L2) subseteq msdom(L1)

  p.minimize({P' in L1.Pz | !Internal(P')}) subseteq SuperClasses(p; P)
  forall ms in msdom(L1):
    p |- L2(ms).mt <~ L1(ms).mt //method subtyping ignoring internal paths
    MustInterface(p; Cs) --> p |- L1(ms).mt <~ L2(ms).mt


p |- P <~ P':
  Internal(P) and Internal(P')
  // TODO: Is this an abuse? Internal returns a Cs, here I'm using it to ensure that it is deefined

p |- P <~ P':
  p |- P <= P'

p |- T <~ T' iff
  T.mdf <= T'.mdf
  p |- T.P <~ T.P'

p |- mdf T1,...,Tn->T'0; Pz <= mdf' T'1,...,T'n->T0; Pz'
  mdf' <= mdf
  p |- T'0 <~ T0 ... p |- T'n <~ Tn
  forall P in Pz:
    exists P' in Pz' such that p |- P <~ P'