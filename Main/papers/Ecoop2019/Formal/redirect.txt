// This file defines the core Redirect operator, it and it's definitions should be implemented in L42
// Util contains some utility definitions used for this formalisism, some of which are implemented in L42 (but shouldn't be too interesting)

// Perform and compute a redirect, using a choice function 'ChooseRedirect' to compute the R mapping
Define Redirect(p; L; Cs1, P1, ..., Csn, Pn) = R(p'.top()[remove Csz]) // Remove the things that will be redirected away
  empty not in Cs1 ... Csn // We can't redirect This0, as that does not make sense
  p' = p.evilPush(L) // to simplify everything, just make L the new top
  Redirectable(RedirectSet(L, Cs1, ..., Csn); L) // Check that the source is valid

  // Chose a mapping, simplifying the input, and update the paths to be relative to our evil-pushed program
  ChooseRedirect(p'; Cs1, p'.minimize(P1[from This1]), ..., Csn, p'.minimize(Pn[from This1])) = R

// Whether the class This0.Cs can be redirected away
// Namely: that the class contains no implemented methods or anything private
Define Redirectable(Csz; L)
  forall Cs in Csz
    Cs not empty
    forall C in Cs: not Private(Cs)
    forall mwt in L[Cs].mwtz:
      mwt.e = empty
      not Private(mwt.m)

    forall C in dom(L[Cs])
      Cs.C in Csz

---------------------------------------------------------------------------------------
CC ::= Cs <= P | P <= Cs

CollectTop(p; R) = CollectAll(p; CCInit(R))
CCInit(Cs1->P1, ..., Csn->Pn) = Cs1 <= P1, P1 <= Cs1, ..., Csn <= Pn, Pn <= Csn
ChooseRedirect(p; R) = ChooseR(p; CollectTop(p; R))

MustInterface(p; Cs) = p(Cs).interface? = interface
MustClass(p; Cs) = p(Cs).interface? = empty and class in p(Cs).mwtz.mdfZ

// CollectAll is the main function that collects all constraints
CollectAll(p; CCz,CCz') := CollectAll(p; CCz'')
  CCz'' = (CCz, CCz') U Collect(p; CCz)
  CCz'' != CCz,CCz'
CollectAll(p; CCz) := CCz
  Otherwise

Define p[P.ms] = p[P](ms)
Define p[Cs.ms] = p[This0.Cs.ms]
Define mwt.P = mwt.mt.T.P
Define mwt.Pi = mwt.mt.Ts.i.P

Define mwt.Cs = Cs
  This0.Cs = mwt.mt.T.P
Define mwt.Csi = Cs
  This0.Cs = mwt.mt.Ts.i.P
Define L.Csz = Internal(L.Pz)


// Note: Collect isn't a function, but a relation,
// I.e. Collect(p; CCz) = Ccz' for multiple different CCz' (even with the same p; CCz)
Define Collect(p; CCz) := CCz':
1: Collect(p; Cs <= P) = P <= Cs
  p[P].interface = empty //since all classes are final

3a: Collect(p; P <= Cs) = MostSpecific(p; Pz) <= Cs'
  Cs' in p[Cs].Csz
  Pz = {P' in SuperClasses(p; P) | PossibleTarget(p; Cs; P')}

3b: Collect(p; P <= Cs) = Cs' <= MostGeneral(p; Pz)
  Cs' in p[Cs].Csz
  Pz = {P' in SuperClasses(p; P) | PossibleTarget(p; Cs; P')}

3c: Collect(p; P <= Cs, Cs' <= P') = Cs <= P' // TODO: Proove this is neccessary
  Cs' in p[Cs].Pz

3d: Collect(p; P <= Cs) = P <= Cs'
  Cs' in p[Cs].Pz


4: Collect(p; P <= Cs) = p[P.ms].P <= p[Cs.ms].Cs
5: Collect(p; CC) = p[Cs.ms].Csi <= p[P.ms].Pi
   CC = P <= Cs or  CC = Cs <= P

6: Collect(p; Cs <= P) = p[Cs.ms].Cs <= p[P.ms].P:
  MustInterface(p; Cs)

7: Collect(p; Cs <= P) = p[P.ms].Pi <= p[Cs.ms].Csi:
  MustInterface(p; Cs)

  // The ? rules
8a:  Collect(p; Cs <= P) = P' <= p[Cs.sel].Cs
  P' = p[P.sel].P
  p[P'].interface?=empty

8d:  Collect(p; Cs <= P) = Cs' <= Origin(p; sel'; P')
  Cs' = p[Cs.sel].Cs
  P' = p[P.sel].P
  sel' in dom(p[Cs']) intersect dom(p[P'])

8'd:  Collect(p; Cs <= P) = Cs' <= Origin(p; sel'; P') // TODO: Proove this is neccessary
  Cs' in p[Cs].Pz
  P' in SuperClasses(p; P)
  sel' in dom(p[Cs']) intersect dom(p[P'])

11a: Collect(p; CCz) = Cs <= P  // TODO: Prove this is neccessary
  RChoices(p; CCz; Cs) = {P}

11b: Collect(p; CCz) = MostSpecific(p; Pz) <= Cs  // TODO: Prove this is neccessary
  RChoices(p; CCz; Cs) = Pz

-------------------------------------------------

Define ChooseR(p; CCz) := R
  Cs1 -> MostSpecific(p; RChoices(p; CCz1))
  ...
  Csn -> MostSpecific(p; RChoices(p; CCzn))


// TODO: Proof that forall p, CCz, Cs
// If exists Pz such that forall p' supereset p: {P | Cs->P satisfies CCz} = Pz
//   then RChoices(p; CCz; Cs) = Pz
// Otherwise, RChoices(p; CCz; Cs) is undefined

RChoices(p; CCz, CCz'; Cs) = RChoices(p; CCz)
  P <= Cs in CCz
  Cs <= P not in CCz'
  P <= Cs not in CCz'

RChoices(p; P1 <= Cs, ..., Pn <= Cs, Cs <= P'1, ..., Cs <= P'k) = Pz''
  Pz = SuperClasses(p; P1, ..., Pn) // This internally does a p.minize, and so Pz'' will also be p.minized
  Pz' = {P in Pz | {P'1, ..., P'k} subseteq SuperClasses(p; P)}
  Pz'' = {P in Pz' | PossibleTarget(p; Cs; P)}
---------------------------------------------
Origin(p; sel; P) = P' // TODO: Define this using the refine keyword? (as in the code)
  forall P'' in Supertypes(p; P) where sel in dom [P'']
    p |- P'' <= P'

SuperClasses(p; Pz) = intersect {p.minimize(p[P].Pz U {P, Any}) | P in Pz}

MostSpecific(p; Pz) = P
  P in p.minimize(Pz)
  p.minimize(Pz) subseteq SuperClasses(p; P)
  // Note: P will be unique in terms of p.equiv, since any other solution P' is in Pz
  // so P' in SuperClasses(p; P), and since P in Pz, P in SuperClasses(p; P')
  // Thus P <= P', and P' <= P

MostGeneral(p; Pz) = P
  {P} = SuperClasses(p; Pz) intersect p.minimize(Pz)
CheckRedirect

PossibleTargets(p; Cs1->P1, ..., Csn->Pn) iff
  PossibleTarget(p; Cs1; P1)
  ...
  PossibleTarget(p; Csn; Pn)

PossibleTarget(p; Cs; P) iff
  L1 = p[Cs]
  L2 = p[P]

  MustClass(p; Cs) --> L2.interface? = empty
  MustInterface(p; Cs) --> L2.interface? = interface

  msdom(L1) subseteq msdom(L2)
  MustInterface(p; Cs) --> msdom(L2) subseteq msdom(L1)

  p.minimize({P' in L1.Pz | P' not of form This0.Cs}) subseteq SuperClasses(p; P)
  forall ms in msdom(L1):
    p |- L2(ms).mt <~ L1(ms).mt //method subtyping ignoring internal paths
    MustInterface(p; Cs) --> p |- L1(ms).mt <~ L2(ms).mt

p |- P <~ P' iff p |- P <= P' //todo define internal(P) ?
  P not of form This0.Cs
  P' not of form  This0.Cs

p |- P <~ P'
  otherwise

p |- T <~ T' iff
  T.mdf <= T'.mdf
  p |- T.P <~ T.P'

p |- mdf T1,...,Tn->T'0; Pz <= mdf' T'1,...,T'n->T0; Pz'
  mdf' <= mdf
  p |- T'0 <~ T0 ... p |- T'n <~ Tn
  forall P in Pz:
    exists P' in Pz' such that p |- P <~ P'

===============================================+++++++++
For nested classes and exceptions?



//CCz implies_p CCz' iff forall P: P satisfies CCz --> P satisfies CCz'
(TODO: Talk about infinite programs)

================================================
