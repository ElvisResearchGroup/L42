// A sketch of the proof, plus some definitions only used internally by
// (i.e. they are not used by the algorithm, nor the properties we are trying to proove about it)

What we want to prove?
=================================================================================
forall (p, R) in ValidProblems: CollectRedirection(p; R) == BestRedirection(p; R)

Where:
  // '==' works on undefined as you would expect...

  BestRedirection(p; R) = UniversalMostSpecific(p; R; ValidRedirections)
  //StableMostSpecific
  UniversalMostSpecific(p; R; f) = R' iff:
    forall p' in SimilarPrograms(p): MostSpecificRedirection(p'; f(p', R)) = R'
    with f a function (p,R)->Rz

// TODO: Other things to prove?
// The input Redirect passes to CollectRedirection is in ValidProblems
//    Thus Redircet[CollectRedirection := BestRedirection] == Redirect
// Proof Meta-level soudnes ++ internal stability <==> validredirection
=============================================================================================
p' in SimilarPrograms(p) iff p <= p' and p.top() = p'.top()
=================================================
// Core definitions for the proof

R' in SatisfiedRedirections(p; R) iff SatisfiedSolutions(p; R; CollectConstraints(p; R))
R' in SatisfiedSolutions(CCz)(p; R) iff
  R satisfies_p CCz && PossibleTargets(p; R) && R' in PossibleRedirections(p; R) && R consistent_p CCz

// Reminder:
//CollectRedirection(p; R) = CollectSolution(p; R; CollectConstraints(p; R))

BestSatisfiedRedirection(p; R) = BestSatisfiedSolution(p; R; CollectConstraints(p; R))
BestSatisfiedSolution(p; R; CCz) = UniversalMostSpecific(p; R; SatisfiedSolutions(CCz))

Define R in CollectMappings(p; CCz), iff:
  dom(R) = dom(CCz)
  forall Cs in dom(CCz): R(Cs) in CollectTargets(p; CCz; Cs)

------------------------------------------------------
Proof that forall (p, R) in ValidProblems: CollectRedirection(p; R) == BestRedirection(p; R)
------------------------------------------------------
Suppose (p, R) in ValidProblems(p; R)

Let CCz = CollectConstraints(p; R)
// Proof that CCz is finite:
//    It has to be, as we never pull Cs's or P's out of thin air,
//    rather we always get them from somehwere in the program (or our current constraint set), since R and p are neccesarily finite, it follows that CCz is also

// Proof that CCz is consitantly defined:
// I.e. that we cant show that CC in CCz and CC not in CCz at the same time
//    well Collect never checks whether something is not in Collect, i.e.
//    we can never derive a proof that CC is not in CCz directly, we can only derive proofs of CC in CCz (So it's all good)
// TODO: Prove that CCz is computable? (i.e. we can print everything)
//    Well it's finite, and everything it uses is computable/decidable...


Theorem 1: If not CompletedConstraints(p; CCz) and ValidRedirections(p; R) != {} then
   exists p' in SimilarPrograms(p) and R' such that R' in ValidRedirections(p'; R') and range(R) not subseteq dom(p)
  // Proof by construction

Theorem 3: CollectSolution(p; R; CCz) in ValidRedirections(p; R)
  // Proof by contradiction
  // might be true...

Theorem 2: ValidRedirections(p; R) subseteq SatisfiedSolutions(CCz)(p; R) // Moderetly hard, but definently true
  // Direct proof

Theorem 4: If forall p' in SimilarPrograms(p), f(p', R) = f(p, R) then
  UniversalMostSpecific(p; R; f) = MostSpecificRedirection(f(p; R))

Theorem 5: forall p' in SimilarPrograms(p): (ValidRedirections(p'; R) \ ValidRedirections(p; R)) disjoint PossibleRedirections(p; R)
  // True?

Lemma 1: If MostSpecificRedirection(p; R,Rz,Rz') = R, then MostSpecificRedirection(p; R,Rz) = R
  // Obviously

// Note: all the '~~~~~~~~~~~~~~~~~'s bellow indicate easy parts of the proof to fill in
// Whereass the theorems above are non trivial
1. Suppose CollectRedirection(p; R) is undefined, then BestRedirection(p; R) is undefined
  1.1. Suppose CompletedConstraints(p; CCz), then BestRedirection(p; R) is undefined
    1.1a. SatisfiedSolutions(CCz) = {}.
      ~~~~~~~~~~~~~~~~~
    By Theorem 2, we have ValidRedirections(p; R) = {}, therefore BestRedirection(p; R) is undefined.

  1.2. Suppose not CompletedConstraints(p; CCz), then BestRedirection(p; R) is undefined
    2.2a. CollectRedirection(p; R) is undefined.
      ~~~~~~~~~~~~~~~~
    By Theorem 1, BestRedirection(p; R) is undefined.

2. Suppose CompletedConstraints(p; CCz), and CollectRedirection(p; R) = R', then BestRedirection(p; R) = R'
  2a. R' in SatisfiedSolutions(CCz)(p; R)
    ~~~~~~~~ // The only non-trivial part is that R' in PossibleRedirections(p; R)
  2b. MostSpecificRedirection(SatisfiedSolutions(CCz)(p; R)) = R'
    ~~~~~~~~ // by definition of CollectSolutions
  2c. forall p' in SimilarPrograms(p), SatisfiedSolutions(CCz)(p; R) == SatisfiedSolutions(CCz)(p'; R)
    ~~~~~~~~
  2d. By 2a, 2b and 2c, and theorem 4, UniversalMostSpecific(p; R; SatisfiedSolutions(CCz)) = R'
    ~~~~~~~~~~~~~~~~~
  Obviously BestRedirection(p; R) in ValidRedirections(p; R).
  By Theorem 2 and, Theorem 3 we have:
     R' in ValidRedirections(p; R) subseteq SatisfiedSolutions(CCz)(p; R)
  And by 2b and Lemma 1 we have that
   R' = MostSpecificRedirection(ValidRedirections(p; R)).
  // How do we show that this won't change with other p's?
  Since SatisfiedSolutions(CCz)(p; R) subseteq PossibleRedirections(p; R), by Theorem 2 and 2c it follows that
    forall p' in SimilarPrograms(p), ValidRedirections(p; R) == ValidRedirections(p'; R)
  By theorem 4 it follows that BestRedirection(p; R) = UniversalMostSpecific(p; R; ValidRedirections) = R'.

Therefore, forall (p, R) in ValidProblems: CollectRedirection(p; R) == BestRedirection(p; R)


=============
// Rules 3d, 4 and 5 ensure the other cases (i.e. implements, return types and paramater types)
// Proof sketch that the mapping
// can't have gone wrong due to an interface method return type not lining up
R(Cs1) = P1, R(Cs2) = P2
P1 <= Cs1 // by rule 11b
P1' <= Cs1 // by rule 4
P2 <= Cs2 // by rule 11b

         P2.s.P = P1'
Where: Cs2.s.Cs = Cs1

// So we have P1' <= P1
// By collectTargets, we have that
 Cs2 -> P2 consistent_p CCz
And so Cs1->P1' satisfies_p P1 <= Cs1
and P1 <= P1'
and hence P1' = P1,
a contradiction.

=============
For paramater types:
	note that rule 8d forces rule 7 to apply
	since we cannot refine paramater types,
	this will work!
===============================================

---------------
Proof 2b

Assumptions:
   (p, R0) in ValidProblems(p; R0)
   CCz = CollectConstraints(p; R0)
   CompletedConstraints(p; CCz)
   CollectRedirection(p; R0) is defined
Goal:
  SatisfiedRedirections(p; R0) subseteq ValidRedirections(p; R0)
----------------------------------------------------------------------
Assumptions:
  R in SatisfiedRedirections(p; R0)
  R not in ValidRedirections(p; R0)
Goal:
  contradiction
----------------------------
Since the only part of valid ValidRedirections not ensured by SatisfiedRedirections is:
  forall Cs in dom(R): p|- R(Cs); p[R(Cs)] <= Cs; R(p[Cs])
this must not be true.
-------------------------------------
Let:
  P = R(Cs)
  L = p[Cs]
  L' = p[P]

Assumptions:
  Cs in dom(R)
  p |/- P; L' <= Cs; R(L)
------------------------------
One of the conditions of the <= must have failed, it can't be a condition on the sdom or interface keyword,
because those are checked by PossibleTarget, so the only possible failures are that:
    exists P' in p.minimize(R(L.Pz)) such that: p |/- P <= P'
    exists s in sdom(L) such that:
        // Note: L'(s) must exist due to PossibleTarget
        p |/- L'(s).mt <= R(L(s).mt)
        if L.interface? = interface: p |/- R(L(s).mt) <= L'(s).mt
Due to PossibleTarget, the failure must be on a Cs', // TODO: Explain
As such, we have either
Case 1: exists Cs' in L.Pz, such that p |/- P <= R(Cs')
Case 2: exists s in sdom(L) such that p |/- L'(s).P <= R(L(s).Cs)
Case 3: exists s in sdom(L), and i, such that p |/- R(L(s).Csi) <= L'(s).Pi

Case 4: L.interface? = interface and exists s in sdom(L) such that p |/- R(L(s).Cs) <= L'(s).P
Case 5: L.interface? = interface and exists s in sdom(L), and i, such that p |/- L'(s).Pi <= R(L(s).Csi)

In particular, we must have that CCz does not imply one of the above relations.

Since CompletedConstraints(p; CCz) we must have a P' <= Cs in CCz, and by CollectSolution, we must have P' <= P
----------------------------------------------------------------------
Assumptions
  PL <= Cs in CCz, PL <= P
  PL' <= Cs' in CCz, PL' <= P'
  R(Cs') = P'
---------------------------------------------


Case 1: exists Cs' in L.Pz, such that p |/- P <= R(Cs')
============================================================
  Rule 3a/b/c/d & 8'd

Let Pz = {Px in SuperClasses(p; PL) | PossibleTarget(p; Cs'; Px)}

Suppose Rule 3a did apply,
  then MostSpecific(p; Pz) is defined, lets say it equals P2
  Since everything in Pz is a superclass of PL,
  it follows that PL <= P2, since we have PL <= P

  So we had the constraint, P2 <= Cs'
  and hence P2 <= P'
  And so PL <= P'
  And we have P </= P'

//  and We have PossibleTarget(p; Cs'; R(Cs')), so
 ........



Case 2: exists s in sdom(L) such that p |/- L'(s).Cs <= R(L(s).Cs)
------------------------------
Let L(s).Cs = Cs'
L'(s).Cs = P'

PL <= P = R(Cs)

  P' </= R(Cs')
Since we have PL <= P
  and s in sdom(L')
  We have s in sdom(p[PL])
  We must have p[PL](s).P = PLR

  PLR <= P'
  By rule 4
    we must have a constraint
         PLR <= R(Cs')

  PLR <= P' </= R(Cs')
  PLR <= R(Cs')






Theroem InternalStability:
  forall p ~R~ p',  BestRedirection_i(p; R) = BestRedirection_i(p'; R)

p ~R~ p'
  // RedirectSet* also includes nested classes?
  p.top()[only RedirectSet*(p; R)] = p'.top()[only RedirectSet*(p'; R)]
  // also delete method bodies...
--------------------------------------------------------------------------
