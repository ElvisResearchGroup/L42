// A sketch of the proof, plus some definitions only used internally by
// (i.e. they are not used by the algorithm, nor the properties we are trying to proove about it)

What we want to prove?
==============================================================================-===
forall p, R: ValidProblem(p; R) --> CollectRedirect(p; R) == BestRedirect(p; R)

Where BestRedirect(p; R) = R', iff:
  forall p' such that SimilarProblem(p; R; p'),
    MostSpecificMapping(p'; {R' | ValidSolution(p'; R; R')}) = R'
// Also '==' works on undefined as you would expect...

// TODO: Other things to prove?
// ValidSolution(p; R; R') --> BestRedirect(p; R') = R'
// The input Redirect passes to CollectRedirect satisfies ValidProblem
// Meta-level soundness?
=============================================================================================
SimilarProblem(p; R; p') iff
  Csz = RedirectSet(p.top(); dom(R))
  L = p.top()[only Csz] = p'.top()[only Csz]
  p.updateTop(L) <= p'.updateTop(L)
  ValidProblem(p'; R)
=================================================
// Core definitions for the proof


SatisfiedSolution(p; CCz; R) iff:
  R satisfies_p CCz && PossibleTargets(p; R) && PossibleSolution(p; R0; R)

// Reminder:
//CollectRedirect(p; R) = CollectSolution(p; CollectConstraints(p; R))

BestSatisfiedRedirect(p; R) = BestSatisfiedSolution(p; R; CollectConstraints(p; R))
BestSatisfiedSolution(p; R; CCz) = R':
  forall p' such that SimilarProblem(p; R; p'),
    MostSpecificMapping(p'; {R' | SatisfiedSolution(p'; CCz; R')}) = R'


Define R in CollectMappings(p; CCz), iff:
  dom(R) = dom(CCz)
  forall Cs in dom(CCz): R(P) in CollectTargets(p; CCz; Cs)
--------------------------------------------
Proof that forall p, R: ValidProblem(p; R) --> CollectRedirect(p; R) = BestRedirect(p; R)
----------------------------------
Take arbitrary p and R such that ValidProblem(p; R)
1. CollectRedirect == BestSatisfiedRedirect
  1a. Proof: suppose that CCz = CollectConstraints(p; R),
    show that BestSatisfiedSolution(p; CCz) == CollectSolution(p; CCz) // Since the rest of CollectRedirect and BestSatisfiedRedirect are the same

    // Hard parts of the proof:
      // proving that PossibleSolution(p; R; CollectSolution(p; CCz))
      // prooving that the forall p' SimilarProblem(p; R; P') dosn't break our algorithm, since:
          // forall Cs,
          // If exists Pz such that forall p' SimilarProblem(p; R; P'): {P | Cs->P satisfies_p' CCz} = Pz
          //   then CollectTargets(p; CCz; Cs) = Pz
          // Otherwise, CollectTargets(p; CCz; Cs) is undefined
          // I.e. the set of things satisfing the constraints is indepent of the program
          // If it's not, we can than prove that the most-specific is also not independent of the program

    // Easy parts:
        // CollectSolution chooses the MostSpecificMapping of CollectMappings (see above)
        // Forall R in CollectMappings, R satisfies_p CCz && PossibleTargets(p; R)

       p, MostSpecific... bullshit, is the same as our MostSpecific(p; Pz) thing...

2. SatisfiedRedirect == ValidRedirect
  2a. SatisfiedRedirect ==> ValidRedirect // Hard
  2b. ValidRedirect ==> SatisfiedRedirect // Easy