// A sketch of the proof, plus some definitions only used internally by
// (i.e. they are not used by the algorithm, nor the properties we are trying to proove about it)

What we want to prove?
=================================================================================
forall (p, R) in ValidProblems: CollectRedirection(p; R) == BestRedirection(p; R)

Where BestRedirection(p; R) = R', iff:
  forall p' in SimilarProblems(p; R), MostSpecificMapping(p'; {R' | ValidRedirection(p'; R; R')}) = R'
// Also '==' works on undefined as you would expect...

// TODO: Other things to prove?
// The input Redirect passes to CollectRedirection satisfies ValidProblem
// Prove internal stability....
// Meta-level soundness?
=============================================================================================
p' in SimilarProblems(p; R) iff p <= p' and ValidProblem(p'; R)
=================================================
// Core definitions for the proof

SatisfiedRedirection(p; R; R') iff SatisfiedSolution(p; R; CollectConstraints(p; R); R')
SatisfiedSolution(p; R; CCz; R') iff:
  R satisfies_p CCz && PossibleTargets(p; R) && PossibleRedirection(p; R; R')

// Reminder:
//CollectRedirection(p; R) = CollectSolution(p; R; CollectConstraints(p; R))

BestSatisfiedRedirection(p; R) = BestSatisfiedSolution(p; R; CollectConstraints(p; R))
BestSatisfiedSolution(p; R; CCz) = R':
  forall p' in SimilarProblems(p; R):
    MostSpecificMapping(p'; {R' | SatisfiedSolution(p'; R; CCz; R')}) = R'

Define R in CollectMappings(p; CCz), iff:
  dom(R) = dom(CCz)
  forall Cs in dom(CCz): R(Cs) in CollectTargets(p; CCz; Cs)

------------------------------------------------------
Proof that forall (p, R) in ValidProblems: CollectRedirection(p; R) == BestRedirection(p; R)
------------------------------------------------------
Suppose (p, R) in ValidProblems(p; R)

Let CCz = CollectConstraints(p; R)
0. CCz is (uniqueley) defined // Right?
  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

1. Suppose CollectRedirection(p; R) is undefined, then BestRedirection(p; R) is undefined
  1.1. Suppose CompleteConstraints(p; CCz), then BestRedirection(p; R) is undefined
    1.1a: {R' | SatisfiedSolution(p; R; CCz; R')} = {} // Easy
      ~~~~~~~~~~~~~~~~~~~~~~~
    1.1b: forall R', if ValidRedirection(p; R; CCz; R') --> SatisfiedSolution(p; R; CCz; R') // Moderatly dificuilt
      ~~~~~~~~~~~~~~~~~~~~~~~
    Therefore, forall R', not ValidRedirection(p; R; CCz; R'), and so BestRedirection(p; R) is undefined

  1.2. Suppose not CollectComplete(p; R), then BestRedirection(p; R) is undefined
    1b. CollectRedirection(p; R) is undefined  // trivial
      ~~~~~~~~~~~~~~~~~~~~~~~
    1a. BestRedirection(p; R) is undefined // hard
      ~~~~~~~~~~~~~~~~~~~~~~~

2. Suppose CollectComplete(p; R), and CollectRedirection(p; R) = R', then BestRedirection(p; R) = R'
  2a. BestSatisfiedRedirection = R'
    2a.a. BestSatisfiedSolution(p; R; CCz) = R'// Since the rest of CollectRedirection and BestSatisfiedRedirection are the same, and CollectSolution(p; R; CCz) = R'
        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

      // Hard parts of the proof:
        // proving that PossibleRedirection(p; R; CollectSolution(p; R; CCz))
      // prooving that the forall p' SimilarProblem(p; R; P') dosn't break our algorithm, since:
          // forall Cs,
          // If exists Pz such that forall p' SimilarProblem(p; R; P'): {P | Cs->P satisfies_p' CCz} = Pz
          //   then CollectTargets(p; CCz; Cs) = Pz
          // Otherwise, CollectTargets(p; CCz; Cs) is undefined
          // I.e. the set of things satisfing the constraints is indepent of the program
          // If it's not, we can than prove that the most-specific is also not independent of the program

    // Easy parts:
        // CollectSolution chooses the MostSpecificMapping of CollectMappings (see above)
        // Forall R in CollectMappings, R satisfies_p CCz && PossibleTargets(p; R)

       p, MostSpecific... bullshit, is the same as our MostSpecific(p; Pz) thing...

  2b. SatisfiedRedirection(p; R; R') ==> ValidRedirection(p; R; R') // Hard
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Therefore, CollectRedirection == BestRedirection

==========
Let f and g be partial function from A->B

Then f == g iff: forall a in A, f(a) == b(a)
Or,

forall a in A,
  f(a) is undefined iff g(a) is undefined
  forall b, f(a) = b iff g(a) = b
------------------------------------------------
Or alternatively we can consider the cases?

  if f(a) is undefined: g(a) is undefined
  if f(a) = b: g(a) = b

Proof that that implies f == g? (who cares about the other  direction?)
  Suppose not, than we must have an a such that f(a) and g(a) disagree,
      if f(a) is undefined, than by the above we must have g(a) is undefined, so a contradiction
      if f(a) = b, then by the above, we must have g(a) = b, again a contradiction




















