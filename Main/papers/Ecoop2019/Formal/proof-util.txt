// This file contains definitions that are not needed by the algorithm, but are needed for the proof
//Do we need to define well formedness for p?

//CCz implies_p CCz' iff forall R: R satisfies_p CCz --> R satisfies_p CCz'

Define ValidProblem(p; R) iff:
  forall P in ran(R):
    p.minimize(P)=P
    P not of form This0._
    p |- p[P][with ncz=empty] : OK // Guaranteed by our reduction rules and type-system?
  Redirectable(p; RedirectSet(p, R))
  // All of these, save for the well-typedness, are guaranteed by Redirect

Define PossibleRedirection(p; R; R')
  R subseteq R'
  dom(R') = RedirectSet(p; R)
  ValidProblem(p; R')

Define ValidRedirection(p; R; R')
  PossibleRedirection(p; R; R')
  forall Cs in dom(R'):
    p |- R'(Cs); p[R'(Cs)] <= Cs; R'(p[Cs])

Define p |- P;L <= Cs;L
 p|- P; {interface?' implements Pz' mwtz', ncz'} <= Cs; {interface? implements Pz mwtz, ncz}
  p.minimize(Pz) subseteq SuperClasses(p; P) //SuperClasses is Pz',P,Any. In this way F-bound polimoprhism works as usual: {implements Foo} can be redirected to Foo
  forall MS in dom(mwtz): // This implicity checks sdom(mwtz) subseteq sdom(mwtz') 
    p |- mwtz'(MS).mt <= mwtz(MS).mt
    //TODO: use s instead of MS ms sel in both redirect and 42 formal
  if interface?=empty: // If the LHS is not an interface
    // One can only call class methods on a non-interface, so if the RHS has them, than the LHS can't be an interface
    if interface?' = interface then class not in mwtz.mdfz
  // If the LHS is an interface, we need to ensure that any valid implementation of the LHS
  // Is a valid implemention of the RHS, which requires that the RHS have the exact same method signatures as the LHS
  else:
    interface? = interface?' // You can't implement non-interfaces
    forall MS in dom(mwtz'): // This implicity checks the msdom
      p |- mwtz(MS).mt <= mwtz'(MS).mt

Define p <= p' // But for paper language only!
=======================================================================================
p <= p' // reflexive

p <= p': // transitive
  exists p" such that:
    p <= p"
    p" <= p'

//(DLs; DVs) <= (DLs DLs'; DVs DVs') //broken in the current form, and not needed?

(DLs id = L[remove Csz] DLs'; DVs) <= (DLs id = L DLs'; DVs)// I.e. L has less nested classes
// TODO: Can this change the meaning of p.minimize?

// NOTE: We are not adding methods! (as doing so will break redirect)

// TODO: Change p to have a DVz for the top-level declarations?
// Or is their order actually important?

========================================
R satisfies_p CC1,...,CCn iff R satisfies_p CC1 ... R satisfies_p CCn

R satisfies_p Cs <= P iff p |- R(Cs) <= P
R satisfies_p P <= Cs iff p |- P <= R(Cs)

===============================================
define MostSpecificRedirection(p; R,Rz) = R
  forall Cs: 
    // forall is limited since R(Cs) is undefined if none of the R,Rz define it
    R(Cs) = MostSpecific(p; {R'(Cs) | R' in R,Rz})

================================
//dom(p) = { p.minimize(P) | p(P) is defined }

//Define ValidProblems = {(p, R) | ValidProblem(p; R)}
//We will write (p, R) in ValidProblem if ValidProblem(p; R)


CompletedConstraints(p; R; CCz) iff:
  forall Cs in RedirectSet(p; R):  _ <= Cs in CCz //dom would do it on both directions

//using our algorithm, R constraints all the RedirectSet
CollectComplete(p; R) iff CompletedConstraints(p; R; CollectConstraints(p; R))

Lemmas (I.e. Proof these!)
=================================
forall R0,p,R
If range(R) not subseteq dom(p), then not PossibleRedirection(p; R0; R)

--------------------------------------------------------------
Let f be some function from (p, R) -> Rz, such that:
  forall (p, R) in ValidProblems,
    forall p' in SimilarProblems(p; R),
      f(p, R) subseteq f(p', R)

define MostSpecificSimilar(p; R; f) = R' iff:
  forall p' in SimilarProblems(p; R):
    MostSpecificRedirection(p'; f(p, R)) = R'

// The idea being that BestRedirection = MostSpecificSimilar(p; R; f)
//  where f(p, R) = {R' | ValidRedirection(p; R; R')}
// And similar with BestSatisfiedRedirection

forall (p, R) in ValidProblems:
  if exists p' in SimilarProblems(p; R), and R', such that:
      R' in f(p', R)
      range(R') not subseteq dom(p)
  then MostSpecificSimilar(p; R; f) is undefined
-------------------------------------------------------------------------------------------------

dom(CollectConstraints(p; R)) subseteq RedirectSet(p; R)


Define p.defineClass(L, C) = p' // But for paper language only!
=======================================================================================
  (id0 = L0, id1 = L0, p).defineClass(L, C) = (id0 = L0, id1 = L1[mwtz = L1.ncz, C: L], p)
  (id0 = L0; DVs).defineClass(L, C) = (id0 = L0; DVs, C = L)




