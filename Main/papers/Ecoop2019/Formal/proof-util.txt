// This file contains definitions that are not needed by the algorithm, but are needed for the proof

//CCz implies_p CCz' iff forall P: P satisfies CCz --> P satisfies CCz'

ValidProblem(p; R) iff:
  // p and R are wellformed ?

  // All of these, save for the well-typedness, are guaranteed by Redirect
  forall P in ran(R):
    p.minimize(P)=P
    P not of form This0._
    p |- p[P] : OK // Guaranteed by our reduction rules and type-system?

  Redirectable(RedirectSet(p.top(), dom(R)); p.top())

Define PossibleSolution(p; R; R')
  R subseteq R'
  dom(R') = RedirectSet(p.top(); dom(R))
  ValidProblem(p; R')

Define ValidSolution(p; R; R')
  PossibleSolution(p; R; R')
  forall Cs in dom(R'):
    p |- R'(Cs); p[R'(Cs)] <= Cs; R'(p[Cs])

// Is the LHS (whose name is 'This0.Cs') a structural supertype of the RHS (whose name is P)
// We say that A is a structural supertype of B if any code written with respect to A
// would also type-check against B
Define p|- P; {interface?' implements Pz' mwtz', ncz'} <= Cs; {interface? implements Pz mwtz, ncz}
  // Check that all the interfaces the LHS implements are also implemented by the RHS
  p.minimize(Pz) subseteq SuperClasses(p; P) //Note: Using SuperClasses (and not Pz') is very important, so that F-bound polimoprhism can work TODO: explain what this means

  // Check that each method-type of the RHS is a subtype of the LHS
  // (So that it any well-typed call to a method on the LHS would also typecheck if it were to call a method on the RHS)
  forall MS in dom(mwtz): // This implicity checks the msdom
    p |- mwtz'(MS).mt <= mwtz(MS).mt

  // If the LHS is not an interface
  if interface?=empty:
    // One can only call class methods on a non-interface, so if the LHS has any, than the RHS can't be an interface
    if interface?' = interface then class not in mwtz.mdfz

  // If the LHS is an interface, we need to ensure that any valid implementation of the LHS
  // Is a valid implemention of the RHS, which requires that the RHS have the exact same method signatures as the LHS
  else:
    interface? = interface?' // You can't implement non-interfaces

    forall MS in dom(mwtz'): // This implicity checks the msdom
      p |- mwtz(MS).mt <= mwtz'(MS).mt


Define p <= p' // But for paper language only!
=======================================================================================
p <= p' // reflexive

p <= p': // transitive
  exists p'' such that:
    p <= p''
    p'' <= p'

(DLs; DVs) <= (DLs DLs'; DVs DVs')
  // I.e. a shallower program, or one with more less top-level declarations

(DLs id = L DLs; DVs) <= (DLs id = L' DLs; DVs)
  L = L'[remove Csz] // I.e. L has les nested classes

// NOTE: We are not adding methods! (as doing so will break redirect)

// TODO: Change P to have a DVz for the top-level declarations?
// Or is their order actually important?


Define L[only Csz] = L'
=======================================================================================
L[only Cs,Csz] = L[only Cs] U L[only Csz]
L[only empty] = {}
// Discard method bodies!, we don't want people looking in them, or do we?
L[only C1...Cn] = {C1: ... {Cn: L(Cs)[with ncz = empty, with mwtz.ez = empty]} ... }

// U above is a 'dumb' sum, namely:
{interface?1 Pz C: L ... Cn: Ln Mz} U {interface?2 Pz' C1: L1' ... Cn: Ln' Mz'} =
  {interface?1 U interface?2 Pz Pz' C1: L1 U L1' ... Cn: Ln U Ln' Mz Mz'}

========================================
R satisfies_p CC1,...,CCn iff
  R satisfies_p CC1
  ...
  R satisfies_p CCn

R satisfies_p Cs <= P iff p |- R(Cs) <= P
R satisfies_p P <= Cs iff p |- P <= R(Cs)

===============================================
define MostSpecificMapping(p; Rz) = R
  R in Rz
  forall Cs:
    // Note: R(Cs) is undefined, if none of the Rz define it
    R(Cs) = MostSpecific(p; {R'(Cs) | R' in Rz})