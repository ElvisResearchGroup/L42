\section{Introduction}
%\begin{lstlisting}
%hi method class Foo{ bar}
%\end{lstlisting}

Associated types are a powerful form of generics, now integrated in both Scala and Rust.
They are a new kind of member, like methods fields and nested classes.
Associated types behave as 'virtual' types: they can be overridden, can be abstract and can have
a default.
However, the user has to specify those types and their concrete instantiations manually; that is, the user
have to provide a complete mapping from all virtual type to concrete instantiation.
When the number of associated types is small this poses no issue, but it hinders designs where the number of
associated types is large. In this paper we examine the possibility of completing
a partial mapping in a desirable way, so that the resulting mapping is sound and also robust with
respect to code evolution.

The core of our design is to reuse the concept of nested classes instead of relying of a new kind of member for
associated types.
An operation, call Redirect, will redirect some nested classes in some external types.
To simplify our formalization and to keep the focus on the core of our approach, we 
present our system on top of a simple 
Java like languages, with only final classes and interfaces, when code reuse is obtained by
trait composition instead of conventional inheritance. 
We rely on a simple nominal type system, where subtyping is induced only by implementing interfaces;
in our approach we can express generics without having a polymorphic type system.
To simplify the treatment of state, we consider fields to be always instance private, and
getters and setters to be automatically generated, together with a \Q@static@ method \Q@of(..)@
that would work as a standard constructor, taking the value of the fields and initializing the instance.
In this way we can focus our presentation to just (static) methods, nested classes and implements relationships.
Expanding our presentation to explicitly include visible fields, constructors and sub-classing would
make it more complicated without adding any conceptual underpinning.
In our proposed setting we could write:
\begin{lstlisting}
String=...
SBox={String inner;
  method String inner(){..}//implicit
  static method SBox of(String inner){..}}//implicit
myTtrait={
  Box={Elem inner}//implicit Box(Elem inner) and Elem inner()
  Elem={Elem concat(Elem that)}
  static method Box merge(Box b,Elem e){return Box.of(b.inner().concat(e));}
  }
Result=myTrait<Box=SBox>//equivalent to trait<Box=SBox, Elem=String>
  ...Result.merge(SBox.of("hello "), "world");//hello world
\end{lstlisting}
Here class \Q@SBox@ is just a container of \Q@String@s, and \Q@myTrait@ is code
encoding \Q@Box@es of any kind of \Q@Elem@ with a \Q@concat@ method.
By instantiating \Q@myTrait<Box=SBox>@, we can infer \Q@Elem=String@, and 
obtain the following flattened code,
where \Q@Box@ and \Q@Elem@ has been removed, and their occurrences are replaced with \Q@SBox@ and \Q@String@.
\begin{lstlisting}
Result={static method SBox merge(SBox b,String e){
  return SBox.of(b.inner().concat(e));}}
\end{lstlisting}

Note how  \Q@Result@ is a new class
that could have been written directly by the programmer,
there is no trace that it has been generated by \Q@myTrait@.
We will represent trait names with lower-case names and class/interface names with upper-case names.
Traits are just units of code reuse, and do not induce nominal types.
%This creates a parallel with generic classes, where the class name is used
%as a type generator and not as a type: it needs to take in input the 

We could have just written 
\Q@Result=myTrait<Elem=String>@, obtaining 
\begin{lstlisting}
Result={
  Box={String inner}
  static method Box merge(Box b,String e){
    return Box.of(b.inner().concat(e));}}
\end{lstlisting}
Note how in this case, class \Q@Result.Box@ would exists. Thanks to our decision of using nested classes
as associated types, the decision of what classes need to be redirected is not made when the trait is written,
but depends on the specific redirect operation.
Moreover, our redirect is not just a way to show the type system that our code is correct, but it can change 
the behaviour of code calling static methods from the redirected classes.


This example show many of the characteristics of our approach:
\begin{itemize}
\item(A) We can redirect mutually recursive nested classes by redirecting them all at the same time, and
if a partial mapping is provided, the system is able to infer the complete mapping.

\item(B) \Q@Box@ and \Q@Elem@ are just normal nested classes inside of \Q@myTrait@; indeed
any nested class can be redirected away.
In case any of their (static) methods was implemented, the implementation is just discarded.
In most other approaches, abstract/associated/generic types are special and have some restriction;
for example, in Java/Scala static methods and constructors can not be invoked on generic/associated types.
With redirect, they are just normal nested classes, so there are no special restrictions on how they can be used.
In our example, note how \Q@merge@ calls \Q@Box.of(..)@.

\item(C) 
While our example language is nominally typed, 
nested classes are redirected over types satisfying the same structural shape.
We will show how this offers some advantages of both nominal and structural typing.
\end{itemize}

A variation of redirect, able to only redirect a single nested class, was already presented in literature.
While points (B) and (C) already applies to such redirect,
we will show how supporting (A) greatly improve their value.

The formal core of our work is in defining 
\begin{itemize}
\item \Q@ValidRedirect@, a computable predicate telling if a mapping respect the structural shapes and
nominal subtype relations.
\item A formal definition of what properties a procedure 
expanding a partial mapping into a complete one should respect.
\item \Q@ChoseRedirect@, an efficient algorithm respecting those properties.
\end{itemize}

We first formally define our core language, then we define our redirect operator and
its formal properties.
Finally we motivate our model showing
how many interesting examples of generics and associated types can be encoded with redirect. Finally, as
an extreme application,
we show how a whole library can be adapted to be injected in a different environment.


\section{Language grammar and well formedness}
\begin{bnf}
	\production{a}{b}{c}\\
	\production{a}{b}{c}\\
	\production{a}{b}{c}\\
\end{bnf}

%In Java, we would need much more complex code:
%  
%(ds x = e)
%I1 I2
%A< I1,I2
%B< I1,I2
%
%return A
%return B
%
%
%g={
% NL:{}
% EL:{}
% Node={constructor(NL label)
%    }
%    Node={implements Tree
%      //fields are implicitly declared as the constructor parameters
%      constructor(L label,Tree left, Tree right)
%      method Void accept(Visitor v){v.acceptNode(this);}
%    }
%
%  
%
%
%//Node=Data<>< class(Tree){}
%
%  tree={
%    L:{}
%    Visitor:{interface
%      method Void visitNode(Node n)
%      method Void visitLeaf(Leaf n)
%    }
%    Tree={interface      
%      method Void accept(Visitor v)
%    }
%    Node={implements Tree
%      //fields are implicitly declared as the constructor parameters
%      constructor(L label,Tree left, Tree right)
%      method Void accept(Visitor v){v.acceptNode(this);}
%    }
%    Leaf={implements Tree
%      constructor(L label)
%      method Void accept(Visitor v){v.acceptLeaf(this);}
%    }
%  }
%  treeToS=tree<+{
%      L:{method String toString()}
%      method String 
%      method Tree merge(Tree a, Tree b){
%        if(a instanceof Leaf &&
%        }
%    }
%    MyA={ method MyB m()= new MyB(); ..}
%    MyB={ method String f()="Hello"; ..}
%    g<A=MyA>//instantiation. The mapping A=MyA,B=MyB
%
%
%I A B
%I{ C visit(I,V) C accept(A) C accept(B)}
%A{ 
%  C visit(I that,V v) that.acceptA(this,v)
%  C accept(A that,v) new AA(this,that).visit(v)
%  C accept(B) new BB()
%}
%PreVisitor
%Visitor AA AB BA BB


\section{extra}

Features:
Structural based generics embedded in a nominal type system.
Code is Nominal, Reuse is Structural.
Static methods support for generics, so generics are not just a trik to make the type system happy but actually
change the behaviour
Subsume associate types.
After the fact generics; redirect is like mixins for generics
Mapping is inferred-> very large maps are possible -> application to libraries


In literature, in addition to conventional Java style F-bound polymorphism, there is
another way to obtain generics: to use associated types (to specify generic paramaters) and inheritence (to instantiate the paramaters).
However, when parametrizing multiple types, the user to specify the full mapping.
For example in Java
    interface A<B>{ B m(); }
    inteface B{String f();}
    class G<TA extends A<TB>, TB>{//TA and TB explicitly listed
      String g(TA a TB b){return a.m().f();}
    }
    class MyA implements A<MyB>{..}
    class MyB implements B {..}
    G<MyA,MyB>//instantiation
Also scala offers genercs, and could encode the example in the same way, but Scala
also offers associated types, allowing to write instead....

Rust also offers generics and associated types, but also support calling static methods
over generic and associated types.

We provide here a fundational model for genericty that subsume the power
of F-bound polimorphims and  associated types.
Moreover, it allows for large sets of generic parameter instantiations to be inferred starting from a much smaller mapping.
For example, in our system we could just write
    g={
      A={ method B m()}
      B={ method String f()}
      method String g(A a B b)=a.m().f()
    }
    MyA={ method MyB m()= new MyB(); ..}
    MyB={ method String f()="Hello"; ..}
    g<A=MyA>//instantiation. The mapping A=MyA,B=MyB

We model a minimal calculus with interfaces and final classes, where implementing an interface is the only way to induce subtyping.
We will show how supporting subtyping constitute the core technical difficulty in our work, inducing ambiguity in the mappings.
As you can see, we base our generic matches the structor of the type instead of respecting a subtype requirement as in F-bound polymorphis.
We can easily encode subtype requirements by using implements:
Print=interface{ method String print();}
g={
  A:{implements Print}
  method A printMe(A a1,A a2){ if(a1.print().size()>a2.print.size()){return a1;} return a2;}
  }
MyPrint={implements Print ..}
g<A=MyPrint> //instantiation
g<A=Print> //works too


--------------
example showing ordering need to strictly improve
EI1: {interface}
EA1: {implements EI1}

EI2: {interface}
EA2: {implements EI2}

EB: {EA1 a1 EA1 a1}

{
A1: {}
A2: {}
B: {A1 a1 A2 a2}
}[B = EB] // A1 -> EI1, A2 -> EA2 a
          // A1 -> EA1, A2 -> EI2 b
          // A1 -> EA1, A2 -> EA2 c

a <=b
b <=a
c<= a,b
a <= c

\Q@hi@
\Q@Hi@
\Q@class@

$ aa \Q@hi@
\Q@Hi@
\Q@class@  qaq$
\begin{bnf}
	\production{a}{b}{c}\\
	\production{a}{b}{c}\\
	\production{a}{b}{c}\\
\end{bnf}

$\Q@}}][()]@$

$\begin{array}{l}
\inferrule[(top)]{
	a \xrightarrow[b]{} c\quad
	\forall i<3 a\vdash b:\text{OK}\\\\
	\forall i<3 a\vdash b:\text{OK}
}{
	1+2
	\rightarrow
	3
}\begin{array}{l}
a\\b\\c
\end{array}
\end{array}$