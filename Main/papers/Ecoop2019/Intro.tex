\section{Introduction}
\begin{lstlisting}
hi method class Foo{ bar}
\end{lstlisting}

here we examine and understand what it means for a mapping to be completed in a desirable way
desarible means sound, but also maintenable

Associated types are a powerful form of generics, now integrated in both Scala and Rust.
They are a new kind of member, like methods fields and nested classes.
Associated types behave as 'virtual' types: they can be overridden, can be abstract and can have
a default.
However, the user has to specify those types and their concrete instantiations manually.
We propose here a different design, where instead of relying on a new kind of member, we reuse the well
known concept of nested classes. An operation, call Redirect, will redirect some nested classes in some external types.
To simplify our formalization and to keep the focus on the core of our approach, we 
present our system on top of a simple 
Java like languages, with only final classes and interfaces, when code reuse is obtained by
trait composition instead of conventional inheritance. 
For example, we could write..
  String=...
  SBox{String inner}
  trait={
    Box={Elem inner}
    Elem={Elem concat(Elem that)}
    class method Box merge(Box b1,Box b2){ new Box(b1.inner.concat(b2.inner));}
    }
  Result=trait<Box=SBox>//expands in trait<Box=SBox, Elem=String>
  Result.merge(new SBox("hello "),new SBox("world"));//hello world
Here class SBox is just a container of Strings, and trait is code
encoding Boxes of any kind of Elem with a concat method.
By instantiating trait<Box=SBox>, we can infer Elem=String, and 
In Java, we would need much more complex code:
  
(ds x = e)
I1 I2
A< I1,I2
B< I1,I2

return A
return B


g={
 NL:{}
 EL:{}
 Node={constructor(NL label)
    }
    Node={implements Tree
      //fields are implicitly declared as the constructor parameters
      constructor(L label,Tree left, Tree right)
      method Void accept(Visitor v){v.acceptNode(this);}
    }

  


//Node=Data<>< class(Tree){}

  tree={
    L:{}
    Visitor:{interface
      method Void visitNode(Node n)
      method Void visitLeaf(Leaf n)
    }
    Tree={interface      
      method Void accept(Visitor v)
    }
    Node={implements Tree
      //fields are implicitly declared as the constructor parameters
      constructor(L label,Tree left, Tree right)
      method Void accept(Visitor v){v.acceptNode(this);}
    }
    Leaf={implements Tree
      constructor(L label)
      method Void accept(Visitor v){v.acceptLeaf(this);}
    }
  }
  treeToS=tree<+{
      L:{method String toString()}
      method String 
      method Tree merge(Tree a, Tree b){
        if(a instanceof Leaf &&
        }
    }
    MyA={ method MyB m()= new MyB(); ..}
    MyB={ method String f()="Hello"; ..}
    g<A=MyA>//instantiation. The mapping A=MyA,B=MyB


I A B
I{ C visit(I,V) C accept(A) C accept(B)}
A{ 
  C visit(I that,V v) that.acceptA(this,v)
  C accept(A that,v) new AA(this,that).visit(v)
  C accept(B) new BB()
}
PreVisitor
Visitor AA AB BA BB




Features:
Structural based generics embedded in a nominal type system.
Code is Nominal, Reuse is Structural.
Static methods support for generics, so generics are not just a trik to make the type system happy but actually
change the behaviour
Subsume associate types.
After the fact generics; redirect is like mixins for generics
Mapping is inferred-> very large maps are possible -> application to libraries


In literature, in addition to conventional Java style F-bound polymorphism, there is
another way to obtain generics: to use associated types (to specify generic paramaters) and inheritence (to instantiate the paramaters).
However, when parametrizing multiple types, the user to specify the full mapping.
For example in Java
    interface A<B>{ B m(); }
    inteface B{String f();}
    class G<TA extends A<TB>, TB>{//TA and TB explicitly listed
      String g(TA a TB b){return a.m().f();}
    }
    class MyA implements A<MyB>{..}
    class MyB implements B {..}
    G<MyA,MyB>//instantiation
Also scala offers genercs, and could encode the example in the same way, but Scala
also offers associated types, allowing to write instead....

Rust also offers generics and associated types, but also support calling static methods
over generic and associated types.

We provide here a fundational model for genericty that subsume the power
of F-bound polimorphims and  associated types.
Moreover, it allows for large sets of generic parameter instantiations to be inferred starting from a much smaller mapping.
For example, in our system we could just write
    g={
      A={ method B m()}
      B={ method String f()}
      method String g(A a B b)=a.m().f()
    }
    MyA={ method MyB m()= new MyB(); ..}
    MyB={ method String f()="Hello"; ..}
    g<A=MyA>//instantiation. The mapping A=MyA,B=MyB

We model a minimal calculus with interfaces and final classes, where implementing an interface is the only way to induce subtyping.
We will show how supporting subtyping constitute the core technical difficulty in our work, inducing ambiguity in the mappings.
As you can see, we base our generic matches the structor of the type instead of respecting a subtype requirement as in F-bound polymorphis.
We can easily encode subtype requirements by using implements:
Print=interface{ method String print();}
g={
  A:{implements Print}
  method A printMe(A a1,A a2){ if(a1.print().size()>a2.print.size()){return a1;} return a2;}
  }
MyPrint={implements Print ..}
g<A=MyPrint> //instantiation
g<A=Print> //works too


--------------
example showing ordering need to strictly improve
EI1: {interface}
EA1: {implements EI1}

EI2: {interface}
EA2: {implements EI2}

EB: {EA1 a1 EA1 a1}

{
A1: {}
A2: {}
B: {A1 a1 A2 a2}
}[B = EB] // A1 -> EI1, A2 -> EA2 a
          // A1 -> EA1, A2 -> EI2 b
          // A1 -> EA1, A2 -> EA2 c

a <=b
b <=a
c<= a,b
a <= c

\Q@hi@
\Q@Hi@
\Q@class@

$ aa \Q@hi@
\Q@Hi@
\Q@class@  qaq$
\begin{bnf}
	\production{a}{b}{c}\\
	\production{a}{b}{c}\\
	\production{a}{b}{c}\\
\end{bnf}

$\Q@}}][()]@$

$\begin{array}{l}
\inferrule[(top)]{
	a \xrightarrow[b]{} c\quad
	\forall i<3 a\vdash b:\text{OK}\\\\
	\forall i<3 a\vdash b:\text{OK}
}{
	1+2
	\rightarrow
	3
}\begin{array}{l}
a\\b\\c
\end{array}
\end{array}$