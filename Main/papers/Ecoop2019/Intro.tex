\section{Introduction}
%\begin{lstlisting}
%hi method class Foo{ bar}
%\end{lstlisting}

\Q@here@ we examine and understand what it means for a mapping to be completed in a desirable way
desarible means sound, but also maintenable

Associated types are a powerful form of generics, now integrated in both Scala and Rust.
They are a new kind of member, like methods fields and nested classes.
Associated types behave as 'virtual' types: they can be overridden, can be abstract and can have
a default.
However, the user has to specify those types and their concrete instantiations manually.
We propose here a different design, where instead of relying on a new kind of member, we reuse the well
known concept of nested classes. An operation, call Redirect, will redirect some nested classes in some external types.
To simplify our formalization and to keep the focus on the core of our approach, we 
present our system on top of a simple 
Java like languages, with only final classes and interfaces, when code reuse is obtained by
trait composition instead of conventional inheritance. 
For example, we could write:
\begin{lstlisting}
  String=...
  SBox={String inner}
  trait={
    Box={Elem inner}
    Elem={Elem concat(Elem that)}
    static method Box merge(Box b,Elem e){return new Box(b.inner.concat(e));}
    }
  Result=trait<Box=SBox>//equivalent to trait<Box=SBox, Elem=String>
  Result.merge(new SBox("hello "), "world");//hello world


  String=...
  SBox=(String inner){
   static method SBox new(String inner)
   method String inner() {this._inner}
}

e ::= ... | this.x | new{(x: e)s}
M ::= ... | T x

// A class is 'coherent' if it has no-abstract methods
// A class with 'fields' cannot be redirected away (and only one operand of a sum may have fields)?


  trait={
    Box={Elem inner}
    Elem={Elem concat(Elem that)}
    static method Box merge(Box b,Elem e){return new Box(b.inner.concat(e));}
    }
  Result=trait<Box=SBox>//equivalent to trait<Box=SBox, Elem=String>
  Result.merge(new SBox("hello "), "world");//hello world


\end{lstlisting}
Here class SBox is just a container of Strings, and trait is code
encoding Boxes of any kind of Elem with a concat method.
In our examples, we assume a constructor that is just initializing the fields is always present.
We will also not consider any other kind of constructors.
By instantiating trait<Box=SBox>, we can infer Elem=String, and 
obtain the flattened code 
\Q@{static method SBox merge(SBox b1,SBox b2){return new SBox(b1.inner.concat(b2.inner));}}@
where \Q@Box@ and \Q@Elem@ has been removed, and their occurrences are replaced with \Q@SBox@ and \Q@String@.
Note how  \Q@Result@ is a new class
that could have been written directly by the programmer.
There is no trace that it has been generated by \Q@trait@.
Moreover, \Q@trait@ is just a unit of code reuse, and is not a nominal type.

This example show many of the characteristics of our approach:
\begin{itemize}
\item(A) We can redirect mutually recursive nested classes by redirecting them all at the same time, and
if a partial mapping is provided, the system is able to infer the complete mapping.

\item(B) \Q@Box@ and \Q@Elem@ are just normal nested classes inside of \Q@trait@; indeed
any nested class can be redirected away.
In case any of their (static) methods was implemented, the implementation is just discarded.
In most other approaches, abstract/associated/generic types are special and have some restriction;
for example, in Java/Scala static methods and constructors can not be invoked on generic/associated types.
With redirect, they are just normal nested classes, so there are no special restrictions on how they can be used.
In our example, note how \Q@merge@ calls \Q@new Box(..)@.

\item(C) 
While our example language is nominally typed, 
nested classes are redirected over types satisfying the same structural shape.
We will show how this offers some advantages of both nominal and structural typing.

\end{itemize}

A variation of redirect, able to only redirect a single nested class, was already presented in literature.
While points (B) and (C) already applies to such redirect,
we will show how supporting (A) greatly improve their value.

The formal core of our work is in defining 
\begin{itemize}
\item \Q@ValidRedirect@, a computable predicate telling if a mapping respect the structural shapes and
nominal subtype relations.
\item \Q@ChoseRedirect@, an algorithm expanding a partial mapping into a complete one.
\item And more importantly a formal definition of what properties we expect
a good expanding procedure should respect, and we prove our \Q@ChoseRedirect@
respect those properties.
\end{itemize}

After formally defining our map expander, we show that such a feature can be very useful,
by showing how 
may interesting examples of generics and associated types can be encoded with redirect, and as
an extreme application,
a whole library can be adapted to be injected in a different environment.

%In Java, we would need much more complex code:
%  
%(ds x = e)
%I1 I2
%A< I1,I2
%B< I1,I2
%
%return A
%return B
%
%
%g={
% NL:{}
% EL:{}
% Node={constructor(NL label)
%    }
%    Node={implements Tree
%      //fields are implicitly declared as the constructor parameters
%      constructor(L label,Tree left, Tree right)
%      method Void accept(Visitor v){v.acceptNode(this);}
%    }
%
%  
%
%
%//Node=Data<>< class(Tree){}
%
%  tree={
%    L:{}
%    Visitor:{interface
%      method Void visitNode(Node n)
%      method Void visitLeaf(Leaf n)
%    }
%    Tree={interface      
%      method Void accept(Visitor v)
%    }
%    Node={implements Tree
%      //fields are implicitly declared as the constructor parameters
%      constructor(L label,Tree left, Tree right)
%      method Void accept(Visitor v){v.acceptNode(this);}
%    }
%    Leaf={implements Tree
%      constructor(L label)
%      method Void accept(Visitor v){v.acceptLeaf(this);}
%    }
%  }
%  treeToS=tree<+{
%      L:{method String toString()}
%      method String 
%      method Tree merge(Tree a, Tree b){
%        if(a instanceof Leaf &&
%        }
%    }
%    MyA={ method MyB m()= new MyB(); ..}
%    MyB={ method String f()="Hello"; ..}
%    g<A=MyA>//instantiation. The mapping A=MyA,B=MyB
%
%
%I A B
%I{ C visit(I,V) C accept(A) C accept(B)}
%A{ 
%  C visit(I that,V v) that.acceptA(this,v)
%  C accept(A that,v) new AA(this,that).visit(v)
%  C accept(B) new BB()
%}
%PreVisitor
%Visitor AA AB BA BB




Features:
Structural based generics embedded in a nominal type system.
Code is Nominal, Reuse is Structural.
Static methods support for generics, so generics are not just a trik to make the type system happy but actually
change the behaviour
Subsume associate types.
After the fact generics; redirect is like mixins for generics
Mapping is inferred-> very large maps are possible -> application to libraries


In literature, in addition to conventional Java style F-bound polymorphism, there is
another way to obtain generics: to use associated types (to specify generic paramaters) and inheritence (to instantiate the paramaters).
However, when parametrizing multiple types, the user to specify the full mapping.
For example in Java
    interface A<B>{ B m(); }
    inteface B{String f();}
    class G<TA extends A<TB>, TB>{//TA and TB explicitly listed
      String g(TA a TB b){return a.m().f();}
    }
    class MyA implements A<MyB>{..}
    class MyB implements B {..}
    G<MyA,MyB>//instantiation
Also scala offers genercs, and could encode the example in the same way, but Scala
also offers associated types, allowing to write instead....

Rust also offers generics and associated types, but also support calling static methods
over generic and associated types.

We provide here a fundational model for genericty that subsume the power
of F-bound polimorphims and  associated types.
Moreover, it allows for large sets of generic parameter instantiations to be inferred starting from a much smaller mapping.
For example, in our system we could just write
    g={
      A={ method B m()}
      B={ method String f()}
      method String g(A a B b)=a.m().f()
    }
    MyA={ method MyB m()= new MyB(); ..}
    MyB={ method String f()="Hello"; ..}
    g<A=MyA>//instantiation. The mapping A=MyA,B=MyB

We model a minimal calculus with interfaces and final classes, where implementing an interface is the only way to induce subtyping.
We will show how supporting subtyping constitute the core technical difficulty in our work, inducing ambiguity in the mappings.
As you can see, we base our generic matches the structor of the type instead of respecting a subtype requirement as in F-bound polymorphis.
We can easily encode subtype requirements by using implements:
Print=interface{ method String print();}
g={
  A:{implements Print}
  method A printMe(A a1,A a2){ if(a1.print().size()>a2.print.size()){return a1;} return a2;}
  }
MyPrint={implements Print ..}
g<A=MyPrint> //instantiation
g<A=Print> //works too


--------------
example showing ordering need to strictly improve
EI1: {interface}
EA1: {implements EI1}

EI2: {interface}
EA2: {implements EI2}

EB: {EA1 a1 EA1 a1}

{
A1: {}
A2: {}
B: {A1 a1 A2 a2}
}[B = EB] // A1 -> EI1, A2 -> EA2 a
          // A1 -> EA1, A2 -> EI2 b
          // A1 -> EA1, A2 -> EA2 c

a <=b
b <=a
c<= a,b
a <= c

\Q@hi@
\Q@Hi@
\Q@class@

$ aa \Q@hi@
\Q@Hi@
\Q@class@  qaq$
\begin{bnf}
	\production{a}{b}{c}\\
	\production{a}{b}{c}\\
	\production{a}{b}{c}\\
\end{bnf}

$\Q@}}][()]@$

$\begin{array}{l}
\inferrule[(top)]{
	a \xrightarrow[b]{} c\quad
	\forall i<3 a\vdash b:\text{OK}\\\\
	\forall i<3 a\vdash b:\text{OK}
}{
	1+2
	\rightarrow
	3
}\begin{array}{l}
a\\b\\c
\end{array}
\end{array}$