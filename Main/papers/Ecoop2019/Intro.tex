\section{Introduction}
%\begin{lstlisting}
%hi method class Foo{ bar}
%\end{lstlisting}

Associated types are a powerful form of generics, now integrated in both Scala and Rust.
They are a new kind of member, like methods fields and nested classes.
Associated types behave as 'virtual' types: they can be overridden, can be abstract and can have
a default.
However, the user has to specify those types and their concrete instantiations manually; that is, the user
have to provide a complete mapping from all virtual type to concrete instantiation.
When the number of associated types is small this poses no issue, but it hinders designs where the number of
associated types is large. In this paper we examine the possibility of completing
a partial mapping in a desirable way, so that the resulting mapping is sound and also robust with
respect to code evolution.

The core of our design is to reuse the concept of nested classes instead of relying of a new kind of member for
associated types.
An operation, call Redirect, will redirect some nested classes in some external types.
To simplify our formalization and to keep the focus on the core of our approach, we 
present our system on top of a simple 
Java like languages, with only final classes and interfaces, when code reuse is obtained by
trait composition instead of conventional inheritance. 
We rely on a simple nominal type system, where subtyping is induced only by implementing interfaces;
in our approach we can express generics without having a polymorphic type system.
To simplify the treatment of state, we consider fields to be always instance private, and
getters and setters to be automatically generated, together with a \Q@static@ method \Q@of(..)@
that would work as a standard constructor, taking the value of the fields and initializing the instance.
In this way we can focus our presentation to just (static) methods, nested classes and implements relationships.
Expanding our presentation to explicitly include visible fields, constructors and sub-classing would
make it more complicated without adding any conceptual underpinning.
In our proposed setting we could write:
\begin{lstlisting}
String=...
SBox={String inner;
  method String inner(){..}//implicit
  static method SBox of(String inner){..}}//implicit
myTtrait={
  Box={Elem inner}//implicit Box(Elem inner) and Elem inner()
  Elem={Elem concat(Elem that)}
  static method Box merge(Box b,Elem e){return Box.of(b.inner().concat(e));}
  }
Result=myTrait<Box=SBox>//equivalent to trait<Box=SBox, Elem=String>
  ...Result.merge(SBox.of("hello "), "world");//hello world
\end{lstlisting}
Here class \Q@SBox@ is just a container of \Q@String@s, and \Q@myTrait@ is code
encoding \Q@Box@es of any kind of \Q@Elem@ with a \Q@concat@ method.
By instantiating \Q@myTrait<Box=SBox>@, we can infer \Q@Elem=String@, and 
obtain the following flattened code,
where \Q@Box@ and \Q@Elem@ has been removed, and their occurrences are replaced with \Q@SBox@ and \Q@String@.
\begin{lstlisting}
Result={static method SBox merge(SBox b,String e){
  return SBox.of(b.inner().concat(e));}}
\end{lstlisting}

Note how  \Q@Result@ is a new class
that could have been written directly by the programmer,
there is no trace that it has been generated by \Q@myTrait@.
We will represent trait names with lower-case names and class/interface names with upper-case names.
Traits are just units of code reuse, and do not induce nominal types.
%This creates a parallel with generic classes, where the class name is used
%as a type generator and not as a type: it needs to take in input the 

We could have just written 
\Q@Result=myTrait<Elem=String>@, obtaining 
\begin{lstlisting}
Result={
  Box={String inner}
  static method Box merge(Box b,String e){
    return Box.of(b.inner().concat(e));}}
\end{lstlisting}
Note how in this case, class \Q@Result.Box@ would exists. Thanks to our decision of using nested classes
as associated types, the decision of what classes need to be redirected is not made when the trait is written,
but depends on the specific redirect operation.
Moreover, our redirect is not just a way to show the type system that our code is correct, but it can change 
the behaviour of code calling static methods from the redirected classes.


This example show many of the characteristics of our approach:
\begin{itemize}
\item(A) We can redirect mutually recursive nested classes by redirecting them all at the same time, and
if a partial mapping is provided, the system is able to infer the complete mapping.

\item(B) \Q@Box@ and \Q@Elem@ are just normal nested classes inside of \Q@myTrait@; indeed
any nested class can be redirected away.
In case any of their (static) methods was implemented, the implementation is just discarded.
In most other approaches, abstract/associated/generic types are special and have some restriction;
for example, in Java/Scala static methods and constructors can not be invoked on generic/associated types.
With redirect, they are just normal nested classes, so there are no special restrictions on how they can be used.
In our example, note how \Q@merge@ calls \Q@Box.of(..)@.

\item(C) 
While our example language is nominally typed, 
nested classes are redirected over types satisfying the same structural shape.
We will show how this offers some advantages of both nominal and structural typing.
\end{itemize}

A variation of redirect, able to only redirect a single nested class, was already presented in literature.
While points (B) and (C) already applies to such redirect,
we will show how supporting (A) greatly improve their value.

The formal core of our work is in defining 
\begin{itemize}
\item \Q@ValidRedirect@, a computable predicate telling if a mapping respect the structural shapes and
nominal subtype relations.
\item \Q@BestRedirect@, a formal definition of what properties a procedure 
expanding a partial mapping into a complete one should respect.
\item \Q@ChoseRedirect@, an efficient algorithm respecting those properties.
\end{itemize}

Before diving in the formal details, we show an example motivating 
that expanding the redirect map is not trivial when subtyping is took in consideration.
Consider an interface \Q@ColorPoint@ implementing \Q@Point@
and \Q@Root@, \Q@Left@, \Q@Right@ and \Q@Merge@
forming a diamond interface implementation, where method 
\Q@m@ return type is refined in \Q@Right@, and thus stay refined in
\Q@Merge@:
\begin{lstlisting}
Point=interface{ ...}
ColorPoint=interface{ implements Point ...}
Root=interface{Point m()}
Left={interface implements EA Point m()}
Right:{interface implements EA ColorPoint m()}
Merge={implements Left, Right    ColorPoint m()}
C={ Merge bind()}
\end{lstlisting}
Trait \Q@t@ contains
 \Q@Target@ with a method returning a \Q@Result@,
that implements an interface \Q@I@ with a method returning a 
\Q@ColorPoint@.
We include an abstract method method 
\Q@show@ reporting in its signature 
\Q@Target@, \Q@Result@ and \Q@I@, so we can see where are they
redirected to.
\begin{lstlisting}
t={
  I=interface{ColorPoint m()}
  Result=interface{implements I    ColorPoint m()}
  Target={Result bind()}
  Target show(Result r, I i)
  }
Res=t<Target=C>
\end{lstlisting}
The big question is, what is the complete mapping inferred
from \Q@t<Target=C>@?
Naively, if \Q@Target=C@, since both \Q@Target@ and \Q@C@
have a method \Q@bind@, we could connect their result types: \Q@Result=Merge@.
This is not acceptable, since \Q@Result@ is an interface while \Q@Merge@ is not, and more (possibly private)
members inside \Q@t@ may be currently implementing \Q@Result@, even if such members are not present now,
it would be reasonable if they was added in the future, and we want our inferred map to be stable to such
additions. Note however that is safe to redirect result to any interface implemented by \Q@Merge@,
Thus we have tree possibilities:\Q@Left@, \Q@Right@ and indirectly \Q@Root@.
The only possibility is \Q@Result=Right@, since the method \Q@m@ need to
return a \Q@ColorPoint@.
However, \Q@Result@ implements \Q@I@, so also \Q@I@ need to be redirected, but to what?
all possible supertypes of \Q@Right@ are a possible option, so in this case \Q@Root@ and \Q@Right@ itself.
The only option here is \Q@Right@, again method \Q@m@ need to
return a \Q@ColorPoint@.
Thus, the final mapping is \Q@Target=C,Result=Right,I=Right@ and the flattening result would be
\Q@Res={C show(Right r, Right i)}@.

We first formally define our core language, then we define our redirect operator and
its formal properties.
Finally we motivate our model showing
how many interesting examples of generics and associated types can be encoded with redirect. Finally, as
an extreme application,
we show how a whole library can be adapted to be injected in a different environment.



%In Java, we would need much more complex code:
%  
%(ds x = e)
%I1 I2
%A< I1,I2
%B< I1,I2
%
%return A
%return B
%
%
%g={
% NL:{}
% EL:{}
% Node={constructor(NL label)
%    }
%    Node={implements Tree
%      //fields are implicitly declared as the constructor parameters
%      constructor(L label,Tree left, Tree right)
%      method Void accept(Visitor v){v.acceptNode(this);}
%    }
%
%  
%
%
%//Node=Data<>< class(Tree){}
%
%  tree={
%    L:{}
%    Visitor:{interface
%      method Void visitNode(Node n)
%      method Void visitLeaf(Leaf n)
%    }
%    Tree={interface      
%      method Void accept(Visitor v)
%    }
%    Node={implements Tree
%      //fields are implicitly declared as the constructor parameters
%      constructor(L label,Tree left, Tree right)
%      method Void accept(Visitor v){v.acceptNode(this);}
%    }
%    Leaf={implements Tree
%      constructor(L label)
%      method Void accept(Visitor v){v.acceptLeaf(this);}
%    }
%  }
%  treeToS=tree<+{
%      L:{method String toString()}
%      method String 
%      method Tree merge(Tree a, Tree b){
%        if(a instanceof Leaf &&
%        }
%    }
%    MyA={ method MyB m()= new MyB(); ..}
%    MyB={ method String f()="Hello"; ..}
%    g<A=MyA>//instantiation. The mapping A=MyA,B=MyB
%
%
%I A B
%I{ C visit(I,V) C accept(A) C accept(B)}
%A{ 
%  C visit(I that,V v) that.acceptA(this,v)
%  C accept(A that,v) new AA(this,that).visit(v)
%  C accept(B) new BB()
%}
%PreVisitor
%Visitor AA AB BA BB


