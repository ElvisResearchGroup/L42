% Definitions for the syntactic forms of our language, where relavent
\usepackage{xspace}

\makeatletter

% A nice questionmark
\newcommand{\@code}[1]{\ensuremath{#1}}
\newcommand{\q}{\ensuremath{?}}
\newcommand{\Empty}{\ensuremath{\epsilon}}
\newcommand{\rp}[1]{\Q{(}\!#1\Q{)}}
\newcommand{\cp}[1]{\,\Q{\{}\!\,#1\,\Q{\}}\!}
\newcommand{\eq}[1]{\,\Q{=}#1}
\newcommand{\ddd}{\ensuremath{{}\mathrel{\ldots}{}}}

%%%% Grammar forms

\newcommand{\prog}[2]{\@code{#1\Q{;}#2}}
	\newcommand{\@meth}[5]{\@code{#1#2\ #3\rp{#4}#5}}

% Methods: any, static, instance, abstract, abstract instance, abstract static
\newcommand{\meth}  [4]{\@meth{\Q{static}\q\,}{#1}{#2}{#3}{\ #4}}
\newcommand{\smeth} [4]{\@meth{\Q{static}\,}  {#1}{#2}{#3}{\ #4}}
\newcommand{\imeth} [4]{\@meth{}              {#1}{#2}{#3}{\ #4}}
\newcommand{\ameth} [4]{\@meth{\Q{static}\q\,}{#1}{#2}{#3}{}}
\newcommand{\asmeth}[4]{\@meth{\Q{static}\,}  {#1}{#2}{#3}{}}
\newcommand{\aimeth}[4]{\@meth{}              {#1}{#2}{#3}{}}

% Nested class
\newcommand{\ncd}[2]{\tld{\Q{private}\q\,#1}{#2}}
% T Top level declaration
\newcommand{\tld}[2]{\@code{#1\,\,\Q{=}\!\,\,#2}}

% Class literals
\newcommand{\clit}[3]{\@code{\cp{#1\Q{;}\ #2\Q{;}\ #3}}}
	
	%\@code{\ensuremath{\Q@\{@#1\Q{;}\ #2\Q{;}\ #3\,\Q@\}@\!}}}

% Thisn.Cs, Cs (the latter has dots!)
\newcommand{\This}[1]{\ensuremath{\Q!This!_{\@code{#1}}}\@nextpath}
\newcommand{\Cs}[1]{#1\@nextpath}
	\newcommand{\@nextpath}{\@ifnextchar\bgroup{\@gobblenextpath}{\xspace}}
	\newcommand{\@gobblenextpath}[1]{\Q!.!\@code{#1}\@ifnextchar\bgroup{\@gobblenextpath}{\xspace}}

% The sum operator
\newcommand{\summ}[2]{\@code{#1\ \Q{<+}\ #2}}

% Redirect operator, and redirect map
\newcommand{\red}[1]{\@code{#1}\,\Q!<!\!\,\@nextCsP{\,\Q!>!}}
\newcommand{\redm}{\@nextCsP{}}
	\newcommand{\@nextCsP}[1]{\@ifnextchar\bgroup{\@gobblenextCs{#1}}{#1}}
	\newcommand{\@gobblenextCs}[2]{\@code{#2}\@ifnextchar\bgroup{\Q!\ =\ !\@gobblenextP{#1}}{#1\xspace}}
	\newcommand{\@gobblenextP}[2]{\@code{#2}\@ifnextchar\bgroup{\Q!,\ !\@gobblenextCs{#1}}{#1\xspace}}

% new expression, field access expressions, method call expression\
\newcommand{\en}[2]{\@code{\Q{new}\ #1\rp{#2}}}
\newcommand{\ef}[2]{\@code{#1\Q{.}#2}}
\newcommand{\ec}[3]{\ef{#1}{#2\rp{#3}}}
	

% Because mathmode puts too much space
\newcommand{\DVz}{\ensuremath{\mathit{DVz}}}
\newcommand{\Id}{\ensuremath{\mathit{Id}}}
\newcommand{\Mz}{\ensuremath{\mathit{Mz}}}
\newcommand{\Tx}{\ensuremath{\mathit{Tx}}}
\newcommand{\Tz}{\ensuremath{\mathit{Tz}}}
\newcommand{\Txs}{\ensuremath{\mathit{Txs}}}

% Meta-notation
\newcommand{\op}[2]{{\ensuremath{{}_{.\textbf{#1}({#2})}}}}
\newcommand{\fop}[2]{{\ensuremath{\footnotesize{\textbf{#1}}({#2})}}}


% Environemnts

\newenvironment{defs}{\setlength{\tabcolsep}{0pt}\noindent\tabularx{\textwidth}{l>{\hfill}X}\midrule}{\endtabularx\\% This is stupid (if I put a \midrule before the \endtabularx it tries to duplicate it and I get errors...)
	\begin{tabularx}{\textwidth}{X}\midrule\end{tabularx}}
\newcommand{\defi}[3]{\ensuremath{#1\coloneqq#2}&\llap{\text{#3}}\\}
\newcommand{\defic}[2]{\ensuremath{\quad\quad#1}&\llap{\text{#2}}\\}

\newcommand{\defiSep}{\midrule}

% operators

\newcommand{\members}[1]{\fop{members}{#1}}
\newcommand{\idd}[1]{\fop{id}{#1}}
\newcommand{\dom}[1]{\fop{dom}{#1}}
\newcommand{\mdom}[1]{\fop{mdom}{#1}}
\newcommand{\mini}[2]{#1\op{min}{#2}}
\newcommand{\from}[2]{#1\op{from}{#2}}
\newcommand{\fromj}[3]{#1\op{from}{#2,#3}}

% Just to typset some words nicecly
\newcommand{\where}{,\quad\text{where }}
\newcommand{\wwhere}{\text{where }}
\newcommand{\otherwise}{,\quad\text{otherwise}}
\makeatother