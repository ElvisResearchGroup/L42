\section{Formal} 
\begin{bnf}
\production{%
id}     {t \mmid{} C}                                                      {}\\\production{%
T}      {\Q{This}n\Q{.}Cs}                                                 {}\\\production{%
CD}     {C\eq{}E}                                                          {class declaration}\\\production{%
CV}     {C\eq{}LV}                                                         {evaluated class declaration}\\\production{%
D}      {id\eq{}E}                                                         {declaration}\\\production{%
DL}     {id\eq{}L}                                                         {partially-evaluated-declaration}\\\production{%
DV}     {id\eq{}LV}                                                       {evaluated-declaration}\\\production{%
L}      {\libi{Tz}{amtz}{}\ \ \mmid{}\ \ \libc{Tz}{Ms}{K$?$}}        {literal}\\\production{%
LV}     {\libi{Tz}{amtz}{}\ \ \mmid{}\ \ \libc{Tz}{MVs}{K$?$}}       {literal value}\\\production{%
amt}    {T m\rp{Txs}}                                                      {abstract method}\\\production{%
mt}     {T m\rp{Txs} e$?$}                                                 {method}\\\production{%
Tx}     {T x}                                                              {paramater-declaration}\\\production{%
M}      {CD \mmid{} mt}                                                    {member}\\\production{%
MV}     {CV \mmid{} mt}                                                    {}\\\production{%
Mid}    {C \mmid{} m}                                                      {member-id}\\\production{%
K}      {\Q{constructor}\rp{Txs}}                                          {constructor}\\\production{%
e}      {x \mmid{} e\Q{.}m\rp{es} \mmid{} e\Q{.}x \mmid{} \Q{new} T\rp{es}}{expression}\\\production{%
E}      {L \mmid{} t \mmid{} \summ{E}{E} \mmid{} \red{E}{Cs}{T}}           {library-expression}\\\production{%
\ctx{V}}{\hole \mmid{}  \summ{\ctx{V}}{E} %
                \mmid{}  \summ{LV}{\ctx{V}} \mmid{} \red{\ctx{V}}{Cs}{T}}  {context of library-evaluation}\\\production{%
\ctx{v}}{\hole \mmid{}  \ctx{v}\Q{.}m\rp{es} \mmid{}  v\Q{.}m\rp{vs \ctx{v} es} %
	\mmid{}  \ctx{v}\Q{.}x \mmid{}  \Q{new} T\rp{vs \ctx{v} es}}           {}\\\production{%
v}      {\Q{new} T\rp{vs}}                                                 {}\\\production{%
p}      {DLs\Q{;} DVs}                                                     {program}\\\production{%
S}      {Ds e}                                                             {source code}
\end{bnf}
\\

\noindent To look up the value of a type in the program we will use the notation $p(T)$, which is defined by the following, but only if the RHS denotes an $LV$:
\begin{defye}%
\defya{(; \_, C\eq{}L, \_)&(\This{0}{C}{Cs})}{L(Cs)}%
\defya{(id\eq{}L, \_)&(\This{0}{Cs})}{L(Cs)}%
\defya{(; \_, C\eq{}L, p)&(\This{n+1}{Cs})}{p(\This{n}{Cs})}%
\end{defye}

\noindent To get the relative value of a trait, we define $p[t]$:
\begin{defye}%
\defy{(DLS; \_, t\eq{LV},\_)[t]}{\from{LV}{\This{\#DLs}}}%
\end{defye}

\noindent To get a the value of a literal, in a way that can be understand from the current location (\This{0}), we define:
\begin{defye}%
	\defy{p[T]}{\from{p(T)}{T}}%
\end{defye}

\noindent And a few simple auxiliary definitions:
\begin{defye}%
	\defy{\s{T} \in p}{\forall T \in \s{T} \bullet p(T) \text{ is defined}}%
	\defy{L({\emptyset})}{L}%
	\defy{L(\Cs{C}{\s{C}})}{L(Cs) \text{ where } L = \lib{\_}{\_, C\eq{L}, \_}{\_}}%
	\defy{L[C\eq{E'}]}{\lib{Tz}{\s{MV}\ C\eq{E'}\ \s{M}}{K?}}
	\defyc{\text{where } L = \lib{Tz}{\s{MV}\ C\eq{\_}\ \s{M}}{K?}}
\end{defye}

\newpage

\begin{comment}
Define p(P) = LV
-----------------------------------


p.exists(Ps) iff forall P in Ps: p(P) is defined

Define L(Cs) = L
--------------------------------------
L(empty) = L
L(C.Cs) = L(Cs)
    L = interface? {_; _, C = L, _; _}

Define L[CD]=L'
---------------------------------------------
L[C = E'] = interface? {Tz; MVs C = E' Ms; K?}
  L = interface? {Tz; MVs C = _ Ms; K?}


Define operations on p
--------------------------------------
p.evilPush(L) = (C = L, p)
	for fresh C

p.push(id) = (id = L, p)
    p = (id' = {_;_, id = L, _ ;_}, _; Ds)

(id = L, p).pop() = p
(id = L, p).top() = L

Define equivy ops...
------------------------------
empty =p empty
P, Ps =p P', Ps' iff:
	p.minimize(P) = p.minimize(P')
	Ps =p Ps'

Pz subseteq_p Pz' iff:
	p.minimize(Pz) subseteq p.minimize(Pz')

p.minimize(empty) = empty
p.minimize(P, Pz) = p.minimize(P), p.minimize(Pz)

p.minimize(Thisn+1.idn.Cs) = p.minimize(Thisn.Cs):
  p = id0 = L0, ..., idn = Ln, _; Ds
  p(Thisn.Cs) = L
  // TODO: Check that Ln is an L instead?
otherwise p.minimize(P) = P

define dom(Mz) = Midz
===========================================
dom(empty) = empty
dom(C = E, Mz) = C, dom(Mz)
dom(T m(Txs), Mz) = m, dom(Mz)
\end{comment}