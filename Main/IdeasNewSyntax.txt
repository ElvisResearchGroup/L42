Isaac note:
When generating code for trowing exceptions,
if you are in a catch, you could use the catched exception as a cause to provide more info for debugging.

Syntax changes:
* with->for and no more typecase in the with.

* IF::= if tMatch+ e? WB (else (IF|WB))?
  tMatch::= T x | T x=e
  WB::= (..) | {..} | throw e | loop e |  ??void??

*Block with catching:
( Decs1 Ks1 Decs2 e) stay the same, but
( Decs1 Ks1 Decs2 Ks2 e) is disallowed, and the user have to write
( Decs1 Ks1 (Decs2 Ks2 e)) instead. This makes much more clear the flow of catching.

*wops A,B,C will retrow errors/exceptions A B C as errors but adding an empty lib for the Position:
Marco still like it.

Parenthesis reduction proposal:
  Term ::= Block | throw e | loop e | void
  Block ::= (...) | { ... }
  K::= if e | while e | catch T x | for (x in e)s | if c e else | loop

  K e1 e2 is not well formed if neither e1 or e2 are Term.
  additionally, if e e1 needs e1 to be not an 'ifelse', and if e e1 else e2
  needs e1 not to be an 'if'
  Note: it is ok for "K e1)" or "K e1}"


Reducing voids?
( bla() catch T x e1) ==> ( bla() catch T x e1 void)
//?may be? ( bla() catch T x) ==> ( bla() catch T x (void))?
// no since is good to be explicit on silenting exceptions


Debug&&X[]

e0&&e1
==>
e0 && e1
(x=e0 (x.#if#and().#checkTrue() catch exception Void unused (x.#else#and()) x & e1))
similarly for ||


if e0 e1 else e2
==>
  (x=e0 if x e1 else e2)
if x e1 else e2
==>
(Void fresh=x.#if().#checkTrue()
 catch exception Void fresh2 (e2)
 e1
)


arg::=e? (x:e)s
e[args] ==> e.#square[args]

e.m[arg1;..argn]
==>
(x=e
x.m(sqBuilder:(
  b=x.sqBuilder()
  ?#add(sqBuilder:b,arg'1)
  ..
  ?#add(sqBuilder:b,arg'n)
  b
)))
where arg'i=argi["\"=b, "\foo"=b.foo()]



Note, there is no need of new sugar for
e[for...]
since 'for ..' is an expression returning void, and
we can just have the builder offering a method
method Void add1(Void that)void


'refine? method T m(Txs) e?'
become
'refine? method T m(Txs); | refine? method T m(Txs)=e; | '

mb ::= ; | : blockcontents ;


1  class { }
2  () :return; class {}
3  () :return; {}
4  {return} eats =  x=e or x '={' }



{ds ks}

{ds ks e?}

Isaacs ideas:
	de ::= d | e
	(ds e de des' ks)==>( ds Void x = e de des' ks)
	(ds e k ks') ==> (ds x = e k ks' x)
	(ds ks) ==> (ds ks void)
For curleys: No extra well-formedness or type rules
	//{des ks} ==> (Void unused=(des ks) catch return x (x) unreachable)
	{des ks e?} ==> ((des ks e?) catch return x (x))


	(ds e ks)
	(ds y = e ks y)

(ds y = e ks y) expected Y
then e expected Y

dsT?  dsT




	T z=(y=(ds ks e) catch return x (x:T) y:T)

	T z=(y=(return T()) catch return x (x:T) y:T)

	(ds e ks)
	(ds x = e ks x) // e happens to have type void
	(ds Void x = e ks void)


T x={
  if a return A
  B
  catch error X x C
  }
T x = {
	if c return T()
	return T()
    }

T x =if c T() else T() //should this work? should we keep it working?


// loop B : T // for all T





---------------------------
DoIt: FileAction <>< {
    //class method T (mut File f)={..f.read()..}
    class method T #$(no mut, lent, Strings fileNames) = {
        FD fd = FilePlugin.#$openFd(fileName)
           (
            mut File f=File.#$(fd)
            T res=This(f)
            fd.#$close()
            return res
            )
        catch error Any x (   fd.#$close(),   error x  )
       }
    class method T #$(no mut, lent) = {
        OpenerID fId = FilePlugin.#$openerID()
            (
            mut FileOpener f=fId.#$()
            T res=This(f)
            fId.#$close()
            return res
            )
        catch error Any x (   fId.#$close(),   error x  )
       }
   }

  f.openFile(S)->mut File

  DoIf(FilePath)->T



  FileAction<><{
    class method T (mut Files fs)={
      with f in fs (..)
      }
    }

--------------------------------------------------------------------
    c1=input1.iterator();...cn=inputn.iterator();//varIterator if var x in..
    {int i=0;
    while(
      c1.hasElem(i) &&..&& c1.hasElem(i) //hasElem==hasNext
      && ( c1.incomplete(i) ||..||cn.incomplete(i))
      ){
      E1 e1=c1.get(i);..En en=cn.get(i);//get==next
      {..
      e3:=e // e3:=c3.update(i,e)
      ..}
      i+=1;
      }
      c1.close(i);..cn.close(i);
    }
-----------------------------------------
what happens with modifiers
imm of imm/class
mut of imm/class
fix of mut   //#get()??
mut of mut   //#get()??
read of read
read of imm/class

####vector<mdf E> // mdf == Mut | Imm
V:read method read I iterator()
V:mut method mut UI varIterator()
V:mut method mut V# #exposer() // only mdf == mut
V#:mut method mut I# iterator() // only mdf == mut
V#:mut method mut UI# #varIter()

I,UI,I#,UI#: read method Bool hasElem(Size i) =  i < this.size()
I,UI,I#,UI#: read method Bool incomplete(Size) = true

I,UI:read method read E get(Size) mdf==mut
I,UI:read method      E get(Size) mdf==imm
I#,UI#:mut method  mut E get(Size) mdf==mut

I,UI,I#,UI#: read method Void close(Size i) = if i<this.size() (error X"")
UI,UI#: mut method mut E update(Size, mut E)  mdf==mut
UI,UI#: mut method     E update(Size,     E)  mdf==imm




on arrays based this is faster on more then 1 collection at the time
and semantic is very intuitive in corner cases

on linked or sparsed collections
  -copy on array before iterating
  -slow and complex with interna reset wrapper




  mut list of imm
  mut list of mut
  imm list imm/mut imm

  mut list of mut
  mut list of imm

  List:{interface
    behave like a mut list of mut
    LMut:{}
    LImm:{}
    //---
    Fix list:{}
    Sublist:{}
  }


Vector: {
    Elem:{}
    read method      Size size()
    read method read Elem  get(Size that)
  Mut: {implements Vector
      read method      Size size()=..
      read method read Elem  get(Size that)=..
       mut method  mut Elem #get(Size that)=..
       mut method      Void  set(Size that, mut Elem val)=..
  }
  Imm: { implement Vector
      refine read method      Size size()=..
      refine read method      Elem  get(Size that)=..
      //refine  mut method      Void  set(Size that,mut Elem val)
      refine  mut method      Void  setImm(Size that,Elem val)=...
  }
}

mut Vector.Mut
mut Vector.Imm
read Vector.Imm
read Vector
imm Vector

imm VectorMut
mut VectorMut
read VectorMut


{
header
Ms
}

{
[Opt,T,34]
methods foo() =this.bar_$_34()
}


ArrayBase: { class method Library gen(Size n) use ArrayGenerator() }
/*
ClassB ArrayGenerator()
{
    // @generator ArrayGenerator(3, Size, 1000)

    return new ClassB {
        sum(ClassB b) { // Does the sum intelligently! }
        redirect() { ... }
    }
}

*/

Array: {
    class method Library gen(Size n) {
        OptUse(ArrayBase(n)) <>< {
            T: {}
            T get(Size index)
            // other public methods
        }
}


A: UsePrivateSate[OptT <>< Any] <> {
    method Void foo() this.get()
}

A: {
    // @optimizer ArrayC
    Any get_$_34()
}

{
[Array, T,Size 128]
}