(Integrated) Metaprogramming and 42

Integrated metaprogramming is when you can generate code
and compile it/run it without manually import 
the generated code in a new program, this include both
compile time and run time metaprogramming, but excludes
external tools/other languages that generate code for later
reuse.   
 
Here we summarize multiple metaprogramming approaches and we 
conclude with the approach of 42 and its balance between gurantees and expressivity

strings
citations:
general workflow: 
  imput->string->eval:
    can fail syntax, type checking, run time
    
   
--------------------
Big General issue:
//NOTE:(first idea, revised after good sleep) TODO: if Size was still undefined, it should not compile
//ADD in normalization to collect as used path to normalize all @P in all comment in eC
//otherwise compilation may introduce compile errors in formerly ok classes
Revised Idea:
comments can contain any @Foo in C: e<<{/* @Foo */} exactly as 
any P is accepted, (even if is mispelled, since is not typed yet)
however, if @Foo (Or a part of a method type) does not exist/not exist yet
introspection will not return a type object for it..
now, what
A:Data<<{B f}
B:Data<<{A f}
should generated?
should we assume B to have == while we generate A?
we "can", since A is not typable, on this way we need an operator that do a redirect from a Doc /*@B*/ ?
looks very fishy, and not very 42ish since we would get the error after the generation
of B, too late to do an "if/catch" around Data<<{B f}.
For example Collections do such "if/catch" to see if == is there

currently available fix:
  Refactor.renamePath(\"A.B" to:\"B")<<{
  A:Data<<{B f  B:Data<<{}}
  B:Data<<{A f}
  ..
  //does not work if here there is something using A/B for metaprogramming, as in
  Foo:A<<{}
  }
Thus, mutually recursive Datas can not be used for metaprogramming
in their scope.. is that bad?
If we accept this pattern as not too bad,
do we still need 
Person:Foo<<{ Persons friends}//can not be Data anyway..
Persons:Collections.vector(of:Person)
 

//TODO:(this still stand) in typing, a class is well typed only if all @P exists

42: Attemping a to reconciliate 2 main trends in Metaprogramming

*Metaprogramming need to support (type) circular datatypes.
Those happens everywhere:
A very simple example, in the contex of a pure OO language,
a String should know his Int lenght(),
and a Int should be able to produce a String toS() representation
of itself.

*Metaprogramming in the functional setting is often seen as a way to
generate the behaviour of a function, knowing his type.
In OO setting, or in general when working with complex datatypes,
metaprogramming is very useful as a way to generate/complete/improve
the "shape" of such datatypes (see F# type providers).

On this line we consider a kind of metaprogramming were
C:e
is a class/datatype name and e is a metaprogramming (closed) expression
that, when executed will produce the datatype.
The shape of the generated datatype is decided by the expression behaviour,
not just by its type:
a type system on the line of MetaML would attempt to
type e as Class<Int m(); String foo()>
This approach requires the type of the result to be encoded in
the expression at the type level.
This disallow the very useful pattern
MyData: FromXML("xml data")//could be JSon or any other data format, including a DB
Where either the shape of the data is used to infer its type
or the data contains its schema (as in a database).

Problems tipical of circular initialization of values are lifted
as problems of circular generation of classes:
For example
A:{B toB() int size()}
B:{A toA() int size()}
is normal -relaxing- looking code with circularity of the type level
While
A:if hasMethodSize(B) then {B toB() int size()} else {B toB()} 
B:if hasMethodSize(A) then {A toA() int size()} else {A toA()}
seams broken code, at least as much as
a=b+1
b=a+1

To make a concrete example,
A:IfFieldsEqualsAddEquals({ Num num; B b;}) //two fields num and b
B:IfFieldsEqualsAddEquals({ Num num; A a;})
IfFieldsEqualsAddEquals should add an equals method that
propagate the check to its fields, but only if all the fields
have an equals method.
What should happens here? should we add equals to both A and B
or to none of the two?  


