(using s instead of overbar, so cs::=c1..cn)
e::=.... |L
L::={implements Pis M1..Mn}
M::=ms e |refine mh eOpt| mh eOpt | C:e
Pi::= This^n.Cs
p::=L1...Ln //representing This0,This1,...,Thisn
Normalization will be called before type checking:
when we today we do
e -p->* _  (metaprogramming)
We will do:
(1)p'=p # Pis, e'=norm(p',e) with Pis=usedPaths_p(e)//recursive in p
(2)|-p':ok Pis, p';exception Any|-e':Library //all exceptions allowed 
(3)e'-p'->*L 
or 
(4)e'-p'->* error/exception v

Step 1 is the new one
usedPaths_p(e) already defined
define # and norm

define #
-p#Pis=p#Csss, where Csss is  Pis organized as list of list of Cs, such that for every Csi,Csj in a Css in Csss, Csi prefix of Csj iff i=j
-p#empty=p
-p,L # csss, css=(p # csss), L'
 css=cs1..csn
 pi=p,L#csi
 Li=norm(pi,L(csi))
 L'=L[cs1=L1..csn=Ln] //replace the nested classes in paths csi with libraries Li.
 
 L#(Cs.C)=(L#Cs),L(Cs.C)
 L#empty=L
 
 define norm(p,e)=e
 
 -norm(p,*localBindingDecl*)= use resolve(p,T)=T' on scheletal types.
 -norm(p,L)=  L={implements Pis M1'...Mn'}
  L={implements Pis M1..Mn}
  L'={implements collect(p,Pis) M1...Mn}
  Mi'=norm(p L', Mi)
  -collect(p,empty)=empty
  -collect(p,Pi Pis)=Pis' if collect(p,Pis)=Pis' and Pi in Pis'
  else collect(p,Pi Pis)=Pis' U Pis''[from Pi] if collect(p,Pis)=Pis' and p(Pi)={implements Pis'' _}
  //should be just collecting or should also check for multiple declaration points for methods? how?
  //how to interpret the result as a set if we do not know the nesting?
  //should norm also normalize the paths?
  //should we let the type system check that?
  
 -norm(p,ms e)=norm(p,refine mh e) 
    p= _ {implements Pis _}
    mh= MhOf(p,Pis,ms)//here is recovering type info
    
 -norm(p,refine mh eOpt)= refine resolve(p,mh) norm(p,eOpt)
    p= _ {implements Pis _}
    mh=~= MhOf(p,Pis,ms^mh)//here check is refined well, that is all equal except return type,
    // no subtyping check on return type 
    
 -norm(p,mh eOpt)= resolve(p,mh) norm(p,eOpt)
    p= _ {implements Pis _}
    undefined MhOf(p,Pis,ms^mh)//check is not an implemented method
 
 -norm(p, C:e) =C:norm(p,e)//assume we can cache if e is already normalized and avoiding repeating
 
 -MhOf(p,Pis,ms)=mh[from Pi]
   exists unique Pi in Pis such that
     p(Pi)=L, L(ms)=mh//not sure is matematically ok...