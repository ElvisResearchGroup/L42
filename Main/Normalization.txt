ASCII rendering of horizontal bar notation:
Letters i,j,k,m,n are integers;
usually indices into sequences or length of sequences
U is the set union,
\ is the set subtraction
we use "and" "or" "disjoint" and "intersection" as words.
"empty" is the emptyset/sequence etc.

using s instead of overbar, so Cs::=C1..Cn
-->p is p under the arrow
a^i is a apex i, ai is a pedex i
[] is the hole/square

in latex we use two different fonts for "(" of the grammar and for
"(" used for disambiguation. here we just hope is clear :/

General Notations:

When a term of the grammar can be accessed with functional notation,
as in a(b), then dom(a) is {b | a(b) is defined}

DOT NOTATION b.a extract the element of form a from b, for example (C:e1).e=e1
More precise: a term of a grammar is a tree of nodes and terminals.
The root-most node of "b" that can be represented with the metavariable "a"
is produced.  

a[with b=b1] replace the element of form b in a with a new b,
so that (a[with b=b1]).b = b1

a[b=c2] when b in dom(a), a(b)=c1 modify a so that a(b)=c2
 

----------------------------
Core language grammar
e::=.... |L //pg1 start of https://github.com/ElvisResearchGroup/L42Docs/blob/master/Formal/Formal.pdf
L::={interface? implements Ps M1..Mn}
M::=ms e |refine mh e?| mh e? | C:e
Ldom::=ms|C
P::= Thisn.Cs //is pronounced "Path"
T::= mdf P | P::mss| P::mss::x

LC::={implements Ps MC1..MCn}  //library compiled
MC::=refine mh eC?| mh eC? | C:LC
eC::=.... |LC
TC::=mdf P// used in eC, MC and LC, and all P normalized w.r.t. a program
r::=LC| exception v | error v

ctxC::=[] | eC.m( (x=eC)s x=ctxC, (x=e)s)| .... // compilation context, e=ctxC[L] selects an L where all the former Ls are LC. The context do not enter in libraries
ctxL::= {interface? MCs ctxM Ms}
ctxM::= C: ctxC |ms ctxC | refine? mh ctxC

//notice how every LC is a special kind of L (barnotation has structural subtyping)
---------
We define functional notation for
L, ctxL and LC (over Ldom domain),
VarEnv (var names)


operations on contexts (for implementation too)
 - L-ctxL=L' if L=ctxL[L']
 - L/ctxL=(ctxL', L')  intuition: if L=ctxL'[L'], ctxL sim ctxL'
   definition (for the special case we need):
   {interface? MC1..MCn M M1..Mk}/{interface? MC1'..MCn' ctxM M1'..Mk'}
   = {interface? MC1..MCn ctxM M1..Mk}, L
    with M-ctxM=L (the Thisn path is never used, so does not change)



-----------
type environment:
VarEnv::=(x:T)s

program grammar

p::=L0;ctxLs //representing This0,...,Thisn

program operations primitive:
-pop
 (L,ctxL,ctxLs).pop()=ctxL[L],ctxLs

-push
 (ctxL[L],ctxLs).push(ctxL,L)=L,ctxL,ctxLs
 
-update top //this is the only one that can detect evilPush
 (L,ctxLs).update(L')=L',ctxLs

-get(n)
 (L,_).get(0)=L
 p.get(n+1)=p.pop().get(n)


- p.equiv(P,P') //ok also this one can be messed up by evilPush
  p.equiv(P,P) holds
  p.equiv(P,P')=p.equiv(P',P)
  p.equiv(This(n+1).C.Cs,P)=p.equiv(Thisn.Cs,P)
   if p=L,ctxL1...ctxL(n+1) _ and ctxL(n+1)(C)=[]
program derived operations:

-push(C)
 p.push(C)=p.push(ctxL,L)
 with ctxL[L]=p.top() and ctxL(C)=[]

-push(L)//non determinism is not relevant if update is not used
 p.push(L)=p.push(ctxL,L)//an evilPush can exist in implementation
 with ctxL[L]=p.top()
 //with p'=p.evilPush(L)   p'.top()==L, p'.pop()==p, p'.update(..) error! 

-top
 p.top()=p.get(0)

-navigate(Cs)
 p.navigate(C1..Ck)=p.push(C1)...push(Ck)

-navigate(P)
 p.navigate(Thisn.Cs)=p.pop()...pop().navigate(Cs) //with n pops
-p(P)
 p(P)=p.navigate(P).top()//but some implementation could be faster
      
//Note for marco: equivalence between p and (Ln,fullP), that is all the other L0..L(n-1) are cached?
//going this way would require/allow to write better CloneWthPath/Locator
//to enforce the equivalence all the time we may have an updateTop operation, that do the hard work level by level.
//p.update(L), p.pop(), p.push(fullP)/p.push(Ldom,ctxC) //currently push(L) is supported and should be removed



----------------------
ReductionTop:
at top level we have a L not of form LC
 
          eC' -->p'+ r              p.top()={_ implements Ps, MCs  C:eC Ms}
(top)------------------------       eC not of form LC
     p ==> p'.update(p'.top()[C=r]) eC'=norm(p,eC)
                                    Ps=usedPaths(p,eC')
                                    p'=p # Ps
                                    p';exception Any; empty|-eC': imm Library
                                    |-p':Ps

                                  ctxL={_ implements Ps, MCs  M[with e=ctxC] Ms}
      p.push(ctxL, L)==> p'       p.top()={_ implements Ps, MCs  M Ms}
(met)-------------------------    M not of form MC
        p ==> p'.pop()            M.e=ctxC[L], L not of form LC


                                 
                                 p.top()=L={_ implements Ps, MCs  M Ms}
(nrm)-------------------------   M not of form MC
     p ==> p.update(L[M.ms=MC])  all L inside M.e are of form LC //for M.e undefined there is no L,forall holds
                                 MC=norm(p,M)

------------------------------------------

- eC inside eC' if eC'=ctxC[eC]      

define norm(p,e)=e
 -norm(p,localBindingDeclaration)= use resolve(p,T)=T' on skeletal types
 -norm(p,L)={interface? implements collect(p',Ps) M1'...Mn'}
  p'=p.push(L)//can be repleaced by evilPush in implementation
  L={interface? implements Ps M1..Mn}
  //L'={interface? implements collect(p',Ps) M1...Mn}
  Mi'=norm(p', Mi)
  -collect(p,empty)=empty
  -collect(p,P Ps)=collect(p,Ps)=Ps' if P in Ps'
  otherwise collect(p,P Ps)=collect(p,Ps) U collect(p.navigate(P),Ps')[from P]
    if p(P)={_ implements Ps' _} 
  //should be just collecting or should also check for multiple declaration points for methods? how?
  //how to interpret the result as a set if we do not know the nesting?
  //should norm also normalize the paths?
  //should we let the type system check that?
  
 -norm(p,ms e)=norm(p,refine mh e) 
    p.top()= {_ implements Ps _}
    mh= MhOf(p,Ps,ms)//here is recovering type info
    
 -norm(p,refine mh e?)= refine resolve(p,mh) norm(p,e?)
    p.top()= {_ implements Ps _}
    mh=~= MhOf(p,Ps,mh.ms)//here check is refined well, that is all equal except return type,
    // no subtyping check on return type 
    
 -norm(p,mh e?)= resolve(p,mh) norm(p,e?)
    p.top()={_ implements Ps _}
    undefined MhOf(p,Ps,mh.ms)//check is not an implemented method
 
 -norm(p, C:e) =C:norm(p,e)//assume we can cache if e is already normalized and avoiding repeating
 
 -MhOf(p,Ps,ms)=mh[from P]
   exists unique P in Ps such that
     p(P)=L, L(ms)=mh//not sure is matematically ok...

define #

- p#Ps = p#Csss, where Csss is  Ps organized as list of list of Cs,
     such that for every Csi,Csj in a Css in Csss, Csi prefix of Csj iff i=j

- p#empty = p

- L # Cs1..Csn= (L',empty) /*a program with empty ctxLs*/
  pi = L.navigate(Csi)
  Li = norm(pi.pop(),pi.top())
  L' = L[Cs1=L1..Csn=Ln] //replace the nested classes in paths Csi with libraries Li.

- p0 # Css, Csss =p2.update(p2.top()#Css) 
 p0=_,ctxL,_// i need to see the internal repr, should we extract a new program primitive operation here?
 p1=p0.pop() # Csss 
 p2=p1.push(p1.top()/ctxL)
 //like p1.growFrom(p0) defined as p.growFrom(_,ctxL,_)==p.push(p.top()/ctxL)
     
- usedPaths(p,eC)=Ps union usedPaths(p,Csss) 
  Ps={P|P inside eC}
  Csss= reorganized Ps 

- usedPaths(p,Cs1..Csn Csss)= usedPaths(p.pop(),Csss) 
    U usedPaths(p.top(),Cs1) U ... U usedPaths(p.top(),Csn)

- usedPaths(L,Cs)=usedInner(L(Cs),Cs)

- usedInner({_ implements Ps, M1..Mn},Cs)=prefix(Cs,Ps U usedPaths(M1) U... U usedPaths(Mn))
