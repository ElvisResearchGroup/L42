-----------------------------------------------------------
Part 0: notations 
-----------------------------------------------------------
ASCII rendering of horizontal bar notation:
Letters i,j,k,m,n are integers;
usually indices into sequences or length of sequences
U is the set union,
\ is the set subtraction
we use "and" "or" "disjoint" and "intersection" as words.
"empty" is the emptyset/sequence etc.

using s instead of overbar, so Cs::=C1..Cn
-->p is p under the arrow
a^i is a apex i, ai is a pedex i
[] is the hole/square
//add tuple notation <;>
in latex we use two different fonts for "(" of the grammar and for
"(" used for disambiguation and function call. here we just hope is clear :/

General Notations:

When a term of the grammar can be accessed with functional notation,
as in a(b), then dom(a) is {b | a(b) is defined}

DOT NOTATION b.a extract the element of form a from b, for example (C:e1).e=e1
More precise: a term of a grammar is a tree of nodes and terminals.
The root-most node of "b" that can be represented with the metavariable "a"
is produced.  

a[with b=b1] replace the element of form b in a with a new b,
so that (a[with b=b1]).b = b1

a[b=c2] when b in dom(a), a(b)=c1 modify a so that a(b)=c2
 

-----------------------------------------------------------
Part 1: grammar, contexts, paths and programs
-----------------------------------------------------------
### Core language grammar
e::=.... |L //pg1 start of https://github.com/ElvisResearchGroup/L42Docs/blob/master/Formal/Formal.pdf
L::={interface? implements Ps M1..Mn}
M::=ms e |refine mh e?| mh e? | C:e
Ldom::=ms|C
P::= Thisn.Cs //is pronounced "Path"
T::= mdf P | P::msxs
msx::=ms(::x)?
LC::={implements Ps MC1..MCn}  //library compiled
MC::=refine mh eC?| mh eC? | C:LC
eC::=.... |LC
// No, compiled types are T, normalized types are only mdf P
// but normalization is a different step
r::=LC| exception v | error v

ctxC::=[] | eC.m( (x=eC)s x=ctxC, (x=e)s)| .... // compilation context, e=ctxC[L] selects an L where all the former Ls are LC. The context do not enter in libraries
ctxM::= C: ctxC |ms ctxC | refine? mh ctxC
ctxL::= {interface? implements Ps MCs ctxM Ms}

//notice how every LC is a special kind of L (barnotation has structural subtyping)
---------
We define functional notation for
L, ctxL and LC (over Ldom domain and Cs)
Moreover, for convenience we define inside in the following way:

- eC' inside eC if eC=ctxC[eC']
- P inside M holds iff P inside M.e 
 or M.mh= refine? T0 m(T1 x1..Tn xn) exception Ps
 and Ti= _ P or Ti= P::_ or P in Ps
 

-----------------------------------------------------------
###operations on contexts (for implementation too)
 -define ctxC sim ctxC
  * [] sim []
  assuming ctxC sim ctxC', then
  * ctxC.m((x:e)s) sim ctxC'.m'((x:e)s')
  * e.m(x1:e1..xn:en x:ctxC (x:e)s) sim e'.m'(x1':e1'..xn':en' x':ctxC' (x:e)s')
  * (T1 x1=e1..Tn xn=en T x=ctxC (T x=e)s e) sim (T1' x1'=e1'..Tn' xn'=en' T' x'=ctxC' (T x=e)s' e')
  * and so on        
 
 -define L/ctxL'=<ctxL; e>   intuition: if L=ctxL[e], ctxL sim ctxL'
  * {interface? implements Ps MC1..MCn C:e Ms}/{interface? implements Ps MC1'..MCn' C':ctxC' Ms'}
   = {interface? implements Ps MC1..MCn C:ctxC Ms}, e0
   e=ctcC[e0] and ctxC sim ctxC'
 
-----------------------------------------------------------
### paths
 paths::= Csss //list of set of list of C
 operations:
 -(Css paths).top()=Css
 
 -(Css paths).pop()=paths
 
 -paths.push(Css)=minimize(Css) paths
 
 -(Css paths) U (Css' paths')=(paths U paths').push(Css U Css')
 -paths U empty=empty U paths = paths
 
 -empty.prefix(_)=empty
 -paths.prefix(empty)= paths
 -(Cs1..Csn).prefix(Cs)=Cs.Cs1 .. Cs.Csn
 -(Css paths).prefix(Cs.C)= paths.prefix(Cs) U Css.prefix(Cs.C)
  //example of prefix:
  //((A)  (B)  (C)  (D)).prefix(W.E)
  // = ((W.E.A  W.B  C) (D))
  
### auxiliary paths operations:
 -reorganize(empty)=empty
 -reorganize(Ps)=Css0,...,Cssn
  Cssn!=empty
  Cssi=minimize(Cssi')
  Cs in Cssi' iff Thisi.Cs in Ps
   
 -minimize(Cs1..Csn)={Cs in Cs1..Csn | forall Csi, Csi._!=Cs}

 

-----------------------------------------------------------
### program

p::=L0;ctxLs //representing This0,...,Thisn // where This0.C refers to a class bound in L0, and (This1..ThisN).C to bindings in cxtL1..cxtLn respectively

program operations primitive:
-pop
 (L,ctxL,ctxLs).pop()=ctxL[L],ctxLs

-push
 (ctxL[L],ctxLs).push(ctxL,L)=L,ctxL,ctxLs
 
-update top //this is the only one that can detect evilPush
 (L,ctxLs).update(L')=L',ctxLs

-get(n)
 (L,_).get(0)=L
 p.get(n+1)=p.pop().get(n)


- p.equiv(P,P') //ok also this one can be messed up by evilPush
  p.equiv(P,P) holds
  p.equiv(P,P')=p.equiv(P',P)
  p.equiv(This(n+1).C.Cs,P)=p.equiv(Thisn.Cs,P)
   if p=L,ctxL1...ctxL(n+1) _ and ctxL(n+1)(C)=[]

- growFellow
  (L,ctxL,_).growFellow(p)==p.push(p.top()/ctxL)
     
program derived operations:

-top
 p.top()=p.get(0)
 
-push(C)
 p.push(C)=p.push(ctxL,L)
 where ctxL[L]=p.top() and ctxL(C)=[]

-push(L)//non determinism is not relevant if update is not used
 p.push(L)=p.push(ctxL,L)//an evilPush can exist in implementation
 with ctxL[L]=p.top()
 //with p'=p.evilPush(L)   p'.top()==L, p'.pop()==p, p'.update(..) error! 


-navigate(Cs)
 p.navigate(C1..Ck)=p.push(C1)...push(Ck)

-navigate(P)
 p.navigate(Thisn.Cs)=p.pop()...pop().navigate(Cs) //with n pops
-p(P)
 p(P)=p.navigate(P).top()//but some implementation could be faster
      
//Note for marco: equivalence between p and (Ln,fullP), that is all the other L0..L(n-1) are cached?
//going this way would require/allow to write better CloneWthPath/Locator
//to enforce the equivalence all the time we may have an updateTop operation, that do the hard work level by level.
//p.update(L), p.pop(), p.push(fullP)/p.push(Ldom,ctxC) //currently push(L) is supported and should be removed


-----------------------------------------------------------
Part 2: reduction rules and notations
-----------------------------------------------------------
depend on:
 p|-L:ok
 p|-e: imm Library
 e -->p+ r
-----------------------------------------------------------
### reduction rules
ReductionTop:
precondition: at top level we have a L not of form LC
 
          eC' -->p'+ r              p.top()={_ implements Ps0, MCs  C:eC Ms}
(top)------------------------       eC not of form LC
     p ==> p'.update(p'.top()[C=r]) eC'=norm(p,eC) //resolve skele types, add all refine, collect supertypes
                                    <paths; paths'>=usedPathsE(p,eC') //tuple notation
                                    p0=p #paths U paths'//norm the part of p required by eC'
                                    paths'|-p0:p' //the part of p' referred to by paths' is well typed
                                    p'|-toAny(paths,eC'): imm Library //replace paths with Any //eC' is well typed


        p.push(ctxL, L)==> p'       p.top()={interface? implements Ps, MCs  M Ms}
(enter)-------------------------    M not of form MC
          p ==> p'.pop()            M.e=ctxC[L], L not of form LC
                                    ctxL={interface? implements Ps, MCs  M[with e=ctxC] Ms}

------------------------------------------
###define methods(p,P)=Ms

subdefinitions:
-collect(p,empty)=empty 
  //an implementation could keep a list of visited P instead of diverging, mathematically is the same.
-collect(p,P0 Ps)=P, collect(p,Ps)\Ps', Ps' //that is,crucially: dept first but we avoid duplicates by keeping the rightmost occurence.  
  p(P0)={_ implements Ps0 _}
  Ps'=collect(p.navigate(P),Ps0)[from P0]
  //this check absence of circularity by looping
  //Note for marco: we remove circularity; update operator sum; plus add privatly implemented concept/error
  //may be a good strategy could be that 
  //"sum can not add abstract implemented methods", this enforces adding either equal hierarchies with different operators, or different hierarchies with equal operators.
  //Or we can make this kind of check happens as extra at the end of multiple sums?

maindefinition:
-methods(p,P0)=M1'..Mk'
  p(P0)={interface? implements Ps Ms} 
  P1..Pn=collect(p,Ps), error unless forall i, p(Pi) is an interface
  ms1..msk={ms|p(Pi)(ms) is defined}
  forall ms in ms1..msk, there is exactly 1 j in 0..n
    such that p(Pj)=mh e? //no refine
  Mi= p(P0)(msi) if is of form  refine? mh e?,
  otherwise
  Mi=addRefine(methods(p,Pj)(msi))
    for the smallest j in 1..k such that methods(p,Pj)(msi) of form refine? mh
  Mi'=Mi[with e?=p(P0)(msi).e?] if defined,
  otherwise
  Mi'=Mi

------------------------------------------
###define norm(p,e)=e
subdefinitions:
-resolve(p,mdf P)=mdf P
-resolve(p,P::ms)=T
  methods(p,P)(ms)=refine? _ method T ms e?
-resolve(p,P::ms::x)=T
  methods(p,P)(ms)=refine? _ method _ _( _ T x _) e? 
-resolve(p,P::msx::msxs)=resolve(p,P'::msxs) //here be carefull for possible infinite recursion 
  resolve(p,P::msx)= _ P'              
  
maindefinition:
-norm(p,localBindingDeclaration)= use resolve(p,T)=T' on skeletal types
-norm(p,L)={interface? implements Ps' norm(p',Ms') }
 L={interface? implements Ps Ms}
 p'=p.push(L)//can be repleaced by evilPush in implementation
 Ps'=collect(p',Ps)
 Ms'=methods(p',This0), {C:e in Ms} //norm now put all the nested classes in the back.
  
//norm(p,ms e) should never be call 

-norm(p,refine? mh e?)= refine? resolve(p,mh) norm(p,e?) 
    
-norm(p, C:e) =C:norm(p,e)

-norm(p,empty)=empty

------------------------------------------
### define #

- p#empty = p

- L # Cs1..Csn/*a single Css*/= (L',empty) /*a program with empty ctxLs*/
  pi = L.navigate(Csi)
  Li = norm(pi.pop(),pi.top())
  L' = L[Cs1=L1..Csn=Ln] //replace the nested classes in paths Csi with libraries Li.

- p # Css, Csss =p'.update(p'.top()#Css) 
  p'=p.growFellow(p.pop() # Csss)
   
------------------------------------------     
###define usedPathsE
- usedPathsE(p,eC)=<reorganize(Ps); usedPathsFix(p,paths, empty)>//assert that the result includes paths in usedPathsFix(p,paths, empty)  
  Ps,Ps'={P|P inside eC}//arbitrary split of the set; heuristic will apply in the implementation.
  paths= reorganize(Ps')
 
- usedPathsFix(p,paths,Css)= usedPathsFix(p, paths U paths0,minimize(paths0.top() U Css)) // U on paths does minimize() internally
   paths.top()\Css!=empty
   paths0=usedPathsL(p.top(),paths.top()\Css)
     
- usedPathsFix(p,paths,Css)= usedPathsFix(p.pop(),paths.pop(),empty).push(Css)
   paths.top()\Css==empty

- usedPathsFix(p,empty,empty) =empty   
    
- usedPathsL(L, Cs1..Csn)=usedInnerL(L(Cs1),Cs1) U ... U usedInnerL(L(Csn),Csn)

- usedInnerL({_ implements Ps, M1..Mn},Cs)=prefix(Cs,reorganize(Ps) U usedInnerM(M1) U... U usedInnerM(Mn))

- usedInnerM(M)= reorganize({P| P inside M}) U (usedInnerL(L1,empty) U...U usedInnerL(Ln,empty)).pop()
  L1..Ln={L| L inside M}

  //in the botton to not mess up line numbers
- toAny(Css0..Cssn,e)=e iff forall i in 0..n, Cs in Cssi, not Thisi.Cs inside e
  otherwise toAny(Css0..Cssn, ctxC[Thisi.Cs])=toAny(Css1..Cssn,ctxC[Any]) 
  where Cs in Cssi
  
  //non determinism heuristic:
  //if P.m(_) inside e, P not Any
  //if ( _ T x=P _ _) inside e and T!=class Any, P not Any.
  //otherwise, P is considered of type class Any.
  // user can always force a not any by writing (x=P x)
  //if we have caching Typed, we can say in the heuristic that if 
  //p(Pi).Cache=Typed, Pi is not Any
  
  Example using caching for typing... needs growFellow :)
  L::={.. Cache}
  Cache::=None | Norm | Typed
  paths |-p:p'
  
      paths |- p.pop():p0
      Css|-p1:L
(pPop)----------------------------------  p1=p.growFellow(p0)
      Cs1..Csn paths |- p : p1.update(L)
  

         Css|-p:L
(pNoPop)--------------------------------  p.pop() undefined
         Cs1..Csn paths |- p :L,empty


(pEmpty)--------------------------------
         empty |- p :p
  

     forall Csi : pi|-pi.top(): ok //if Li.Cache=Typed, the check will be just asserted
(pL) ---------------------------------------   pi=p.navigate(Csi)
     Cs1..Csn|-p:p.top()[Cs1=L1,.. Csn=Ln]     Li=pi.top()[with Cache=Typed]//also inside all somehow contained Ls

 