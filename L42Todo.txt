-CACHING: there is a bug when sometime a .unwrap field is null, causing an assert error. It is about re running after errors.
2)-CACHING bug: if I reuse adam towel and declare a nested call Test it fails for shadowing (correctly)
    but when I then rename it, it keeps failing for shadowing
 -IDE: clear cache should stop the loading of the old cache and set up run?
 -IDE: cut paste on win do not survive the IDE being closed
 -IDE: syntax bug: this.foo::0() get marked red
 -IDE: meth names wiht more then one # are badly highlighted
3) -Run a balanced parenthesis test on syntax errors
-L42 optimization: if an e is just the Full.L emptyLibrary, I can avoid a lot of fromming of CTzs.... it can speed up a lot whith tests using{}: as tag!
-L42 cache optimization: new NormResult<T>(circle); and the "commander" pattern can be made faster
 //TODO: now somehow the Info is always declassed to "norm" :-(    

 -Cache.Now optimization: we could search for a normalized version of the object just created,
 and in case it exists we can use the cached results on the normalized one. 
 
 -add multi args cache for imm/class?
   They can be done by close or even by user defined decorators?

-fix the failing test of rename free vars

-test cache in case the cached method do some exceptions/errors
  
-add and test System.restartThreads() //or better name

-Expand multi method types:this should work also for read/mut/imm/capsule. Unsure about lent
 class method fwd mut This toMap(fwd mut This that)=that
-Should I have inference for exceptions? so that [] just infers the exception clause?
  half could simply collect all the meth calls, and if they are typed, add the information (of course... filter caches etc)
-Bug: CircularityIssue need to be improved by a long time 
-circular toString in TestData?
-toLibrary in Data? is similar to the toString...

-new CachedRes for imm only on norms (now are allocated all of the time) (search new CachedRes)

------------------
Should I do Alphanumeric?
//   );}@Test public void t1(){top(//TODO: fix, so that also a class expression can be a top level toLibrary?
//   top("{A={class method Library #toLibrary()={#norm{}}} B=(class A a=A<:class A a)}","{A={#typed{}}B={#typed{}}#norm{}}")
Data.Value:
  Value just annotate as @Cache.Now the first method, that must be class void.
  then the method argument become imm fields and the result is dataed
  MCall=Data.Value:{[Expr] class method Void
    (Expr receiver, Name name, Expr.List args)
    =Data.Ensure[name.args().size()==args.size()]
    }

AddDocs:  myDoc.addTo({},name=...)


//NO?:
Should organize check that $ renamed stuff is renamed onto an existing target?
otherwise Organize:{Foo={}   Fooo$={}} works with no reported errors
But.... Foo$Bar is ok if Foo exists and Bar does not...

More tests?
I verified, but not added a test, the following:
-correctly not coherent if mut This or fields exists. 
 It seams like all the restrictions of nativeKinds are implemented
LM={
  class method This of::0()
  #norm{
    nativeKind=LazyMessage
    typeDep=This close}
  }
-capturing a NonDeterministicException in a non #$ method is not well typed

-data properly have fwd for the fields not used in invariants
-data works just fine on 0 fields objects.
-parse error can be whoopsed
Throw={class method Void (S.ParseError that)[S.ParseError]=exception that}
Main=(
  S.ParseError ee=(_=Size"nope" catch error S.ParseError pe pe error X"")
  Debug(ee)
  Debug(S"More text")
  (Throw(ee)
  whoops S.ParseError
  void))

  
  ---Documentation for Cache?
Cache.Lazy class () //trivial
Cache.Lazy imm () //trivial
Cache.Now class (..) ->read
Cache.ReadLazy class (..) ->read//not working now
//NO Cache.Now imm ()??? 
//NO Cache.Now class ()??? 
//NO Cache.Lazy imm(..)??? no dots +imm
//NO Cache.Now imm(..)???

//option 1: just use the pattern by hand:
@Cache.Lazy method A methName(B b,C c)=e //do not write
MethName=Data:{A that,B b,C c  @Cache.Lazy method A()=e}//instead write

//option 2:
@Cache.Lazy method A methName(B b,C c)=e//close take this code
method A _methName(B b,C c)=e//and generate those 3 lines, then set _methName and MethName private
MethName=Data:{A that,B b,C c  @Cache.Lazy method A()=that._methName(b=b,c=c)}
@Cache.Lazy  method A methName(B b,C c)=MethName(_this=this,b=b,c=c)()


@Cache.Lazy class method A a(B b,C c)=e
class method A a(B b,C c)=BC(b=b,c=c)()
BC=Data:{B b,C c  @Cache.Lazy method A()=e}