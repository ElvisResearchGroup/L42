- Should shortcircut squre have a shortut desugar for []
- How often desugar generates "(void)" or similar?
- For the guide: nested return, how does it work? can A a={  B b={ return A()}} skip a curly?
- remove unused code in load (what did I ment here?)
- load must throw error if the map can not be completed
-IDE formatting: the // in http://.. is seen as a comment in the 'reuse[]'
-the l42 project need to encapsulate all used libraries under private class loaders?
 --otherwise, users of the slaves will need to know about those!
-in guide first occurence of Module is unfortunate
  options to replace: static class, utility class, component
-declaration for vector of num >> list of num?
-Bug rename: if a class is cleared and a method return type is
This2.XX::n it will give an assertion error instead of a 42 exception
In general, should all the 'from' method become #apply? is not it just  a 'constructor'?
In progress: "Cache.Call:" should be used before deploy/deployModule, not in Public
Error reporting Bug: 
A ={B.C}
B=Baz:{
  C={}
  D=A.foo() //requires A, that requires B.C,
  //A can not be compiled yet, even if C is typed.
  //B.C will not be detected as a missing dependency from the current CircularityIssue :-( 
  }
-Bug: it should require parenthesis around the for body!! 
A =(ss=S.List[]
  for a in ss ss.add(a)
  Debug(ss) )  
-autocomplete, takes 9 for a (
also, does not reset on dots?
-X.Pre should throw a X.Pre instead of an X?
-Must test X[] and X.Pre, may make a X.Condition decorator that adds new stuff like X and X.Pre?
-Rename SQL tests and add some explicit iql tests.. how?
-should typeDep and coherentDep always contains explicitly the roots of the unique names one?
    now it is inconsistent. Also, what about depending from This0?
-TODO: test two cache now methods with same name and different fields name
-db: null can also be input to the query
-handle division by zero int, long, Num (and double? how is NAN cached eq?)
-Test cut() when object are removed, it may give a out of bound exception anyway?
-Easy: when printing positions sort them by file
-for pluggable type systems and field docs: it is very sad that
 @Foo T bar put the annotation on the field but imm @Foo bar puts it on the type
-Bug: if you have a sum that sums wrong types for a field, we get a cache assertion fail.
  for example sum A a and $A a
-GUI: somehow allows termination of the 42 program
-COnsistency of the desugar: should #if also work for while? what happens in for?
-Bug -add constructor and possibly others remove docs form args of overridden abstract methods
-DB: test it on a gui, improve error messages, support more parameters
-Bug Optional toString in internal toString: it just prints the inside;  what happens if null? 
-we could avoid a ton of problems if we used the class object instead of null for opts!! But... how to handle Opt String and Opt Integer??? 
-Cache.Lazy: it seams to be fine when applied on class methods of natives.
  -test this corner case more; -do we get a good error if we try Cache.Lazy on an imm method of a native?
-BIG: Find a pattern to enable any native to be mapped on any type; consider loading a library on a towel where S is not native
-BIG, but confusing: the java compiler go in loop for code too complex, like to many &&. See TestTopNorm t_manyAnds() :-(
-CACHING: there is a bug when sometime a .unwrap field is null, causing an assert error. It is about re running after errors.
-IDE crash: paste on IDE. close IDE, open IDE, copy on IDE. System now unresponsive!
-IDE: cut paste on win do not survive the IDE being closed
-IDE: clear cache should stop the loading of the old cache and set up run?
-IDE: somehow disable insertion of random '}'
-IDE:we can sort alphabetically the members 
-bug initVisitor 149 TODO: the above test is dangerous, it may encounter ... or reuse, and then we do not know if it is in the domain (good AssertionError)
-L42 optimization: if an e is just the Full.L emptyLibrary, I can avoid a lot of fromming of CTzs.... it can speed up a lot whith tests using{}: as tag!
-L42 cache optimization: new NormResult<T>(circle); and the "commander" pattern can be made faster
 //TODO: now somehow the Info is always declassed to "norm" :-(    
-Vector BUG: the error message seams to only mention imms:
  -- "#val called, but the element in position "+%1$s+" was inserted as immutable"
-can we simplify or remove class NormResult?
-Cache.Now optimization: we could search for a normalized version of the object just created,
 and in case it exists we can use the cached results on the normalized one. 
-Cache: use String .intern()?
  -what about Integer? what about big rational? what about arrays //now all ValueCache stuff is not flyweithed 
  -should wrap all the returns with normalization, so that we only return normalized numbers?
-test cache in case the cached method do some exceptions/errors
-collections methods are quite irregular, for example add() is shortcut for add(right), but #add() does not exists to be a shortcut for #add(right)
-if a method ends in stack oveflow, the error is only reported in Java and not in the IDE
-add and test System.restartThreads() //or better name
-Consider removing 'pos' from Info toS, since pos is very big, that toFullS() is shorted then toS()
-circular toString in TestData?
-toLibrary in Data? is similar to the toString... now we have ListS+from(string), should we have from(ListAnys fields)? 
-new CachedRes for imm only on norms (now are allocated all of the time) (search new CachedRes)
-BootStrapping: consider moving some operations inside of it
------------------
-write in some guides: A=B:{..} does not typecheck .. but typechecks all its nested classes if dependencies are sorted
//To test, NativeNames: there is now a set of forbidden words, this may not be exactly identical to what identifiers can have.
//Should hava an automatic test that works, and may be we should be sure that a method parameter can not be called "reuse" if it is directly wrote in the program.
//Could be done, but is not now: redirect:
You may redirect a native** on another native** if the native pars are
  idenatically transferred in redirect
//TODO: we really need to decide if == and co take a read or an imm
//for now Data make it take an imm
//Num, Size,Unit and String take a read. Is it ok to have different ways?
Should I do Alphanumeric?
//   );}@Test public void t1(){top(//TODO: fix, so that also a class expression can be a top level toLibrary?
//   top("{A={class method Library #toLibrary()={#norm{}}} B=(class A a=A<:class A a)}","{A={#typed{}}B={#typed{}}#norm{}}")
Data.Value:
  Value just annotate as @Cache.Now the first method, that must be class void.
  then the method argument become imm fields and the result is dataed
  MCall=Data.Value:{[Expr] class method Void
    (Expr receiver, Name name, Expr.List args)
    =Data.Ensure[name.args().size()==args.size()]
    }

Make a more complete AddDocs?  myDoc.addTo({},name=...) currently only string docs are supported

 -add multi args cache for imm/class?
   They can be done by close or even by user defined decorators?
   
//NO?:
Should organize check that $ renamed stuff is renamed onto an existing target?
otherwise Organize:{Foo={}   Fooo$={}} works with no reported errors
But.... Foo$Bar is ok if Foo exists and Bar does not...

More tests?
I verified, but not added a test, the following:
-correctly not coherent if mut This or fields exists. 
 It seams like all the restrictions of nativeKinds are implemented
LM={
  class method This of::0()
  #norm{
    nativeKind=LazyMessage
    typeDep=This close}
  }
-capturing a NonDeterministicException in a non #$ method is not well typed

-data properly have fwd for the fields not used in invariants
-data works just fine on 0 fields objects.
-parse error can be whoopsed
Throw={class method Void (S.ParseError that)[S.ParseError]=exception that}
Main=(
  S.ParseError ee=(_=Size"nope" catch error S.ParseError pe pe error X"")
  Debug(ee)
  Debug(S"More text")
  (Throw(ee)
  whoops S.ParseError
  void))

  
  ---Documentation for Cache?
Cache.Lazy class () //trivial
Cache.Lazy imm () //trivial
Cache.Now class (..) ->read
Cache.ReadLazy class (..) ->read//not working now
//NO Cache.Now imm ()??? 
//NO Cache.Now class ()??? 
//NO Cache.Lazy imm(..)??? no dots +imm
//NO Cache.Now imm(..)???

//option 1: just use the pattern by hand:
@Cache.Lazy method A methName(B b,C c)=e //do not write
MethName=Data:{A that,B b,C c  @Cache.Lazy method A()=e}//instead write

//option 2:
@Cache.Lazy method A methName(B b,C c)=e//close take this code
method A _methName(B b,C c)=e//and generate those 3 lines, then set _methName and MethName private
MethName=Data:{A that,B b,C c  @Cache.Lazy method A()=that._methName(b=b,c=c)}
@Cache.Lazy  method A methName(B b,C c)=MethName(_this=this,b=b,c=c)()

@Cache.Lazy class method A a(B b,C c)=e
class method A a(B b,C c)=BC(b=b,c=c)()
BC=Data:{B b,C c  @Cache.Lazy method A()=e}
