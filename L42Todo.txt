-CACHING: there is a bug when sometime a .unwrap field is null, causing an assert error. It is about re running after errors.
 -IDE: clear cache should stop the loading of the old cache and set up run?
 -IDE: cut paste on win do not survive the IDE being closed
 -IDE: syntax bug: this.foo::0() get marked red
 -Run a balanced parenthesis test on syntax errors
-L42 optimization: if an e is just the Full.L emptyLibrary, I can avoid a lot of fromming of CTzs.... it can speed up a lot whith tests using{}: as tag!
-L42 cache optimization: new NormResult<T>(circle); and the "commander" pattern can be made faster
 //TODO: now somehow the Info is always declassed to "norm" :-(    

 -Cache.Now optimization: we could search for a normalized version of the object just created,
 and in case it exists we can use the cached results on the normalized one. 
 
 -add callSiteCache?
   Discovery: Cache.Calls can be done by close as a 'transformation'
   adding private class Cache.Lazy methods.
   No new runtime support needed. No new J tweaks
   -option: a decorator that do it on all the code, including all the private code in nesteds.
     we could just apply it to adam towel, then we could add it to Data/Organize? may be just organize?
 -add multi args cache for imm/class?
   They can be done by close or even by user defined decorators?
 -add parallel cache/eagerCache

Data.Value:
  Value just annotate as @Cache.Now the first method, that must be class void.
  then the method argument become imm fields and the result is dataed
  MCall=Data.Value:{[Expr] class method Void
    (Expr receiver, Name name, Expr.List args)
    =Data.Ensure[name.args().size()==args.size()]
    }

AddDocs:  myDoc.addTo({},name=...)

-fix the failing test of rename free vars

-Test Close/Data: if a well typed trait is Dataed, then 
  data need to throw exceptions if @Cache.** annotations are badly places.
  Try for example to place them on mut methods
  test all kind of annotations
  
-Main=(//this code is considered a "degenerated statement" Well formedness 235
  Debug(Point(3\,5\).xy())//the issue s that there are no parName= for parameters.... but this is a terrible error to get in this case
  )
  
-add and test System.restartThreads() //or better name

-Expand multi method types:this should work also for read/mut/imm/capsule. Unsure about lent
 class method fwd mut This toMap(fwd mut This that)=that
 
-Bug: CircularityIssue need to be improved by a long time 
-circular toString in TestData?
-toLibrary in Data? is similar to the toString...

-new CachedRes for imm only on norms (now are allocated all of the time) (search new CachedRes)

------------------
Should I do Alphanumeric?
//   );}@Test public void t1(){top(//TODO: fix, so that also a class expression can be a top level toLibrary?
//   top("{A={class method Library #toLibrary()={#norm{}}} B=(class A a=A<:class A a)}","{A={#typed{}}B={#typed{}}#norm{}}")


//NO?:
Should organize check that $ renamed stuff is renamed onto an existing target?
otherwise Organize:{Foo={}   Fooo$={}} works with no reported errors
But.... Foo$Bar is ok if Foo exists and Bar does not...

More tests?
I verified, but not added a test, the following:
-correctly not coherent if mut This or fields exists. 
 It seams like all the restrictions of nativeKinds are implemented
LM={
  class method This of::0()
  #norm{
    nativeKind=LazyMessage
    typeDep=This close}
  }
-capturing a NonDeterministicException in a non #$ method is not well typed

-data properly have fwd for the fields not used in invariants
-data works just fine on 0 fields objects.
-parse error can be whoopsed
Throw={class method Void (S.ParseError that)[S.ParseError]=exception that}
Main=(
  S.ParseError ee=(_=Size"nope" catch error S.ParseError pe pe error X"")
  Debug(ee)
  Debug(S"More text")
  (Throw(ee)
  whoops S.ParseError
  void))

  
  ---Documentation for Cache?
Cache.Lazy class () //trivial
Cache.Lazy imm () //trivial
Cache.Now class (..) ->read
Cache.ReadLazy class (..) ->read//not working now
//NO Cache.Now imm ()??? 
//NO Cache.Now class ()??? 
//NO Cache.Lazy imm(..)??? no dots +imm
//NO Cache.Now imm(..)???

//option 1: just use the pattern by hand:
@Cache.Lazy method A methName(B b,C c)=e //do not write
MethName=Data:{A that,B b,C c  @Cache.Lazy method A()=e}//instead write

//option 2:
@Cache.Lazy method A methName(B b,C c)=e//close take this code
method A _methName(B b,C c)=e//and generate those 3 lines, then set _methName and MethName private
MethName=Data:{A that,B b,C c  @Cache.Lazy method A()=that._methName(b=b,c=c)}
@Cache.Lazy  method A methName(B b,C c)=MethName(_this=this,b=b,c=c)()


@Cache.Lazy class method A a(B b,C c)=e
class method A a(B b,C c)=BC(b=b,c=c)()
BC=Data:{B b,C c  @Cache.Lazy method A()=e}