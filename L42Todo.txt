-test that if we (only) manually add a ::0 private implemented method,
then 'canditate' public constructors are not recognized, and the class is never instantiable
-Rename feature add: must be possible to rename-sum an interface with, at lease, an empty class never used. 
-should \add(e) call this.add(e)? so that '\res<=' can disappear?
  #conseguences: a.foo() == a.foo. ; however a.foo() is never interpreted as (a.foo)(); thus a.foo()() will stay the same 
-ToHalf 586 was not completed:
    if(m._e()==null){throw todo();}
    if(!m.varTxs().isEmpty()){throw todo();}
-another toS bug: A=Data:{} B=Data:{A a} B(a=A()).toS()
-Cache.Lazy: it seams to be fine when applied on class methods of natives.
  -test this corner case more; -do we get a good error if we try Cache.Lazy on an imm method of a native?
  we can sort alphabetically the members
-TypeSystem enrich: simmetric of multi method types:
  -a method taking no mut,read,lent and returning imms (can take fwds?)
    can be typed returning either imm OR read (and not immPFwd?)
  -a method taking no muts and returning imm/capsule (can take fwds?)
    can be typed returning either imm or mut (and not their mdfPFwd?)
-BIG: Find a pattern to enable any native to be mapped on any type; consider loading a library on a towel where S is not native
-Big, but confusing: the java compiler go in loop for code too complex, like to many &&. See TestTopNorm t_manyAnds() :-(
-CACHING: there is a bug when sometime a .unwrap field is null, causing an assert error. It is about re running after errors.
-IDE crash: paste on IDE. close IDE, open IDE, copy on IDE. System now unresponsive!
-IDE: clear cache should stop the loading of the old cache and set up run?
-IDE: cut paste on win do not survive the IDE being closed
-IDE: somehow disable insertion of random '}'
-IDE:when printing outline: docs need to be \n\n and
-untrusted nativeCode: if Size is the result, we make a generic of <int> instead of <Integer> 
-errorbug: if we use a non existent url for trusted op we get an assertion error instead of a 42 error, as in java.lang.AssertionError: #isSize#
-bug initVisitor 149 TODO: the above test is dangerous, it may encounter ... or reuse, and then we do not know if it is in the domain (good AssertionError)
-L42 optimization: if an e is just the Full.L emptyLibrary, I can avoid a lot of fromming of CTzs.... it can speed up a lot whith tests using{}: as tag!
-L42 cache optimization: new NormResult<T>(circle); and the "commander" pattern can be made faster
 //TODO: now somehow the Info is always declassed to "norm" :-(    
-Vector BUG: the error message seams to only mention imms:
  -- "#val called, but the element in position "+%1$s+" was inserted as immutable"
-Cache.Now optimization: we could search for a normalized version of the object just created,
 and in case it exists we can use the cached results on the normalized one. 
-Cache: use String .intern()?
  -what about Integer? what about big rational? what about arrays 
and should wrap all the returns with normalization, so that we only return normalized numbers.

-test cache in case the cached method do some exceptions/errors
  
-add and test System.restartThreads() //or better name
-Consider removing 'pos' from Introspection toS, since pos is very big, that toFullS() is shorted then toS()
-Bug: CircularityIssue need to be improved by a long time 
-circular toString in TestData?
-toLibrary in Data? is similar to the toString... now we have ListS+from(string), should we have from(ListAnys fields)? 
-mispelling a native causes an assertion error instead of a compile error
-new CachedRes for imm only on norms (now are allocated all of the time) (search new CachedRes)
-BootStrapping: consider moving some operations inside of it
-Collections.AnyToS should consider HasToS.Raw

-Test List of itself and Maps and Set of itself. The following may be needed
  re designing arraylist caching and map caching
  right now the code to take fetch the cache object for the gen parameter of 
  an arraylist, when the type is native is:
  return wrapperT+".myCache.rawFieldCache(0)";
  This may or may not work if the type is an arrayList,
  and I doubt it working for an arraylist of "This0", that is possible in L42
  Should we have a "function" that give you the cache in the first element of the array,
  instead of the cache object iself?

------------------
//To test, NativeNames: there is now a set of forbidden words, this may not be exactly identical to what identifiers can have.
//Should hava an automatic test that works, and may be we should be sure that a method parameter can not be called "reuse" if it is directly wrote in the program.
//Could be done, but is not now: redirect:
You may redirect a native** on another native** if the native pars are
  idenatically transferred in redirect
//TODO: we really need to decide if == and co take a read or an imm
//for now Data make it take an imm
//Num, Size,Unit and String take a read. Is it ok to have different ways?
Should I do Alphanumeric?
//   );}@Test public void t1(){top(//TODO: fix, so that also a class expression can be a top level toLibrary?
//   top("{A={class method Library #toLibrary()={#norm{}}} B=(class A a=A<:class A a)}","{A={#typed{}}B={#typed{}}#norm{}}")
Data.Value:
  Value just annotate as @Cache.Now the first method, that must be class void.
  then the method argument become imm fields and the result is dataed
  MCall=Data.Value:{[Expr] class method Void
    (Expr receiver, Name name, Expr.List args)
    =Data.Ensure[name.args().size()==args.size()]
    }

Make a more complete AddDocs?  myDoc.addTo({},name=...) currently only string docs are supported

 -add multi args cache for imm/class?
   They can be done by close or even by user defined decorators?
   
//NO?:
Should organize check that $ renamed stuff is renamed onto an existing target?
otherwise Organize:{Foo={}   Fooo$={}} works with no reported errors
But.... Foo$Bar is ok if Foo exists and Bar does not...

More tests?
I verified, but not added a test, the following:
-correctly not coherent if mut This or fields exists. 
 It seams like all the restrictions of nativeKinds are implemented
LM={
  class method This of::0()
  #norm{
    nativeKind=LazyMessage
    typeDep=This close}
  }
-capturing a NonDeterministicException in a non #$ method is not well typed

-data properly have fwd for the fields not used in invariants
-data works just fine on 0 fields objects.
-parse error can be whoopsed
Throw={class method Void (S.ParseError that)[S.ParseError]=exception that}
Main=(
  S.ParseError ee=(_=Size"nope" catch error S.ParseError pe pe error X"")
  Debug(ee)
  Debug(S"More text")
  (Throw(ee)
  whoops S.ParseError
  void))

  
  ---Documentation for Cache?
Cache.Lazy class () //trivial
Cache.Lazy imm () //trivial
Cache.Now class (..) ->read
Cache.ReadLazy class (..) ->read//not working now
//NO Cache.Now imm ()??? 
//NO Cache.Now class ()??? 
//NO Cache.Lazy imm(..)??? no dots +imm
//NO Cache.Now imm(..)???

//option 1: just use the pattern by hand:
@Cache.Lazy method A methName(B b,C c)=e //do not write
MethName=Data:{A that,B b,C c  @Cache.Lazy method A()=e}//instead write

//option 2:
@Cache.Lazy method A methName(B b,C c)=e//close take this code
method A _methName(B b,C c)=e//and generate those 3 lines, then set _methName and MethName private
MethName=Data:{A that,B b,C c  @Cache.Lazy method A()=that._methName(b=b,c=c)}
@Cache.Lazy  method A methName(B b,C c)=MethName(_this=this,b=b,c=c)()

@Cache.Lazy class method A a(B b,C c)=e
class method A a(B b,C c)=BC(b=b,c=c)()
BC=Data:{B b,C c  @Cache.Lazy method A()=e}