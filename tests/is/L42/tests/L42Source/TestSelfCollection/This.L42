reuse [AdamTowel]
A=Organize:{//TODO: add Maps sets and ops, then simplify cache suppliers
  L$={}
  L=Collection.list(L$)
  S$={}
  S=Collection.set(S$)
  SN=Collection.set(Num)
  SSN=Collection.set(SN)
  M$={} 
  M=Collection.map(key=M$ val=M$)
  O$={}
  O=Collection.optional(O$)
  Ol=Collection.optional(This1.S.List)
  Lol=Collection.list(Ol)
  Mol=Collection.map(key=This1.S, val=Ol)
  A={class method This()}
  OA=Collection.optional(A)
  Loa=Collection.list(OA)
  Soa=Collection.set(OA)
  Sos=Collection.set(This1.S.Opt)
  Mos=Collection.map(key=I,val=This1.S.Opt)
  La=Collection.list(A)
  Ola=Collection.optional(La)
  Mini=Collection.map(key=A, val=La)
  Sola=Collection.set(Ola)
  }
MainMini=(
  mini=A.Mini[key=A.A(), val=A.La[]]
  Debug(mini)
  {}:Test""(expected=S"{A.A()->[]}" actual=mini)
  )
MainSoa=(
  soa0=A.Soa[A.OA()]
  Debug(soa0)
  {}:Test""(expected=S"{[]}" actual=soa0)
  soa1=A.Soa[A.OA(A.A())]
  Debug(soa1)
  {}:Test""(expected=S"{[A.A()]}" actual=soa1)
  )
MainLoa=(
  loa0=A.Loa[A.OA()]
  Debug(loa0)
  {}:Test""(expected=S"[[]]" actual=loa0)
  loa1=A.Loa[A.OA(A.A())]
  Debug(loa1)
  {}:Test""(expected=S"[[A.A()]]" actual=loa1)
  )
MainSola=(
  sola0=A.Sola[\()]
  Debug(sola0)
  {}:Test""(expected=S"{[]}" actual=sola0)
  sola1=A.Sola[\(A.La[])]
  Debug(sola1)
  {}:Test""(expected=S"{[[]]}" actual=sola1)
  )

MainMos=(
  mos=A.Mos[key=12\, val=S.Opt(S"hi")]
  Debug(mos)
  {}:Test""(expected=S"{12->[%S.dq()hi%S.dq()]}" actual=mos)
  )
MainMols=(
  imm ol=A.Ol()
  mol=A.Mol[key=S"hello" val=ol]
  Debug(mol)
  {}:Test""(expected=S"{%S.dq()hello%S.dq()->[]}" actual=mol)  
  )
MainSos=(
  sos=A.Sos[S.Opt(S"hi")]
  Debug(sos)
  {}:Test""(expected=S"{[%S.dq()hi%S.dq()]}" actual=sos)
  )

MainL=(
  l1=A.L()
  l2=A.L()
  imm l3=A.L()
  l1.#add(right=l2)
  l1.#add(right=l2)
  l1.add(right=l3)
  Debug(l1)
  Debug(l1.size())
  {}:Test""(expected=S"[[]; []; []]" actual=l1)
  {}:Test""(expected=3I actual=l1.size())
  )
MainSSN=(
  s1=A.SSN()
  imm s2=A.SN()
  imm s3=(
    s=A.SN()
    s.add(3Num)//s2
    s
    )
  s1.add(s2)
  Debug(s1)
  s1.add(s3)
  Debug(s1)
  Debug(s1.size())
  {}:Test""(expected=S"{{}; {3}}" actual=s1)
  {}:Test""(expected=2I actual=s1.size())
  )
MainS=(
  s1=A.S()
  imm s2=A.S()
  imm s3=(
    s=A.S()
    s.add(s2)
    s
    )
  s1.add(s2)
  Debug(s1)
  s1.add(s3)
  Debug(s1)
  Debug(s1.size())
  {}:Test""(expected=S"{{}; {{}}}" actual=s1)
  {}:Test""(expected=2I actual=s1.size())
  )
MainM=(
  mut m1=A.M()
  imm m2=A.M()
  mut mVal=A.M()
  imm m3=A.M[key=m2 mutVal=A.M()]
  m1.put(key=m2 val=m2)
  Debug(m1)
  m1.#put(key=m3 val=mVal)
  Debug(m1)
  Debug(m1.size())
  {}:Test""(expected=S"{{}->{}; {{}->{}}->{}}" actual=m1)
  {}:Test""(expected=2I actual=m1.size())
  )
MainO=(
  o1=A.O()
  o2=A.O(o1)
  o3=A.O(o2)
  Debug(o1)
  {}:Test""(expected=S"[]" actual=o1)
  Debug(o2)
  {}:Test""(expected=S"[[]]" actual=o2)
  {}:Test""(expected=S"[[[]]]" actual=o3)
  )
MainLols=(
  imm ss=S.List[S"hello"; S" ";S"world"]
  imm ol=A.Ol(ss)
  lol=A.Lol[ol;A.Ol();ol]
  Debug(lol)
  mol=A.Mol[key=lol.val(0\).val().val(0\) val=lol.val(2\)]
  Debug(mol)
  {}:Test""(expected=S"[[[%S.dq()hello%S.dq(); %S.dq() %S.dq(); %S.dq()world%S.dq()]]; []; [[%S.dq()hello%S.dq(); %S.dq() %S.dq(); %S.dq()world%S.dq()]]]" actual=lol)
  {}:Test""(expected=S"{%S.dq()hello%S.dq()->[[%S.dq()hello%S.dq(); %S.dq() %S.dq(); %S.dq()world%S.dq()]]}" actual=mol)  
  )