//TODO: divide organize more clearly in multiple decorators that can be used from users
//now we have 4 fases that should become usable decorators:
//-CloseAll
//-Rename$
//-Hide non Public
//-CacheCall

@Public CacheCall$Fail=Class$Relax:Message.Native:{[Message$Guard]}
CacheCall$Meta={
  class method This #apply()
  method Library cacheCall(Library that)=native{trusted:cacheCall} error void
  #norm{nativeKind=Meta,
    typeDep=This0 This1.CacheCall$Fail,This2.S
    watched=This1.CacheCall$Fail,This2.S
    coherentDep=This1.CacheCall$Fail,
    nativePar=This1.CacheCall$Fail This1.CacheCall$Fail This1.CacheCall$Fail This1.CacheCall$Fail This1.CacheCall$Fail
    }}
CacheCall={
  @Public ClassOperators={class method class This1 ()=This1}
  @Public class method Trait :(Trait t)[CacheCall$Fail]=Trait(this:t.code())
  @Public class method Trait :(class Trait.Lifted l)[CacheCall$Fail]=Trait(this:l.code())
  @Public class method Library :(Library that)[CacheCall$Fail]={
    return CacheCall$Meta().cacheCall(that)
    catch error CacheCall$Fail x exception x
    }
  }

CloseAll={
  class method Trait (Trait that)[Data.Close$Fail]=(
    n=Introspection.Nested.from(library=that.code())
    This(that,n=n)  
    )
  class method Trait (Trait that,Introspection.Nested n)[Data.Close$Fail]=(
    var res=that
    for ni in n.nesteds() (res:=This(res,n=ni))
    if !n.isInterface() && !n.isClose() (res:=Data.Close(n.nameFromRoot(),autoNorm=Bool.false()):res)
    res
    )
  }
ClassOperators={class method This1()=This1()}
Name public
Bool just$
class method This (Name public, Bool just$)
class method This (Name public)=\(public=public,just$=Bool.false())
class method This(Bool just$)=\(public=Name"",just$=just$) 
class method This()=\(public=Name"",just$=Bool.false()) 

method I maxLev(Introspection.Nested that)=(
  var res=0I
  for ni in that.nesteds() (
    tmp=this.maxLev(ni)
    if res<tmp res:=tmp
    )
  res+1I
  )
method Library :(Library that)[Data.Close$Fail,Trait$InvalidName,Trait$InvalidMap,Trait$ClassClash,Trait$MethodClash,CacheCall$Fail]=
  (this:Trait(that)).code()

method Trait :(class Trait.Lifted lifted)[Data.Close$Fail,Trait$InvalidName,Trait$InvalidMap,Trait$ClassClash,Trait$MethodClash,CacheCall$Fail]=
  (this:lifted())
  
method Trait :(Trait trait)[Data.Close$Fail,Trait$InvalidName,Trait$InvalidMap,Trait$ClassClash,Trait$MethodClash,CacheCall$Fail]=(
  max=this.maxLev(Introspection.Nested.from(library=trait.code()))
  var res=trait
  (var lev=0I while lev<max (//range will come later
    lev+=1I
    i=Introspection.Nested.from(library=res.code())//trait.introspection() will come later
    res:=res(squareBuilder=this.mapRename$(Trait.Acc(Name$Mapping()),n=i,level=max-lev))
    ))
  if !this.just$() res:=this.after$(res,max=max)
  res
  )
method Trait after$(Trait that, I max)[Data.Close$Fail,Trait$InvalidName,Trait$InvalidMap,Trait$ClassClash,Trait$MethodClash,CacheCall$Fail]=(
  var res=that
  res:=CloseAll(res)
  (var lev=0I while lev<max (//range will come later
    lev+=1I
    i=Introspection.Nested.from(library=res.code())//trait.introspection() will come later
    res:=res(squareBuilder=this.mapHide(Trait.Acc(Name$Mapping()),n=i,level=max-lev))
    ))
  catch error S$ParseError e exception Trait$InvalidName(e.text())
  CacheCall:res
  )
EmptyOnThis={class method S (S that)=if that==S"This" S"" else that}

method Bool isPrivate(Introspection.Doc that)={
  if this.public()==Name"" return !that.annotatedAs(Public)
  return !that.annotatedAs(nested=that.root().nested(name=this.public()))
  }
  
method mut Trait.Acc mapHide(mut Trait.Acc that, Introspection.Nested n, I level)={
  ncs=n.nesteds()
  if level!=0I (
    for ni in ncs (_=this.mapHide(that,n=ni,level=level-1\) void)
    return that
    )
  ms=n.methods()
  var hasPublic=Bool.false()
  privates=Name$List()((
    for e in ncs (
      if this.isPrivate(e.outerDoc()) \add(e.nameFromRoot())
      else hasPublic:=Bool.true()
      )
    for e in ms (
      if this.isPrivate(e.doc()) (
        if !e.isRefined() \add(e.nameFromRoot())
        )
      else hasPublic:=Bool.true()
      )
    ))
  if hasPublic (for name in privates that.#squareAdd(hide=name))
  return that
  }
method mut Trait.Acc mapRename$(mut Trait.Acc that, Introspection.Nested n, I level)={
  ncs=n.nesteds()
  if level!=0I (
    for ni in ncs (_=this.mapRename$(that,n=ni,level=level-1\) void)
    return that
    )
  outName=EmptyOnThis(n.nameFromRoot().toS())
  outSize=outName.size()
  for ni in ncs {
    inName=ni.nameFromRoot().toS() //A.B$C$   A.$
    var inC=if outSize==0I inName 
      else inName.subString(outSize+1\ to=\size) //"B$C$"   "$"
    if inC.contains(\"$$") return void
    if !inC.contains(\"$") return void
    if inC.endsWith(\"$") (inC:=inC.subString(0\ to=\size-1\)) //"B$C"    ""
    if inC.startsWith(\"$") return void
    inC:=inC.replace(\"$" with=\".") //"B.C"    ""
    if inC.size()==0I return that.#squareAdd(\"%inName"=>n.nameFromRoot())
    return that.#squareAdd(\"%inName"=>\"%(n.nameFromRoot()).%inC")  //A.B$C$ =>A.B.C
    }
  return that
  }
@AbstractTowel{organize}