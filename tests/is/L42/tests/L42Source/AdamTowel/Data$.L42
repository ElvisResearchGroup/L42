class method Void checkCoherent(Library that)[Class$IncoherentClass]=
  this.checkCoherent(n=Introspection.Nested.from(library=that))
class method Void checkCoherent(Introspection.Nested n)[Class$IncoherentClass]=(
  S s=n.isCoherent()
  if s!=S"" exception Class$IncoherentClass"%s"
  for ni in n.nesteds() this.checkCoherent(n=ni) 
  )
Close={
  @Public class method Trait all(Trait that, Bool autoNorm)[Data.Close$Fail]=(
    n=Introspection.Nested.from(library=that.code())
    This(that,n=n,autoNorm=autoNorm)  
    )
  class method Trait (Trait that,Introspection.Nested n, Bool autoNorm)[Data.Close$Fail]=(
    var res=that
    for ni in n.nesteds() ( res:=this(res,n=ni,autoNorm=autoNorm) )
    var toClose=!n.isInterface() && !n.isClose()
    if toClose ( res:=Data.Close(n.nameFromRoot(),autoNorm=autoNorm):res )
    res
    )
  }
//Extra features that can be manually added as in
//Point = Data:Data.AddList:{Num x, Num y} 
TraitAddList = Trait({
  $={read method Bool readEquality(read This that)}
  List=Collection.list($)
  })['$=>'This]
TraitAddSet = Trait({
  $={read method Bool readEquality(read This that)}
  Set=Collection$.set($)
  })['$=>'This]
TraitAddOpt = Trait({
  $={read method Bool readEquality(read This that)}
  Opt=Collection.optional($)
  })['$=>'This]
@Public AddList = {class method This()
  @Public ClassOperators={class method This1() = This1()}
  @Public method Library :(Library lib)[_] = (this:Trait(lib)).code()
  @Public method Trait :(Trait that)[_] = TraitAddList+that
  }
@Public AddSet = {class method This()
  @Public ClassOperators={class method This1() = This1()}
  @Public method Library :(Library lib)[_] = (this:Trait(lib)).code()
  @Public method Trait :(Trait that)[_] = TraitAddSet+that
  }
@Public AddOpt = {class method This()
  @Public ClassOperators={class method This1() = This1()}
  @Public method Library :(Library lib)[_] = (this:Trait(lib)).code()
  @Public method Trait :(Trait that)[_] = TraitAddOpt+that
  }