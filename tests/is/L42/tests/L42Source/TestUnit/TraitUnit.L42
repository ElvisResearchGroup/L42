[HasToS]
Support=Class.Relax:Math.Support
Support that
class method This (Support that)
method Support #inner()=this.that()
method toS()=this.that().toS()
class method This #from(S.StringBuilder stringLiteral)
  =This(Support.#from(stringLiteral=stringLiteral))
method This +(This that)
  =This(this.that()+that.that())
method This -(This that)
  =This(this.that()-that.that())
method This *(Support support)
  =This(this.that()*support)
method This /(Support support)
  =This(this.that()/support)
method Support /(This that)
  =this.that()/that.that()

read method Bool readEquality(read This that)
  =this.that()==that.that()  
method Bool ==(This that)
  =this.that()==that.that()
method Bool !=(This that)
  =this.that()!=that.that()
  
method Bool >(This that)
  =this.that()>that.that()
method Bool <(This that)
  =this.that()<that.that()
method Bool >=(This that)
  =this.that()>=that.that()
method Bool <=(This that)
  =this.that()<=that.that()
class method This zero()
  =\(Support.zero())
method I ceil()
  =this.that().ceil()
method I floor()
  =this.that().floor()
method I round()
  =this.that().floor()
method Double toDouble()
  =this.that().toDouble()
method This self()=this

Times={class method Library (class Any that)[NotValidUnit,NotSameSupport]
  =CompositUnit(N(This1), and=N(that))}
Per={class method Library (class Any that)[NotValidUnit,NotSameSupport]
  =CompositUnit(N(This1), per=N(that))}
Inverse={class method Library ()[NotValidUnit]
  =CompositUnit(inverse=N(This1))}