WBigTitle(`More decorators')
Using the expressive power of programmatic refactoring many different decorators can be designed. Here we list and explain some of the most useful.

WTitle((1/5)`Public')
The Wcode(Public) decorator allows us to 
select certain members as Wcode(Public), and to hide all the others: for any nested class containing at least one Wcode(Public) annotation, Wcode(Public) hides all the non Wcode(Public) annotated members.
WBR
Consider the following example:
OBCode
MyProgram = Public:{
  Person = Data:{
    @Public var S name
    var I age
    @Public class method mut This (S name, I age)
    @Public mut method Void birthDay() = this.age(\age+1I)
    }
  Car = Data:{
    capsule Person driver
    @Cache.Now class method Void drivingAge(read Person driver) =
      X[driver.age()>=18I]
    }
  }
CCode
Here we have a Wcode(Person) class with Wcode(name) and Wcode(age),
but we expose only the Wcode(name).
We also expose the method Wcode(birthDay), that can update the Wcode(age).
WBR
Wcode(Data) is generating a bunch of other methods, but we are not exposing them.
In order to make our Wcode(Person) class usable, we need to at least expose a factory, as we do in line 5.
WBR
On the other side, consider Wcode(Car): since there is no Wcode(Public) annotation in Wcode(Car), no members are hidden.
Also, note how the Wcode(Car) invariant can refer to Wcode(Person.age()) normally. This works because the Wcode(Public) decorator is applied outside of both Wcode(Person) and Wcode(Car). This is indeed a very common pattern: Wcode(Public) is often used high up in the nested tree, to allow for tightly connected classes to see each others private members when needed.
Using the outline IDE feature, we could see the following:
OBCode
  MyProgram={
    Car={
      [This2.HasToS]
      class method mut This #apply(capsule This1.Person driver)=(..)
      method This2.Bool #bangequal0(This that)=(..)
      method This2.Bool #equalequal0(This that)=(..)
      class method This #immK(This1.Person driver)=(..)
      mut method capsule This capsuleClone()=(..)
      read method This immClone()=(..)
      read method read This1.Person driver()=(..)
      @This2.Cache.Now read method Void drivingAge()native{..}=(..)
      class method Void drivingAge(read This1.Person driver)=(..)
      method This norm()=(..)
      read method This2.Bool readEquality(read This that)=(..)
      read method This2.S toS()=(..)
      method This with(This1.Person driver)=(..)
      }
    Person={
      [This2.HasToS]
      @This2.Public class method mut This #apply(This2.S name, This2.I age)=(..)
      @This2.Public mut method Void birthDay()=(..)
      @This2.Public read method This2.S name()=(..)
      @This2.Public mut method Void name(This2.S that)=(..)
      read method This2.S toS()=(..)
      }
    }
CCode
As you can see, Wcode(Car) exposes all of the methods generated by Wcode(Data), while Wcode(Person) exposes only a minimal interface.
WP
Alternativelly,
when we only wish to hide a few specific methods,
we could just specify the private members. To this aim, we need to specify in Wcode(Public) the path to use to indicate privateness. We could for example use Wcode(X), that loosely speaking represents a form of denial:

OBCode
MyProgram = Public(private=\(X)):{
  Person = Data:{ /*..as before..*/}
  Car = Data:{
    capsule Person driver
    @X @Cache.Now class method Void drivingAge(read Person driver) =
      X[driver.age()>=18I]
    }
  }
CCode
The code above hides the Wcode(Car) invariant; this of course means that the invariant is still enforced, but methods Wcode(drivingAge()) and Wcode(drivingAge(driver)) are not polluting the interface of Wcode(Car) any more.
WP
Finally, Wcode(Public) is closing all the nested classes;
this means that the fields and constructors are not any more abstract methods but implemented methods delegating  to hidden ones.
A sealed class encapsulates its state, but can be reused in less flexible ways: the code of two sealed classes can not be merged with trait operators Wcode(+) and Wcode(:).

WTitle((2/5)`Organize')

With metaprogramming, often we have to create code in a certain order,
and this order may be in contrast with the final structure we want to create.
For example, we may want to have an interface whose nested classes implements such interface.
However, the following code:
OBCode
I = {interface
  method Void foo()
  A= Data:{[I] foo()=void}
  }
CCode
Would not work: we can not apply Data on Wcode({[I] foo()=void}) since Wcode(I) it is not compiled yet.

We could use rename and write
OBCode
I = Class:Trait({
  Top = {interface method Void foo() }
  A= Data:{[Top] foo()=void}
  })['Top=>'This]
CCode
That is, first we create a bunch of nested classes, and then we organize the result by renaming to obtain the desired shape.
This common pattern is automated by the decorator Wcode(Organize)
performing a standard pattern of renames:
WBR
Names containing the special Wcode($) character are renamed in names where Wcode($) is replaced with a Wcode(.) or just removed; for example Wcode(A$B$C) is renamed in Wcode(A.B.C),
Wcode(A$) is renamed in Wcode(A) and Wcode($) is renamed into Wcode(This).

Thus, we could rewrite the code above as
OBCode
I = Organize:{
  $ = {interface method Void foo() }
  A= Data:{[$] foo()=void}
  }
CCode
WP

In metaprogramming systems, code generation needs to proceed in a specific order. This sometimes creates difficoult situations.
For example, the following naive implementation of a Wcode(Person) with a map of friends to locations would not work:

OBCode
Point = Data:{ Num x, Num y }
Person = Data:{ Map friends }
Map = Collection.map(key=Person, val=Point)
CCode
Wcode(Map) can not be generated, since Wcode(Person) is untypable until Wcode(Map) is generated.
WBR
We can circumvent
those limitations with Wcode(Organize) by writing:
OBCode
MyCode = Organize:{
  Point = Data:{ Num x, Num y }
  Person$ = {}
  Map = Collection.map(key=Person$, val=Point)
  Person = Data:{ Map friends }
  }
CCode

Wcode(Organize) is also very useful to avoid redeclaring 
abstract methods when extending code.
This sometimes requires WTerm(late typing), usually by introducing an extra nested class that will only be used
as a dependency.

One such case happened while designing a little 42 videogame; where we encountered the setting below:
We have Wcode(NPC)s following each other in a Wcode(Map).
Each Wcode(NPC) knows about the Wcode(Map), the Wcode(Map) values are Wcode(NPC) objects.
Moreover, we do not just reuse a Wcode(Collection.map) but we add new operations to it: the map is going to have specialized location aware operations.


OBCode
Point = Data:{I x, I y}
Game = Organize:{
  NPC$ = {}
  Map$ = Collection.map(key=Point, val=NPC$)
  NPC = Data:{
    var Point location
    var I lifePoints
    var mut This target
    mut method Void step(mut Map$ map) = /*lots of code*/
    }
  Map = {
    mut method Void add(mut NPC that) = this.#put(key=that.location(), val=that)
    mut method Void remove(mut NPC that) = this.remove(key=that.location())
    mut method Void move(mut NPC that,Point to) = (
      this.remove(that)
      that.location(to)
      this.add(that)
      )
    mut method mut NPC get(Point that) =
      (this<:mut @Late Map$).#val(key=that).#val()
    mut method Void stepAll() =
      for (mut val) in this<:mut Map$
        (val<:mut NPC).step(map=this)
    }
  }
Late = {}
CCode
The former code declares both Wcode(NPC) and Wcode(NPC$), and both Wcode(Map) and Wcode(Map$).
They will be merged by Wcode(Organize) but are still separated inside the code library, before Wcode(Organize) can act.
This is relevant when type inference is required.
For example, method Wcode(Map.get(that))
can not be simply implemented as
Wcode(this.#val(key=that).#val())
since there is no method Wcode(#val(key)) in Wcode(Map); such method is presented in Wcode(Map$).
The solution is to add an up-cast to Wcode(Map$).
However, if this code was typed before Wcode(Organize) could
run, such a cast would not typecheck, since Wcode(Map$) is not Wcode(Map).
We can easly delay the type checking by adding an annotation:
Wcode(this<:mut @Late Map$)
casts Wcode(this) to Wcode(mut Map$) only when also nested class Wcode(Late) can be typed. Since Wcode(Late) is declared after Wcode(Game), this is happening after Wcode(Organize) has been applied.
Alternatively, we could use a local variable declaration and write the following:
OBCode
mut method mut NPC get(Point that) = (
  mut @Late Map$ self=this
  self.#val(key=that).#val()
  )
CCode
WBR
Also method Wcode(stepAll()) requires upcasting; however we do not need to repeat the Wcode(Late) annotation since type dependencies are class-wide: a single Wcode(Late) annotation anywhere in any method covers all the methods of the same class (but not the methods in nested classes).

Note that this approach does not rely on any dynamic checks; the 42 upcast operator Wcode(<:) is only guiding the type system, and even if the typing happens later, it will happen before the code is ready for execution.

Instead of Wcode(Late) we could rely on the class Wcode(Game) itself, and
write Wcode(this<:mut @Game Map$).
If we want to make what is happening more explicit, we could even get creative and write Wcode(this<:mut @Deploy{after @Game} Map$).

WTitle((3/5)`Data.**')
The Wcode(Data) decorator contains many useful nested classes, that can be used as independent decorators.

WTitle(`Data.AddList, Data.AddOpt, Data.AddSet')
Decorators Wcode(Data.AddList), allows us to add a
nested class Wcode(List) working as a list of Wcode(This).
 Wcode(Data.AddOpt) and Wcode(Data.AddSet) work similarly, but for Wcode(Opt) and Wcode(Set).
That is, to define a Wcode(Point) supporting both lists of points and sets of points we can simply write:
OBCode
Point = Data:Data.AddList:Data.AddSet:{
  I x, I y
  }
..
ps = Point.List[\(x=3I,y=4I);\(x=5I,y=6I);]
CCode
Note that the order of application of the above decorators is not important.

WTitle(`Data.AddConstructors')

Wcode(Data.AddConstructors) applies a heuristic to decide what are the field of a class and add two constructors:
The first is called Wcode(#immK) and the second has the empty name; also known as Wcode(#apply).
Wcode(#immK) simply takes all fields as immutable and produces an immutable result.
Wcode(#apply) takes the most general type for the fields and produces a Wcode(mut) result if class instances are mutable, and Wcode(imm) otherwise.
The most general type for fields may be Wcode(fwd imm) or Wcode(fwd mut).
We have not seen Wcode(fwd) types yet in this guide; they are useful for circular initialization. For example 
OBCode
Person = Data:{S name, Person bestFriend}
..
fred = Person(name='Fred, bestFriend=barney)
barney = Person(name='Barney, bestFriend=fred)
CCode
This code works in 42 and creates two circularly connected deeply immutable objects.
Forward types can also be used as parameters in regular methods, and the type system will check that their values can not be directly accessed but only passed around until they reach an abstract factory method.
Wcode(Data.AddConstructors) takes two parameters:
Wcode(Name that) and Wcode(Bool noFwd).
Wcode(Name that) choses the nested class to influence, and it is Wcode(Name"This") by default.
Wcode(Bool noFwd) is false by default, and 
prevents Wcode(fwd imm) and Wcode(fwd mut) constructors when true.

Wcode(Name that) can also specify an alternative name for the empty name constructor and the field names and order.
Wcode(Data.AddConstructors) can also be built as an alphanumeric to simply initialize the Wcode(Name that) parameter.
Also Wcode(Data) can be built as an alphanumeric and it will internally propagate that parameter
to Wcode(Data.AddConstructors).
The code below provides good examples:
OBCode
Data:{ Num y, Num x } //no explict constructor, #apply(y,x) is inferred
Data"(x,y)":{ Num y, Num x } //#apply(x,y) is explicitly provided
Data.AddConstructors"(x,y)":{ Num y, Num x } //to add only the constructors
Data"of(x,y)":{ Num y, Num x } //of(x,y) explicitly provided
Data"B(x,y)":{ B={ Num y, Num x } } //The nested B is completed, constructor provided
Data"B.of(x,y)":{ B={ Num y, Num x } } //The nested B is completed, constructor provided
Data"B":{ B={ Num y, Num x } } //The nested B is completed, constructor inferred
Data.Relax"(x,y)":{ Num x, Num y  method Num foo() } //ensures 'foo' is not a field

CCode
Passing the constructor parameter names explicitly is very useful in case we want to
 reorganize the order of the fields or explicitly exclude some abstract method 
that would be inferred to be a field otherwise.

WTitle(`Data.Seal')

Wcode(Data.Seal) also takes two parameters:
Wcode(Name that) and Wcode(Bool autoNorm).
Wcode(Name that) chooses the nested class to influence, and it is Wcode(Name"This") by default.
Wcode(Bool autoNorm) is false by default, and if it is true attempts to use an already existent Wcode(norm()) method to only expose normalized values out.
It only works if class instances are immutable
and fails if any constructor parameter is forward.
Wcode(Data.Seal) is the part of Wcode(Data) processing and activating of all the Wcode(Cache.**) annotations.
WP
Wcode(Data.Seal) implements all of the abstract state operations by delegating to an equivalent private method.
The class is then WTerm(sealed). 
Wcode(Data.Seal.all(..)) is a convenient class method that applies Wcode(Data.Seal) on all the nested classes in a library literal.
Wcode(Public) uses Wcode(Data.Seal.all(..)) internally.
As discussed for Wcode(Public), code composition of sealed classes is less flexible since the state is now set in stone.

WTitle(`Data.Wither')

Wcode(Data.Wither) takes an open class and adds 
Wcode(with(..)) methods; one for each field.
Those methods create a new object calling Wcode(#immK), where all the fields are the same, except for the one provided as a parameter.
For example, in the usual iconic Wcode(Point) example, we could write 
Wcode(Point(x=3I,y=4I).with(x=5I))
to get Wcode(Point(x=5I,y=4I))
Note that this generates only the withers to update a single parameter at a time.

WTitle(`Data.Defaults')

In 42, methods are distinguished by their full selector, not their name; this is particularly convenient to encode default arguments, so that calling a method without mentioning a parameter will be equivalent to passing a default value to it.
This can be done by hand; as shown in the example below:
OBCode
Point = Data:{
  I x, I y
  class method This () = \(x=0I,y=0I)
  method This moveUp(I that) = this.with(x=\x+that)
  method This moveUp() = this.moveUp(1I)
  }
CCode
The decorator Wcode(Data.Defaults)
allows us to generate those delegator methods more easily.
The code above could equivalently be rewritten as follows
OBCode
Point = Data:{
  I x=0I, I y=0I
  method This moveUp(I that) = this.with(x=\x+that)
  method I #default#moveUp#that() = 1I
  }
CCode
Methods starting with Wcode(#default#) are recognized by Wcode(Data.Defaults) and used to create delegators. Moreover, in the same way fields are expanded into methods, the expression associated with the field is expanded in a no-arg Wcode(#default#) method.
Manually defined Wcode(#default#) methods can also take parameters; they must have the same name and type of parameters specified before the current parameter in the original method.
WBR
In more detail: for every method where at least one Wcode(#default#) method is recognized, another method will be generated. 
WP
This generate method will not have any of the parameter with a recognized Wcode(#default#); it will call those Wcode(#default#) methods to produce the needed values and delegates to the original method.

WTitle(`Data.Relax')

Wcode(Data.Relax)
works exactly like Wcode(Data), 
but does not call Wcode(`This.checkCoherent(..)')
on the result.

WTitle(`Data traits')

Finally, the following methods return traits
with one operation each, as obvious from their name:
Wcode(addHasToS()),
Wcode(addEqOp()),
Wcode(addReadEqOp()),
Wcode(addNEqOp()),
Wcode(addCapsuleClone()),
Wcode(addImmClone()),
Wcode(addImmNorm()).


WTitle(`Data as a combination of decorators')

In the end, Wcode(Data) just composes all of those decorators and traits together as follows:
OBCode
method Trait :(Trait that)[Data$Fail]=(
  name=this.that()
  cs=Name(string=name.path())
  autoNorm=this.autoNorm()
  var Trait acc=that
  acc:=this.optionallyApply(This.addHasToS(), acc=acc)
  acc:=this.optionallyApply(This.addEqOp(), acc=acc)
  acc:=this.optionallyApply(This.addReadEqOp(), acc=acc)
  acc:=this.optionallyApply(This.addNEqOp(), acc=acc)
  acc:=this.optionallyApply(This.addCapsuleClone(), acc=acc)
  acc:=this.optionallyApply(This.addImmClone(), acc=acc)
  acc:=this.optionallyApply(This.addImmNorm(), acc=acc)  
  acc:=AddConstructors(name,noFwd=autoNorm):acc
  acc:=Wither(cs):acc
  acc:=Defaults(cs):acc
  acc:=Seal(cs,autoNorm=autoNorm):acc
  if this.check() (This.checkCoherent(acc.code()))
  acc
  )  
CCode 
Where Wcode(optionallyApply(..)) applies the trait in the Wcode(name) position only if this causes no error. In this way if a method with the same name was already defined, the operation is simply skipped.

WTitle((4/5)`Decorator')
The Wcode(Decorator) decorator simplifies  creating new decorators.
for example, for a variant of Wcode(Data) that always normalize, we could do as follows, where we simply specify a method from Wcode(Trait) into Wcode(Trait) that can throw any kind of Wcode(Message.Guard).
OBCode
Value = Decorator:{
  method Trait(Trait trait)[Message.Guard] =
    Data('This,autoNorm=Bool.true()):trait
  }
CCode
The Wcode(Decorator) decorator will then use our code to create a decorator.
It will provide the following:
OBCode
class method This #apply() //no-arg factory
method Library #colon0(Library lib)[This.Fail] //decorator for Library
method This1.Trait #colon0(This1.Trait trait)[This.Fail]//decorator for Trait
ClassOperators={..}//support for 'Value:..'
//instead of requiring 'Value():..'
Fail={[Message.Guard]..}//dedicated exception type
CCode
We can also define parameters in our decorator, but we need to ensure the object could be created with the unnamed no-arg factory.

For example,
to add to Wcode(Value) the option of acting in an arbitrary nested class of the input,
 we could write:
OBCode
Value = Decorator:Data:{
  Name that=Name"This"
  method Trait(Trait trait)[Message.Guard] =
    Data(this.that(),autoNorm=Bool.true()):trait
  }
CCode
WP
We can produce very liberal variations of Wcode(Data) by simply re-implementing the method that composes all the individual decorators and traits.
For example, if we wanted a variation of data that does not generate the withers, we could just write:
OBCode
DataNoWither = Decorator:Data:{
  Name that=Name"This"
  Bool autoNorm=Bool.false()
  Bool relax=Bool.false()

  method Trait(Trait trait)[Message.Guard] = (
    name=this.that()
    autoNorm=this.autoNorm()
    data = Data(name,autoNorm=autoNorm)
    var Trait acc=trait
    acc:=data.optionallyApply(Data.addHasToS(), acc=acc)
    acc:=data.optionallyApply(Data.addEqOp(), acc=acc)
    acc:=data.optionallyApply(Data.addReadEqOp(), acc=acc)
    acc:=data.optionallyApply(Data.addNEqOp(), acc=acc)
    acc:=data.optionallyApply(Data.addCapsuleClone(), acc=acc)
    acc:=data.optionallyApply(Data.addImmClone(), acc=acc)
    acc:=data.optionallyApply(Data.addImmNorm(), acc=acc)  
    acc:=Data.AddConstructors(name,noFwd=autoNorm):acc
    //acc:=Data.Wither(name):acc//for example, we can just skip this line
    acc:=Data.Defaults(name):acc
    acc:=Data.Seal(name,autoNorm=autoNorm):acc
    if !this.relax() (Data.checkCoherent(acc.code()))
    acc
    )
  }
CCode
As you can see, with Wcode(Decorator) we can easy tweak any existing decorator and compose them into new ones.

Another interesting example is Wcode(S.Alphanumeric);
it is present in AdamsTowel, but it is quite easy to redefine:
OBCode
Alphanumeric = Decorator:{
  AlphanumericTrait = Trait:{[HasToS]
    S that
    method toS()=this.that()
    @Cache.Call class method This #from(S.StringBuilder stringLiteral) = 
      this(string=stringLiteral.toS())
    class method This (S string)
    }
  method Trait(Trait trait)[Message.Guard] = 
    Data('This,autoNorm=Bool.true()):AlphanumericTrait():trait
  }
CCode
WP
Wcode(Enum) is a much more challenging decorator
to define, but we have finally explored all the needed features. 
As a reminder, Wcode(Collection.Enum)
generates one enumeration element for any nested class. Thus, for example
OBCode
Directions = Collections.Enum:{
  Left={}, Top={}, Right={}, Bottom={}}
CCode
would turn the top level nested class into an interface and would enrich those 4 nested classes so that they implement Wcode(This1) and support equality.
Moreover, a nested class Wcode(Vals) is added allowing us to list all the elements of the enumeration, and to map them from string.

We will now see how to encode such a complex behaviour.
OBCode
Enum = Decorator:{
  //we start with 3 composable units of code
  TraitEnumBase = Trait:{...}//the starting point

  TraitEnumStep = Trait:{...}//the inductive step.

  TraitCacheVals = Organize:Trait:{...}//the final touch

  method Trait(Trait trait)[Message.Guard] = (
    var res = TraitEnumBase()  //we start from the TraitEnumBase code
    for (nameFromRoot) in trait.info().nesteds() (  //for all the names of all the nesteds:
      base = res['Vals.next()=>'Vals.prev()]  //res.Vals.next is renamed into .prev
      step = TraitEnumStep['E=>nameFromRoot]  //set the current TraitEnumStep name
      res := (step+base)[hide='Vals.prev()]  //the new candidate result composes step and base
      //res.Vals.prev is hidden, so that the next iteration we can rename next onto prev
      )
    res := (res+TraitCacheVals)[hide='Vals.next()]  //res.Vals.next connects the
    //inductive step with the result, and can then be hidden
    (res+trait)[hide='sealed()]  //finally, we compose what we created with
    //any extra code that the user provided, and we seal the top level interface
    )
  }
CCode
The general pattern shown above is quite common when building complex decorators:
Start from some base code.
Iterate on a number of steps depending on the input trait; for each step combine the base code with code representing this extra step.
At the end of each step apply some renaming and hiding so that the resulting code has the same structural shape of the base code.
Finally, compose the result with the original user input and some more code providing a better user API.
WBR
For Wcode(Enum), the base code is as follow:
OBCode
TraitEnumBase = Trait:{
  List = {class method mut This()}
  Vals = { class method List next() = List() }
  }
CCode
We have a Wcode(List) nested, that will be the list type returned by Wcode(Vals()).
In Wcode(List) we only declare the abstract methods used in Wcode(Vals.next()).

The inductive code is much more interesting:
we declare the top level as an interface, with a Wcode(sealed()) method. This is the device to finally seal the hierarchy, so that the enumeration only has a fixed set of options.
The enumeration offers the three methods that are usually provided by classes supporting equality: Wcode(readEquality), Wcode(==) and Wcode(!=).
Nested class Wcode(E) represents an arbitrary element of our enumeration, and provides a standard implementation for those methods.
It is a class with sealed state and no fields, thus 42 will implicitly use the normalized value for its single instance.
This means that the method Wcode(System.immClone(this)) will simply convert the Wcode(read) reference to Wcode(imm) without the need of any expensive computation.
OBCode
TraitEnumStep = Trait:{interface
  class method Void sealed()
  read method Bool readEquality(read This that)
  method Bool ==(This that)
  method Bool !=(This that)
  E = {[This1,HasToS]
    class method This of::0()
    class method This() = this.of::0()
    class method Void sealed() = void
    method readEquality(that) = 
      System.immEquality(System.immClone(this) and=System.immClone(that))
    method ==(that) = this.readEquality(that)
    method !=(that) = !this.readEquality(that)
    method toS() = Info(This).outerName().toS()
    }
  List = { method This withAlsoRight(This1 that) }
  Vals = {
    class method List prev()
    class method List next() = this.prev().withAlsoRight(E())
    }
  }
CCode
Wcode(List) and Wcode(Vals) are now playing the inductive game of growing a list.
The base code Wcode(next()) starts with an empty list, and any base case will append to the right the instance of the current Wcode(E).
WBR
Finally, to provide a good and efficient API,
we cache Wcode(Vals()) and Wcode(Vals.map()).
This is also the place where we provide an actual implementation for Wcode(List) and Wcode(Map).
OBCode
TraitCacheVals = Organize:Trait:{
  $ = {interface[HasToS],    read method Bool readEquality(read This that) }
  List = Collection.list($)
  Map = Collection.map(key=S val=$)
  Vals = Data.Relax:{
    class method List next()
    @Cache.Lazy class method List () = this.next()
    @Cache.Lazy class method Map map() = \()( for e in this() \put(key=e.toS() val=e) )
    class method $ (S that) = {
      return this.map().val(key=that).val()
      catch error Any _ error S.ParseError(S"""
        |Invalid enumeration name: %(that).
        |Valid enumeration names are %this()
        """)
      }
    }
  }
CCode
We carefully capture and regenerate errors: Wcode(MyEnum.Vals('MisspelledName)) should provide a Wcode(S.ParseError).
WP
As you can see, with a little experience it is possible to define decorators that behave like language extensions.
Developement on a large 42 program should start defining some appropriate decorators to make the rest of the code more fluent and compact.

WComm decorator Resource/lift string?
WComm Trait.LiftS(p)['#apply()=>n] 
WComm produces a class with a class method S () returning the string.



WTitle((5/5)Metaprogramming summary)
<ul><li>
Metaprogramming is hard; 42 tries to make it simpler, but it is still not trivial.
</li><li>
Making your own decorators it is easy when your decorators are just a simple composition of other decorators.
</li><li>
Error handling is important while writing decorators.
A large part of decorators code should be dedicated
to handling errors and lifting them into a more understandable
form, for the sake of the final user.
</li><li>
We are just scratching the surface of what we
can do with metaprogramming.
If you are interested in becoming a Magrathean, then
join our effort to design the painful metaprogramming guide.
</li><li>
In the current state of the art we do not have an answer for what is the best 42 (meta-)programming style.
Indeed, we still do not understand the question.
</li></ul>