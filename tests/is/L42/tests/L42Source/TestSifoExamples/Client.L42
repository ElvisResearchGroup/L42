[HasToS]
I id
S name
mut Keyring keyring
imm @Top I privateKey
var Bool autoResponse
mut AddressBook addressBook
var mut OptClient forwardReceiver
mut Counter static
class method fwd mut This (fwd mut Client$ that)
read method S toS() = this.name()//could have more info, but not privateKey
//mut method mut Client$ self()
class method mut This(I id,S name,mut Keyring keyring,
  @Top I privateKey,Bool autoResponse,mut AddressBook addressBook,
  mut OptClient forwardReceiver,mut Counter static)
read method Bool  == (read Client that) = this.id() == that.id()
mut method Void deliver(mut Email msg) = Debug(S"mail delivered%S.nl()")//represents the real sending of the email
mut method Void incomingWrappeeAutoResponder(mut Email msg) = (
  this.deliver(msg = msg)
  if this.autoResponse() this.autoRespond(msg = msg)
  )
mut method Void incomingWrappeeForward(mut Email msg) = (
  this.incomingWrappeeAutoResponder(msg = msg)
  receiverOpt  =  this.#forwardReceiver()
  if receiverOpt (
    msg.to(This(receiverOpt.#val())<:read This.name())
    this.forward(msg = msg)
    This(receiverOpt.#val())<:mut This.incoming(msg = msg)
    )
  )
mut method Void incomingWrappeeVerify(mut Email msg) = (
  this.verify(msg = msg)
  this.incomingWrappeeForward(msg = msg)
  )
mut method Void incoming(mut Email msg) = (
  @Top I privkey  =  this.privateKey()
  mut @Top MetaData m = msg.#metaData()
  @Top Bool nonZero  =  privkey !=  0I
  if nonZero (
    @Top Bool valid  =  m.isEncrypted() && This.isKeyPairValid(publicKey = m.encryptionKey(), privateKey = privkey)
    if valid ( //high context, only assignments to high
      m.isEncrypted(Bool.false())
      m.encryptionKey(0I)
      )
    )
  this.incomingWrappeeVerify(msg = msg)
  void
  )
mut method Void mail(mut Email msg) = Debug(S"mail sent")
mut method Void outgoingWrappeeBase(mut Email msg) = (
  msg.from(this)
  this.mail(msg = msg)
  )
mut method Void outgoingWrappeeEncrypt(mut Email msg) = (
  mut Client receiver  =  This(this.#static().client(address = msg.to()))
  I pubkey  =  this.getKeyringPublicKey(client = receiver)
  if pubkey !=  0I ( // low
    msg.#metaData().encryptionKey(pubkey) //pubkey promoted to high
    msg.#metaData().isEncrypted(Bool.true())
    Debug(S"Encrypted Mail %msg.id()")
    )
  this.outgoingWrappeeBase(msg = msg)
  )
mut method Void outgoingWrappeeAddressbook(mut Email msg) = {
  mut S.List aliasReceivers  =  this.getAddressBookReceivers(alias = msg.to())
  if aliasReceivers.isEmpty() return this.outgoingWrappeeEncrypt(msg = msg)
  for i in Range(aliasReceivers.size()-1I) (
    S receiverAddress  =  aliasReceivers.val(i+1\)
    msg.to(receiverAddress)
    this.outgoing(msg = msg)
    This(this.#static().client(address = receiverAddress))<:mut This.incoming(msg = msg)
    )
  msg.to(aliasReceivers.val(0\))
  return this.outgoingWrappeeEncrypt(msg = msg)
  }
mut method Void outgoing(mut Email msg) = (
  this.sign(msg = msg)
  this.outgoingWrappeeAddressbook(msg = msg)
  )
mut method Void sendEmail(S receiverAddress, S subject, @Top S body) = (//TODO: counter must have the create method
  mut Email email  =  Email.create(counter = this.#static(), subject = subject, body = body, from = this, to = receiverAddress)
  Debug(S"sending Mail %email.id()")
  this.outgoing(msg = email)
  receiver  =  this.#static().client(address = email.to())
  This(receiver)<:mut This.incoming(msg = email)
  )
mut method Void addKeyringEntry(mut Client client, I publicKey) = (
  this.#keyring().#add(right = KeyringEntry(keyOwner = client, publicKey = publicKey))
  )
mut method I getKeyringPublicKey(mut Client client) = {
  for mut e in this.#keyring() (
    if This(e.#keyOwner()) == client return e.publicKey()
    )
  return 0I
  }
class method Bool isKeyPairValid(I publicKey,I privateKey) = {
  //NOTE: this function was going in top*top in top, but is much easier to use low and promote
  //Debug(S"keypair valid %publicKey %privateKey")//correctly fails verification
  isZero  =  publicKey  ==  0I || privateKey  ==  0I
  if isZero return Bool.false()
  return privateKey  ==  publicKey //should be a secure validation. This is just an example.
  }
mut method Void autoRespond(mut Email msg) = (
  Debug(S"sending autoresponse%S.nl()")
  sender  =  msg.#from()
  msg.to(sender.name())
  this.outgoing(msg = msg)
  sender.incoming(msg = msg)
  )
mut method mut S.List getAddressBookReceivers(S alias) = {
  for mut e in this.#addressBook() (
    if e.alias() == alias return e.#receivers()
    )
  return S.List()
  }
mut method Void addAddressbookEntry(S alias, S receiver) = {
  for mut e in this.#addressBook() (
    if e.alias() == alias return e.add(receiver = receiver)
    )
  newEntry  =  AddressBookEntry(alias = alias, receivers = S.List[receiver])
  return this.#addressBook().#add(right = newEntry)
  }
mut method Void sign(mut Email msg) = {
  @Top I privkey  =  this.privateKey()
  @Top Bool isZero  =  privkey  ==  0I
  if isZero return void
  msg.#metaData().isSigned(Bool.true())
  msg.#metaData().signKey(privkey)
  return void
  }
mut method Void verify(mut Email msg) = ( //receiver of message
  mut @Top MetaData metaData = msg.#metaData()
  I pubkey  =  this.getKeyringPublicKey(client = msg.#from())
  @Top Bool keyValid  =  pubkey !=  0I && This.isKeyPairValid(publicKey = pubkey, privateKey = metaData.signKey())
  if keyValid metaData.isSignatureVerified(Bool.true()) 
  )
mut method Void forward(mut Email msg) = (
  Debug(S"Forwarding message.%S.nl()")
  msg.printMail()
  this.outgoing(msg = msg)
  )