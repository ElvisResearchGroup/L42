reuse[#$AdamsTowel]
TestNum=(
  {}:Test"zero"(0Num+0Num==0Num)
  {}:Test"one+"(1Num+1Num==2Num)
  {}:Test"one*"(1Num*1Num==1Num)
  {}:Test"two+"(2Num+2Num==4Num)
  {}:Test"two*"(2Num*2Num==4Num)
  {}:Test"numOp1"(Num"25/30"+Num"11/60"==Num"61/60")
  {}:Test"numOp2"(Num"25/30"+Num"-11/60"==Num"39/60")
  {}:Test"numOp3"(Num"25/30"*Num"11/10"==Num"275/300")
  {}:Test"numOp4"(Num"25/30"*Num"-11/10"==Num"-275/300")
  {}:Test"numConversion1"((12I).toNum(denominator=3I)==4Num)
  {}:Test"numConversion2"((12Math.Long).toNum(denominator=3Math.Long)==4Num)
  {}:Test"numConversion2"((12Double).toNum()==12Num)
  )
TestQuote=(
  ss=S.List['hi()]
  {}:Test"quote"(S"hi()"==ss.left())
  )
OptS=Collection.optional(S)
OptSize=Collection.optional(I)
TestOptS=(
  OptS o1=OptS()
  OptS o2=OptS(S"hi")
  {}:Test"opt"(o2.val()==S"hi")
  {}:Test"optNope"(S"Optional value is empty"==(
    error o1.val() catch error Collection.NoElementInOpt e e.text()
    ))
  )
TestOptSize=(
  OptSize o1=OptSize()
  OptSize o2=OptSize(8I)
  {}:Test"opt"(o2.val()==8I)
  {}:Test"optNope"(S"Optional value is empty"==(
    error o1.val() catch error Collection.NoElementInOpt e e.text()
    ))
  )
TestSizeRange=(
  var sAcc=S""
  for i in Range(21I) (sAcc++=S"a")
  {}:Test"range 21"(sAcc.size()==21I)
  )
TestMatchReduce=((
  mut S.List ss=S.List[S"a";S"b";S"c"]
  {}:Test"reduceWithValue"(S"DDabc"==
    ss.reduce(S"DD")(for e in \vals \add(\acc++e)))
  ),,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,(
  lent S.List ss=S.List[S"a";S"b";S"c"]
  {}:Test"reduceWithValue"(S"DDabc"==
    ss.reduce(S"DD")(for e in \vals \add(\acc++e)))    
  ),,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,(
  read S.List ss=S.List[S"a";S"b";S"c"]
  {}:Test"reduceWithValue"(S"DDabc"==
    ss.reduce(S"DD")(for e in \vals \add(\acc++e)))    
  ),,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,(
  imm S.List ss=S.List[S"a";S"b";S"c"]
  {}:Test"reduceWithValue"(S"DDabc"==
    ss.reduce(S"DD")(for e in \vals \add(\acc++e)))    
  ))
TestMatchSome=(
  ss=S.List[S"a";S"b";S"c"]
  (    
    res=Match.Some()(for s in ss \add(s==S"c"))
    {}:Test"MatchSome"(res)
    ),,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,(
    var sAcc=S""
    res=Match.Some()(for s in ss (sAcc++=S"#" \add(s==S"b")))
    {}:Test"MatchSomeShortCircut"(sAcc.size()==2I)
    )
  )
TestSizeInString=(
  half=21I
  answer=half+half
  {}:Test"Sum"(answer==42I)"Computed answer is %answer.toS()"
  //{}:Test"Failing test"(answer==8I)"Computed answer is %answer.toS()"
  {}:Test"StringConcat"(S"Hello World "++answer.toS()++S"!" == S"Hello World 42!")
  {}:Test"StringSpliceConcat"(S"Hello World %answer!" == S"Hello World 42!")
  )
TestSizeParsing=(
  err=I"oh NO!"//throws error
  {}:Test"InvalidParseInt"( Bool.false() )"Errors not thrown"
  catch error S.ParseError x 
    {}:Test"InvalidParseIntError"(
      actual=x.text()
      expected=S"The string %S.dq()oh NO!%S.dq() is not a valid int32 number"
      )
  )
NotCoh={This field, class method This ()}
TestMakeNotCohList=Class.Relax:Collection.listTrait()['Elem=>NotCoh<:class Any]
TestSList=(
  s=S.List()
  s.add(\"hi")
  {}:Test"singleVal"(expected=S"hi", actual=s.val(0I))
  {}:Test"size1"(s.size()==1I)
  )
TestMap=(
  imm s=S.List[S"a";S"b";S"c"]
  res=S.List()(for e in s \add(S"Q"++e))
  {}:Test"mapped"(res.val(1\)==S"Qb")
  )

TestWhile=(
  while Bool.true() (
    {}:Test"while runs"(Bool.true())
    exception void  
    )
  )
TestBoolRelOps=(
  {}:Test"Less then"(!(3I<3I))
  {}:Test"Less then and false"(!(3I<3I && Bool.false()))
  )
TestListOps=(
  ss1=S.List[S"a";S"b";S"c"]
  ss2=S.List[S"1";S"2";S"3"]
  (
    var sAcc=S""
    for imm si in ss1 (sAcc++=si)
    {}:Test"Simple for"(sAcc==S"abc")
    ),,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,(
    var sAcc=S""
    for s1 in ss1, imm s2 in ss2 (sAcc++=s1++s2)
    {}:Test"Simple for"(sAcc==S"a1b2c3")
    ),,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,(
    ss3=S.List()(\add(S"hi"))
    {}:Test"justSlash"(ss3.size()==1I)
    ),,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,(
    ss4=S.List()(for s1 in ss1, imm s2 in ss2 \add(s1++s2))
    for var imm si in ss4 (si:=S"pe"++si)
    for var si in ss4 (si:=S"No"++si)
    var sAcc=S""
    for imm si in ss4 (sAcc++=si)
    {}:Test"Simple for"(sAcc==S"Nopea1Nopeb2Nopec3")
    )
  )
TestLog=(
  Log iLog=Log(S"Foo")
  mut Log mLog=iLog.#$reader()
  iLog.write(S"Hello")
  iLog.write(S" ")
  iLog.write(S"World")
  {}:Test"logTest"(expected=S"Hello World", actual=mLog.read())
  iLog.clear()
  )

Person={
  var S name
  var I age
  class method mut This(S name,I age)
  read method capsule This clone()=This(name=this.name(),age=this.age())
  }
Couple={
  var Person p1
  var Person p2
  class method mut This(Person p1, Person p2)
  read method capsule This clone()=This(p1=this.p1(),p2=this.p2())
  imm method Void normMe()=native{trusted:lazyCache} (void)
  }
A={ class method mut This() }
TestEqualities=(
  Person immPerson = (
    mut Person p1=Person(name=S"bob",age=23I)
    mut Person p2=Person(name=S"bob",age=23I)
    {}:Test"RefEq1"(!System.mutReferenceEquality(p1 and=p2))
    {}:Test"RefEq2"(System.mutReferenceEquality(p1 and=p1))
    {}:Test"RefEq3"(System.mutReferenceEquality(p2 and=p2))
    {}:Test"StructEq1"(System.mutStructuralEquality(p1 and=p2))
    p1.age(24I)
    {}:Test"StructEq2"(!System.mutStructuralEquality(p1 and=p2))
    mut Person p3 = p1.clone()
    {}:Test"StructEq3"(System.mutStructuralEquality(p1 and=p3))
    p1
    )
  Couple immCouple = (
    mut Couple c1 = Couple(p1=immPerson, p2=immPerson)
    mut Couple c2 = Couple(p1=immPerson, p2=immPerson.clone())
    {}:Test"StructEq4"(!System.mutStructuralEquality(c1 and=c2))
    c2
    )
  Couple immCouple2 = Couple(p1=immPerson, p2=immPerson)
  Couple immCouple3 = Couple(p1=immPerson.clone(), p2=immPerson.clone())
  Couple immCouple4 = Couple(p1=immPerson, p2=Person(name=S"Claire",age=20I))
  {}:Test"ImmEq1"(System.immEquality(immCouple and=immCouple2))
  {}:Test"ImmEq2"(System.immEquality(immCouple2 and=immCouple3))
  {}:Test"ImmEq3"(!System.immEquality(immCouple3 and=immCouple4))
  A i1 = A()
  A i2 = A()
  {}:Test"ImmEq4"(System.immEquality(i1 and=i2))
  
  mut Couple mutCouple = Couple(p1=immPerson, p2=immPerson)
  {}:Test"CapsuleClone1"(!System.mutReferenceEquality(mutCouple and=System.capsuleClone(mutCouple)))
  {}:Test"CapsuleClone2"(System.mutStructuralEquality(mutCouple and=System.capsuleClone(mutCouple)))
  {}:Test"ImmClone1"(System.immEquality(System.immClone(mutCouple) and=System.immClone(mutCouple)))
  void
  )

TestNestedTraits={
  Trait2=Trait:{method Void foo()=void}
  A=Trait2:{
    class method Bool k()=Bool.true()
    B=Trait:{
      class method class This1 m()=This1
      }
    }
  AA=A.code()
  BB=AA.B.code()
  TestBB={}:Test"bb"(BB.m().k())
  }